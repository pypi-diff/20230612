# Comparing `tmp/smaplib-1.0.1-py3-none-any.whl.zip` & `tmp/smaplib-1.0.3-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,32 +1,42 @@
-Zip file size: 23979 bytes, number of entries: 30
--rw-r--r--  2.0 unx      519 b- defN 23-May-24 07:08 smaplib/__init__.py
--rw-r--r--  2.0 unx      158 b- defN 23-May-24 07:00 smaplib/fsio/__init__.py
--rw-r--r--  2.0 unx     1921 b- defN 23-Apr-13 21:34 smaplib/fsio/array.py
--rw-r--r--  2.0 unx     2815 b- defN 23-May-03 16:32 smaplib/fsio/common.py
--rw-r--r--  2.0 unx     3128 b- defN 23-Apr-14 12:39 smaplib/fsio/dss.py
--rw-r--r--  2.0 unx      904 b- defN 23-Apr-13 21:35 smaplib/fsio/json.py
--rw-r--r--  2.0 unx      856 b- defN 23-Apr-13 21:35 smaplib/fsio/pickle.py
--rw-r--r--  2.0 unx      914 b- defN 23-Apr-13 21:35 smaplib/fsio/text.py
--rw-r--r--  2.0 unx      121 b- defN 23-May-24 07:00 smaplib/img/__init__.py
--rw-r--r--  2.0 unx     3420 b- defN 23-Apr-14 12:40 smaplib/img/classes.py
--rw-r--r--  2.0 unx     9468 b- defN 23-May-24 06:57 smaplib/img/dss.py
--rw-r--r--  2.0 unx     7878 b- defN 23-May-04 06:52 smaplib/img/helpers.py
--rw-r--r--  2.0 unx      729 b- defN 23-Apr-14 15:49 smaplib/img/plot.py
--rw-r--r--  2.0 unx      105 b- defN 23-Apr-13 21:35 smaplib/misc/__init__.py
--rw-r--r--  2.0 unx     3161 b- defN 23-May-03 16:35 smaplib/misc/common.py
--rw-r--r--  2.0 unx     1970 b- defN 23-Apr-13 21:48 smaplib/misc/http.py
--rw-r--r--  2.0 unx      555 b- defN 23-Apr-14 12:17 smaplib/misc/iterable.py
--rw-r--r--  2.0 unx       84 b- defN 23-Apr-13 21:28 smaplib/pnc/__init__.py
--rw-r--r--  2.0 unx     1117 b- defN 23-Apr-13 21:36 smaplib/pnc/classes.py
--rw-r--r--  2.0 unx     2053 b- defN 23-Apr-13 21:35 smaplib/pnc/helpers.py
+Zip file size: 36478 bytes, number of entries: 40
+-rw-r--r--  2.0 unx      164 b- defN 23-Jun-01 13:50 setup.py
+-rw-r--r--  2.0 unx      937 b- defN 23-Jun-06 13:58 smaplib/__init__.py
+-rw-r--r--  2.0 unx      154 b- defN 23-May-31 09:10 smaplib/fsio/__init__.py
+-rw-r--r--  2.0 unx     1956 b- defN 23-May-31 09:10 smaplib/fsio/array.py
+-rw-r--r--  2.0 unx     2775 b- defN 23-May-31 09:10 smaplib/fsio/common.py
+-rw-r--r--  2.0 unx     3226 b- defN 23-May-31 09:10 smaplib/fsio/dss.py
+-rw-r--r--  2.0 unx      939 b- defN 23-May-31 09:10 smaplib/fsio/json.py
+-rw-r--r--  2.0 unx      892 b- defN 23-May-31 09:10 smaplib/fsio/pickle.py
+-rw-r--r--  2.0 unx      949 b- defN 23-May-31 09:10 smaplib/fsio/text.py
+-rw-r--r--  2.0 unx      117 b- defN 23-May-31 09:10 smaplib/img/__init__.py
+-rw-r--r--  2.0 unx     3449 b- defN 23-May-31 09:10 smaplib/img/classes.py
+-rw-r--r--  2.0 unx     9521 b- defN 23-May-31 09:10 smaplib/img/dss.py
+-rw-r--r--  2.0 unx     7769 b- defN 23-May-31 09:10 smaplib/img/helpers.py
+-rw-r--r--  2.0 unx      761 b- defN 23-May-31 09:10 smaplib/img/plot.py
+-rw-r--r--  2.0 unx       99 b- defN 23-May-31 09:10 smaplib/misc/__init__.py
+-rw-r--r--  2.0 unx     3241 b- defN 23-May-31 09:10 smaplib/misc/common.py
+-rw-r--r--  2.0 unx     1937 b- defN 23-May-31 09:10 smaplib/misc/http.py
+-rw-r--r--  2.0 unx     1113 b- defN 23-Jun-05 20:53 smaplib/misc/iterable.py
+-rw-r--r--  2.0 unx       35 b- defN 23-May-31 09:10 smaplib/misc/tests/__init__.py
+-rw-r--r--  2.0 unx     2032 b- defN 23-May-31 09:10 smaplib/misc/tests/test_common.py
+-rw-r--r--  2.0 unx       80 b- defN 23-May-31 09:10 smaplib/pnc/__init__.py
+-rw-r--r--  2.0 unx     1247 b- defN 23-May-31 09:10 smaplib/pnc/classes.py
+-rw-r--r--  2.0 unx     2037 b- defN 23-May-31 09:10 smaplib/pnc/helpers.py
+-rw-r--r--  2.0 unx      160 b- defN 23-Jun-05 20:56 smaplib/sim/__init__.py
+-rw-r--r--  2.0 unx     3237 b- defN 23-Jun-06 13:58 smaplib/sim/dataset.py
+-rw-r--r--  2.0 unx    33872 b- defN 23-Jun-06 13:58 smaplib/sim/feature.py
+-rw-r--r--  2.0 unx     1015 b- defN 23-Jun-06 13:58 smaplib/sim/layer.py
+-rw-r--r--  2.0 unx     1972 b- defN 23-Jun-06 13:58 smaplib/sim/model.py
+-rw-r--r--  2.0 unx     1087 b- defN 23-Jun-06 13:58 smaplib/sim/pca.py
+-rw-r--r--  2.0 unx     5106 b- defN 23-Jun-06 13:58 smaplib/sim/trainer.py
 -rw-r--r--  2.0 unx       85 b- defN 23-May-08 14:27 smaplib/similarity/__init__.py
 -rw-r--r--  2.0 unx    23851 b- defN 23-May-24 06:57 smaplib/similarity/feature.py
 -rw-r--r--  2.0 unx     5735 b- defN 23-May-16 15:25 smaplib/similarity/manager.py
--rw-r--r--  2.0 unx       63 b- defN 23-Apr-13 21:35 smaplib/tsfl/__init__.py
--rw-r--r--  2.0 unx      932 b- defN 23-Apr-14 13:27 smaplib/tsfl/helpers.py
--rw-r--r--  2.0 unx     1073 b- defN 23-May-24 20:23 smaplib-1.0.1.dist-info/LICENSE
--rw-r--r--  2.0 unx      767 b- defN 23-May-24 20:23 smaplib-1.0.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-24 20:23 smaplib-1.0.1.dist-info/WHEEL
--rw-r--r--  2.0 unx        8 b- defN 23-May-24 20:23 smaplib-1.0.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2357 b- defN 23-May-24 20:23 smaplib-1.0.1.dist-info/RECORD
-30 files, 76839 bytes uncompressed, 20233 bytes compressed:  73.7%
+-rw-r--r--  2.0 unx       58 b- defN 23-Jun-05 20:55 smaplib/tsfl/__init__.py
+-rw-r--r--  2.0 unx      949 b- defN 23-May-31 09:10 smaplib/tsfl/helpers.py
+-rw-r--r--  2.0 unx     1073 b- defN 23-Jun-12 08:59 smaplib-1.0.3.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2231 b- defN 23-Jun-12 08:59 smaplib-1.0.3.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Jun-12 08:59 smaplib-1.0.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 23-Jun-12 08:59 smaplib-1.0.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3144 b- defN 23-Jun-12 08:59 smaplib-1.0.3.dist-info/RECORD
+40 files, 129123 bytes uncompressed, 31536 bytes compressed:  75.6%
```

## zipnote {}

```diff
@@ -1,7 +1,10 @@
+Filename: setup.py
+Comment: 
+
 Filename: smaplib/__init__.py
 Comment: 
 
 Filename: smaplib/fsio/__init__.py
 Comment: 
 
 Filename: smaplib/fsio/array.py
@@ -45,23 +48,50 @@
 
 Filename: smaplib/misc/http.py
 Comment: 
 
 Filename: smaplib/misc/iterable.py
 Comment: 
 
+Filename: smaplib/misc/tests/__init__.py
+Comment: 
+
+Filename: smaplib/misc/tests/test_common.py
+Comment: 
+
 Filename: smaplib/pnc/__init__.py
 Comment: 
 
 Filename: smaplib/pnc/classes.py
 Comment: 
 
 Filename: smaplib/pnc/helpers.py
 Comment: 
 
+Filename: smaplib/sim/__init__.py
+Comment: 
+
+Filename: smaplib/sim/dataset.py
+Comment: 
+
+Filename: smaplib/sim/feature.py
+Comment: 
+
+Filename: smaplib/sim/layer.py
+Comment: 
+
+Filename: smaplib/sim/model.py
+Comment: 
+
+Filename: smaplib/sim/pca.py
+Comment: 
+
+Filename: smaplib/sim/trainer.py
+Comment: 
+
 Filename: smaplib/similarity/__init__.py
 Comment: 
 
 Filename: smaplib/similarity/feature.py
 Comment: 
 
 Filename: smaplib/similarity/manager.py
@@ -69,23 +99,23 @@
 
 Filename: smaplib/tsfl/__init__.py
 Comment: 
 
 Filename: smaplib/tsfl/helpers.py
 Comment: 
 
-Filename: smaplib-1.0.1.dist-info/LICENSE
+Filename: smaplib-1.0.3.dist-info/LICENSE
 Comment: 
 
-Filename: smaplib-1.0.1.dist-info/METADATA
+Filename: smaplib-1.0.3.dist-info/METADATA
 Comment: 
 
-Filename: smaplib-1.0.1.dist-info/WHEEL
+Filename: smaplib-1.0.3.dist-info/WHEEL
 Comment: 
 
-Filename: smaplib-1.0.1.dist-info/top_level.txt
+Filename: smaplib-1.0.3.dist-info/top_level.txt
 Comment: 
 
-Filename: smaplib-1.0.1.dist-info/RECORD
+Filename: smaplib-1.0.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## smaplib/__init__.py

```diff
@@ -1,29 +1,26 @@
-from __future__ import absolute_import
+from __future__ import annotations
 
+from .fsio import array as fsio_array
+from .fsio import common as fsio_common
+from .fsio import dss as fsio_dss
+from .fsio import json as fsio_json
+from .fsio import pickle as fsio_pickle
+from .fsio import text as fsio_text
+from .img import classes as img_classes
+from .img import dss as img_dss
+from .img import helpers as img_helpers
+from .img import plot as img_plot
+from .misc import common as misc_common
+from .misc import http as misc_http
+from .misc import iterable as misc_iterable
+from .pnc import classes as pnc_classes
+from .pnc import helpers as pnc_helpers
+from .sim import dataset as similarity_dataset
+from .sim import feature as similarity_feature
+from .sim import layer as similarity_layer
+from .sim import model as similarity_model
+from .sim import pca as similarity_pca
+from .sim import trainer as similarity_trainer
+from .tsfl import helpers as tsfl_helpers
 
-from .img import classes
-from .img import dss
-from .img import helpers
-from .img import plot
-
-from .fsio import array
-from .fsio import common
-from .fsio import dss
-from .fsio import json
-from .fsio import pickle
-from .fsio import text
-
-from .misc import common
-from .misc import http
-from .misc import iterable
-
-from .pnc import classes
-from .pnc import helpers
-
-from .similarity import feature
-from .similarity import manager
-
-from .tsfl import helpers
-
-
-__version__ = '1.0.1'
+__version__ = "1.0.3"
```

## smaplib/fsio/__init__.py

```diff
@@ -1,8 +1,8 @@
-from __future__ import absolute_import
+from __future__ import annotations
 
 from . import array
 from . import common
 from . import dss
 from . import json
 from . import pickle
 from . import text
```

## smaplib/fsio/array.py

```diff
@@ -1,9 +1,10 @@
-import numpy as np
+from __future__ import annotations
 
+import numpy as np
 
 
 def save_array(file_path, data):
     """Save a NumPy array to disk as a compressed .npz file.
 
     Args:
         file_path (str): The path to save the file to.
@@ -21,15 +22,15 @@
 
     Args:
         file_path (str): The path of the file to load.
 
     Returns:
         numpy.ndarray: The loaded NumPy array.
     """
-    return np.load(file=file_path, allow_pickle=True)['x']
+    return np.load(file=file_path, allow_pickle=True)["x"]
 
 
 def save_cache_dict_file(file_path, dict):
     """Save a dictionary as a .npz file.
 
     Args:
         file_path (str): The path to save the file to.
```

## smaplib/fsio/common.py

```diff
@@ -1,10 +1,11 @@
-import os as os
-import hashlib as hl
+from __future__ import annotations
 
+import hashlib as hl
+import os as os
 
 
 def md5(file_path):
     """
     Calculates the MD5 hash of a file.
 
     Args:
@@ -28,53 +29,44 @@
         filename (str): The filename without extension.
         extension (str): The file extension.
         stamp (datetime): The datetime to use as the timestamp.
 
     Returns:
         str: The timestamped filename.
     """
-    return '{0}-{1}.{2}'.format(
-        filename,
-        get_stamp_text(stamp),
-        extension)
+    return "{0}-{1}.{2}".format(filename, get_stamp_text(stamp), extension)
 
 
 def get_timestamped_name(name, stamp):
     """
     Generates a name with a timestamp.
 
     Args:
         name (str): The name without timestamp.
         stamp (datetime): The datetime to use as the timestamp.
 
     Returns:
         str: The timestamped name.
     """
-    return '{0}-{1}'.format(
-        name,
-        get_stamp_text(stamp))
+    return "{0}-{1}".format(name, get_stamp_text(stamp))
 
 
 def get_stamp_text(stamp):
     """
     Generates a string representation of a timestamp.
 
     Args:
         stamp (datetime): The datetime to use as the timestamp.
 
     Returns:
         str: The timestamp as a string.
     """
-    return '{0:04d}-{1:02d}-{2:02d}-{3:02d}-{4:02d}-{5:02d}'.format(
-        stamp.year,
-        stamp.month,
-        stamp.day,
-        stamp.hour,
-        stamp.minute,
-        stamp.second)
+    return "{0:04d}-{1:02d}-{2:02d}-{3:02d}-{4:02d}-{5:02d}".format(
+        stamp.year, stamp.month, stamp.day, stamp.hour, stamp.minute, stamp.second
+    )
 
 
 def create_if_not_exists(path):
     """Create a directory if it does not exist.
 
     Args:
         path (str): The path of the directory to create.
@@ -93,27 +85,28 @@
     Args:
         path (str): The path of the parent directory.
         stamp (datetime.datetime): The timestamp to use for the subdirectory name.
 
     Returns:
         str: The path of the created subdirectory.
     """
-    return create_if_not_exists(
-        os.path.join(
-            path,
-            get_stamp_text(stamp)))
+    return create_if_not_exists(os.path.join(path, get_stamp_text(stamp)))
 
 
 def get_path(path, file):
     """Get the full path to a file in a directory.
 
     Args:
         path (str): The path of the directory.
         file (str): The name of the file.
 
     Returns:
         str: The full path to the file.
     """
     file_path = os.path.join(path, file)
     file_exists = os.path.exists(file_path)
-    print('[{0}] file "{1}" in path "{2}": "{3}"'.format('X' if file_exists else ' ', file, path, file_path))
+    print(
+        '[{0}] file "{1}" in path "{2}": "{3}"'.format(
+            "X" if file_exists else " ", file, path, file_path
+        )
+    )
     return file_path
```

## smaplib/fsio/dss.py

```diff
@@ -1,14 +1,19 @@
+from __future__ import annotations
+
+from typing import Any
+from typing import Dict
+from typing import Tuple
+from typing import Union
+
 import dataiku as di
-from typing import Dict, Tuple, Union, Any
 
 from ..misc import http as web
 
 
-
 def get_folder(folder: Union[str, di.Folder]) -> di.Folder:
     """Gets a managed folder handle.
 
     Args:
         folder (Union[str, di.Folder]): The name of the DSS managed folder, or the folder handle.
 
     Returns:
@@ -27,16 +32,16 @@
     Returns:
         Tuple[bool, Any]: A 2-tuple containing:
           1) True if the path is valid, False otherwise
           2) The result of get_path_details(file_path).
     """
     try:
         info = get_folder(folder).get_path_details(path)
-        return info['exists'], info
-    except:
+        return info["exists"], info
+    except Exception:
         return False, None
 
 
 def file_exists(folder: Union[str, di.Folder], path: str) -> Tuple[bool, Any]:
     """Checks whether a path exists in a managed folder and is a file.
 
     Args:
@@ -46,16 +51,16 @@
     Returns:
         Tuple[bool, Any]: A 2-tuple containing:
           1) True if the path is valid, False otherwise
           2) The result of get_path_details(file_path).
     """
     try:
         info = get_folder(folder).get_path_details(path)
-        return not info['directory'] and info['exists'], info
-    except:
+        return not info["directory"] and info["exists"], info
+    except Exception:
         return False, None
 
 
 def directory_exists(folder: Union[str, di.Folder], path: str) -> Tuple[bool, Any]:
     """Checks whether a path exists in a managed folder and is a directory.
 
     Args:
@@ -65,16 +70,16 @@
     Returns:
         Tuple[bool, Any]: A 2-tuple containing:
           1) True if the path is valid, False otherwise
           2) The result of get_path_details(file_path).
     """
     try:
         info = get_folder(folder).get_path_details(path)
-        return info['directory'] and info['exists'], info
-    except:
+        return info["directory"] and info["exists"], info
+    except Exception:
         return False, None
 
 
 def url_to_managed_folder(url: str, folder: Union[str, di.Folder], path: str) -> bool:
     """Downloads the contents of a URL and saves it in a managed folder.
 
     Args:
@@ -82,19 +87,19 @@
         folder (Union[str, di.Folder]): The name of the DSS managed folder, or the folder handle.
         path (str): The path to the file.
 
     Returns:
         bool: True if the file exists after the copy, False otherwise.
     """
     exists = False
-    
+
     try:
         handle = get_folder(folder)
-        
+
         with handle.get_writer(path) as w:
             w.write(web.get_url(url))
-            
+
         exists, _ = file_exists(handle, path)
-    except:
+    except Exception:
         exists = False
-        
+
     return exists
```

## smaplib/fsio/json.py

```diff
@@ -1,9 +1,10 @@
-import json as js
+from __future__ import annotations
 
+import json as js
 
 
 def to_json(data):
     """Convert a Python object to a JSON string.
 
     Args:
         data (any): The Python object to convert.
@@ -20,24 +21,24 @@
     Args:
         file_path (str): The path to the JSON file.
         data (any): The Python object to save.
 
     Returns:
         str: The path to the saved file.
     """
-    with open(file_path, 'w') as fp:
+    with open(file_path, "w") as fp:
         js.dump(data, fp, sort_keys=False, indent=4)
     return file_path
 
 
 def load_from_json(file_path):
     """Load a Python object from a JSON file.
 
     Args:
         file_path (str): The path to the JSON file.
 
     Returns:
         any: The loaded Python object.
     """
-    with open(file_path, 'rb') as fp:
+    with open(file_path, "rb") as fp:
         data = js.load(fp)
     return data
```

## smaplib/fsio/pickle.py

```diff
@@ -1,33 +1,35 @@
+from __future__ import annotations
+
 import os as os
-import numpy as np
 import pickle as pk
 
+import numpy as np
 
 
 def save_to_pickle(file_path, data):
     """Saves a Python object to a pickle file at the specified file path.
 
     Args:
         file_path (str): The file path where the pickle file should be saved.
         data (any): The Python object to be saved.
 
     Returns:
         str: The file path of the saved pickle file.
     """
-    with open(file_path, 'wb') as fp:
+    with open(file_path, "wb") as fp:
         pk.dump(data, fp, protocol=pk.HIGHEST_PROTOCOL)
     return file_path
 
 
 def load_from_pickle(file_path):
     """Loads a Python object from a pickle file at the specified file path.
 
     Args:
         file_path (str): The file path of the pickle file to be loaded.
 
     Returns:
         any: The Python object loaded from the pickle file.
     """
-    with open(file_path, 'rb') as fp:
+    with open(file_path, "rb") as fp:
         data = pk.load(fp)
     return data
```

## smaplib/fsio/text.py

```diff
@@ -1,33 +1,34 @@
-import os as os
+from __future__ import annotations
 
+import os as os
 
 
 def save_text_to_text_file(file_path, text):
     """Saves a string of text to a text file at the specified file path.
 
     Args:
         file_path (str): The file path where the text file should be saved.
         text (str): The string of text to be saved.
 
     Returns:
         str: The file path of the saved text file.
     """
-    with open(file_path, 'w') as fp:
+    with open(file_path, "w") as fp:
         fp.write(text)
     return file_path
 
 
 def save_list_to_text_file(file_path, items):
     """Saves a list of items as a text file at the specified file path, with each item on a new line.
 
     Args:
         file_path (str): The file path where the text file should be saved.
         items (list): The list of items to be saved.
 
     Returns:
         str: The file path of the saved text file.
     """
-    with open(file_path, 'w') as fp:
+    with open(file_path, "w") as fp:
         for item in items:
-            fp.write(item + '\r\n')
+            fp.write(item + "\r\n")
     return file_path
```

## smaplib/img/__init__.py

```diff
@@ -1,6 +1,6 @@
-from __future__ import absolute_import
+from __future__ import annotations
 
 from . import classes
 from . import dss
 from . import helpers
 from . import plot
```

## smaplib/img/classes.py

```diff
@@ -1,20 +1,24 @@
+from __future__ import annotations
+
 import math as mth
-from typing import Optional, Tuple
+from typing import Optional
+from typing import Tuple
 
 
 class Rectangle:
     """A rectangle with coordinates (x, y) and dimensions (width, height).
 
     Args:
         x (int): The x-coordinate of the top-left corner of the rectangle.
         y (int): The y-coordinate of the top-left corner of the rectangle.
         width (int): The width of the rectangle.
         height (int): The height of the rectangle.
     """
+
     def __init__(self, x: int, y: int, width: int, height: int):
         self.x = x
         self.y = y
         self.width = width
         self.height = height
 
     def __repr__(self) -> str:
@@ -39,15 +43,15 @@
         return (*self.lt(), *self.rb())
 
     def size(self) -> Optional[Tuple[int, int]]:
         """
         Returns a tuple (width, height) representing the rectangle
         """
         return self.width, self.height
-    
+
     def area(self) -> int:
         """Calculate the area of the rectangle.
 
         Returns:
             float: The area of the rectangle.
         """
         return self.width * self.height
@@ -57,50 +61,50 @@
 
         Args:
             rectangle (Rectangle): The rectangle to check.
 
         Returns:
             bool: True if the given rectangle is contained within this rectangle, False otherwise.
         """
-        return (self.x <= rectangle.x
-                and self.y <= rectangle.y
-                and self.x + self.width >= rectangle.x + rectangle.width
-                and self.y + self.height >= rectangle.y + rectangle.height)
+        return (
+            self.x <= rectangle.x
+            and self.y <= rectangle.y
+            and self.x + self.width >= rectangle.x + rectangle.width
+            and self.y + self.height >= rectangle.y + rectangle.height
+        )
 
-    def grow(self, ratio, image_width, image_height) -> 'Rectangle':
+    def grow(self, ratio, image_width, image_height) -> "Rectangle":
         """Try and inflate a rectangle by a ratio, without exceeding the image itself.
 
         Args:
             ratio (float): The ratio by which to inflate the rectangle.
             image_width (int): The width of the image containing the rectangle.
             image_height (int): The height of the image containing the rectangle.
 
         Returns:
             Rectangle: The grown rectangle, given the constraints.
         """
         image = Rectangle(0, 0, image_width, image_height)
 
         w_max = min(
             min(self.x, image.width - (self.x + self.width)),
-            mth.floor(self.width * ratio / 2.0))
+            mth.floor(self.width * ratio / 2.0),
+        )
 
         h_max = min(
             min(self.y, image.height - (self.y + self.height)),
-            mth.floor(self.height * ratio / 2.0))
+            mth.floor(self.height * ratio / 2.0),
+        )
 
-        r_max = min(
-            2 * w_max / self.width,
-            2 * h_max / self.height)
+        r_max = min(2 * w_max / self.width, 2 * h_max / self.height)
 
         w = mth.floor(self.width * r_max / 2.0)
 
         h = mth.floor(self.height * r_max / 2.0)
 
         new_rec = Rectangle(
-            self.x - w,
-            self.y - h,
-            self.width + 2 * w,
-            self.height + 2 * h)
+            self.x - w, self.y - h, self.width + 2 * w, self.height + 2 * h
+        )
 
         assert image.contains(new_rec)
 
         return new_rec
```

## smaplib/img/dss.py

```diff
@@ -1,10 +1,17 @@
+from __future__ import annotations
+
+from collections.abc import Iterable
+from typing import List
+from typing import Optional
+from typing import Tuple
+from typing import Union
+
 import dataiku as di
 import numpy as np
-from typing import Iterable, List, Tuple, Union, Optional
 from PIL import Image as pim
 
 from . import helpers as lim
 from ..fsio import dss as lio
 from ..misc import iterable as it
 
 
@@ -15,15 +22,17 @@
     Attributes:
         __folder (str): The folder containing the image.
         __file_path (str): The file path of the image.
         __width (int): The target width of the image.
         __height (int): The target height of the image.
     """
 
-    def __init__(self, folder: Union[str, di.Folder], file_path: str, width: int, height: int):
+    def __init__(
+        self, folder: Union[str, di.Folder], file_path: str, width: int, height: int
+    ):
         """
         Initializes an instance of the ImageContainer class.
 
         Args:
             folder (Union[str, di.Folder]): The folder containing the image.
             file_path (str): The file path of the image.
             width (int): The target width of the image.
@@ -34,15 +43,20 @@
         self.__width = width
         self.__height = height
         self.__key = None
         self.__image = None
         self.__valid_image = False
 
     @staticmethod
-    def from_directory(folder: Union[str, di.Folder], files: Optional[List[str]], width: int, height: int):
+    def from_directory(
+        folder: Union[str, di.Folder],
+        files: Optional[List[str]],
+        width: int,
+        height: int,
+    ):
         """_summary_
 
         Args:
             folder (Union[str, di.Folder]): _description_
             files (Optional[List[str]]): _description_
             width (int): _description_
             height (int): _description_
@@ -55,31 +69,31 @@
         return [ImageContainer(handle, file, width, height) for file in file_list]
 
     def prepare(self):
         """
         Prepares the image by getting the key.
         """
         exists, info = lio.file_exists(self.__handle, self.__file_path)
-        
+
         if exists:
-            self.__key = info['name']
+            self.__key = info["name"]
         else:
             self.__key = None
-            
+
         return self.is_prepared()
 
     def validate(self):
         """_summary_
 
         Returns:
             _type_: _description_
         """
         self.__valid_image = is_valid_image(self.__handle, self.__file_path)
         return self.is_valid()
-    
+
     @property
     def key(self):
         """_summary_
 
         Returns:
             _type_: _description_
         """
@@ -94,36 +108,41 @@
         """
         return (self.__width, self.__height)
 
     @property
     def image(self):
         if self.__image is None:
             if not self.is_prepared():
-                raise Exception('The ImageContainer instance has not been prepared. Call prepared() first.')
-                
+                raise Exception(
+                    "The ImageContainer instance has not been prepared. Call prepared() first."
+                )
+
             if not self.is_valid():
-                raise Exception('The ImageContainer instance has not been validated. Call validate() first.')
-                
+                raise Exception(
+                    "The ImageContainer instance has not been validated. Call validate() first."
+                )
+
             self.__image = load_and_resize_image(
                 folder=self.__handle,
                 file_path=self.__file_path,
                 width=self.__width,
-                height=self.__height)
-            
+                height=self.__height,
+            )
+
         return self.__image
-            
+
     def is_prepared(self) -> bool:
         """
         Checks if the image is prepared.
 
         Returns:
             bool: True if the image is prepared, otherwise False.
         """
         return self.__key is not None
-       
+
     def is_valid(self) -> bool:
         """
         Checks if the image is valid.
 
         Returns:
             bool: True if the image is valid, otherwise False.
         """
@@ -137,20 +156,20 @@
             rescaled (bool, optional): Whether to rescale the image. Defaults to True.
 
         Returns:
             np.ndarray: The image as a batch array.
         """
         if self.image is None:
             return None
-        return lim.image_to_batch_array(
-            pil_image=self.image,
-            rescaled=rescaled)
+        return lim.image_to_batch_array(pil_image=self.image, rescaled=rescaled)
 
 
-def open_valid_image(folder: Union[str, di.Folder], file_path: str) -> Optional[pim.Image]:
+def open_valid_image(
+    folder: Union[str, di.Folder], file_path: str
+) -> Optional[pim.Image]:
     """Opens a valid image from the given folder and file path.
 
     Args:
         folder (Union[str, di.Folder]): The name of the DSS managed folder, or the folder handle.
         file_path (str): The path to the image file.
 
     Returns:
@@ -161,27 +180,29 @@
 
     if handle is not None:
         if is_valid_image(handle, file_path):
             return open_image(handle, file_path)
 
     return None
 
+
 def open_image(folder: Union[str, di.Folder], file_path: str) -> pim.Image:
     """Opens an image from the given folder and file path.
 
     Args:
         folder (Union[str, di.Folder]): The name of the DSS managed folder, or the folder handle.
         file_path (str): The path to the image file.
 
     Returns:
         np.ndarray: The loaded image.
     """
     with lio.get_folder(folder).get_download_stream(file_path) as stream:
         return pim.open(stream)
 
+
 def is_valid_image(folder: Union[str, di.Folder], file_path: str) -> bool:
     """
     Checks if the given file path corresponds to a valid image file.
 
     Args:
         folder (Union[str, di.Folder]): The name of the DSS managed folder, or the folder handle.
         file_path (str): The path to the file to check.
@@ -203,91 +224,99 @@
 
         return True
 
     except (IOError, SyntaxError, ValueError, OSError):
         # Catch specific exceptions that can occur when verifying the image file.
         return False
 
+
 def load_image(folder: Union[str, di.Folder], file_path: str) -> np.ndarray:
     """Loads an image from the given folder and file path.
 
     Args:
         folder (Union[str, di.Folder]): The name of the DSS managed folder, or the folder handle.
         file_path (str): The path to the image file.
 
     Returns:
         Image: The loaded image.
     """
-    return np.array(
-        open_image(
-            folder,
-            file_path))
+    return np.array(open_image(folder, file_path))
 
-def load_and_fit_image(folder: Union[str, di.Folder], file_path: str, width: Optional[int], height: Optional[int]) -> pim.Image:
+
+def load_and_fit_image(
+    folder: Union[str, di.Folder],
+    file_path: str,
+    width: Optional[int],
+    height: Optional[int],
+) -> pim.Image:
     """Loads an image and scales it to the given width and height while preserving aspect ratio.
 
     Args:
         folder (Union[str, di.Folder]): The name of the DSS managed folder, or the folder handle.
         file_path (str): The path to the image file.
         width (Optional[int]): The desired width of the image.
         height (Optional[int]): The desired height of the image.
 
     Returns:
         Image: The loaded and scaled image.
     """
-    return lim.fit_image(
-        open_image(folder, file_path),
-        width, 
-        height)
+    return lim.fit_image(open_image(folder, file_path), width, height)
+
 
-def load_and_resize_image(folder: Union[str, di.Folder], file_path: str, width: Optional[int], height: Optional[int]) -> pim.Image:
+def load_and_resize_image(
+    folder: Union[str, di.Folder],
+    file_path: str,
+    width: Optional[int],
+    height: Optional[int],
+) -> pim.Image:
     """Loads an image and resizes it to the given width and height.
 
     Args:
         folder (str or di.Folder): The name of the DSS managed folder, or the folder handle.
         file_path (str): The path to the image file.
         width (Optional[int]): The desired width of the image.
         height (Optional[int]): The desired height of the image.
 
     Returns:
         pim.Image: The loaded and resized image.
     """
-    return lim.resize_image(
-        open_image(folder, file_path),
-        width, 
-        height)
-    
-def get_images_as_batches(folder: Union[str, di.Folder], target_width: int, target_height: int, batch_size: int, rescaled: bool = True) -> Iterable[Tuple[np.ndarray, List[str]]]:
+    return lim.resize_image(open_image(folder, file_path), width, height)
+
+
+def get_images_as_batches(
+    folder: Union[str, di.Folder],
+    target_width: int,
+    target_height: int,
+    batch_size: int,
+    rescaled: bool = True,
+) -> Iterable[Tuple[np.ndarray, List[str]]]:
     """Returns image batches and file names for all images in a given directory.
 
     Args:
         images_path (str): The path to the directory containing the images.
         target_width (int): The desired width of the images.
         target_height (int): The desired height of the images.
         batch_size (int): The size of the batches to return.
         rescaled (bool, optional): Whether to rescale the images to the range [0,1]. Defaults to True.
 
     Yields:
         Tuple[numpy.ndarray, List[str]]: A tuple containing a batch of images and a list of their file names.
     """
     handle = lio.get_folder(folder)
-    
+
     files = [file_path for file_path in handle.list_paths_in_partition()]
-    
+
     for files_chunk in it.chunks(files, batch_size):
         images = []
         file_names = []
-        
+
         for file in files_chunk:
-            
             if is_valid_image(handle, file):
                 image = open_image(handle, file)
-            
-                images.append(
-                    lim.resize_image(image, target_width, target_height))
-                
-                file_names.append(
-                    handle.get_path_details(file)['name'])
 
-        yield lim.images_to_batch_array(pil_images=images, rescaled=rescaled), file_names
+                images.append(lim.resize_image(image, target_width, target_height))
 
+                file_names.append(handle.get_path_details(file)["name"])
 
+        yield lim.images_to_batch_array(
+            pil_images=images, rescaled=rescaled
+        ), file_names
```

## smaplib/img/helpers.py

```diff
@@ -1,108 +1,101 @@
+from __future__ import annotations
+
 import math as mth
+import os as os
+from typing import List
+from typing import Optional
+from typing import Tuple
+
 import numpy as np
 from PIL import Image as pim
 from PIL import ImageOps as pio
-import os as os
-from typing import List, Tuple, Optional
 
 from . import classes as cls
 
 
-
 def fit_image(
-    pil_image: pim.Image, 
-    width: Optional[int], 
-    height: Optional[int]) -> pim.Image:
+    pil_image: pim.Image, width: Optional[int], height: Optional[int]
+) -> pim.Image:
     """Resizes an image to the given maximum dimension while preserving aspect ratio.
 
     Args:
         pil_image (pim.Image): The image to resize.
         width (Optional[int]): The desired width of the image.
         height (Optional[int]): The desired height of the image.
 
     Returns:
         pim.Image: The resized image.
     """
     if width is None and height is None:
         return pil_image
-    
+
     if width is None:
         width = pil_image.width
-        
-    if height is None: 
+
+    if height is None:
         height = pil_image.height
 
-    return pio.fit(
-        pil_image,
-        (width, height),
-        pim.ANTIALIAS)
+    return pio.fit(pil_image, (width, height), pim.ANTIALIAS)
 
 
 def resize_image(
-    pil_image: pim.Image, 
-    width: Optional[int], 
-    height: Optional[int]) -> pim.Image:
+    pil_image: pim.Image, width: Optional[int], height: Optional[int]
+) -> pim.Image:
     """Resizes an image to the given width and height.
 
     Args:
         pil_image (pim.Image): The image to resize.
         width (Optional[int]): The desired width of the image.
         height (Optional[int]): The desired height of the image.
 
     Returns:
         pim.Image: The resized image.
     """
     if width is None and height is None:
         return pil_image
-    
+
     if width is None:
         width = pil_image.width
-        
-    if height is None: 
+
+    if height is None:
         height = pil_image.height
-        
-    return pil_image.resize(
-        size=(width, height), 
-        resample=pim.ANTIALIAS)
+
+    return pil_image.resize(size=(width, height), resample=pim.ANTIALIAS)
 
 
-def image_to_array(
-    pil_image: pim.Image, 
-    rescaled: bool = True) -> np.ndarray:
+def image_to_array(pil_image: pim.Image, rescaled: bool = True) -> np.ndarray:
     """Convert a PIL Image to a NumPy array.
 
     Args:
         pil_image (pim.Image): The input PIL Image.
         rescaled (bool, optional): Whether or not to rescale the array.
 
     Returns:
         np.ndarray: The NumPy array.
     """
     return np.array(pil_image, dtype=np.float32) / (255.0 if rescaled else 1.0)
 
 
-def image_to_batch_array(
-    pil_image: pim.Image, 
-    rescaled: bool = True) -> np.ndarray:
+def image_to_batch_array(pil_image: pim.Image, rescaled: bool = True) -> np.ndarray:
     """Convert a PIL Image to a batched NumPy array.
 
     Args:
         pil_image (pim.Image): The input PIL Image.
         rescaled (bool, optional): Whether or not to rescale the array.
 
     Returns:
         np.ndarray: The batched NumPy array.
     """
     return image_to_array(pil_image=pil_image, rescaled=rescaled)[np.newaxis, :, :, :]
 
 
 def images_to_batch_array(
-    pil_images: List[pim.Image], 
-    rescaled: bool = True) -> np.ndarray:
+    pil_images: List[pim.Image], rescaled: bool = True
+) -> np.ndarray:
     """Convert a list of PIL Images to a batched NumPy array.
 
     Args:
         pil_images (List[pim.Image]): The list of PIL Images.
         rescaled (bool, optional): Whether or not to rescale the array.
 
     Returns:
@@ -112,38 +105,38 @@
 
     for pil_image in pil_images:
         ar.append(image_to_array(pil_image, rescaled))
 
     return np.array(ar)
 
 
-def crop_image(
-    pil_image: pim.Image, 
-    rectangle: cls.Rectangle) -> pim.Image:
+def crop_image(pil_image: pim.Image, rectangle: cls.Rectangle) -> pim.Image:
     """Crop a PIL Image to a specified rectangle.
 
     Args:
         pil_image (pim.Image): The input PIL Image.
         rectangle (cim.Rectangle): The rectangle to crop.
 
     Returns:
         pim.Image: The cropped PIL Image.
     """
     return pil_image.transform(
-        size=(rectangle.width, rectangle. height),
+        size=(rectangle.width, rectangle.height),
         method=pim.EXTENT,
         resample=pim.ANTIALIAS,
-        data=rectangle.ltrb())
+        data=rectangle.ltrb(),
+    )
 
 
 def extract_square_portion(
-    image: pim.Image, 
-    horizontal_position: Optional[str], 
-    vertical_position: Optional[str], 
-    output_size: Optional[Tuple[int, int]]) -> pim.Image:
+    image: pim.Image,
+    horizontal_position: Optional[str],
+    vertical_position: Optional[str],
+    output_size: Optional[Tuple[int, int]],
+) -> pim.Image:
     """
     Extracts a square portion of a PIL Image.
 
     Args:
         image (pim.Image): The input PIL Image.
         horizontal_position (Optional[str]): The horizontal position of the portion (left, center, right).
         vertical_position (Optional[str]): The vertical position of the portion (top, middle, bottom).
@@ -151,43 +144,44 @@
 
     Returns:
         pim.Image: The extracted square portion.
     """
     max_dimension = min(image.width, image.height)
 
     # Determine the x coordinate of the left edge of the square portion based on the horizontal position.
-    if horizontal_position == 'left':
+    if horizontal_position == "left":
         x = 0
-    elif horizontal_position == 'center' or horizontal_position is None:
+    elif horizontal_position == "center" or horizontal_position is None:
         x = mth.floor((image.width - max_dimension) / 2)
-    elif horizontal_position == 'right':
+    elif horizontal_position == "right":
         x = image.width - max_dimension
     else:
-        raise ValueError(f'Invalid horizontal position: {horizontal_position}')
+        raise ValueError(f"Invalid horizontal position: {horizontal_position}")
 
     # Determine the y coordinate of the top edge of the square portion based on the vertical position.
-    if vertical_position == 'top':
+    if vertical_position == "top":
         y = 0
-    elif vertical_position == 'middle' or vertical_position is None:
+    elif vertical_position == "middle" or vertical_position is None:
         y = mth.floor((image.height - max_dimension) / 2)
-    elif vertical_position == 'bottom':
+    elif vertical_position == "bottom":
         y = image.height - max_dimension
     else:
-        raise ValueError(f'Invalid vertical position: {vertical_position}')
+        raise ValueError(f"Invalid vertical position: {vertical_position}")
 
     # If the output size is not specified, use the maximum dimension of the square portion.
     if output_size is None:
         output_size = (max_dimension, max_dimension)
 
     # Crop the image to the square portion.
     return image.transform(
         size=output_size,
         method=pim.EXTENT,
         resample=pim.ANTIALIAS,
-        data=(x, y, x + max_dimension, y + max_dimension))
+        data=(x, y, x + max_dimension, y + max_dimension),
+    )
 
 
 def open_image(file_path: str) -> pim.Image:
     """Opens an image from the given file path.
 
     Args:
         file_path (str): The path to the image file.
@@ -232,44 +226,40 @@
 
     Args:
         file_path (str): The path to the image file.
 
     Returns:
         Image: The loaded image.
     """
-    return np.array(
-        open_image(
-            file_path))
+    return np.array(open_image(file_path))
 
 
-def load_and_fit_image(file_path: str, width: Optional[int], height: Optional[int]) -> pim.Image:
+def load_and_fit_image(
+    file_path: str, width: Optional[int], height: Optional[int]
+) -> pim.Image:
     """Loads an image and scales it to the given width and height while preserving aspect ratio.
 
     Args:
         file_path (str): The path to the image file.
         width (Optional[int]): The desired width of the image.
         height (Optional[int]): The desired height of the image.
 
     Returns:
         Image: The loaded and scaled image.
     """
-    return fit_image(
-        open_image(file_path),
-        width, 
-        height)
+    return fit_image(open_image(file_path), width, height)
 
 
-def load_and_resize_image(file_path: str, width: Optional[int], height: Optional[int]) -> pim.Image:
+def load_and_resize_image(
+    file_path: str, width: Optional[int], height: Optional[int]
+) -> pim.Image:
     """Loads an image and resizes it to the given width and height.
 
     Args:
         file_path (str): The path to the image file.
         width (Optional[int]): The desired width of the image.
         height (Optional[int]): The desired height of the image.
 
     Returns:
         pim.Image: The loaded and resized image.
     """
-    return resize_image(
-        open_image(file_path),
-        width, 
-        height)
+    return resize_image(open_image(file_path), width, height)
```

## smaplib/img/plot.py

```diff
@@ -1,27 +1,25 @@
+from __future__ import annotations
+
 import matplotlib.pyplot as plt
 import numpy as np
 from PIL import Image as pim
 
 
-
-def display_image(pil_image: pim.Image, factor:int = 3):
+def display_image(pil_image: pim.Image, factor: int = 3):
     """
     Displays an image from a PIL image. The image is displayed with a
     figure size of 3 times the length and 2 times the width of the
     image.
 
     Args:
         pil_image (pim.Image): The PIL image to display.
         factor (int, optional): The factor to multiply the image size by. Defaults to 3.
     """
-    fig = plt.figure(figsize=(factor*3, factor*2))
+    plt.figure(figsize=(factor * 3, factor * 2))
 
     plt.grid(False)
-    plt.imshow(pil_image) # type: ignore
+    plt.imshow(pil_image)  # type: ignore
     axis = plt.gca()
     axis.get_xaxis().set_visible(False)  # disable x-axis
     axis.get_yaxis().set_visible(False)  # disable y-axis
     plt.show()
-
-
-
```

## smaplib/misc/__init__.py

```diff
@@ -1,7 +1,5 @@
-from __future__ import absolute_import
-
+from __future__ import annotations
 
 from . import common
 from . import http
 from . import iterable
-
```

## smaplib/misc/common.py

```diff
@@ -1,71 +1,74 @@
-import pandas as pd
-from typing import Dict, Any, List, Literal, Tuple
-import numpy as np
+from __future__ import annotations
+
 import re
-from urllib.parse import urlparse
 from enum import Enum
+from typing import Any
+from typing import Dict
+from typing import List
+from typing import Literal
+from typing import Tuple
+from urllib.parse import urlparse
+
+import numpy as np
+import pandas as pd
 
 
 def cleanup_dict(d: Dict[str, Any]) -> Dict[str, Any]:
     """
     Clean up dictionary values by converting pd.Timestamp objects to strings and replacing None with empty strings.
-    
+
     Args:
         d (Dict[str, Any]): The input dictionary.
 
     Returns:
         Dict[str, Any]: The cleaned-up dictionary.
     """
-    return {
-        name: format_value(value)
-        for name, value in d.items()
-    }
+    return {name: format_value(value) for name, value in d.items()}
 
 
 def format_value(value: Any) -> Any:
     """
     Formats the given value for display.
 
     Args:
         value (Any): The value to format.
 
     Returns:
         Any: The formatted value.
     """
     if value is None:
-        return '<<NULL>>'
+        return "<<NULL>>"
     elif isinstance(value, pd.Timestamp):
-        return value.strftime('%Y-%m-%d %X')
+        return value.strftime("%Y-%m-%d %X")
     else:
         return value
 
 
 def flatten_name_value_pairs(pairs: List[Tuple[str, Any, str]], separator: str) -> str:
     """Formats a list of name-value pairs into a flattened string with a separator between each pair.
 
     Args:
         pairs (List[Tuple[str, Any, str]]): A list of tuples, where each tuple contains the name, value, and format specifier for a pair to be formatted.
         separator (str): The separator to place between each name-value pair.
 
     Returns:
         str: A flattened string of name-value pairs with the specified separator between each pair.
     """
-    message = ''
+    message = ""
 
     for name, value, format in pairs:
-        message += '{0}: {1}{2}'.format(
-            name,
-            ('{0:'+format+'}').format(value),
-            separator)
-            
-    return message[:-1*len(separator)]
+        message += "{0}: {1}{2}".format(
+            name, ("{0:" + format + "}").format(value), separator
+        )
+
+    return message[: -1 * len(separator)]
 
 
-def shift_array(ar: np.ndarray, n:int) -> np.ndarray:
+def shift_array(ar: np.ndarray, n: int) -> np.ndarray:
     """Shifts the elements of a 1D NumPy array by a specified number of positions.
 
     Args:
         ar (np.ndarray): The 1D NumPy array to be shifted.
         n (int): The number of positions by which to shift the array. A positive value will shift the array to the right, and a negative value will shift the array to the left.
 
     Returns:
@@ -78,35 +81,37 @@
     else:
         e[n:] = np.nan
         e[:n] = ar[-n:]
     return e
 
 
 class StringKind(Enum):
-    """An enumeration of the kinds of strings (URL, file path, or other).
-    """
-    Url = 'Url'
-    Path = 'Path'
-    Other = 'Other'
+    """An enumeration of the kinds of strings (URL, file path, or other)."""
+
+    Url = "Url"
+    Path = "Path"
+    Other = "Other"
+
 
 def get_string_kind(string: str) -> StringKind:
     """Determines the kind of string (URL, file path, or other).
     Args:
         string (str): The string to be evaluated.
     Returns:
         StringKind: The kind of string.
     """
     try:
         url = urlparse(string)
 
         if url.scheme and url.netloc:
             return StringKind.Url
-        
-        file_path_pattern = re.compile(r'^(?:[a-zA-Z]:|\/|[a-zA-Z0-9_\-\s]+)(?:\/[a-zA-Z0-9_\-\s]+)*\.{0,1}[a-zA-Z0-9]*$')
+
+        file_path_pattern = re.compile(
+            r"^(?:[a-zA-Z]:|\/|[a-zA-Z0-9_\-\s]+)(?:\/[a-zA-Z0-9_\-\s]+)*\.{0,1}[a-zA-Z0-9]*$"
+        )
 
         if file_path_pattern.match(string):
             return StringKind.Path
-    except:
+    except Exception:
         pass
-    
-    return StringKind.Other
 
+    return StringKind.Other
```

## smaplib/misc/http.py

```diff
@@ -1,32 +1,32 @@
+from __future__ import annotations
+
 import io as io
-from typing import Any
-from PIL import Image as pim
 import urllib as ul
+from typing import Any
 
+from PIL import Image as pim
 
 
 def get_url(url: str, user_agent: str = None) -> Any:
     """Downloads the contents of a URL.
 
     Args:
         url (str): The URL to download.
         user_agent (str, optional): The user agent string to use in the request. Defaults to None.
 
     Returns:
         bytes: The downloaded content as bytes.
     """
     opener = ul.request.build_opener()
-    dummy_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36'
+    dummy_agent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36"
 
     opener.addheaders = [
-        (
-            'User-Agent',
-            dummy_agent if user_agent is None else user_agent
-        )]
+        ("User-Agent", dummy_agent if user_agent is None else user_agent)
+    ]
 
     ul.request.install_opener(opener)
     response = ul.request.urlopen(url)
 
     return response.read()
 
 
@@ -35,49 +35,45 @@
 
     Args:
         url (str): The URL to download.
 
     Returns:
         io.BytesIO: The downloaded content as a BytesIO object.
     """
-    return io.BytesIO(
-        get_url(url))
+    return io.BytesIO(get_url(url))
 
 
 def download_image(url: str) -> pim.Image:
     """Downloads an image from a URL and returns it as a PIL Image object.
 
     Args:
         url (str): The URL of the image to download.
 
     Returns:
         pim.Image: The downloaded image as a PIL Image object.
     """
-    return pim.Image.open(
-        download_bytes(
-            url))
+    return pim.Image.open(download_bytes(url))
 
 
 def download_text(url: str) -> str:
     """Downloads the contents of a URL as a string.
 
     Args:
         url (str): The URL to download.
 
     Returns:
         str: The downloaded content as a string.
     """
-    return str(
-        get_url(url))
+    return str(get_url(url))
 
 
 def get_url_filename(url: str) -> str:
     """Extracts the filename from a URL.
 
     Args:
         url (str): The URL to extract the filename from.
 
     Returns:
         str: The filename extracted from the URL.
     """
-    parts = url.split('/')
+    parts = url.split("/")
     return parts[-1]
```

## smaplib/misc/iterable.py

```diff
@@ -1,9 +1,15 @@
+from __future__ import annotations
+
 import itertools as it
-from typing import Any, Iterable, Tuple
+from collections.abc import Iterable
+from typing import Any
+from typing import Tuple
+
+import pandas as pd
 
 
 def chunks(iterable: Iterable, batch_size: int) -> Iterable:
     """
     Divide an iterable into chunks of a specified size.
 
     Args:
@@ -16,7 +22,23 @@
     """
     ite = iter(iterable)
     chunk = tuple(it.islice(ite, batch_size))
 
     while chunk:
         yield chunk
         chunk = tuple(it.islice(ite, batch_size))
+
+
+def iterate_dataframe(df: pd.DataFrame, return_index: bool) -> Iterable:
+    """
+    Iterate over a dataframe.
+    """
+    for row in df.itertuples(index=return_index):
+        yield row._asdict()
+
+
+def chunks_dataframe(df: pd.DataFrame, batch_size: int, return_index: bool) -> Iterable:
+    """
+    Divide a dataframe into chunks of a specified size.
+    """
+    for chunk in chunks(iterate_dataframe(df, return_index), batch_size):
+        yield chunk
```

## smaplib/pnc/__init__.py

```diff
@@ -1,5 +1,4 @@
-from __future__ import absolute_import
-
+from __future__ import annotations
 
 from . import classes
-from . import helpers
+from . import helpers
```

## smaplib/pnc/classes.py

```diff
@@ -1,16 +1,26 @@
+from __future__ import annotations
+
+from typing import Any
+from typing import Dict
+from typing import List
+from typing import Union
+
 import numpy as np
-from typing import List, Dict, Any, Union
 
 from ..misc import common as lco
 
 
-
 class PineconeIndexElement:
-    def __init__(self, key: str, vector: Union[np.ndarray, List[float]], metadata: Dict[str, Any] = None):
+    def __init__(
+        self,
+        key: str,
+        vector: Union[np.ndarray, List[float]],
+        metadata: Dict[str, Any] = None,
+    ):
         """
         Creates a new PineconeIndexElement.
 
         Args:
             key (str): The unique identifier for the element.
             vector (Union[np.ndarray, List[float]]): The vector representation of the element.
             metadata (Dict[str, Any], optional): Any additional metadata associated with the element. Defaults to None.
@@ -23,11 +33,11 @@
         """
         Returns a dictionary representation of the element.
 
         Returns:
             Dict[str, Any]: A dictionary containing the key, vector, and metadata of the element.
         """
         return {
-            'id': self.key,
-            'values': self.vector.tolist(),
-            'metadata': lco.cleanup_dict(self.metadata)
+            "id": self.key,
+            "values": self.vector.tolist(),
+            "metadata": lco.cleanup_dict(self.metadata),
         }
```

## smaplib/pnc/helpers.py

```diff
@@ -1,47 +1,47 @@
-import pinecone as pc
+from __future__ import annotations
+
 from typing import List
 
-from . import classes as cpi
+import pinecone as pc
 
+from . import classes as cpi
 
 
 def initialize_session(api_key: str, environment: str) -> None:
     """
     Initializes the Pinecone session with the given API key and environment.
 
     Args:
         api_key (str): The Pinecone API key.
         environment (str): The Pinecone environment to use.
     """
-    pc.init(
-        api_key=api_key, 
-        environment=environment)
+    pc.init(api_key=api_key, environment=environment)
 
 
-def get_or_create_index(name: str, dimension: int, metric: str, pod_type: str) -> pc.Index:
+def get_or_create_index(
+    name: str, dimension: int, metric: str, pod_type: str
+) -> pc.Index:
     """
     Returns the Pinecone index with the given name, or creates it if it does not exist.
 
     Args:
         name (str): The name of the index.
         dimension (int): The dimensionality of the vectors in the index.
         metric (str): The distance metric to use for the index.
         pod_type (str): The type of pod to use for the index.
 
     Returns:
         pc.Index: The Pinecone index.
     """
     if name not in pc.list_indexes():
         pc.create_index(
-            name=name, 
-            dimension=dimension, 
-            metric=metric, 
-            pod_type=pod_type)
-        
+            name=name, dimension=dimension, metric=metric, pod_type=pod_type
+        )
+
     return pc.Index(index_name=name)
 
 
 def validate_keys(index: pc.Index, namespace: str, keys: List[str]) -> List[str]:
     """
     Checks if the given keys are defined in the index.
 
@@ -50,17 +50,19 @@
         namespace (str): The namespace to use.
         key (List[str]): The keys to check.
 
     Returns:
         List[str]: The list of valid keys.
     """
     return index.fetch(keys, namespace).vectors.keys()
-        
 
-def upsert_elements(index: pc.Index, namespace: str, elements: List[cpi.PineconeIndexElement]) -> None:
+
+def upsert_elements(
+    index: pc.Index, namespace: str, elements: List[cpi.PineconeIndexElement]
+) -> None:
     """
     Upserts the given elements into the Pinecone index.
 
     Args:
         index (pc.Index): The Pinecone index.
         namespace (str): The namespace to use.
         elements (List[cpi.PineconeIndexElement]): The Pinecone index elements to upsert.
```

## smaplib/tsfl/__init__.py

```diff
@@ -1,4 +1,3 @@
-from __future__ import absolute_import
-
+from __future__ import annotations
 
 from . import helpers
```

## smaplib/tsfl/helpers.py

```diff
@@ -1,37 +1,36 @@
-import tensorflow as tf
-import tensorflow_hub as th
+from __future__ import annotations
+
 import os as os
 
+import tensorflow as tf
+import tensorflow_hub as th
 
 
 def set_tensorflow_hub_cache_location(path: str) -> None:
     """Sets the location of the Tensorflow Hub cache directory.
 
     Args:
         path (str): The path to the cache directory.
     """
-    os.environ['TFHUB_CACHE_DIR'] = path
-    
+    os.environ["TFHUB_CACHE_DIR"] = path
+
 
 def get_model(model_url: str) -> th.KerasLayer:
     """Get the Tensorflow Hub model at the given URL.
 
     Args:
         model_url (str): The URL of the Tensorflow Hub model.
 
     Returns:
         th.KerasLayer: The Tensorflow Hub model.
     """
     return th.KerasLayer(model_url)
-    
-    
+
+
 def print_tensorflow_version():
-    """Prints out the current versions of the Tensorflow and Tensorflow Hub libraries
-    """
+    """Prints out the current versions of the Tensorflow and Tensorflow Hub libraries"""
     print("Tensorflow version: {0}".format(tf.__version__))
     print("Tensorflow Hub version: {0}".format(th.__version__))
 
     for device in tf.config.list_physical_devices():
         print(device)
-
-
```

## Comparing `smaplib-1.0.1.dist-info/LICENSE` & `smaplib-1.0.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `smaplib-1.0.1.dist-info/RECORD` & `smaplib-1.0.3.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,30 +1,40 @@
-smaplib/__init__.py,sha256=4tZ8AiKFvegZzbWNePn_AV95euQhcS6p_WRitGYnN6Q,519
-smaplib/fsio/__init__.py,sha256=QO6TzJtg5zPheLob4eQBlXcPapNeOwE6tf7Typzzq1c,158
-smaplib/fsio/array.py,sha256=ag-Y6ekwlsz8GbsK-M6rYccfNtBHWrHBVXk0Uizvh_w,1921
-smaplib/fsio/common.py,sha256=Z3VinHO-V5Qk_PgixvETx0YBeHEVVwWTit7nN45DnIo,2815
-smaplib/fsio/dss.py,sha256=xOdJPjRwXuOy8AMYBX_ssAckR9mN9hycSPZTicVbS08,3128
-smaplib/fsio/json.py,sha256=hx_LloOWCzJqAMyKw79aAcnHPe69syfgsBmVxtcgbvY,904
-smaplib/fsio/pickle.py,sha256=_vKSWipB7QAqMRuwASX2_phNJ-W8LT3w3J9ORfvVzQQ,856
-smaplib/fsio/text.py,sha256=DBFEfzP3BbMtQUEPL-lmD8Z2VZ3lmET0dkxcU6eXbWU,914
-smaplib/img/__init__.py,sha256=uz_6GM7IjHM4oeH7TuEOrZJpmqelumEpXjXbZadWTA8,121
-smaplib/img/classes.py,sha256=hNkiP952b_O8fFFypv5Glu7daAUXHB1THySJf_6kZS4,3420
-smaplib/img/dss.py,sha256=OV_xmVuwUfrg3QKoPCkShGp0JPMYGyN7rpx0ujkvtd4,9468
-smaplib/img/helpers.py,sha256=elD5ZnLDfRMcybny74Ucfv0r4zmv9XaXbizUMwEcLjU,7878
-smaplib/img/plot.py,sha256=xgV4cSUnJvXsIIVU6EDseovDuOeTH93A1ibgla2pvq4,729
-smaplib/misc/__init__.py,sha256=0kmde5WN0MQbWI2lhZy-5GYteqvaqTvEUOGVZSs8APE,105
-smaplib/misc/common.py,sha256=SOc3sn3Ix2280pBAGTyuNM7GABeKweX0j9an4CDwOMI,3161
-smaplib/misc/http.py,sha256=UJ4dYRiInSNh9fCVAHD3ViKn1G9g3orRblqY61FZIyg,1970
-smaplib/misc/iterable.py,sha256=6f3pQTVtm47ftGHUBEMdNOmWZ67YTX-M4EJZPdu44hI,555
-smaplib/pnc/__init__.py,sha256=Dq_52-wUUUHCL9or3qai7D1DpWQGgVuPjMVTwx9k66c,84
-smaplib/pnc/classes.py,sha256=PI7Y3nzXciKvhd0uNHBre8dMMALZEZ7g2rxei_X95ds,1117
-smaplib/pnc/helpers.py,sha256=mPMGqTdQ9tlB64R-I2Nq4QuHMS5ZT6uH4T82-ntTUBA,2053
+setup.py,sha256=nr2RYN-TLMZpb8oTl7oFmeTzuAlyI6aPGtT-zlttLiQ,164
+smaplib/__init__.py,sha256=kSlBNoMJGPbIgaKcVHVmfnJ4TCbW51gSsY6HlTcrhls,937
+smaplib/fsio/__init__.py,sha256=GSZN9fNUURR8A6Q1x6pUZWzhwDu8Iv0CzWiZ8TgtG3o,154
+smaplib/fsio/array.py,sha256=rU5l_gj8U8i_fOfOcFxl6g5RR6qsetQ6q-ulfTDZ8O4,1956
+smaplib/fsio/common.py,sha256=t-vNkFHYatUeXa4JxYDaJWA2eoCSg50-I5G2vfqF7Dc,2775
+smaplib/fsio/dss.py,sha256=vapXQj0LvtXxqWu9-7MvpUm41qjbAKMU4qANVXNWpkA,3226
+smaplib/fsio/json.py,sha256=0S14Z2Wi6HUMpeWfarqHStHpLWoKq8CnjMGrQGvacgU,939
+smaplib/fsio/pickle.py,sha256=64OamtVrZbctoqQu4AVsY2CXi7pYi3ec5eiQ-R3tvv4,892
+smaplib/fsio/text.py,sha256=JGm-xM6N4FuR5Gd89rffQ8L21QBiAk265qBOYk1dOCg,949
+smaplib/img/__init__.py,sha256=VX2_ex6lYZHR-9ZV8FGbmdOwhyFbmkZghWdbFr2JqSg,117
+smaplib/img/classes.py,sha256=r2cCekfUEOwyBF65F6p6RcBxc0D6j08cSKZJzvfPx30,3449
+smaplib/img/dss.py,sha256=h8hA5E4UYsO7jfboQjBwL_v3zuwuqrgIGGx01bRz3nA,9521
+smaplib/img/helpers.py,sha256=21WWwi-5ds-LzB4zVg7JsE9LXDjCjmxru-rUnMRAo5c,7769
+smaplib/img/plot.py,sha256=YDNToUZg-Wvop3bDPOWJPp_dZCY2s80gl_hiHPYsz90,761
+smaplib/misc/__init__.py,sha256=mM4MHjuuP_iP1ad7d4kthvB1KruOfBw2u56mmYAcg6Y,99
+smaplib/misc/common.py,sha256=NjJujGOufvVKrudza-5EcI3hDuGMrDRI9PgkmsWHIps,3241
+smaplib/misc/http.py,sha256=TKmiEHkRUHVXWtKC-KDFa2mM9f4oWhv3pCHf92V4QkQ,1937
+smaplib/misc/iterable.py,sha256=zuqfNIWG6s0MCQJn789cG4TiP62iJ_MFdt_r7eZr41Y,1113
+smaplib/misc/tests/__init__.py,sha256=U4S_2y3zgLZVfMenHRaJFBW8yqh2mUBuI291LGQVOJ8,35
+smaplib/misc/tests/test_common.py,sha256=8bbqq_kVW8XHPIuXZSIwRGv4SB89V7MKySeYZYOTq7c,2032
+smaplib/pnc/__init__.py,sha256=-76HTn6dklpI1rZDmE279p7zq8CHxAPSNl_VCcxnyeE,80
+smaplib/pnc/classes.py,sha256=_pWgwZ_CFY_VVo9LdUzMYMFDn4g0-HjMklkPppEZTRs,1247
+smaplib/pnc/helpers.py,sha256=z1wYm3EYPefyNN-3EF6RKXThd-LbiZhUeoa4dDfRwn4,2037
+smaplib/sim/__init__.py,sha256=63AP-UZK9ea2K0el7B9VEhcJsORnHfb9YX5movfuBYA,160
+smaplib/sim/dataset.py,sha256=owvgTmHqAoNHMgAzzh9rEsrbhpxYzTWG5P2bqzYKyHA,3237
+smaplib/sim/feature.py,sha256=qGEmTCF3W7GFdVCKf5anuASOCrwKCQalHB2JO_K7WJQ,33872
+smaplib/sim/layer.py,sha256=ey4ZNYdb3lMT_VqWZNMZskRI_MWNjTpMrxY7lJxi71s,1015
+smaplib/sim/model.py,sha256=QPvLtcSKe--Fe94gxIUK9KwHeHPlzbhIfyOK42KXaSU,1972
+smaplib/sim/pca.py,sha256=DVEOmlF2iDug4suT0dM0Gpzn25ytUHAJsj_Ng77sZO4,1087
+smaplib/sim/trainer.py,sha256=1rcWqLFd76DvHYtM-jenqSpYON9jqCDvd3TRv6lrp_I,5106
 smaplib/similarity/__init__.py,sha256=UCizh7MFHOO_rzVn_HOqUXQQNuQQze7lAYydXAjG9Wo,85
 smaplib/similarity/feature.py,sha256=1ZnQ85jU5SQM3pw12DJQIguRtsjbKMpEoFUuHlqLOUs,23851
 smaplib/similarity/manager.py,sha256=Vi5qbTsucxRm7S-AupuR7W2GueW2EnbklVoCkqD5_F0,5735
-smaplib/tsfl/__init__.py,sha256=2Nc5vi-Ko0eZeneuD7Id-0fs6UkJyomJeh3BCGb80S4,63
-smaplib/tsfl/helpers.py,sha256=u9BQreh4OHaB5StzIXKBv0tHjviZjPRbPtHuM0BrrmY,932
-smaplib-1.0.1.dist-info/LICENSE,sha256=HKKCuMxK4CzcKTU3b7sYNA8X3N8uABzOHE98yqHRiTA,1073
-smaplib-1.0.1.dist-info/METADATA,sha256=Xv6QuJSVRwqYDogUm0sFkh7mxigMsCBgUSxF7D5AwN0,767
-smaplib-1.0.1.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-smaplib-1.0.1.dist-info/top_level.txt,sha256=CjSWmYIVBHK2qMuGIj3STwmQqx-ZsnyxoTuYa3PFBKw,8
-smaplib-1.0.1.dist-info/RECORD,,
+smaplib/tsfl/__init__.py,sha256=FuU93rb-GEFGMvGvbIaaOl-2Ms24qBBJvJapk-lK0L4,58
+smaplib/tsfl/helpers.py,sha256=AKV4JdDj6g6dE3VS0DJwjElCHU2bitezAeMEiVeU7ww,949
+smaplib-1.0.3.dist-info/LICENSE,sha256=HKKCuMxK4CzcKTU3b7sYNA8X3N8uABzOHE98yqHRiTA,1073
+smaplib-1.0.3.dist-info/METADATA,sha256=C5p-KtFda9Gq-ydrftpkuXVNnPWueC4ZBxbO_YhTqtI,2231
+smaplib-1.0.3.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+smaplib-1.0.3.dist-info/top_level.txt,sha256=CjSWmYIVBHK2qMuGIj3STwmQqx-ZsnyxoTuYa3PFBKw,8
+smaplib-1.0.3.dist-info/RECORD,,
```

