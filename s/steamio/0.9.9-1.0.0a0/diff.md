# Comparing `tmp/steamio-0.9.9.tar.gz` & `tmp/steamio-1.0.0a0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "steamio-0.9.9.tar", max compression
+gzip compressed data, was "steamio-1.0.0a0.tar", max compression
```

## Comparing `steamio-0.9.9.tar` & `steamio-1.0.0a0.tar`

### file list

```diff
@@ -1,97 +1,99 @@
--rw-r--r--   0        0        0     6849 2022-07-16 15:55:15.000000 steamio-0.9.9/LICENSE
--rw-r--r--   0        0        0     2710 2022-07-16 15:53:55.000000 steamio-0.9.9/README.md
--rw-r--r--   0        0        0     2223 2022-07-16 15:53:55.000000 steamio-0.9.9/build.py
--rw-r--r--   0        0        0     3775 2023-06-12 14:35:39.177349 steamio-0.9.9/pyproject.toml
--rw-r--r--   0        0        0     1112 2022-09-17 19:08:31.321031 steamio-0.9.9/steam/__init__.py
--rw-r--r--   0        0        0      496 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/__main__.py
--rw-r--r--   0        0        0      527 2023-05-20 12:03:01.034167 steamio-0.9.9/steam/__metadata__.py
--rw-r--r--   0        0        0     5423 2023-05-20 12:09:09.369658 steamio-0.9.9/steam/_const.py
--rw-r--r--   0        0        0    34979 2023-05-20 11:28:40.679421 steamio-0.9.9/steam/abc.py
--rw-r--r--   0        0        0     3989 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/badge.py
--rw-r--r--   0        0        0     4954 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/channel.py
--rw-r--r--   0        0        0    20143 2022-09-17 19:08:31.321457 steamio-0.9.9/steam/chat.py
--rw-r--r--   0        0        0    19534 2022-09-17 19:08:31.321638 steamio-0.9.9/steam/clan.py
--rw-r--r--   0        0        0    51212 2022-12-25 15:21:57.031771 steamio-0.9.9/steam/client.py
--rw-r--r--   0        0        0     2272 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/comment.py
--rw-r--r--   0        0        0    54164 2022-09-17 19:08:31.322137 steamio-0.9.9/steam/enums.py
--rw-r--r--   0        0        0     5685 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/errors.py
--rw-r--r--   0        0        0    13882 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/event.py
--rw-r--r--   0        0        0       76 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/ext/__init__.pyi
--rw-r--r--   0        0        0      249 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/ext/_gc/__init__.py
--rw-r--r--   0        0        0     2692 2022-09-17 19:08:31.322244 steamio-0.9.9/steam/ext/_gc/client.py
--rw-r--r--   0        0        0     4172 2022-09-17 19:08:31.322332 steamio-0.9.9/steam/ext/_gc/state.py
--rw-r--r--   0        0        0      283 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/ext/commands/__init__.py
--rw-r--r--   0        0        0    24898 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/ext/commands/bot.py
--rw-r--r--   0        0        0     8362 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/ext/commands/cog.py
--rw-r--r--   0        0        0    36982 2022-12-25 15:22:23.696735 steamio-0.9.9/steam/ext/commands/commands.py
--rw-r--r--   0        0        0     3350 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/ext/commands/context.py
--rw-r--r--   0        0        0    16878 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/ext/commands/converters.py
--rw-r--r--   0        0        0     4230 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/ext/commands/cooldown.py
--rw-r--r--   0        0        0     3584 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/ext/commands/errors.py
--rw-r--r--   0        0        0     6807 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/ext/commands/help.py
--rw-r--r--   0        0        0     4434 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/ext/commands/utils.py
--rw-r--r--   0        0        0     1924 2022-09-17 19:08:31.322581 steamio-0.9.9/steam/friend.py
--rw-r--r--   0        0        0    28372 2023-05-20 12:22:32.389588 steamio-0.9.9/steam/game.py
--rw-r--r--   0        0        0    13800 2022-09-17 19:08:31.322939 steamio-0.9.9/steam/game_server.py
--rw-r--r--   0        0        0    21769 2022-09-17 19:08:31.323091 steamio-0.9.9/steam/gateway.py
--rw-r--r--   0        0        0     1643 2022-09-17 19:08:31.323199 steamio-0.9.9/steam/group.py
--rw-r--r--   0        0        0     4335 2022-12-24 01:16:05.994890 steamio-0.9.9/steam/guard.py
--rw-r--r--   0        0        0    37745 2023-05-20 11:27:00.424677 steamio-0.9.9/steam/http.py
--rw-r--r--   0        0        0     4148 2022-09-17 19:08:31.323519 steamio-0.9.9/steam/image.py
--rw-r--r--   0        0        0     2709 2022-09-17 19:08:31.323625 steamio-0.9.9/steam/invite.py
--rw-r--r--   0        0        0    28711 2022-09-17 19:08:31.323797 steamio-0.9.9/steam/iterators.py
--rw-r--r--   0        0        0    33775 2023-06-11 21:18:05.421419 steamio-0.9.9/steam/manifest.py
--rw-r--r--   0        0        0     3645 2023-05-20 12:18:10.393377 steamio-0.9.9/steam/message.py
--rw-r--r--   0        0        0     8213 2022-09-17 19:08:31.324100 steamio-0.9.9/steam/models.py
--rw-r--r--   0        0        0    10056 2022-09-17 19:08:31.324206 steamio-0.9.9/steam/package.py
--rw-r--r--   0        0        0    15196 2022-09-17 19:08:31.324322 steamio-0.9.9/steam/profile.py
--rw-r--r--   0        0        0     5785 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/protobufs/__init__.py
--rw-r--r--   0        0        0     7682 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/app_info.py
--rw-r--r--   0        0        0    11110 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/base.py
--rw-r--r--   0        0        0    42005 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/chat.py
--rw-r--r--   0        0        0     1629 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/clan.py
--rw-r--r--   0        0        0    17207 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/client_server.py
--rw-r--r--   0        0        0    34144 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/client_server_2.py
--rw-r--r--   0        0        0     6074 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/protobufs/comments.py
--rw-r--r--   0        0        0     2739 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/content_manifest.py
--rw-r--r--   0        0        0     3001 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/protobufs/content_server.py
--rw-r--r--   0        0        0     4076 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/econ.py
--rw-r--r--   0        0        0    95433 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/emsg.py
--rw-r--r--   0        0        0      593 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/encrypted_app_ticket.py
--rw-r--r--   0        0        0     5500 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/friend_messages.py
--rw-r--r--   0        0        0    11533 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/friends.py
--rw-r--r--   0        0        0     4542 2022-07-16 15:53:55.000000 steamio-0.9.9/steam/protobufs/game_servers.py
--rw-r--r--   0        0        0     6226 2022-09-17 19:08:31.324425 steamio-0.9.9/steam/protobufs/headers.py
--rw-r--r--   0        0        0     5969 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/inventory.py
--rw-r--r--   0        0        0     3168 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/leaderboards.py
--rw-r--r--   0        0        0     7905 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/login.py
--rw-r--r--   0        0        0    10960 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/protobufs/loyalty_rewards.py
--rw-r--r--   0        0        0     4977 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/parental.py
--rw-r--r--   0        0        0    30650 2022-09-17 19:08:31.324548 steamio-0.9.9/steam/protobufs/player.py
--rw-r--r--   0        0        0    11924 2022-07-16 15:53:55.000000 steamio-0.9.9/steam/protobufs/protobufs.py
--rw-r--r--   0        0        0    26228 2022-09-17 19:08:31.324731 steamio-0.9.9/steam/protobufs/published_file.py
--rw-r--r--   0        0        0     4363 2022-09-17 19:08:31.324822 steamio-0.9.9/steam/protobufs/reviews.py
--rw-r--r--   0        0        0     2261 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/protobufs/struct_messages.py
--rw-r--r--   0        0        0     4610 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/two_factor.py
--rw-r--r--   0        0        0     9647 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/ucm.py
--rw-r--r--   0        0        0    35795 2022-09-17 19:08:31.324973 steamio-0.9.9/steam/protobufs/unified.py
--rw-r--r--   0        0        0     3726 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/protobufs/user_stats.py
--rw-r--r--   0        0        0    18146 2022-09-17 19:08:31.325107 steamio-0.9.9/steam/published_file.py
--rw-r--r--   0        0        0        0 2022-02-06 01:00:12.000000 steamio-0.9.9/steam/py.typed
--rw-r--r--   0        0        0     7808 2022-09-17 19:08:31.325235 steamio-0.9.9/steam/reaction.py
--rw-r--r--   0        0        0    10263 2022-09-17 19:08:31.325336 steamio-0.9.9/steam/review.py
--rw-r--r--   0        0        0     3683 2022-09-17 19:08:31.325431 steamio-0.9.9/steam/role.py
--rw-r--r--   0        0        0    82158 2023-05-20 12:21:04.828368 steamio-0.9.9/steam/state.py
--rw-r--r--   0        0        0    27562 2023-02-05 12:21:11.322961 steamio-0.9.9/steam/trade.py
--rw-r--r--   0        0        0      148 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/types/__init__.py
--rw-r--r--   0        0        0     3133 2022-09-17 19:08:31.326078 steamio-0.9.9/steam/types/game.py
--rw-r--r--   0        0        0      454 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/types/http.py
--rw-r--r--   0        0        0      238 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/types/id.py
--rw-r--r--   0        0        0     2257 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/types/manifest.py
--rw-r--r--   0        0        0      918 2022-09-17 19:08:31.326172 steamio-0.9.9/steam/types/package.py
--rw-r--r--   0        0        0     3299 2022-11-13 20:46:34.239927 steamio-0.9.9/steam/types/trade.py
--rw-r--r--   0        0        0      837 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/types/user.py
--rw-r--r--   0        0        0     1343 2022-07-16 15:55:15.000000 steamio-0.9.9/steam/types/vdf.py
--rw-r--r--   0        0        0    17988 2023-05-20 11:29:51.711213 steamio-0.9.9/steam/user.py
--rw-r--r--   0        0        0    25475 2022-09-17 19:08:31.326483 steamio-0.9.9/steam/utils.py
--rw-r--r--   0        0        0     4164 1970-01-01 00:00:00.000000 steamio-0.9.9/PKG-INFO
+-rw-r--r--   0        0        0     6550 2022-11-13 21:11:46.043904 steamio-1.0.0a0/LICENSE
+-rw-r--r--   0        0        0     2710 2022-11-13 21:11:46.043904 steamio-1.0.0a0/README.md
+-rw-r--r--   0        0        0     2180 2022-11-13 21:11:46.043904 steamio-1.0.0a0/build.py
+-rw-r--r--   0        0        0     4312 2022-11-13 21:11:46.047904 steamio-1.0.0a0/pyproject.toml
+-rw-r--r--   0        0        0     1089 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/__init__.py
+-rw-r--r--   0        0        0      496 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/__main__.py
+-rw-r--r--   0        0        0      538 2022-11-13 21:14:27.762162 steamio-1.0.0a0/steam/__metadata__.py
+-rw-r--r--   0        0        0     6889 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/_const.py
+-rw-r--r--   0        0        0    31495 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/abc.py
+-rw-r--r--   0        0        0    33364 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/app.py
+-rw-r--r--   0        0        0     4052 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/badge.py
+-rw-r--r--   0        0        0     7487 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/channel.py
+-rw-r--r--   0        0        0    24553 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/chat.py
+-rw-r--r--   0        0        0    23756 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/clan.py
+-rw-r--r--   0        0        0    54900 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/client.py
+-rw-r--r--   0        0        0     2253 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/comment.py
+-rw-r--r--   0        0        0    49097 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/enums.py
+-rw-r--r--   0        0        0     5726 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/errors.py
+-rw-r--r--   0        0        0    14330 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/event.py
+-rw-r--r--   0        0        0      249 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/_gc/__init__.py
+-rw-r--r--   0        0        0     2666 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/_gc/client.py
+-rw-r--r--   0        0        0     4637 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/_gc/state.py
+-rw-r--r--   0        0        0      283 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/__init__.py
+-rw-r--r--   0        0        0    24866 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/bot.py
+-rw-r--r--   0        0        0     8328 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/cog.py
+-rw-r--r--   0        0        0    36875 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/commands.py
+-rw-r--r--   0        0        0     3350 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/context.py
+-rw-r--r--   0        0        0    16869 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/converters.py
+-rw-r--r--   0        0        0     4204 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/cooldown.py
+-rw-r--r--   0        0        0     3584 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/errors.py
+-rw-r--r--   0        0        0     6777 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/help.py
+-rw-r--r--   0        0        0     4386 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/ext/commands/utils.py
+-rw-r--r--   0        0        0     1869 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/friend.py
+-rw-r--r--   0        0        0    12822 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/game_server.py
+-rw-r--r--   0        0        0    30542 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/gateway.py
+-rw-r--r--   0        0        0     1622 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/group.py
+-rw-r--r--   0        0        0     4500 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/guard.py
+-rw-r--r--   0        0        0    30837 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/http.py
+-rw-r--r--   0        0        0    17261 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/id.py
+-rw-r--r--   0        0        0     4136 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/image.py
+-rw-r--r--   0        0        0     2660 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/invite.py
+-rw-r--r--   0        0        0    33508 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/manifest.py
+-rw-r--r--   0        0        0     3690 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/message.py
+-rw-r--r--   0        0        0     9213 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/models.py
+-rw-r--r--   0        0        0     9135 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/package.py
+-rw-r--r--   0        0        0     1887 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/post.py
+-rw-r--r--   0        0        0    15741 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/profile.py
+-rw-r--r--   0        0        0     1931 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/protobufs/__init__.py
+-rw-r--r--   0        0        0     7732 2022-11-13 21:11:46.047904 steamio-1.0.0a0/steam/protobufs/app_info.py
+-rw-r--r--   0        0        0    10280 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/auth.py
+-rw-r--r--   0        0        0     9659 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/base.py
+-rw-r--r--   0        0        0    42333 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/chat.py
+-rw-r--r--   0        0        0     1596 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/clan.py
+-rw-r--r--   0        0        0    17107 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/client_server.py
+-rw-r--r--   0        0        0    35061 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/client_server_2.py
+-rw-r--r--   0        0        0     6054 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/comments.py
+-rw-r--r--   0        0        0     2715 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/content_manifest.py
+-rw-r--r--   0        0        0     3148 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/content_server.py
+-rw-r--r--   0        0        0     6010 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/econ.py
+-rw-r--r--   0        0        0    95570 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/emsg.py
+-rw-r--r--   0        0        0      593 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/encrypted_app_ticket.py
+-rw-r--r--   0        0        0     5586 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/friend_messages.py
+-rw-r--r--   0        0        0    12060 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/friends.py
+-rw-r--r--   0        0        0     4561 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/game_servers.py
+-rw-r--r--   0        0        0     4581 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/headers.py
+-rw-r--r--   0        0        0     5965 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/inventory.py
+-rw-r--r--   0        0        0     3201 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/leaderboards.py
+-rw-r--r--   0        0        0     8125 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/login.py
+-rw-r--r--   0        0        0    11271 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/loyalty_rewards.py
+-rw-r--r--   0        0        0    10203 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/msg.py
+-rw-r--r--   0        0        0     2338 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/notifications.py
+-rw-r--r--   0        0        0     5024 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/parental.py
+-rw-r--r--   0        0        0    30780 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/player.py
+-rw-r--r--   0        0        0    26465 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/published_file.py
+-rw-r--r--   0        0        0     4404 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/reviews.py
+-rw-r--r--   0        0        0    15907 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/store.py
+-rw-r--r--   0        0        0     1141 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/struct_messages.py
+-rw-r--r--   0        0        0     4629 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/two_factor.py
+-rw-r--r--   0        0        0     9678 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/ucm.py
+-rw-r--r--   0        0        0     3734 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/protobufs/user_stats.py
+-rw-r--r--   0        0        0    18159 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/published_file.py
+-rw-r--r--   0        0        0        0 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/py.typed
+-rw-r--r--   0        0        0    10492 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/reaction.py
+-rw-r--r--   0        0        0    10217 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/review.py
+-rw-r--r--   0        0        0     3633 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/role.py
+-rw-r--r--   0        0        0    85242 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/state.py
+-rw-r--r--   0        0        0    26154 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/trade.py
+-rw-r--r--   0        0        0      148 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/types/__init__.py
+-rw-r--r--   0        0        0     2906 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/types/app.py
+-rw-r--r--   0        0        0      522 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/types/http.py
+-rw-r--r--   0        0        0     1139 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/types/id.py
+-rw-r--r--   0        0        0     2256 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/types/manifest.py
+-rw-r--r--   0        0        0      917 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/types/package.py
+-rw-r--r--   0        0        0     3174 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/types/trade.py
+-rw-r--r--   0        0        0      837 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/types/user.py
+-rw-r--r--   0        0        0     1343 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/types/vdf.py
+-rw-r--r--   0        0        0    17061 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/user.py
+-rw-r--r--   0        0        0    19967 2022-11-13 21:11:46.051904 steamio-1.0.0a0/steam/utils.py
+-rw-r--r--   0        0        0     4052 1970-01-01 00:00:00.000000 steamio-1.0.0a0/PKG-INFO
```

### Comparing `steamio-0.9.9/LICENSE` & `steamio-1.0.0a0/LICENSE`

 * *Files 5% similar despite different names*

```diff
@@ -39,19 +39,16 @@
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 
-/steam/abc.py -> https://github.com/ValvePython/steam/tree/master/steam/steamid.py
+/steam/id.py -> https://github.com/ValvePython/steam/tree/master/steam/steamid.py
 /steam/gateway.py -> https://github.com/ValvePython/steam/blob/master/steam/core/cm.py
-/steam/utils.py -> https://github.com/ValvePython/steam/blob/master/steam/steamid.py
-/steam/protobufs/__init__.py -> https://github.com/ValvePython/steam/tree/master/steam/core/msg/__init__.py
-/steam/protobufs/headers.py -> https://github.com/ValvePython/steam/blob/master/steam/core/msg/headers.py
 
 This code also contains substantial portions of https://github.com/Rapptz/discord.py and so requires this license
 
 The MIT License (MIT)
 
 Copyright (c) 2015-present Rapptz
 
@@ -73,15 +70,15 @@
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.
 
 /steam/client.py -> https://github.com/Rapptz/discord.py/tree/master/discord/client.py
 /steam/gateway.py -> https://github.com/Rapptz/discord.py/tree/master/discord/gateway.py
 /steam/utils.py -> https://github.com/Rapptz/discord.py/tree/master/discord/utils.py
 /steam/ext/commands/bot.py -> https://github.com/Rapptz/discord.py/tree/master/discord/ext/commands/bot.py
-/steam/ext/commands/commands.py ->https://github.com/Rapptz/discord.py/tree/master/discord/ext/commands/core.py
+/steam/ext/commands/commands.py -> https://github.com/Rapptz/discord.py/tree/master/discord/ext/commands/core.py
 
 The code for /steam/guard.py also contains substantial portions of
 - https://github.com/bukson/steampy/blob/master/steampy/guard.py
 - https://github.com/Zwork101/steam-trade/blob/master/pytrade/confirmations.py
 and so requires these licenses
 
 MIT License
```

### Comparing `steamio-0.9.9/README.md` & `steamio-1.0.0a0/README.md`

 * *Files identical despite different names*

### Comparing `steamio-0.9.9/build.py` & `steamio-1.0.0a0/build.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,18 +34,16 @@
     end_char = " "  # if this was empty, it would raise a ValueError
 else:
     release_level = RELEASE_LEVELS[end_char]
 
     # try to find out the commit hash if checked out from git, and append it to __version__ (since we use this value
     # from setup.py, it gets automatically propagated to an installed copy as well)
     try:
-        commit_count = subprocess.check_output(["git", "rev-list", "--count", "HEAD"]).decode("utf-8").strip()
-        if commit_count:
-            commit_hash = subprocess.check_output(["git", "rev-parse", "--short", "HEAD"]).decode("utf-8").strip()
-            if commit_hash:
+        if commit_count := subprocess.check_output(["git", "rev-list", "--count", "HEAD"]).decode("utf-8").strip():
+            if commit_hash := subprocess.check_output(["git", "rev-parse", "--short", "HEAD"]).decode("utf-8").strip():
                 VERSION = f"{VERSION}{commit_count}+g{commit_hash}"
     except Exception:
         pass
 
 
 major, minor, micro = VERSION.split(".")
 micro = micro.split(end_char, maxsplit=1)[0]
```

### Comparing `steamio-0.9.9/pyproject.toml` & `steamio-1.0.0a0/pyproject.toml`

 * *Files 24% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 [tool.poetry]
 name = "steamio"
-version = "0.9.9"
+version = "1.0.0a"
 description = "A Python wrapper for the Steam API"
-authors = ["Gobot1234"]
+authors = ["Gobot1234 <gobot1234yt@gmail.com>"]
 license = "MIT"
 readme = "README.md"
 keywords = ["steam.py", "steam", "steamio", "steam-api"]
 classifiers=[
     "Development Status :: 5 - Production/Stable",
     "Framework :: AsyncIO",
     "Intended Audience :: Developers",
@@ -32,49 +32,53 @@
 
 [tool.poetry.urls]
 "Documentation" = "https://steam-py.github.io/docs/latest"
 "Code" = "https://github.com/Gobot1234/steam.py"
 "Bug Tracker" = "https://github.com/Gobot1234/steam.py/issues"
 
 [tool.poetry.dependencies]
-python = "^3.7"
-aiohttp = ">=3.7,<3.9"
+python = "^3.10"
+aiohttp = "^3.8"
 beautifulsoup4 = "^4.10"
-cryptography = "^37.0"
+cryptography = "^38.0"
 betterproto = "2.0.0b4"
-typing-extensions = "4.2.0"
+typing-extensions = "4.4.0"
 vdf = "^3.4"
 tomli = {version = "~2", optional = true, python = "<3.11"}
 
+[tool.poetry.group.speedups]
+optional = true
 [tool.poetry.group.speedups.dependencies]
 aiohttp = {version = ">=3.7,<3.9", extras = ["speedups"]}
 lxml = "^4.8.0"
 # orvdf = "^1.0.0"
 orjson = "^3.6.8"
 
+[tool.poetry.group.docs]
+optional = true
 [tool.poetry.group.docs.dependencies]
 sphinx = "^5.0"
 myst-parser = "^0.18"
 mypy = "^0.961"
 sphinxcontrib_trio = "^1.1.2"
 sphinx-copybutton = "^0.5.0"
 sphinx-codeautolink = "^0.10.0"
 csscompressor = "^0.9.5"
 htmlmin = "^0.1.12"
 rjsmin = "^1.2.0"
 
 [tool.poetry.group.dev.dependencies]
-black = "^22.1"
+black = "^22.3"
 isort = "^5.10"
 #flake8 = "^4.0"
 pytest = "^7.1"
 pytest-asyncio = "^0.18"
 mypy = "^0.961"
 pre-commit = "^2.18"
-poethepoet = {version="^0.13"}  #, extras=["poetry_plugin"]}
+poethepoet = {version="^0.13", extras=["poetry_plugin"]}
 blacken-docs = "^1.12"
 
 [tool.poe.tasks]
 test = {cmd = "pytest tests", help = "Run the tests"}
 _blacken_docs = {script = "scripts.blacken_docs_correctly:main"}
 _black = "black ."
 _isort = "isort ."
@@ -88,51 +92,66 @@
 [tool.poe.tasks.decode.args.input]
 required = true
 positional = true
 help = "A base64 encoded protobufs message from Steam to decode"
 
 [tool.black]
 line-length = 120
+python_version = "py310"
 
 [tool.isort]
 profile = "black"
 line_length = 120
 combine_as_imports = true
 atomic = true
 ensure_newline_before_comments = true
 
 [tool.blacken-docs]
 line-length = 120
-target-version = ["py37"]
+target-version = ["py310"]
 
 [tool.mypy]
 ignore_missing_imports = true
-strict_optional = false
 disallow_untyped_defs = true
 disallow_incomplete_defs = true
 check_untyped_defs = true
 disallow_untyped_decorators = true
 allow_redefinition = true
 show_error_codes = true
 warn_no_return = false
 pretty = true
-files = "steam/*.py, steam/ext/commands/*.py, steam/protobufs/__init__.py, steam/protobufs/headers.py"
-exclude = "venv, .venv"
 
 [tool.pyright]
 typeCheckingMode = "basic"
+pythonVersion = "3.10"
+useLibraryCodeForTypes = true
+exclude = ["tests", "steam/ext/commands"]
 reportSelfClsParameterName = "none"
 reportUntypedFunctionDecorator = "error"
 reportUntypedClassDecorator = "error"
 reportUntypedNamedTuple = "error"
-reportImplicitStringConcatenation = "none"  # I like to use this a fair bit
+reportImplicitStringConcatenation = "error"
 reportOverlappingOverload = "error"
 reportMissingTypeArgument = "error"
-venv = ".venv"
+strictListInference = true
+strictDictionaryInference = true
+strictSetInference = true
+strictParameterNoneValue = true
+reportMissingImports = "error"
+reportUnusedImport = "error"
+reportFunctionMemberAccess = "warning"
+reportDuplicateImport = "error"
+reportUnnecessaryTypeIgnoreComment = "warning"
+reportUnknownParameterType = "error"
+reportUnknownReturnType = "error"
+# reportUnknownArgumentType = "error"
+reportUnknownMemberType = "error"
+reportUnnecessaryComparison = true
+reportUnnecessaryContains = true
 
 [tool.pytest.ini_options]
 testpaths = ["tests"]
 asyncio_mode = "strict"
 
 [build-system]
-requires = ["poetry-core>=1.2", "tomli; python_version < '3.11'"]
+requires = ["poetry-core>=1.1.0,<2", "tomli; python_version < '3.11'"]
 build-backend = "poetry.core.masonry.api"
```

### Comparing `steamio-0.9.9/steam/__init__.py` & `steamio-1.0.0a0/steam/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,37 +6,37 @@
 
 Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE
 """
 
 from . import abc as abc, guard as guard, utils as utils
 from .__metadata__ import *
 from .abc import *
+from .app import *
 from .badge import *
 from .channel import *
 from .clan import *
 from .client import *
 from .comment import *
 from .enums import *
 from .errors import *
 from .event import *
 from .friend import *
-from .game import *
 from .game_server import *
 from .group import *
+from .id import *
 from .image import *
 from .invite import *
 from .manifest import *
 from .message import *
 from .models import *
 from .package import *
+from .post import *
 from .profile import *
 from .published_file import *
 from .reaction import *
 from .review import *
 from .role import *
 from .trade import *
 from .user import *
 
 __import__("logging").getLogger(__name__).addHandler(__import__("logging").NullHandler())  # don't leak scope
 __import__("warnings").filterwarnings("always", ".*", module=rf"{__name__}(.\w+)+", append=False)
-
-__getattr__ = enums.__getattr__  # shim for old enum names
```

### Comparing `steamio-0.9.9/steam/__metadata__.py` & `steamio-1.0.0a0/steam/__metadata__.py`

 * *Files 25% similar despite different names*

```diff
@@ -17,9 +17,9 @@
     micro: int
     releaselevel: Literal["alpha", "beta", "candidate", "final"]
 
 
 __title__: Final = "steam"
 __author__: Final = "Gobot1234"
 __license__: Final = "MIT"
-__version__: Final = "0.9.7"
-version_info: Final = VersionInfo(major=0, minor=9, micro=7, releaselevel="final")
+__version__: Final = "1.0.0a1+g1c4f422"
+version_info: Final = VersionInfo(major=1, minor=0, micro=0, releaselevel="alpha")
```

### Comparing `steamio-0.9.9/steam/abc.py` & `steamio-1.0.0a0/steam/app.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,1103 +1,1044 @@
-"""
-Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE
-
-Contains large portions of:
-https://github.com/ValvePython/steam/blob/master/steam/steamid.py
-The appropriate license is in LICENSE
-"""
+"""Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
-import abc
 import asyncio
 import re
-from collections.abc import Coroutine
-from datetime import datetime, timezone
-from typing import TYPE_CHECKING, Any, TypeVar
-
-import attr
-from typing_extensions import ClassVar, Final, Protocol, Required, Self, TypedDict, runtime_checkable
-
-from ._const import URL
-from .badge import FavouriteBadge, UserBadges
-from .enums import *
-from .errors import WSException
-from .game import Game, StatefulGame, UserGame, WishlistGame
-from .iterators import AsyncIterator, CommentsIterator, UserPublishedFilesIterator, UserReviewsIterator
-from .models import Ban
-from .profile import *
-from .reaction import Award, AwardReaction, Emoticon, MessageReaction, PartialMessageReaction, Sticker
-from .trade import Inventory
-from .utils import (
-    _INVITE_HEX,
-    _INVITE_MAPPING,
-    DateTime,
-    InstanceType,
-    Intable,
-    TypeType,
-    UniverseType,
-    cached_slot_property,
-    id64_from_url,
-    make_id64,
-)
+from collections.abc import AsyncGenerator, Sequence
+from dataclasses import dataclass
+from datetime import datetime, timedelta
+from typing import TYPE_CHECKING, Any, Final, Literal, NamedTuple, TypeVar, overload
+
+from . import utils
+from ._const import DOCS_BUILDING, MISSING, STATE, UNIX_EPOCH, URL
+from .enums import AppFlag, Enum, Language, PublishedFileQueryFileType, PublishedFileRevision, ReviewType
+from .id import ID, id64_from_url
+from .protobufs import client_server, player
+from .types.id import AppID, ContextID, Intable
+from .utils import DateTime
 
 if TYPE_CHECKING:
-    from aiohttp import ClientSession
-
     from .clan import Clan
-    from .comment import Comment
-    from .group import Group
-    from .http import StrOrURL
-    from .image import Image
-    from .message import Authors
-    from .protobufs.chat import Mentions
+    from .friend import Friend
+    from .manifest import AppInfo, Depot, HeadlessDepot, Manifest
+    from .package import FetchedAppPackage, License
+    from .published_file import PublishedFile
     from .review import Review
     from .state import ConnectionState
-    from .types.id import ID32, ID64
-    from .user import User
+    from .types import app
 
 __all__ = (
-    "SteamID",
-    "Message",
-    "Channel",
+    "App",
+    "TF2",
+    "LFD2",
+    "DOTA2",
+    "CSGO",
+    "STEAM",
+    "CUSTOM_APP",
+    "DLC",
+    "UserApp",
+    "WishlistApp",
+    "FetchedApp",
 )
 
-C = TypeVar("C", bound="Commentable")
-M_co = TypeVar("M_co", bound="Message", covariant=True)
+T = TypeVar("T")
+APP_ID_MAX: Final = AppID(1 << 32 - 1)
 
 
-# TODO when defaults are implemented, make this Generic over Literal[Type] maybe
-# TypeT = typing.TypeVar("TypeT", bound=Type)
-#
-#
-# class SteamID(typing.Generic[TypeT]):
-#     type TypeT
-class SteamID(metaclass=abc.ABCMeta):
-    """Convert a Steam ID between its various representations.
-
-    Note
-    ----
-    See :func:`steam.utils.make_id64` for the full parameter list.
+class App:
+    """Represents a Steam app.
+
+    Attributes
+    ----------
+    name
+        The app's name.
+    id
+        The app's app ID.
+    context_id
+        The context id of the app normally ``2``.
     """
 
-    __slots__ = ("__BASE",)
+    __slots__ = (
+        "id",
+        "name",
+        "context_id",
+    )
+
+    @overload
+    def __init__(self, *, id: Intable, name: str | None = ..., context_id: int | None = ...):
+        ...
+
+    @overload
+    def __init__(self, *, name: Literal["Team Fortress 2"], id: Intable = ..., context_id: int | None = ...):
+        ...
+
+    @overload
+    def __init__(self, *, name: Literal["Left 4 Dead 2"], id: Intable = ..., context_id: int | None = ...):
+        ...
+
+    @overload
+    def __init__(self, *, name: Literal["DOTA 2"], id: Intable = ..., context_id: int | None = ...):
+        ...
 
+    @overload
     def __init__(
-        self,
-        id: Intable = 0,
-        type: TypeType | None = None,
-        universe: UniverseType | None = None,
-        instance: InstanceType | None = None,
+        self, *, name: Literal["Counter Strike Global-Offensive"], id: Intable = ..., context_id: int | None = ...
     ):
-        self.__BASE: Final = make_id64(id, type, universe, instance)
+        ...
 
-    def __int__(self) -> ID64:
-        return self.__BASE
+    @overload
+    def __init__(self, *, name: Literal["Steam"], id: Intable = ..., context_id: int | None = ...):
+        ...
 
-    def __eq__(self, other: Any) -> bool:
-        try:
-            return self.__BASE == int(other)
-        except (TypeError, ValueError):
-            return NotImplemented
+    def __init__(
+        self,
+        *,
+        id: Intable | None = None,
+        name: str | None = None,
+        context_id: int | None = None,
+    ):
+        if name is None and id is None:
+            raise TypeError("__init__() missing a required keyword argument: 'id' or 'name'")
 
-    def __str__(self) -> str:
-        return str(self.__BASE)
+        if id is None:
+            app = utils.get(Apps, name=name)
+            if app is None:
+                raise ValueError(f"Cannot find a matching app for {name!r}")
+            id = app.id
+        else:
+            try:
+                id = int(id)
+            except (ValueError, TypeError):
+                raise ValueError("id expected to support int()") from None
+
+            app = utils.get(Apps, id=id)
+            if app is not None:
+                name = app.name
+
+        if id < 0:
+            raise ValueError("id cannot be negative")
+
+        if name == "Steam" and context_id is None:
+            context_id = 6
+
+        self.id: AppID = AppID(id)
+        self.name: str | None = name
+        self.context_id: ContextID = ContextID(2 if context_id is None else context_id)
 
-    def __hash__(self) -> int:
-        return hash(self.__BASE)
+    def __str__(self) -> str:
+        return self.name or ""
 
     def __repr__(self) -> str:
-        return f"SteamID(id={self.id}, type={self.type}, universe={self.universe}, instance={self.instance})"
-
-    @property
-    def instance(self) -> InstanceFlag:
-        """The instance of the SteamID."""
-        return InstanceFlag.try_value((self.__BASE >> 32) & 0xFFFFF)
+        attrs = ("name", "id", "context_id")
+        resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
+        return f"{self.__class__.__name__}({', '.join(resolved)})"
 
-    @property
-    def type(self) -> Type:
-        """The Steam type of the SteamID."""
-        return Type((self.__BASE >> 52) & 0xF)
+    def __eq__(self, other: Any) -> bool:
+        return self.id == other.id if isinstance(other, App) else NotImplemented
 
-    @property
-    def universe(self) -> Universe:
-        """The Steam universe of the SteamID."""
-        return Universe((self.__BASE >> 56) & 0xFF)
+    def __hash__(self) -> int:
+        return hash(self.id)
 
-    @property
-    def id64(self) -> ID64:
-        """The SteamID's 64-bit ID."""
-        return self.__BASE
+    def to_proto(self) -> client_server.CMsgClientGamesPlayedGamePlayed:
+        if self.is_valid():
+            return client_server.CMsgClientGamesPlayedGamePlayed(game_id=self.id)
+
+        if self.name is None or self.id is None:
+            raise TypeError("un-serializable app with no title and or id")
+        return client_server.CMsgClientGamesPlayedGamePlayed(game_id=self.id, game_extra_info=self.name)
 
-    @property
-    def id(self) -> ID32:
-        """The SteamID's 32-bit ID."""
-        return self.__BASE & 0xFFFFFFFF
+    def is_valid(self) -> bool:
+        """Whether the app could be a Steam app."""
+        return self.id <= APP_ID_MAX
 
     @property
-    def id2(self) -> str:
-        """The SteamID's ID 2.
+    def url(self) -> str:
+        """What should be the app's url on steamcommunity if applicable."""
+        return f"{URL.COMMUNITY}/app/{self.id}"
 
-        e.g ``STEAM_1:0:1234``.
-        """
-        return f"STEAM_{self.universe.value}:{self.id % 2}:{self.id >> 1}"
 
-    @property
-    def id2_zero(self) -> str:
-        """The SteamID's ID 2 accounted for bugged GoldSrc and Orange Box games.
+def CUSTOM_APP(
+    name: str,
+) -> App:  # TODO if actually optimising make this return a different class cause it's a u64 cause haha steam
+    """Create a custom app instance for :meth:`~steam.Client.change_presence`.
+    The :attr:`App.id` will be set to ``15190414816125648896`` and the :attr:`App.context_id` to ``None``.
 
-        Note
-        ----
-        In these games the accounts :attr:`universe`, ``1`` for :class:`.Type.Public`, should be the ``X`` component of
-        ``STEAM_X:0:1234`` however, this was bugged and the value of ``X`` was ``0``.
+    Example:
 
-        e.g ``STEAM_0:0:1234``.
-        """
-        return self.id2.replace("_1", "_0")
+    .. code-block:: python3
 
-    @property
-    def id3(self) -> str:
-        """The SteamID's ID 3.
+        await client.change_presence(app=steam.CUSTOM_APP("my cool game"))
 
-        e.g ``[U:1:1234]``.
-        """
-        type_char = TypeChar(self.type).name
-        instance = None
-
-        if self.type in (Type.AnonGameServer, Type.Multiseat):
-            instance = self.instance
-        elif self.type == Type.Individual:
-            if self.instance != InstanceFlag.Desktop:
-                instance = self.instance
-        elif self.type == Type.Chat:
-            if self.instance & InstanceFlag.ChatClan > 0:
-                type_char = "c"
-            elif self.instance & InstanceFlag.ChatLobby > 0:
-                type_char = "L"
-            else:
-                type_char = "T"
+    Parameters
+    ----------
+    name
+        The name of the app to set your playing status to.
+    """
+    return App(name=name, id=15190414816125648896, context_id=None)
 
-        return f"[{type_char}:{self.universe.value}:{self.id}{f':{instance.value}' if instance is not None else ''}]"
 
-    @property
-    def invite_code(self) -> str | None:
-        """The SteamID's invite code in the s.team invite code format.
+import hashlib
+from contextlib import asynccontextmanager
+from datetime import timezone
+from ipaddress import IPv4Address
+from zlib import crc32
+
+
+class Ignore:
+    async def changes_since(self, change_number: int) -> tuple[list[AppInfo], list[PackageInfo]]:
+        ...
+
+    async def fetch_encrypted_ticket(self, key: bytes, *, user_data: bytes = b"") -> GameTicket:
+        encrypted_ticket = await self._state.fetch_encrypted_app_ticket(self.id, user_data)
+        decrypted = utils.StructIO(utils.symmetric_decrypt(encrypted_ticket.encrypted_ticket, key))
+        if crc32(decrypted.buffer, encrypted_ticket.crc_encryptedticket):
+            raise ValueError
+
+        user_data = decrypted.buffer[: encrypted_ticket.cb_encrypteduserdata]
+        decrypted.seek(encrypted_ticket.cb_encrypteduserdata)
+        ticket_length = decrypted.read_u32()
+        ticket = GameTicket(
+            decrypted.buffer[
+                encrypted_ticket.encrypted_app_ticket.cb_encrypteduserdata
+                + ticket_length : encrypted_ticket.encrypted_app_ticket.cb_encrypteduserdata
+            ],
+            encrypted=True,
+        )
+        remainder = decrypted.buffer[encrypted_ticket.cb_encrypteduserdata + ticket_length :]
+        if len(remainder) >= 8 + 20:
+            to_hash = decrypted.buffer[: encrypted_ticket.cb_encrypteduserdata + ticket_length]
+            salt = remainder[:8]
+            hash = remainder[8:28]
+            remainder = remainder[28:]
+
+            hasher = hashlib.sha1(to_hash + salt)
+            digested = hasher.digest()
+            assert digested == hash, f"Oh no {digested} {hash}"
+
+        return ticket
+
+    @asynccontextmanager
+    async def create_auth_ticket(self) -> AsyncGenerator[GameTicket, None]:
+        """Create an authentication ticket for this game.
 
-        e.g. ``cv-dgb``.
-        """
-        if self.type == Type.Individual and self.is_valid():
-            invite_code = re.sub(f"[{_INVITE_HEX}]", lambda x: _INVITE_MAPPING[x.group()], f"{self.id:x}")
-            split_idx = len(invite_code) // 2
-            return invite_code if split_idx == 0 else f"{invite_code[:split_idx]}-{invite_code[split_idx:]}"
+        Examples
+        --------
 
-    @property
-    def invite_url(self) -> str | None:
-        """The SteamID's full invite code URL.
+        .. code-block:: python3
 
-        e.g ``https://s.team/p/cv-dgb``.
+            async with game.create_auth_ticket() as ticket:
+                ...  # send the ticket to a user or server
         """
-        code = self.invite_code
-        return f"https://s.team/p/{code}" if code else None
-
-    @property
-    def community_url(self) -> str | None:
-        """The SteamID's community url.
+        # for the ticket to be valid we have to be playing the game
+        to_dict = self.to_dict()
+        state = self._state
+        games = state._games.copy()  # keep a copy of the old list
+        if to_dict not in games:
+            await state.ws.change_presence(games=[*games, to_dict])
 
-        e.g https://steamcommunity.com/profiles/123456789.
-        """
-        suffix = {
-            Type.Individual: "profiles",
-            Type.Clan: "gid",
-        }
+        ticket = await state.create_ticket(self.id)
         try:
-            return f"https://steamcommunity.com/{suffix[self.type]}/{self.id64}"
-        except KeyError:
-            return None
-
-    def is_valid(self) -> bool:
-        """Whether the SteamID is valid."""
-        if self.type == Type.Invalid or self.type >= Type.Max:
-            return False
+            yield GameTicket(ticket, encrypted=False)
+        finally:
+            await state.cancel_ticket(self.id)
+            if to_dict not in games:
+                await state.ws.change_presence(games=games)
 
-        if self.universe == Universe.Invalid or self.universe >= Universe.Max:
-            return False
+    async def fetch_ownership_ticket(self) -> Ticket:
+        await self._state.fetch_ownership_ticket(self.id)
 
-        if self.type == Type.Individual and (self.id == 0 or self.instance > 4):
-            return False
 
-        if self.type == Type.Clan and (self.id == 0 or self.instance != 0):
-            return False
+class FriendThoughts(NamedTuple):
+    recommended: list[Friend]
+    not_recommended: list[Friend]
 
-        if self.type == Type.GameServer and self.id == 0:
-            return False
 
-        if self.type == Type.AnonGameServer and self.id == 0 and self.instance == 0:
-            return False
+class PartialApp(App):
+    """Apps that have state."""
 
-        return True
+    __slots__ = ("_state",)
 
-    @staticmethod
-    async def from_url(url: StrOrURL, session: ClientSession | None = None) -> SteamID | None:
-        """A helper function creates a SteamID instance from a Steam community url.
-
-        Note
-        ----
-        See :func:`id64_from_url` for the full parameter list.
-        """
-        id64 = await id64_from_url(url, session)
-        return SteamID(id64) if id64 else None
-
-
-class _CommentableKwargs(TypedDict, total=False):
-    id64: Required[int]
-    thread_type: Required[int]
-    gidfeature: int
-    gidfeature2: int
-    thread_id: int
-    upvotes: int
-    include_deleted: bool
+    def __init__(self, state: ConnectionState, **kwargs: Any):
+        super().__init__(**kwargs)
+        self._state = state
 
+    def __repr__(self) -> str:
+        attrs = ("name", "id", "context_id")
+        resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
+        return f"<{self.__class__.__name__} {' '.join(resolved)}>"
 
-class Commentable(Protocol):
-    """A mixin that implements commenting functionality."""
+    async def clan(self) -> Clan:
+        """Fetch this app's clan.
 
-    __slots__ = ()
-    _state: ConnectionState
+        This can be useful to get an App's updates.
 
-    @property
-    @abc.abstractmethod
-    def _commentable_kwargs(self) -> _CommentableKwargs:
-        raise NotImplementedError
+        .. code-block:: python3
 
-    async def fetch_comment(self, id: int) -> Comment[Self]:
-        """Fetch a comment by its ID.
+            clan = await app.clan()
+            async for update in clan.announcements():
+                if update.type in (steam.EventType.MajorUpdate, steam.EventType.SmallUpdate):
+                    ...  # do something with the update
 
-        Parameters
-        ----------
-        id
-            The ID of the comment to fetch.
+        Raises
+        ------
+        ValueError
+            This app has no associated clan.
         """
-        from .comment import Comment
 
-        comment = await self._state.fetch_comment(self, id)
-        return Comment(
-            self._state,
-            id=comment.id,
-            content=comment.content,
-            created_at=DateTime.from_timestamp(comment.timestamp),
-            author=await self._state._maybe_user(comment.author_id64),
-            owner=self,
-            reactions=[AwardReaction(self._state, reaction) for reaction in comment.reactions],
-        )
+        id64 = await id64_from_url(self.url, self._state.http._session)
+        if id64 is None:
+            raise ValueError("App has no associated clan")
+        clan = await self._state.fetch_clan(id64)
+        if clan is None:
+            raise ValueError("App has no associated clan")
+        return clan
+
+    async def player_count(self) -> int:
+        """The apps current player count."""
+        return await self._state.fetch_app_player_count(self.id)
+
+    async def friends_who_own(self) -> list[Friend]:
+        """Fetch the users in your friend list who own this app."""
+        id64s = await self._state.fetch_friends_who_own(self.id)
+        return [self._state.get_friend(id64) for id64 in id64s]
 
-    async def comment(self, content: str, *, subscribe: bool = True) -> Comment[Self]:
-        """Post a comment to a comments section.
+    async def review(
+        self,
+        content: str,
+        *,
+        recommend: bool,
+        public: bool = True,
+        commentable: bool = True,
+        received_compensation: bool = False,
+        language: Language | None = None,
+    ) -> Review:
+        """Review an app.
 
         Parameters
         ----------
         content
-            The message to add to the comment section.
-        subscribe
-            Whether to subscribe to notifications on any future activity in this comment's thread.
-
-        Returns
-        -------
-        The created comment.
+            The content of the review.
+        recommend
+            Whether you recommended the app.
+        public
+            Whether the review should be public.
+        commentable
+            Whether the review should allow comments.
+        received_compensation
+            Whether you received compensation for this review.
+        language
+            The language the review is in.
         """
-        return await self._state.post_comment(self, content, subscribe)
+        language = language or self._state.http.language
+        await self._state.http.post_review(
+            self.id, content, recommend, public, commentable, received_compensation, language.api_name
+        )
+        return await self._state.user.fetch_review(self)  # TODO this sucks can we actually get the id ourselves?
 
-    def comments(
+    async def reviews(
         self,
         *,
-        oldest_first: bool = False,
-        limit: int | None = None,
+        limit: int | None = 100,
         before: datetime | None = None,
         after: datetime | None = None,
-    ) -> CommentsIterator[Self]:
-        """An :class:`~steam.iterators.AsyncIterator` for accessing a comment section's :class:`~steam.Comment` objects.
+    ) -> AsyncGenerator[Review, None]:
+        """An :term:`async iterator` for accessing a :class:`steam.App`'s
+        :class:`steam.Review`\\s.
 
         Examples
         --------
 
         Usage:
 
         .. code-block:: python3
 
-            async for comment in commentable.comments(limit=10):
-                print("Author:", comment.author, "Said:", comment.content)
-
-        Flattening into a list:
-
-        .. code-block:: python3
-
-            comments = await commentable.comments(limit=50).flatten()
-            # comments is now a list of Comment
+            async for review in app.reviews(limit=10):
+                print("Reviewer:", review.author)
+                print("Said:", review.content)
 
         All parameters are optional.
 
         Parameters
         ----------
-        oldest_first
-            Whether or not to request comments with the oldest comments first or last. Defaults to ``False``.
         limit
-            The maximum number of comments to search through.
-            Default is ``None`` which will fetch the all the comments in the comments section.
+            The maximum number of reviews to search through. Default is ``100``. Setting this to ``None`` will fetch all
+            the app's reviews, but this will be a very slow operation.
         before
-            A time to search for comments before.
+            A time to search for reviews before.
         after
-            A time to search for comments after.
+            A time to search for reviews after.
 
         Yields
-        ---------
-        :class:`~steam.Comment`
-        """
-        return CommentsIterator(
-            oldest_first=oldest_first, owner=self, state=self._state, limit=limit, before=before, after=after
-        )
-
-
-class Awardable(Protocol):
-    """A mixin that implements award functionality."""
-
-    __slots__ = ()
-
-    id: int
-    _state: ConnectionState
-    _AWARDABLE_TYPE: ClassVar[int]
-
-    async def award(self, award: Award) -> None:
-        """Add an :class:`Award` to this piece of user generated content.
-
-        Parameters
-        ----------
-        award
-            The award to add.
-        """
-        await self._state.add_award(self, award)
-
-    # async def fetch_reactions(self) -> list[AwardReaction]:
-    #     """Fetch the reactions on this piece of user generated content."""
-    #     reactions = await self._state.fetch_award_reactions(self)
-    #     return [AwardReaction(self._state, reaction) for reaction in reactions]
-
-
-class BaseUser(SteamID, Commentable):
-    """An ABC that details the common operations on a Steam user.
-    The following classes implement this ABC:
-
-        - :class:`~steam.User`
-        - :class:`~steam.ClientUser`
-
-    .. container:: operations
-
-        .. describe:: x == y
-
-            Checks if two users are equal.
-
-        .. describe:: str(x)
-
-            Returns the user's name.
-
-    Attributes
-    ----------
-    name
-        The user's username.
-    state
-        The current persona state of the account (e.g. LookingToTrade).
-    game
-        The Game instance attached to the user. Is ``None`` if the user isn't in a game or one that is recognised by the
-        api.
-    primary_clan
-        The primary clan the User displays on their profile.
-
-        Note
-        ----
-        This can be lazily awaited to get more attributes of the clan.
-
-    avatar_url
-        The avatar url of the user. Uses the large (184x184 px) image url.
-    real_name
-        The user's real name defined by them. Could be ``None``.
-    created_at
-        The time at which the user's account was created. Could be ``None``.
-    last_logoff
-        The last time the user logged into steam. Could be None (e.g. if they are currently online).
-    country
-        The country code of the account. Could be ``None``.
-    flags
-        The persona state flags of the account.
-    rich_presence
-        The user's rich presence.
-    """
-
-    __slots__ = (
-        "name",
-        "game",
-        "state",
-        "flags",
-        "country",
-        "primary_clan",
-        "trade_url",
-        "real_name",
-        "avatar_url",
-        "last_seen_online",
-        "created_at",
-        "last_logoff",
-        "last_logon",
-        "rich_presence",
-        "privacy_state",
-        "community_url",
-        "comment_permissions",
-        "profile_state",
-        "_level",
-        "_state",
-        "__weakref__",
-    )
-
-    name: str
-    real_name: str | None
-    community_url: str | None
-    avatar_url: str | None  # TODO make this a property and add avatar hash
-    primary_clan: Clan | None
-    country: str | None
-    created_at: datetime | None
-    last_logoff: datetime | None
-    last_logon: datetime | None
-    last_seen_online: datetime | None
-    game: StatefulGame | None
-    state: PersonaState | None
-    flags: PersonaStateFlag | None
-    privacy_state: CommunityVisibilityState | None
-    comment_permissions: CommentPrivacyState | None
-    profile_state: CommunityVisibilityState | None
-    rich_presence: dict[str, str] | None
-    _state: ConnectionState
-
-    def __repr__(self) -> str:
-        attrs = ("name", "state", "id", "universe", "instance")
-        resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
-        return f"<{self.__class__.__name__} {' '.join(resolved)}>"
-
-    def __str__(self) -> str:
-        return self.name
-
-    @property
-    def _commentable_kwargs(self) -> _CommentableKwargs:
-        return {
-            "id64": self.id64,
-            "thread_type": 10,
-        }
-
-    @property
-    def mention(self) -> str:
-        """The string used to mention the user in chat."""
-        return f"[mention={self.id}]@{self.name}[/mention]"
-
-    async def inventory(self, game: Game, *, language: Language | None = None) -> Inventory:
-        """Fetch a user's :class:`~steam.Inventory` for trading.
-
-        Parameters
-        -----------
-        game
-            The game to fetch the inventory for.
-        language
-            The language to fetch the inventory in. If ``None`` will default to the current language.
-
-        Raises
         ------
-        :exc:`~steam.Forbidden`
-            The user's inventory is private.
-        """
-        resp = await self._state.http.get_user_inventory(self.id64, game.id, game.context_id, language)
-        return Inventory(state=self._state, data=resp, owner=self, game=game, language=language)
-
-    async def friends(self) -> list[User]:
-        """Fetch the list of the users friends."""
-        friends = await self._state.http.get_friends(self.id64)
-        return [self._state._store_user(friend) for friend in friends]
-
-    async def games(self, *, include_free: bool = True) -> list[UserGame]:
-        r"""Fetches the :class:`~steam.Game`\s the user owns.
-
-        Parameters
-        ----------
-        include_free
-            Whether to include free games in the list. Defaults to ``True``.
+        :class:`~steam.Review`
         """
-        games = await self._state.fetch_user_games(self.id64, include_free)
-        return [UserGame(self._state, game) for game in games]
+        from .review import Review, ReviewApp
 
-    async def clans(self) -> list[Clan]:
-        r"""Fetches a list of :class:`~steam.Clan`\s the user is in."""
-
-        async def getter(gid: int) -> Clan:
-            try:
-                clan = await self._state.client.fetch_clan(gid)
-                assert clan is not None
-                return clan
-            except WSException as exc:
-                if exc.code == Result.RateLimitExceeded:
-                    await asyncio.sleep(20)
-                    return await getter(gid)
-                raise
-
-        resp = await self._state.http.get_user_clans(self.id64)
-        return await asyncio.gather(*(getter(int(clan["gid"])) for clan in resp["response"]["groups"]))  # type: ignore
-
-    async def bans(self) -> Ban:
-        r"""Fetches the user's :class:`.Ban`\s."""
-        resp = await self._state.http.get_user_bans(self.id64)
-        resp = resp["players"][0]
-        resp["EconomyBan"] = resp["EconomyBan"] != "none"
-        return Ban(data=resp)
-
-    async def badges(self) -> UserBadges:
-        r"""Fetches the user's :class:`.UserBadges`\s."""
-        resp = await self._state.http.get_user_badges(self.id64)
-        return UserBadges(self._state, data=resp["response"])
-
-    async def level(self) -> int:
-        """Fetches the user's level if your account is premium, otherwise it's cached."""
-        if self._state.http.api_key is not None:
-            resp = await self._state.http.get_user_level(self.id64)
-            return resp["response"]["player_level"]
-        return self._level
-
-    async def wishlist(self) -> list[WishlistGame]:
-        r"""Get the :class:`.WishlistGame`\s the user has on their wishlist."""
-        data = await self._state.http.get_wishlist(self.id64)
-        return [WishlistGame(self._state, id=id, data=game_info) for id, game_info in data.items()]
-
-    async def favourite_badge(self) -> FavouriteBadge | None:
-        """The user's favourite badge."""
-        badge = await self._state.fetch_user_favourite_badge(self.id64)
-        if not badge.has_favorite_badge:
-            return
-
-        return FavouriteBadge(
-            id=UserBadge.try_value(badge.badgeid),
-            item_id=badge.communityitemid,
-            type=badge.item_type,
-            border_colour=badge.border_color,
-            game=StatefulGame(self._state, id=badge.appid) if badge.appid else None,
-            level=badge.level,
+        after = after or UNIX_EPOCH
+        before = before or DateTime.now()
+        cursor = "*"
+        app = self
+
+        yielded = 0
+
+        while True:
+            data = await self._state.http.get_reviews(self.id, "all", "all", "all", cursor)
+            if cursor == "*":
+                app = ReviewApp(self._state, self.id, data["query_summary"]["review_score"])
+            assert isinstance(app, ReviewApp)
+            cursor = data["cursor"]
+            reviews = data["reviews"]
+
+            for review, user in zip(
+                reviews,
+                await self._state.fetch_users(int(review["author"]["steamid"]) for review in reviews),
+            ):
+                if user is None:
+                    continue
+                review = Review._from_data(self._state, review, app, user)
+                if not after < review.created_at < before:
+                    return
+                if limit is not None and yielded >= limit:
+                    return
+
+                yield review
+                yielded += 1
+
+    async def friend_thoughts(self) -> FriendThoughts:
+        """Fetch the client user's friends who recommended and didn't recommend this app in a review.
+
+        .. source:: FriendThoughts
+        """
+        proto = await self._state.fetch_friend_thoughts(self.id)
+        return FriendThoughts(
+            [self._state.get_friend(utils.parse_id64(id)) for id in proto.accountids_recommended],
+            [self._state.get_friend(utils.parse_id64(id)) for id in proto.accountids_not_recommended],
         )
 
-    async def equipped_profile_items(self, *, language: Language | None = None) -> EquippedProfileItems:
-        """The user's equipped profile items.
+    # async def fetch(self) -> Self & FetchedApp:  # TODO update signature to this when types.Intersection is done
+    #     fetched = await self._state.client.fetch_app(self)
+    #     return utils.update_class(fetched, copy.copy(self))
 
-        Parameters
-        ----------
-        language
-            The language to fetch the profile items in. If ``None`` the current language is used
-        """
-        items = await self._state.fetch_user_equipped_profile_items(self.id64, language)
-        return EquippedProfileItems(
-            background=ProfileItem(self._state, self, items.profile_background) if items.profile_background else None,
-            mini_profile_background=(
-                ProfileItem(self._state, self, items.mini_profile_background) if items.mini_profile_background else None
-            ),
-            avatar_frame=ProfileItem(self._state, self, items.avatar_frame) if items.avatar_frame else None,
-            animated_avatar=ProfileItem(self._state, self, items.animated_avatar) if items.animated_avatar else None,
-            modifier=ProfileItem(self._state, self, items.profile_modifier) if items.profile_modifier else None,
-        )
+    async def fetch(self, *, language: Language | None = None) -> FetchedApp:
+        """Shorthand for:
 
-    async def profile_customisation_info(self, *, language: Language | None = None) -> ProfileCustomisation:
-        """Fetch a user's profile customisation information.
+        .. code-block:: python3
 
-        Parameters
-        ----------
-        language
-            The language to fetch the profile items in. If ``None`` the current language is used
+            app = await client.fetch_app(app)
         """
-        info = await self._state.fetch_user_profile_customisation(self.id64, language)
-        return ProfileCustomisation(self._state, self, info)
-
-    async def profile(self, *, language: Language | None = None) -> Profile:
-        """Fetch a user's entire profile information.
+        app = await self._state.client.fetch_app(self, language=language)
+        if app is None:
+            raise ValueError("Fetched app was not valid.")
+        return app
+
+    async def depots(self) -> Sequence[Depot | HeadlessDepot]:
+        info = await self.info()
+        return await info.depots()
+
+    async def fetch_manifest(
+        self, *, id: int, depot_id: int, branch: str = "public", password_hash: str = ""
+    ) -> Manifest:
+        """Fetch a CDN manifest for an app.
 
         Parameters
         ----------
-        language
-            The language to fetch the profile items in. If ``None`` the current language is used
-
-        Note
-        ----
-        This calls all the profile related functions to return a Profile object which has all the info set.
+        id
+            The ID of the manifest to fetch.
+        depot_id
+            The ID of the manifest's associated depot.
+        branch
+            The name of the branch the manifest is from.
+        password_hash
+            The hashed password for the manifest.
         """
-
-        return Profile(
-            *await asyncio.gather(
-                self.equipped_profile_items(language=language),
-                self.profile_customisation_info(language=language),
-            )
+        return await self._state.fetch_manifest(
+            self.id, id, depot_id, name=None, branch=branch, password_hash=password_hash
         )
 
-    def is_commentable(self) -> bool:
-        """Specifies if the user's account can be commented on."""
-        if hasattr(self, "is_friend"):
-            return self.comment_permissions in (
-                CommentPrivacyState.Public,
-                CommentPrivacyState.FriendsOnly if self.is_friend() else CommentPrivacyState.Public,
-            )
-        return True  # our account
-
-    def is_private(self) -> bool:
-        """Specifies if the user has a private profile."""
-        return self.privacy_state == CommunityVisibilityState.Private
-
-    async def is_banned(self) -> bool:
-        """Specifies if the user is banned from any part of Steam.
-
-        Shorthand for:
-
-        .. code-block:: python3
-
-            bans = await user.bans()
-            bans.is_banned()
-        """
-        bans = await self.bans()
-        return bans.is_banned()
-
-    def reviews(
+    async def manifests(
         self,
         *,
-        limit: int | None = None,
+        limit: int | None = 100,
         before: datetime | None = None,
         after: datetime | None = None,
-    ) -> UserReviewsIterator:
-        """An :class:`~steam.iterators.AsyncIterator` for accessing a user's :class:`~steam.Review`\\s.
+        branch: str = "public",
+        password: str | None = None,
+        password_hash: str = "",
+    ) -> AsyncGenerator[Manifest, None]:
+        """An :term:`async iterator` for accessing a :class:`steam.App`'s
+        :class:`steam.Manifest`\\s.
 
         Examples
         --------
-        Usage:
-
-        .. code-block:: python3
 
-            async for review in user.reviews(limit=10):
-                print(f"Author: {review.author} {'recommended' if review.recommend 'doesn\\'t recommend'} {review.game}")
-
-        Flattening into a list:
+        Usage:
 
         .. code-block:: python3
 
-            reviews = await user.reviews(limit=50).flatten()
-            # reviews is now a list of Review
+            async for manifest in app.manifests(limit=10):
+                print("Manifest:", manifest.name)
+                print(f"Contains {len(manifest.paths)} manifests")
 
         All parameters are optional.
 
         Parameters
         ----------
         limit
-            The maximum number of reviews to search through. Setting this to ``None`` will fetch all the
-            user's reviews.
+            The maximum number of :class:`.Manifests` to return.
         before
-            A time to search for reviews before.
+            The time to get manifests before.
         after
-            A time to search for reviews after.
+            The time to get manifests after.
+        branch
+            The name of the branch to fetch manifests from.
+        password
+            The password for the branch, if any.
+        password_hash
+            The hashed password for a manifest.
 
         Yields
         ------
-        :class:`~steam.Review`
-        """
-        return UserReviewsIterator(self._state, self, limit, before, after)
-
-    async def fetch_review(self, game: Game) -> Review:
-        """Fetch this user's review for a game.
-
-        Parameters
-        ----------
-        game
-            The games to fetch the reviews for.
-        """
-        (review,) = await self.fetch_reviews(game)
-        return review
-
-    async def fetch_reviews(self, *games: Game) -> list[Review]:
-        """Fetch this user's review for games.
-
-        Parameters
-        ----------
-        games
-            The games to fetch the reviews for.
+        :class:`Manifest`
         """
-        from .review import Review
+        manifest_coros = await self._state.fetch_manifests(self.id, branch, password, limit, password_hash)
+        for chunk in utils.as_chunks(manifest_coros, 100):
+            for manifest in await asyncio.gather(*chunk):
+                if after < manifest.created_at < before:
+                    yield manifest
 
-        reviews = await self._state.fetch_user_review(self.id64, (game.id for game in games))
-        return [Review._from_proto(self._state, review, self) for review in reviews]
-
-    def published_files(
+    async def published_files(
         self,
         *,
-        game: Game | None = None,
+        type: PublishedFileQueryFileType = PublishedFileQueryFileType.Items,
         revision: PublishedFileRevision = PublishedFileRevision.Default,
-        type: PublishedFileType = PublishedFileType.Community,
         language: Language | None = None,
-        limit: int | None = None,
+        limit: int | None = 100,
         before: datetime | None = None,
         after: datetime | None = None,
-    ) -> UserPublishedFilesIterator:
-        """An :class:`~steam.iterators.AsyncIterator` for accessing a user's :class:`~steam.PublishedFile`\\s.
+    ) -> AsyncGenerator[PublishedFile, None]:
+        """An :term:`async iterator` for accessing an app's :class:`steam.PublishedFile`\\s.
 
         Examples
         --------
 
         Usage:
 
         .. code-block:: python3
 
-            async for file in user.published_files(limit=10):
-                print("Author:", file.author, "Published:", file.name)
-
-        Flattening into a list:
-
-        .. code-block:: python3
-
-            files = await user.published_files(limit=50).flatten()
-            # files is now a list of PublishedFile
+            async for published_file in app.published_files(limit=10):
+                print("Published file:", published_file.name)
+                print("Published at:", published_file.created_at)
+                print("Published by:", published_file.author)
 
         All parameters are optional.
 
         Parameters
         ----------
-        game
-            The game to fetch published files in.
         type
-            The type of published file to fetch.
+            The type of published files to fetch.
         revision
-            The desired revision of the published file to fetch.
+            The desired revision of the published files to fetch.
         language
-            The language to fetch the published file in. If ``None``, the current language is used.
+            The language to fetch the published files in. If ``None`` the current language is used.
         limit
-            The maximum number of published files to search through. Setting this to ``None`` will fetch all of the
-            user's published files.
+            The maximum number of published files to search through. Default is ``100``. Setting this to ``None`` will
+            fetch all the app's published files, but this will be a very slow operation.
         before
             A time to search for published files before.
         after
             A time to search for published files after.
 
         Yields
         ------
         :class:`~steam.PublishedFile`
         """
-        return UserPublishedFilesIterator(self._state, self, game, type, revision, language, limit, before, after)
+        from .published_file import PublishedFile
 
-    @classmethod
-    def _patch_without_api(cls) -> None:
-        import functools
-
-        def __init__(self, state: ConnectionState, data: dict[str, Any]) -> None:
-            super().__init__(data["steamid"])
-            self._state = state
-            self.name = data["persona_name"]
-            self.avatar_url = data.get("avatar_url") or self.avatar_url
-            self.community_url = super().community_url
-            self.trade_url = URL.COMMUNITY / "tradeoffer/new/" % {"partner": str(self.id)}
-
-            self.real_name = NotImplemented
-            self.primary_clan = NotImplemented
-            self.country = NotImplemented
-            self.created_at = NotImplemented
-            self.last_logoff = NotImplemented
-            self.last_logon = NotImplemented
-            self.last_seen_online = NotImplemented
-            self.game = NotImplemented
-            self.state = NotImplemented
-            self.flags = NotImplemented
-            self.privacy_state = NotImplemented
-            self.comment_permissions = NotImplemented
-            self.profile_state = NotImplemented
-            self._level = data["level"]
-
-        def __repr__(self) -> str:
-            attrs = ("name", "id", "type", "universe", "instance")
-            resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
-            return f"<{self.__class__.__name__} {' '.join(resolved)}>"
-
-        setattr(cls, "__init__", __init__)
-        setattr(cls, "__repr__", __repr__)
-
-        def not_implemented(function: str) -> None:
-            @functools.wraps(getattr(cls, function))
-            async def wrapped(*_, **__) -> None:
-                raise NotImplementedError(
-                    f"Accounts without an API key cannot use User.{function}, this is a Steam limitation not a library "
-                    f"limitation, sorry."
-                )
-
-            setattr(cls, function, wrapped)
-
-        not_implemented("friends")
-        not_implemented("badges")
-        not_implemented("is_commentable")
-        not_implemented("is_private")
-        not_implemented("is_banned")
-
-
-@runtime_checkable
-class Messageable(Protocol[M_co]):
-    """An ABC that details the common operations on a Steam message.
-    The following classes implement this ABC:
-
-        - :class:`~steam.User`
-        - :class:`~steam.ClanChannel`
-        - :class:`~steam.GroupChannel`
-        - :class:`~steam.DMChannel`
-    """
+        before = before or DateTime.now()
+        after = after or UNIX_EPOCH
+        remaining = None
+        cursor = "*"
+        yielded = 0
+
+        while remaining is None or remaining > 0:
+            protos = await self._state.fetch_app_published_files(self.id, type, revision, language, limit, cursor)
+            if remaining is None:
+                remaining = protos.total
+            remaining -= len(protos.publishedfiledetails)
+            cursor = protos.next_cursor
+
+            files: list[PublishedFile] = []
+            for file in protos.publishedfiledetails:
+                file = PublishedFile(self._state, file, ID(file.creator))
+                if not after < file.created_at < before:
+                    remaining = 0
+                    break
+                files.append(file)
+
+            for file, author in zip(files, await self._state._maybe_users(file.author.id64 for file in files)):
+                if limit is not None and yielded >= limit:
+                    return
+                file.author = author
+                yield file
+                yielded += 1
 
-    __slots__ = ()
+    async def info(self) -> AppInfo:
+        """Shorthand for:
+
+        .. code-block:: python3
 
-    @abc.abstractmethod
-    def _message_func(self, content: str) -> Coroutine[Any, Any, M_co]:
-        raise NotImplementedError
-
-    @abc.abstractmethod
-    def _image_func(self, image: Image) -> Coroutine[Any, Any, None]:
-        raise NotImplementedError
+            (info,) = await client.fetch_product_info(apps=[app])
+        """
+        (info,), _ = await self._state.fetch_product_info((self.id,))
+        return info
 
-    async def send(self, content: Any = None, image: Image | None = None) -> M_co | None:
-        """Send a message to a certain destination.
+    async def dlc(self, *, language: Language | None = None) -> list[DLC]:
+        """Fetch the app's DLC.
 
         Parameters
         ----------
-        content
-            The content of the message to send.
-        image
-            The image to send to the user.
-
-        Note
-        ----
-        Anything as passed to ``content`` is implicitly cast to a :class:`str`.
+        language
+            The language to fetch the DLC in. If ``None``, the current language will be used.
+        """
+        data = await self._state.http.get_app_dlc(self.id, language)
+        self.name = data["name"]
+        return [DLC(self._state, dlc) for dlc in data["dlc"]]
+
+    async def packages(self, *, language: Language | None = None) -> list[FetchedAppPackage]:
+        """Fetch the app's packages.
+
+        Parameters
+        ----------
+        language
+            The language to fetch the packages in. If ``None``, the current language will be used.
+        """
+        fetched = await self.fetch(language=language)
+        return fetched._packages
+
+    async def add_free_licenses(self) -> list[License]:
+        """Request the free licenses for this app.
 
         Raises
         ------
-        :exc:`~steam.HTTPException`
-            Sending the message failed.
-        :exc:`~steam.Forbidden`
-            You do not have permission to send the message.
-
-        Returns
-        -------
-        The sent message, only applicable if ``content`` is passed.
+        ValueError
+            No licenses were granted.
         """
-        message = None if content is None else await self._message_func(str(content))
-        if image is not None:
-            await self._image_func(image)
+        _, licenses = await self._state.request_free_license(self.id)
+        return licenses
 
-        return message
 
+class Apps(PartialApp, Enum):
+    """This is "enum" to trick type checkers into allowing Literal[TF2] to be valid for overloads in extensions."""
 
-@attr.dataclass(slots=True)
-class Channel(Messageable[M_co]):
-    _state: ConnectionState
-    clan: Clan | None = None
-    group: Group | None = None
+    __slots__ = ("_name",)
 
-    @abc.abstractmethod
-    def history(
-        self,
-        *,
-        limit: int | None = 100,
-        before: datetime | None = None,
-        after: datetime | None = None,
-    ) -> AsyncIterator[M_co]:
-        """An :class:`~steam.iterators.AsyncIterator` for accessing a channel's :class:`steam.Message`\\s.
+    def __new__(cls, name: str, *args: Any, value: tuple[str, int, int] | tuple[()] = ()) -> Apps:
+        self = object.__new__(cls)
+        set_attribute = object.__setattr__
 
-        Examples
-        --------
+        if args:  # being called when docs are building
+            name = ""
+            value = (name, args[0], args[1])
 
-        Usage:
+        assert value
+        set_attribute(self, "_name", name)
+        set_attribute(self, "name", value[0])
+        set_attribute(self, "id", value[1])
+        set_attribute(self, "context_id", value[2])
+        return self
 
-        .. code-block:: python3
+    if DOCS_BUILDING:
 
-            async for message in channel.history(limit=10):
-                print("Author:", message.author, "Said:", message.content)
+        def __init__(self, *args: Any) -> None:
+            ...
 
-        Flattening into a list:
+    def __repr__(self) -> str:
+        return self._name
 
-        .. code-block:: python3
+    @property
+    def value(self) -> int:
+        return self.id
 
-            messages = await channel.history(limit=50).flatten()
-            # messages is now a list of Message
+    TF2 = "Team Fortress 2", 440, 2
+    LFD2 = "Left 4 Dead 2", 550, 2
+    DOTA2 = "DOTA 2", 570, 2
+    CSGO = "Counter Strike Global-Offensive", 730, 2
+    STEAM = "Steam", 753, 6
 
-        All parameters are optional.
+    @property
+    def _state(self) -> ConnectionState:
+        state = STATE.get(MISSING)
+        if state is MISSING:
+            raise ValueError("Cannot access the state of constant apps outside of a client.")
+        return state
+
+
+TF2 = Apps.TF2  #: The Team Fortress 2 app.
+DOTA2 = Apps.DOTA2  #: The DOTA 2 app.
+CSGO = Apps.CSGO  #: The Counter Strike Global-Offensive app.
+LFD2 = Apps.LFD2  #: The Left 4 Dead 2 app.
+STEAM = Apps.STEAM  #: The Steam app with context ID 6 (gifts).
+
+
+@dataclass(slots=True)
+class PartialAppPriceOverview:
+    currency: str
+    initial: int
+    final: int
+    discount_percent: int
 
-        Parameters
-        ----------
-        limit
-            The maximum number of messages to search through. Setting this to ``None`` will fetch all of the channel's
-            messages, but this will be a very slow operation.
-        before
-            A time to search for messages before.
-        after
-            A time to search for messages after.
 
-        Yields
-        ------
-        :class:`~steam.Message`
-        """
-        raise NotImplementedError
+class DLC(PartialApp):
+    """Represents DLC (downloadable content) for an app.
 
+    Attributes
+    ----------
+    created_at
+        The time the DLC was released at.
+    logo_url
+        The logo url of the DLC.
+    price_overview
+        A price overview for the DLC.
+    """
 
-def _clean_up_content(content: str) -> str:  # steam does weird stuff with content
-    return content.replace(r"\[", "[").replace("\\\\", "\\")
+    name: str
 
+    __slots__ = (
+        "created_at",
+        "logo_url",
+        "price_overview",
+        "_on_windows",
+        "_on_mac_os",
+        "_on_linux",
+    )
 
-STEAM_EPOCH = datetime(2005, 1, 1, tzinfo=timezone.utc)
+    def __init__(self, state: ConnectionState, data: app.DLC):
+        super().__init__(state, id=data["id"], name=data["name"])
+        self.created_at = DateTime.from_timestamp(int(data["release_date"]["steam"]))
+        self.logo_url: str = data["header_image"]
+        self.price_overview = PartialAppPriceOverview(**data["price_overview"])
+
+        platforms = data["platforms"]
+        self._on_windows: bool = platforms["windows"]
+        self._on_mac_os: bool = platforms["mac"]
+        self._on_linux: bool = platforms["linux"]
+
+    def is_free(self) -> bool:
+        """Whether the app is free to download."""
+        return not self.price_overview.final
+
+    def is_on_windows(self) -> bool:
+        """Whether the app is playable on Windows."""
+        return self._on_windows
+
+    def is_on_mac_os(self) -> bool:
+        """Whether the app is playable on macOS."""
+        return self._on_mac_os
+
+    def is_on_linux(self) -> bool:
+        """Whether the app is playable on Linux."""
+        return self._on_linux
 
 
-class Message(metaclass=abc.ABCMeta):
-    """Represents a message from a :class:`~steam.User`. This is a base class from which all messages inherit.
+class UserApp(PartialApp):
+    """Represents a Steam app fetched by :meth:`steam.User.apps`
 
-    The following classes implement this:
+    Attributes
+    ----------
+    playtime_forever
+        The total time the app has been played for.
+    icon_url
+        The icon url of the app.
+    playtime_two_weeks
+        The amount of time the user has played the app in the last two weeks.
+    playtime_windows
+        The total amount of time the user has played the app on Windows.
+    playtime_mac_os
+        The total amount of time the user has played the app on macOS.
+    playtime_linux
+        The total amount of time the user has played the app on Linux.
+    last_played_at
+        The time the user last played this app at.
+    """
 
-        - :class:`~steam.UserMessage`
-        - :class:`~steam.GroupMessage`
-        - :class:`~steam.ClanMessage`
+    __slots__ = (
+        "playtime_forever",
+        "playtime_two_weeks",
+        "playtime_windows",
+        "playtime_mac_os",
+        "playtime_linux",
+        "icon_url",
+        "last_played_at",
+        "_stats_visible",
+    )
 
-    .. container:: operations
+    name: str
+
+    def __init__(self, state: ConnectionState, proto: player.GetOwnedGamesResponseGame):
+        super().__init__(state=state, id=proto.appid, name=proto.name)
+        self.playtime_forever: timedelta = timedelta(minutes=proto.playtime_forever)
+        self.playtime_two_weeks: timedelta = timedelta(minutes=proto.playtime_2_weeks)
+        self.playtime_windows: timedelta = timedelta(minutes=proto.playtime_windows_forever)
+        self.playtime_mac_os: timedelta = timedelta(minutes=proto.playtime_mac_forever)
+        self.playtime_linux: timedelta = timedelta(minutes=proto.playtime_linux_forever)
+        self.icon_url = (
+            f"https://cdn.cloudflare.steamstatic.com/steamcommunity/public/images/apps/{self.id}/"
+            f"{proto.img_icon_url}.jpg"
+        )
+        self.last_played_at = DateTime.from_timestamp(proto.rtime_last_played)
 
-        .. describe:: x == y
+        self._stats_visible = proto.has_community_visible_stats
 
-            Checks if two messages are equal
+    def has_visible_stats(self) -> bool:
+        """Whether the app has publicly visible stats."""
+        return self._stats_visible
 
-        .. describe:: hash(x)
 
-            Returns the hash of a message.
+class WishlistApp(PartialApp):
+    """Represents a Steam app fetched by :meth:`steam.User.wishlist`\\.
 
+    Attributes
+    ----------
+    priority
+        The priority of the app in the wishlist.
+    added_at
+        The time that the app was added to their wishlist.
+    created_at
+        The time the app was uploaded at.
+    background_url
+        The background URL of the app.
+    rank
+        The global rank of the app by popularity.
+    review_status
+        The review status of the app.
+    score
+        The score of the app out of ten.
+    screenshots
+        The screenshots of the app.
+    tags
+        The tags of the app.
+    total_reviews
+        The total number reviews for the app.
+    type
+        The type of the app.
+    logo_url
+        The logo url of the app.
     """
 
     __slots__ = (
-        "author",
-        "content",
-        "channel",
-        "clean_content",
+        "priority",
+        "added_at",
+        "background_url",
         "created_at",
-        "ordinal",
-        "group",
-        "clan",
-        "mentions",
-        "reactions",
-        "partial_reactions",
-        "_id_cs",
-        "_state",
+        "logo_url",
+        "rank",
+        "review_status",
+        "score",
+        "screenshots",
+        "tags",
+        "total_reviews",
+        "type",
+        "_free",
+        "_on_linux",
+        "_on_mac_os",
+        "_on_windows",
     )
 
-    author: Authors
-    """The message's author."""
-    channel: Channel[Self]
-    """The channel the message was sent in."""
-    content: str
-    """The message's content.
-
-    Note
-    ----
-    This is **not** what you will see in the steam client see :attr:`clean_content` for that.
-    """
-    clean_content: str
-    """The message's clean content without BBCode."""
-    created_at: datetime
-    """The time this message was sent at."""
-    clan: Clan | None
-    """The clan the message was sent in. Will be ``None`` if the message wasn't sent in a :class:`~steam.Clan`."""
-    group: Group | None
-    """The group the message was sent in. Will be ``None`` if the message wasn't sent in a :class:`~steam.Group`."""
-    reactions: list[MessageReaction]
-    """The message's reactions."""
-    ordinal: int
-    """A per-channel incremented integer up to ``1000`` for every message sent in a second window."""
-    mentions: Mentions | None
-    """An object representing mentions in this message."""
-    reactions: list[MessageReaction]
-    """The reactions this message has received."""
-    partial_reactions: list[PartialMessageReaction]
-
-    def __init__(self, channel: Channel[Self], proto: Any):
-        self._state: ConnectionState = channel._state
-        self.channel = channel
-        self.group = channel.group
-        self.clan = channel.clan
-        self.content = _clean_up_content(proto.message)
-        self.ordinal = proto.ordinal
-        self.clean_content = getattr(proto, "message_no_bbcode", "") or self.content
-        self.mentions = getattr(proto, "mentions", None)
-        self.partial_reactions = []
-        self.reactions = []
+    name: str
+
+    def __init__(self, state: ConnectionState, id: int | str, data: app.WishlistApp):
+        super().__init__(state, id=id, name=data["name"])
+        self.logo_url = data["capsule"]
+        self.score = data["review_score"]
+        self.total_reviews = int(data["reviews_total"].replace(",", ""))
+        self.review_status = ReviewType[data["review_desc"].replace(" ", "")]
+        self.created_at = DateTime.from_timestamp(int(data["release_date"]))
+        self.type: str = data["type"]
+        self.screenshots = [
+            f"https://cdn.cloudflare.steamstatic.com/steam/apps/{self.id}/{screenshot_url}"
+            for screenshot_url in data["screenshots"]
+        ]
+        self.added_at = DateTime.from_timestamp(data["added"])
+        self.background_url = data["background"]
+        self.tags = data["tags"]
+        self.rank = data["rank"]
+        self.priority = int(data["priority"])
+
+        self._free = data["is_free_game"]
+        self._on_windows = bool(data.get("win", False))
+        self._on_mac_os = bool(data.get("mac", False))
+        self._on_linux = bool(data.get("linux", False))
+
+    def is_free(self) -> bool:
+        """Whether the app is free to download."""
+        return self._free
+
+    def is_on_windows(self) -> bool:
+        """Whether the app is playable on Windows."""
+        return self._on_windows
+
+    def is_on_mac_os(self) -> bool:
+        """Whether the app is playable on macOS."""
+        return self._on_mac_os
+
+    def is_on_linux(self) -> bool:
+        """Whether the app is playable on Linux."""
+        return self._on_linux
+
+
+class Movie:
+    __slots__ = ("name", "id", "url", "created_at")
+
+    def __init__(self, movie: dict[str, Any]):
+        self.name: str = movie["name"]
+        self.id: int = movie["id"]
+        self.url: str = movie["mp4"]["max"]
+        match = re.search(r"t=(\d+)", self.url)
+        self.created_at = DateTime.from_timestamp(int(match[1])) if match else None
 
     def __repr__(self) -> str:
-        attrs = ("author", "id", "channel")
+        attrs = ("name", "id", "url", "created_at")
         resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
-        return f"<{self.__class__.__name__} {' '.join(resolved)}>"
+        return f"<Movie {' '.join(resolved)}>"
 
-    def __eq__(self, other: object) -> bool:
-        return (
-            self.channel == other.channel and self.id == other.id
-            if isinstance(other, self.__class__)
-            else NotImplemented
-        )
 
-    def __hash__(self) -> int:
-        return hash((self.channel, self.id))
+@dataclass(slots=True)
+class AppPriceOverview(PartialAppPriceOverview):
+    initial_formatted: str
+    final_formatted: str
 
-    @cached_slot_property
-    def id(self) -> int:
-        """A unique identifier for every message sent in a channel.
-
-        Note
-        ----
-        This is **not** something Steam provides, this is meant to be a simple way to compare messages.
-        """
-        # a u64 "snowflake-esk" id measuring of the number of seconds passed since Steam's EPOCH and then the
-        # "sequence"/ordinal of the message.
-        return int(
-            f"{int((self.created_at - STEAM_EPOCH).total_seconds()):032b}{self.ordinal:032b}",
-            base=2,
+
+class FetchedApp(PartialApp):
+    """Represents a Steam app fetched by :meth:`steam.Client.fetch_app`\\.
+
+    Attributes
+    ----------
+    created_at
+        The time the app was uploaded at.
+    background_url
+        The background URL of the app.
+    type
+        The type of the app.
+    logo_url
+        The logo URL of the app.
+    partial_dlc
+        The app's downloadable content.
+    website_url
+        The website URL of the app.
+    developers
+        The developers of the app.
+    publishers
+        The publishers of the app.
+    description
+        The short description of the app.
+    full_description
+        The full description of the app.
+    movies
+        A list of the app's movies, each of which has ``name``\\, ``id``\\, ``url`` and optional
+        ``created_at`` attributes.
+    price_overview
+        The price overview of the app.
+    """
+
+    __slots__ = (
+        "logo_url",
+        "background_url",
+        "created_at",
+        "type",
+        "partial_dlc",
+        "_packages",
+        "website_url",
+        "developers",
+        "publishers",
+        "description",
+        "full_description",
+        "movies",
+        "price_overview",
+        "_free",
+        "_on_windows",
+        "_on_mac_os",
+        "_on_linux",
+        "_language",
+    )
+
+    name: str
+
+    def __init__(self, state: ConnectionState, data: app.FetchedApp, language: Language):
+        super().__init__(state, id=data["steam_appid"], name=data["name"])
+        self.logo_url = data["header_image"]
+        self.background_url = data["background"]
+        self.created_at = (
+            DateTime.parse_steam_date(data["release_date"]["date"], full_month=False)
+            if data["release_date"]["date"]
+            else None
         )
+        self.type = AppFlag.from_str(data["type"])
+        self.price_overview = AppPriceOverview(**data["price_overview"])
 
-    # @abc.abstractmethod
-    # async def delete(self) -> None:
-    #     raise NotImplementedError()
-
-    @abc.abstractmethod
-    async def add_emoticon(self, emoticon: Emoticon) -> None:
-        """Adds an emoticon to this message.
+        self.partial_dlc = [PartialApp(state, id=dlc_id) for dlc_id in data.get("dlc", [])]
 
-        Parameters
-        ----------
-        emoticon
-            The emoticon to add to this message.
-        """
-        raise NotImplementedError()
+        from .package import FetchedAppPackage
 
-    @abc.abstractmethod
-    async def remove_emoticon(self, emoticon: Emoticon) -> None:
-        """Removes an emoticon from this message.
+        self._packages = [
+            FetchedAppPackage(state, package)
+            for package_group in data["package_groups"]
+            for package in package_group["subs"]
+        ]
 
-        Parameters
-        ----------
-        emoticon
-            The emoticon to remove from this message.
-        """
-        raise NotImplementedError()
+        self.website_url = data.get("website")
+        self.developers = data["developers"]
+        self.publishers = data["publishers"]
+        self.description = data["short_description"]
+        self.full_description = data["detailed_description"]
 
-    @abc.abstractmethod
-    async def add_sticker(self, sticker: Sticker) -> None:
-        """Adds a sticker to this message.
+        self.movies = [Movie(movie) for movie in data["movies"]] if "movies" in data else None
 
-        Parameters
-        ----------
-        sticker
-            The sticker to add to this message.
-        """
-        raise NotImplementedError()
+        self._free = data["is_free"]
+        self._on_windows = bool(data["platforms"].get("windows", False))
+        self._on_mac_os = bool(data["platforms"].get("mac", False))
+        self._on_linux = bool(data["platforms"].get("linux", False))
 
-    @abc.abstractmethod
-    async def remove_sticker(self, sticker: Sticker) -> None:
-        """Adds a sticker to this message.
+        self._language = language
 
-        Parameters
-        ----------
-        sticker
-            The sticker to remove from this message.
-        """
-        raise NotImplementedError()
+    async def packages(self, *, language: Language | None = None) -> list[FetchedAppPackage]:
+        if language is not self._language:
+            return await super().packages(language=language)
+        return self._packages
+
+    def is_free(self) -> bool:
+        """Whether the app is free to download."""
+        return self._free
+
+    def is_on_windows(self) -> bool:
+        """Whether the app is playable on Windows."""
+        return self._on_windows
+
+    def is_on_mac_os(self) -> bool:
+        """Whether the app is playable on macOS."""
+        return self._on_mac_os
+
+    def is_on_linux(self) -> bool:
+        """Whether the app is playable on Linux."""
+        return self._on_linux
+
+
+@dataclass(slots=True)
+class UserInventoryInfoContext:
+    """Represents a context ID type."""
+
+    id: ContextID
+    """The ID of the context ID type."""
+    name: str
+    """The name of the context ID type."""
+    count: int
+    """The number of items in the context ID type."""
+
+
+class UserInventoryInfoApp(PartialApp):
+    name: str
+    __slots__ = ("icon_url", "inventory_logo_url")
+
+    def __init__(self, state: ConnectionState, id: int, name: str, icon_url: str, inventory_logo_url: str):
+        super().__init__(state, id=id, name=name)
+        self.icon_url = icon_url
+        self.inventory_logo_url = inventory_logo_url
```

### Comparing `steamio-0.9.9/steam/channel.py` & `steamio-1.0.0a0/steam/channel.py`

 * *Files 25% similar despite different names*

```diff
@@ -4,23 +4,26 @@
 
 import asyncio
 from collections.abc import AsyncGenerator, Coroutine
 from contextlib import asynccontextmanager
 from datetime import datetime
 from typing import TYPE_CHECKING, Any
 
+from ._const import MISSING, UNIX_EPOCH
 from .abc import Channel
 from .chat import Chat, GroupChannelProtos
-from .iterators import DMChannelHistoryIterator
-from .message import ClanMessage, GroupMessage, UserMessage
+from .message import ClanMessage, GroupMessage, Message, UserMessage
+from .reaction import Emoticon, MessageReaction, Sticker
+from .utils import DateTime
 
 if TYPE_CHECKING:
     from .clan import Clan
     from .group import Group
     from .image import Image
+    from .protobufs import friend_messages
     from .state import ConnectionState
     from .user import User
 
 __all__ = (
     "DMChannel",
     "GroupChannel",
     "ClanChannel",
@@ -89,22 +92,84 @@
 
         Note
         ----
         This only works in DMs.
         """
         await self._state.send_user_typing(self.participant.id64)
 
-    def history(
+    async def history(
         self,
         *,
         limit: int | None = 100,
-        before: datetime | None = None,
-        after: datetime | None = None,
-    ) -> DMChannelHistoryIterator:
-        return DMChannelHistoryIterator(state=self._state, channel=self, limit=limit, before=before, after=after)
+        before: datetime = MISSING,
+        after: datetime = MISSING,
+    ) -> AsyncGenerator[UserMessage, None]:
+        after = after or UNIX_EPOCH
+        before = before or DateTime.now()
+        after_timestamp = int(after.timestamp())
+        before_timestamp = int(before.timestamp())
+        yielded = 0
+
+        last_message_timestamp = before_timestamp
+        ordinal = 0
+
+        while True:
+            resp = await self._state.fetch_user_history(
+                self.participant.id64, start=after_timestamp, last=last_message_timestamp, start_ordinal=ordinal
+            )
+
+            message: friend_messages.GetRecentMessagesResponseFriendMessage | None = None
+
+            for message in resp.messages:
+                new_message = UserMessage.__new__(UserMessage)
+                new_message.created_at = DateTime.from_timestamp(message.timestamp)
+                if not after < new_message.created_at < before:
+                    return
+                if limit is not None and yielded >= limit:
+                    return
+
+                Message.__init__(new_message, channel=self, proto=message)
+                new_message.author = self.participant if message.accountid == self.participant.id else self._state.user
+                emoticon_reactions = [
+                    MessageReaction(
+                        self._state,
+                        new_message,
+                        Emoticon(self._state, r.reaction),
+                        None,
+                        self.participant if reactor == self.participant.id else self._state.user,
+                    )
+                    for r in message.reactions
+                    if r.reaction_type == 1
+                    for reactor in r.reactors
+                ]
+                sticker_reactions = [
+                    MessageReaction(
+                        self._state,
+                        new_message,
+                        None,
+                        Sticker(self._state, r.reaction),
+                        self.participant if reactor == self.participant.id else self._state.user,
+                    )
+                    for r in message.reactions
+                    if r.reaction_type == 2
+                    for reactor in r.reactors
+                ]
+                new_message.reactions = emoticon_reactions + sticker_reactions
+
+                yield new_message
+                yielded += 1
+
+            if message is None:
+                return
+
+            last_message_timestamp = message.timestamp
+            ordinal = message.ordinal
+
+            if not resp.more_available:
+                return
 
 
 class GroupChannel(Chat[GroupMessage]):
     """Represents a group channel.
 
     Attributes
     ----------
```

### Comparing `steamio-0.9.9/steam/chat.py` & `steamio-1.0.0a0/steam/chat.py`

 * *Files 13% similar despite different names*

```diff
@@ -4,124 +4,162 @@
 Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE
 """
 
 from __future__ import annotations
 
 import abc
 import asyncio
-from collections.abc import Coroutine, Sequence
+from collections.abc import AsyncGenerator, Callable, Coroutine, Iterable, Sequence
 from datetime import datetime
-from random import randint
-from typing import TYPE_CHECKING, Any, Generic, TypeVar
+from typing import TYPE_CHECKING, Any, Generic, Protocol, TypeAlias, TypeVar, cast
 
-from typing_extensions import Self, TypeAlias
+from typing_extensions import Self
 
 from . import utils
-from .abc import Channel, Message, SteamID
+from ._const import MISSING, UNIX_EPOCH
+from .abc import Channel, Message
+from .app import PartialApp
 from .enums import ChatMemberRank, Type
 from .errors import WSException
-from .game import StatefulGame
-from .iterators import ChatHistoryIterator
-from .protobufs import MsgProto, chat
-from .reaction import Emoticon, MessageReaction, Sticker
+from .id import ID
+from .models import Avatar
+from .protobufs import chat
+from .reaction import Emoticon, MessageReaction, PartialMessageReaction, Sticker
 from .role import Role
+from .types.id import ID32, ID64, ChatGroupID, ChatID, Intable
 from .user import User, WrapsUser
 from .utils import DateTime
 
 if TYPE_CHECKING:
     from .channel import ClanChannel, GroupChannel
     from .clan import Clan
     from .group import Group
     from .image import Image
-    from .message import Authors, ClanMessage, GroupMessage
+    from .message import ClanMessage, GroupMessage
     from .state import ConnectionState
-    from .types.id import ID32, ID64, ChannelID, ChatGroupID
 
 
 ChatT = TypeVar("ChatT", bound="Chat[Any]", covariant=True)
 MemberT = TypeVar("MemberT", bound="Member", covariant=True)
 
 
-class Member(WrapsUser):
-    """Represents a member of a chat group."""
+class _PartialMemberProto(Protocol):
+    _state: ConnectionState
+    rank: ChatMemberRank
+    _role_ids: tuple[int, ...]
+    kick_expires_at: datetime
+    clan: Clan | None
+    group: Group | None
+
 
+class PartialMember(ID, _PartialMemberProto):
     __slots__ = (
         "clan",
         "group",
         "rank",
         "kick_expires_at",
         "_role_ids",
+        "_state",
     )
+
     clan: Clan | None
     group: Group | None
 
-    def __init__(
-        self, state: ConnectionState, chat_group: ChatGroup[Any, Any], user: User, member: chat.Member
-    ) -> None:
-        super().__init__(state, user)
+    def __init__(self, state: ConnectionState, chat_group: ChatGroup[Any, Any], member: chat.Member) -> None:
+        super().__init__(member.accountid, type=Type.Individual)
         self.clan = None
         self.group = None
+        self._state = state
         self._update(member)
 
-    def _update(self, member: chat.Member) -> None:
+    def _update(self: _PartialMemberProto, member: chat.Member) -> None:
         self.rank = ChatMemberRank.try_value(member.rank)
         self._role_ids = tuple(member.role_ids)
         self.kick_expires_at = DateTime.from_timestamp(member.time_kick_expire)
 
     @property
-    def roles(self) -> list[Role]:
+    def roles(self: _PartialMemberProto) -> list[Role]:
         """The member's roles."""
         chat_group = self.group or self.clan
         assert chat_group is not None
         return [chat_group._roles[role_id] for role_id in self._role_ids]
 
+
+class Member(WrapsUser):
+    """Represents a member of a chat group."""
+
+    __slots__ = (
+        "clan",
+        "group",
+        "rank",
+        "kick_expires_at",
+        "_role_ids",
+    )
+
+    rank: ChatMemberRank
+    kick_expires_at: datetime
+    _role_ids: tuple[int, ...]
+
+    def __init__(
+        self, state: ConnectionState, chat_group: ChatGroup[Any, Any], user: User, member: chat.Member
+    ) -> None:
+        super().__init__(state, user)
+        self.clan: Clan | None = None
+        self.group: Group | None = None
+
+        self._update(member)
+
+    _update: Callable[[chat.Member], None] = PartialMember._update  # type: ignore
+    roles = PartialMember.roles
+
     # async def add_role(self, role: Role):
     #     """Add a role to the member."""
 
     # async def ban(self, *, reason: str | None = None) -> None:
     #     """Bans the member from the chat group."""
     #     group = self.group or self.clan
     #     assert group is not None
     #     await group.ban(self, reason=reason)
 
 
 class ChatMessage(Message):
     channel: GroupChannel | ClanChannel
     mentions: chat.Mentions
-    author: Member | SteamID
+    author: Member | PartialMember
 
-    def __init__(self, proto: chat.IncomingChatMessageNotification, channel: Any, author: Authors):
+    def __init__(self, proto: chat.IncomingChatMessageNotification, channel: Any, author: Member | PartialMember):
         super().__init__(channel, proto)
         self.author = author
         self.created_at = DateTime.from_timestamp(proto.timestamp)
 
+    @property
+    def _chat_group(self) -> Clan | Group:
+        return self.channel._chat_group
+
     async def fetch_reaction(self, emoticon: Emoticon | Sticker) -> list[MessageReaction]:
         """Fetches the reactions to this message with a given emoticon."""
-        chat_group = self.clan or self.group
-        assert chat_group is not None
-        is_emoticon = isinstance(emoticon, Emoticon)
         reactors = await self._state.fetch_message_reactors(
             *self.channel._location,
             server_timestamp=int(self.created_at.timestamp()),
             ordinal=self.ordinal,
-            reaction_name=str(emoticon) if is_emoticon else emoticon.name,
-            reaction_type=1 if is_emoticon else 2,
+            reaction_name=str(emoticon) if isinstance(emoticon, Emoticon) else emoticon.name,
+            reaction_type=emoticon._TYPE,
         )
 
         reaction = utils.find(
             lambda r: (r.emoticon or r.sticker).name == emoticon.name, self.partial_reactions  # type: ignore
         )
         assert reaction
         return [
             MessageReaction(
                 self._state,
                 self,
-                reaction.emoticon,
-                reaction.sticker,
-                user=chat_group._members.get(reactor) or SteamID(reactor),
+                reaction.emoticon,  # type: ignore
+                reaction.sticker,  # type: ignore  # needs conditional types
+                user=self._chat_group._members.get(reactor) or ID(reactor),
             )
             for reactor in reactors
         ]
 
     async def fetch_reactions(self) -> list[MessageReaction]:
         """Fetches all this message's reactions.
 
@@ -142,77 +180,77 @@
 
     async def add_emoticon(self, emoticon: Emoticon) -> None:
         await self._state.react_to_chat_message(
             *self.channel._location,
             int(self.created_at.timestamp()),
             self.ordinal,
             str(emoticon),
-            reaction_type=1,
+            reaction_type=emoticon._TYPE,
             is_add=True,
         )
         self._state.dispatch(
             "reaction_add",
             MessageReaction(self._state, self, emoticon, None, self._state.user, DateTime.now(), self.ordinal),
         )
 
     async def remove_emoticon(self, emoticon: Emoticon) -> None:
         await self._state.react_to_chat_message(
             *self.channel._location,
             int(self.created_at.timestamp()),
             self.ordinal,
             str(emoticon),
-            reaction_type=1,
+            reaction_type=emoticon._TYPE,
             is_add=False,
         )
         self._state.dispatch(
             "reaction_remove",
             MessageReaction(self._state, self, emoticon, None, self._state.user, DateTime.now(), self.ordinal),
         )
 
     async def add_sticker(self, sticker: Sticker) -> None:
         await self._state.react_to_chat_message(
             *self.channel._location,
             int(self.created_at.timestamp()),
             self.ordinal,
             sticker.name,
-            reaction_type=2,
+            reaction_type=sticker._TYPE,
             is_add=True,
         )
         self._state.dispatch(
             "reaction_add",
             MessageReaction(self._state, self, None, sticker, self._state.user, DateTime.now(), self.ordinal),
         )
 
     async def remove_sticker(self, sticker: Sticker) -> None:
         await self._state.react_to_chat_message(
             *self.channel._location,
             int(self.created_at.timestamp()),
             self.ordinal,
             sticker.name,
-            reaction_type=2,
+            reaction_type=sticker._TYPE,
             is_add=False,
         )
         self._state.dispatch(
             "reaction_remove",
             MessageReaction(self._state, self, None, sticker, self._state.client.user, DateTime.now(), self.ordinal),
         )
 
 
 ChatMessageT = TypeVar("ChatMessageT", bound="GroupMessage | ClanMessage", covariant=True)
-GroupChannelProtos: TypeAlias = "chat.IncomingChatMessageNotification | chat.State | chat.ChatRoomState"
+GroupChannelProtos: TypeAlias = chat.IncomingChatMessageNotification | chat.State | chat.ChatRoomState
 
 
 class Chat(Channel[ChatMessageT]):
     __slots__ = ("id", "name", "joined_at", "position", "last_message")
 
     def __init__(
         self, state: ConnectionState, group: ChatGroup[Any, Self], proto: GroupChannelProtos
     ):  # group is purposely unused
         super().__init__(state)
-        self.id = int(proto.chat_id)
+        self.id = ChatID(proto.chat_id)
         self.name: str | None = None
         self.joined_at: datetime | None = None
         self.position: int | None = None
         self.last_message: ChatMessageT | None = None
         self._update(proto)
 
     def _update(self, proto: GroupChannelProtos) -> None:
@@ -220,172 +258,247 @@
             first, _, second = proto.chat_name.partition(" | ")
             self.name = second or first
 
         self.joined_at = (
             DateTime.from_timestamp(proto.time_joined) if isinstance(proto, chat.ChatRoomState) else self.joined_at
         )
         self.position = proto.sort_order if isinstance(proto, chat.State) else self.position
-        (message_cls,) = self._type_args
         if isinstance(proto, chat.IncomingChatMessageNotification):
-            steam_id = SteamID(proto.steamid_sender, type=Type.Individual)
-            self.last_message = message_cls(proto, self, self._state.get_user(steam_id.id) or steam_id)  # type: ignore
+            steam_id = ID(proto.steamid_sender, type=Type.Individual)
+            (message_cls,) = self._type_args
+            self.last_message = message_cls(proto, self, self._chat_group.get_member(steam_id.id64) or steam_id)
 
     def __repr__(self) -> str:
         attrs = ("name", "id", "group" if self.group is not None else "clan", "position")
         resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
         return f"<{self.__class__.__name__} {' '.join(resolved)}>"
 
     def __eq__(self, other: object) -> bool:
         return self._location == other._location if isinstance(other, Chat) else NotImplemented
 
     @property
-    def _location(self) -> tuple[ChatGroupID, ChannelID]:
-        chat = self.clan or self.group
-        assert chat is not None
-        chat_id = chat._id
+    def _location(self) -> tuple[ChatGroupID, ChatID]:
+        chat_id = self._chat_group._id
         assert chat_id is not None
         return chat_id, self.id
 
+    @property
+    def _chat_group(self) -> Clan | Group:
+        chat_group = self.clan or self.group
+        assert chat_group is not None
+        return chat_group
+
     @utils.classproperty
     def _type_args(cls: type[Chat]) -> tuple[type[ChatMessageT]]:  # type: ignore
         return cls.__orig_bases__[0].__args__  # type: ignore
 
     def _message_func(self, content: str) -> Coroutine[Any, Any, ChatMessageT]:
         return self._state.send_chat_message(*self._location, content)  # type: ignore
 
     def _image_func(self, image: Image) -> Coroutine[Any, Any, None]:
         return self._state.http.send_chat_image(*self._location, image)
 
-    def history(
+    async def history(
         self,
         *,
         limit: int | None = 100,
         before: datetime | None = None,
         after: datetime | None = None,
-    ) -> ChatHistoryIterator[ChatMessageT, Self]:
-        return ChatHistoryIterator(state=self._state, channel=self, limit=limit, before=before, after=after)
+    ) -> AsyncGenerator[ChatMessageT, None]:
+        after = after or UNIX_EPOCH
+        before = before or DateTime.now()
+
+        chat_group = self._chat_group
+        after_timestamp = int(after.timestamp())
+        before_timestamp = int(before.timestamp())
+        last_message_timestamp = before_timestamp
+        last_ordinal: int = getattr(self.last_message, "ordinal", 0)
+        yielded = 0
+        (message_cls,) = self._type_args
 
-    # async def edit(self, *, name: str) -> None:
-    #     await self._state.edit_channel(*self._location, name)
+        while True:
+            resp = await self._state.fetch_chat_group_history(
+                *self._location, start=after_timestamp, last=last_message_timestamp, last_ordinal=last_ordinal
+            )
+            message = None
+            messages: list[ChatMessageT] = []
 
+            for message in resp.messages:
+                new_message = message_cls.__new__(message_cls)
+                Message.__init__(new_message, channel=self, proto=message)
+                new_message.created_at = DateTime.from_timestamp(message.server_timestamp)
+                if not after < new_message.created_at < before:
+                    return
+                if limit is not None and yielded >= limit:
+                    return
+
+                new_message.author = ID(message.sender)
+                emoticon_reactions = [
+                    PartialMessageReaction(
+                        self._state,
+                        new_message,
+                        Emoticon(self._state, r.reaction),
+                        None,
+                    )
+                    for r in message.reactions
+                    if r.reaction_type == 1
+                ]
+                sticker_reactions = [
+                    PartialMessageReaction(
+                        self._state,
+                        new_message,
+                        None,
+                        Sticker(self._state, r.reaction),
+                    )
+                    for r in message.reactions
+                    if r.reaction_type == 2
+                ]
+                new_message.partial_reactions = emoticon_reactions + sticker_reactions
+
+                messages.append(new_message)
+                yielded += 1
+
+            if message is None:
+                return
+
+            last_message_timestamp = message.server_timestamp
+            last_ordinal = message.ordinal
+
+            for message_, author in zip(messages, chat_group._maybe_members(m.author.id for m in messages)):
+                message_.author = author
+                yield message_
 
-# class SteamIDMember(SteamID):  # TODO?
-#     ...
+            if not resp.more_available:
+                return
 
+    # async def edit(self, *, name: str) -> None:
+    #     await self._state.edit_channel(*self._location, name)
 
-class ChatGroup(SteamID, Generic[MemberT, ChatT]):
+
+class ChatGroup(ID, Generic[MemberT, ChatT]):
     """Base class for :class:`steam.Clan` and :class:`steam.Group`."""
 
     __slots__ = (
         "name",
         "_id",
-        "game",
+        "app",
         "tagline",
-        "avatar_url",
         "active_member_count",
         "chunked",
         "_state",
         "_members",
         "_partial_members",
         "_owner_id",
         "_top_members",
         "_channels",
         "_default_channel_id",
         "_roles",
         "_default_role_id",
+        "_avatar_sha",
     )
     name: str
     _id: ChatGroupID
-    game: StatefulGame | None
+    app: PartialApp | None
     tagline: str
     avatar_url: str
     active_member_count: int
     chunked: bool
+    _avatar_sha: bytes
     _state: ConnectionState
 
     _members: dict[ID32, MemberT]
     _owner_id: ID32
     _top_members: list[ID32]
     _partial_members: dict[ID32, chat.Member]  # deleted after _members is populated (if chunked)
 
     _channels: dict[int, ChatT]
     _default_channel_id: int
 
     _roles: dict[int, Role]
     _default_role_id: int
 
-    def __init__(self, *args: Any, **kwargs: Any):
-        super().__init__(*args, **kwargs)
+    def __init__(self, state: ConnectionState, id: Intable, type: Type = MISSING):
+        super().__init__(id, type=type)
+        self._state = state
         self.chunked = False
-        self.game: StatefulGame | None = None
+        self.app: PartialApp | None = None
         self._members = {}
         self._partial_members = {}
         self._channels: dict[int, ChatT] = {}
         self._roles: dict[int, Role] = {}
 
     @classmethod
     async def _from_proto(
         cls,
         state: ConnectionState,
         proto: chat.GetChatRoomGroupSummaryResponse,
         *,
-        id: ID32 | ChatGroupID | None = None,
+        id: ChatGroupID | None = None,
         maybe_chunk: bool = True,
     ) -> Self:
         self = cls(state, id if id is not None else proto.chat_group_id)
         self.name = proto.chat_group_name
-        self._id = proto.chat_group_id
+        self._id = ChatGroupID(proto.chat_group_id)
         self.active_member_count = proto.active_member_count
-        self._owner_id = proto.accountid_owner
-        self._top_members = proto.top_members
+        self._owner_id = ID32(proto.accountid_owner)
+        self._top_members = [ID32(id) for id in proto.top_members]
         self.tagline = proto.chat_group_tagline
-        self.game = StatefulGame(state, id=proto.appid) if proto.appid else self.game
+        self.app = PartialApp(state, id=proto.appid) if proto.appid else self.app
+        self._avatar_sha = proto.chat_group_avatar_sha
 
         self._default_role_id = proto.default_role_id
         self._update_channels(proto.chat_rooms, default_channel_id=proto.default_chat_id)
 
         if maybe_chunk:
             try:
-                group_state = await self._state.set_chat_group_active(proto.chat_group_id)
+                group_state = await self._state.set_chat_group_active(self._id)
             except WSException:
                 pass
             else:
-                self._partial_members = {member.accountid: member for member in group_state.members}
+                self._partial_members = {ID32(member.accountid): member for member in group_state.members}
                 self._roles = {
                     role.role_id: Role(self._state, self, role, permissions)  # type: ignore
                     for role in group_state.header_state.roles
                     for permissions in group_state.header_state.role_actions
                     if permissions.role_id == role.role_id
                 }
+                member_cls, _ = self._type_args
+                self._members = {
+                    self._state.user.id: member_cls(
+                        self._state, self, self._state.user, self._partial_members[self._state.user.id]  # type: ignore
+                    )
+                }
 
             if self._state.auto_chunk_chat_groups:
                 await self.chunk()
 
         return self
 
     @utils.classproperty
-    def _type_args(cls: type[ChatGroup]) -> tuple[type[MemberT], type[ChatT]]:  # type: ignore
+    def _type_args(cls: type[Self]) -> tuple[type[MemberT], type[ChatT]]:  # type: ignore
         return cls.__orig_bases__[0].__args__  # type: ignore
 
     async def _add_member(self, member: chat.Member) -> MemberT:
         member_cls, _ = self._type_args
-        user = await self._state._maybe_user(member.accountid)
+        id32 = ID32(member.accountid)
+        user = await self._state._maybe_user(id32)
         assert isinstance(user, User)
         new_member = member_cls(self._state, self, user, member)
         if self.chunked:
-            self._members[member.accountid] = new_member
+            self._members[id32] = new_member
         else:
-            self._partial_members[member.accountid] = member
+            self._partial_members[id32] = member
         return new_member
 
     def _remove_member(self, member: chat.Member) -> MemberT | None:
+        id32 = ID32(member.accountid)
         if self.chunked:
-            return self._members.pop(member.accountid, None)
+            return self._members.pop(id32, None)
         else:
-            self._partial_members.pop(member.accountid, None)
+            self._partial_members.pop(id32, None)
 
     def _update_channels(
         self, channels: list[chat.State] | list[chat.ChatRoomState], *, default_channel_id: int | None = None
     ) -> None:
         _, channel_cls = self._type_args
         for channel in channels:
             try:
@@ -397,27 +510,27 @@
                 new_channel._update(channel)
 
         if default_channel_id is not None:
             self._default_channel_id = default_channel_id
 
     def _update_header_state(self, proto: chat.GroupHeaderState) -> None:
         self.name = proto.chat_name
-        self._owner_id = proto.accountid_owner
-        self.game = StatefulGame(self._state, id=proto.appid)
+        self._owner_id = ID32(proto.accountid_owner)
+        self.app = PartialApp(self._state, id=proto.appid)
         self.tagline = proto.tagline
-        self.avatar_url = utils._get_avatar_url(proto.avatar_sha)
+        self._avatar_sha = proto.avatar_sha
         self._default_role_id = proto.default_role_id or self._default_role_id
         for role in proto.roles:
             for role_action in proto.role_actions:
                 if role.role_id == role_action.role_id:
                     self._roles[role.role_id] = Role(self._state, self, role, role_action)  # type: ignore
 
     def __repr__(self) -> str:
         attrs = ("name", "id", "universe", "instance")
-        resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
+        resolved = [f"{attr}={getattr(self, attr, MISSING)!r}" for attr in attrs]
         return f"<{self.__class__.__name__} {' '.join(resolved)}>"
 
     def __str__(self) -> str:
         return self.name
 
     @property
     def members(self) -> Sequence[MemberT]:
@@ -430,22 +543,30 @@
         Parameters
         ----------
         id64
             The 64 bit ID of the member to get.
         """
         return self._members.get(id64 & 0xFFFFFFFF)  # TODO consider just passing ID32
 
+    def _maybe_members(self, ids: Iterable[ID32]) -> list[MemberT | PartialMember]:
+        if self.chunked:
+            return [self._members[id] for id in ids if id in self._members]
+        else:
+            return [
+                PartialMember(self._state, self, self._partial_members[id]) for id in ids if id in self._partial_members
+            ]
+
     @property
     def owner(self):
-        return self._members.get(self._owner_id) or SteamID(self._owner_id)
+        return self._members.get(self._owner_id) or ID(self._owner_id)
 
     @property
-    def top_members(self) -> Sequence[MemberT | SteamID]:
+    def top_members(self) -> Sequence[MemberT | ID]:
         """A list of the chat group's top members."""
-        return [(self._members.get(id) or SteamID(id)) for id in self._top_members]
+        return [(self._members.get(id) or ID(id)) for id in self._top_members]
 
     @property
     def me(self) -> MemberT:
         """The client user's account in this chat group."""
         return self._members[self._state.user.id]
 
     @property
@@ -484,14 +605,19 @@
         return self._roles.get(id)
 
     @property
     def default_role(self) -> Role:
         """The group's default role."""
         return self._roles[self._default_role_id]
 
+    @property
+    def avatar(self) -> Avatar:
+        """The chat group's avatar."""
+        return Avatar(self._state, self._avatar_sha)
+
     @abc.abstractmethod
     async def chunk(self) -> Sequence[MemberT]:
         """Get a list of all members in the group."""
         self.chunked = True
         del self._partial_members
         return self.members
 
@@ -499,27 +625,26 @@
         """Search for members in the chat group.
 
         Parameters
         ----------
         name
             The name of the member to search for.
         """
-        msg: MsgProto[chat.SearchMembersResponse] = await self._state.ws.send_um_and_wait(
-            "ChatRoom.SearchMembers",
-            chat_group_id=self._id,
-            search_text=name,
+        msg: chat.SearchMembersResponse = await self._state.ws.send_um_and_wait(
+            chat.SearchMembersRequest(
+                chat_group_id=self._id,
+                search_text=name,
+            )
         )
 
         if self.chunked:
-            return [self._members[user.accountid] for user in msg.body.matching_members]
+            return [self._members[ID32(user.accountid)] for user in msg.matching_members]
 
         member_cls, _ = self._type_args
-        users = [
-            User(self._state, self._state.patch_user_from_ws({}, user.persona)) for user in msg.body.matching_members
-        ]
+        users = [User(self._state, user.persona) for user in msg.matching_members]
         return [member_cls(self._state, self, user, self._partial_members[user.id]) for user in users]
 
     async def invite(self, user: User) -> None:
         """Invites a :class:`~steam.User` to the chat group.
 
         Parameters
         -----------
@@ -561,21 +686,21 @@
     # async def fetch_invite(self, code: str) -> InviteLink:  # chat.GetChatInviteLinkResponse
     #     ...
     #
     # async def invites(self) -> list[InviteLink]:  # chat.GetChatInvitesResponse
     #     ...
     #
     # add Member.x equivalent for these 3
-    # async def mute(self, member: SteamID) -> None:  # chat.MuteUserRequest
+    # async def mute(self, member: ID) -> None:  # chat.MuteUserRequest
     #     ...
     #
-    # async def kick(self, member: SteamID) -> None:  # chat.KickUserRequest
+    # async def kick(self, member: ID) -> None:  # chat.KickUserRequest
     #     ...
     #
-    # async def ban(self, member: SteamID) -> None:  # chat.SetUserBanStateRequest
+    # async def ban(self, member: ID) -> None:  # chat.SetUserBanStateRequest
     #     ...
     #
     # async def bans(self) -> list[Ban]:  # chat.GetBanListRequest
     #     ...
     #
-    # async def unban(self, user: SteamID) -> None:  # chat.SetUserBanStateRequest
+    # async def unban(self, user: ID) -> None:  # chat.SetUserBanStateRequest
     #     ...
```

### Comparing `steamio-0.9.9/steam/clan.py` & `steamio-1.0.0a0/steam/clan.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,41 +1,57 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import asyncio
+import itertools
 import re
-import warnings
-from collections.abc import Sequence
-from datetime import datetime
-from typing import TYPE_CHECKING, TypeVar, overload
+from collections.abc import AsyncGenerator, Sequence
+from datetime import date, datetime, timezone
+from ipaddress import IPv4Address
+from operator import itemgetter
+from typing import TYPE_CHECKING, Literal, TypeVar, overload
 
 from bs4 import BeautifulSoup
-from typing_extensions import Literal, Self
+from typing_extensions import Self
+from yarl import URL
 
 from . import utils
-from ._const import HTML_PARSER
-from .abc import Commentable, SteamID, _CommentableKwargs
+from ._const import HTML_PARSER, UNIX_EPOCH
+from .abc import Commentable, _CommentableKwargs
+from .app import App, PartialApp
 from .channel import ClanChannel
 from .chat import ChatGroup, Member
 from .enums import EventType, Language, Type
 from .errors import HTTPException
 from .event import Announcement, Event
-from .game import Game, StatefulGame
-from .iterators import AnnouncementsIterator, EventIterator
+from .id import CLAN_ID64_FROM_URL_REGEX, ID, parse_id64
 from .protobufs import chat
+from .types.id import ID32, ID64
 from .utils import DateTime
 
 if TYPE_CHECKING:
     from .state import ConnectionState
-    from .types.id import ID32
+    from .types.http import IPAdress
     from .user import User
 
 __all__ = ("Clan", "ClanMember")
 
+BoringEvents = Literal[
+    EventType.Other,
+    EventType.Chat,
+    EventType.Party,
+    EventType.Meeting,
+    EventType.SpecialCause,
+    EventType.MusicAndArts,
+    EventType.Sports,
+    EventType.Trip,
+]
+CreateableEvents = Literal[BoringEvents, EventType.Game]
+
 BoringEventT = TypeVar(
     "BoringEventT",
     Literal[EventType.Other],
     Literal[EventType.Chat],
     Literal[EventType.Party],
     Literal[EventType.Meeting],
     Literal[EventType.SpecialCause],
@@ -68,16 +84,14 @@
 
             Returns the clan's name.
 
     Attributes
     ------------
     name
         The name of the clan.
-    avatar_url
-        The icon url of the clan. Uses the large (184x184 px) image url.
     content
         The content of the clan.
     tagline
         The clan's tagline.
     member_count
         The amount of users in the clan.
     online_count
@@ -88,100 +102,100 @@
         The amount of user's currently in game.
     created_at
         The time the clan was created_at.
     language
         The language set for the clan.
     location
         The location set for the clan.
-    game
-        The clan's associated game.
+    app
+        The clan's associated app.
     owner
         The clan's owner.
     admins
         A list of the clan's administrators.
     mods
         A list of the clan's moderators.
     """
 
     __slots__ = (
-        "content",
+        "summary",
         "created_at",
         "language",
         "location",
         "member_count",
         "in_game_count",
         "online_count",
         "admins",
         "mods",
         "community_url",
-        "is_game_clan",
+        "is_app_clan",
     )
 
     # TODO more to implement https://github.com/DoctorMcKay/node-steamcommunity/blob/master/components/groups.js
     # Clan.requesting_membership
     # Clan.respond_to_requesting_membership(*users, approve)
     # Clan.respond_to_all_requesting_membership(approve)
 
     # V1
     # Clan.headline
-    # Clan.summary
     # Clan.flags https://cs.github.com/SteamDatabase/SteamTracking/blob/5c4420496f18384bea932f4535ee1a87fd9271e4/Structs/enums.steamd#L526
     # or more likely https://cs.github.com/SteamDatabase/SteamTracking/blob/5c4420496f18384bea932f4535ee1a87fd9271e4/Structs/enums.steamd#L3177
 
-    content: str
+    summary: str
     created_at: datetime | None
     member_count: int
     online_count: int
     in_game_count: int
     language: Language
     location: str
     mods: list[ClanMember]
     admins: list[ClanMember]
-    is_game_clan: bool
+    is_app_clan: bool
 
     def __init__(self, state: ConnectionState, id: int):
-        super().__init__(id, type=Type.Clan)
+        super().__init__(state, id, type=Type.Clan)
         self._state = state
 
     async def __ainit__(self) -> None:
         resp = await self._state.http._session.get(super().community_url)  # type: ignore
         text = await resp.text()  # technically we loose proper request handling here
         if not self.id64:
-            search = utils.CLAN_ID64_FROM_URL_REGEX.search(text)
+            search = CLAN_ID64_FROM_URL_REGEX.search(text)
             if search is None:
                 raise ValueError("unreachable code reached")
-            super().__init__(search["steamid"], type=Type.Clan)
+            super().__init__(self._state, search["steamid"], type=Type.Clan)
 
         soup = BeautifulSoup(text, HTML_PARSER)
-        _, __, name = soup.title.text.rpartition(" :: ")
-        self.name = name
+        if not hasattr(self, "name"):
+            _, _, self.name = soup.title.text.rpartition(" :: ")
         content = soup.find("meta", property="og:description")
-        self.content = content["content"] if content is not None else None
-        icon_url = soup.find("link", rel="image_src")
-        self.avatar_url = icon_url["href"] if icon_url else None
-        self.is_game_clan = "games" in resp.url.parts
-        self.community_url = str(resp.url)
-        if self.is_game_clan:
+        self.summary = content["content"] if content is not None else None
+        if not hasattr(self, "_avatar_sha"):
+            icon_url = soup.find("link", rel="image_src")
+            url = URL(icon_url["href"]) if icon_url else None
+            if url:
+                self._avatar_sha = bytes.fromhex(url.path.removesuffix("/").removesuffix("_full.jpg"))
+        self.is_app_clan = "games" in resp.url.parts
+
+        if self.is_app_clan:
             for entry in soup.find_all("div", class_="actionItem"):
-                a = entry.a
-                if a is not None:
+                if (a := entry.a) is not None:
                     href = a.get("href", "")
-                    match = re.findall(r"store.steampowered.com/app/(\d+)", href)
-                    if match:
-                        self.game = StatefulGame(self._state, id=match[0])
+                    if match := re.findall(r"store.steampowered.com/app/(\d+)", href):
+                        self.app = PartialApp(self._state, id=match[0])
         stats = soup.find("div", class_="grouppage_resp_stats")
         if stats is None:
             return
 
         for stat in stats.find_all("div", class_="groupstat"):
             if "Founded" in stat.text:
                 text = stat.text.split("Founded")[1].strip()
                 if ", " not in stat.text:
                     text = f"{text}, {DateTime.now().year}"
-                self.created_at = utils.DateTime.parse_steam_date(text)
+                self.created_at = DateTime.parse_steam_date(text)
             if "Language" in stat.text:
                 self.language = stat.text.split("Language")[1].strip()
             if "Location" in stat.text:
                 self.location = stat.text.split("Location")[1].strip()
 
         for count in stats.find_all("div", class_="membercount"):
             if "MEMBERS" in count.text:
@@ -225,73 +239,72 @@
     async def _from_proto(
         cls,
         state: ConnectionState,
         proto: chat.GetChatRoomGroupSummaryResponse,
         *,
         maybe_chunk: bool = True,
     ) -> Self:
-        self = await super()._from_proto(state, proto, id=proto.clanid, maybe_chunk=maybe_chunk)
+        self = await super()._from_proto(state, proto, id=ID32(proto.clanid), maybe_chunk=maybe_chunk)
         return await self
 
     # TODO properties for admins and mods when chunked?
 
     async def chunk(self) -> Sequence[ClanMember]:
+        if self.chunked:
+            return self.members
+
         self._members = dict.fromkeys(self._partial_members)  # type: ignore
         if len(self._partial_members) <= 100:
             # TODO might be if self.flags & ClanFlags.Large (2)?
-            for id, member in self._partial_members.items():
-                user = self._state.get_user(id)
-                if user is None:
-                    await asyncio.sleep(0)
-                    user = await self._state._maybe_user(utils.make_id64(id))  # TODO maybe users
-                member = ClanMember(self._state, self, user, member)
-                self._members[member.id] = member
+            for user, member in zip(
+                await self._state._maybe_users(parse_id64(id, type=Type.Individual) for id in self._partial_members),
+                self._partial_members.values(),
+            ):
+                self._members[user.id] = ClanMember(self._state, self, user, member)
+
             return await super().chunk()
 
         # these actually need fetching
         view_id = self._state.chat_group_to_view_id[self._id]
         users: dict[ID32, User] = {
             user.id: user
             for users in await asyncio.gather(
                 *(
-                    self._state.request_chat_group_members(
+                    self._state.fetch_chat_group_members(
                         self._id,
                         view_id,
-                        client_change_number + 1,  # steam doesn't send responses if they're 0
+                        client_change_number
+                        + 1,  # steam doesn't send responses if they're 0 (TODO this might be a betterproto bug)
                         start + 1,
                         stop,
                     )
                     for client_change_number, (start, stop) in enumerate(
                         utils._int_chunks(len(self._partial_members), 100)
                     )
                 )
             )
             for user in users
         }
         for id, member in self._partial_members.items():
             try:
                 user = users[id]
             except KeyError:
-                # steam doesn't include the first user cause ???, this however, isn't that big a deal.
-                user = await self._state._maybe_user(utils.make_id64(id))
-                if isinstance(user, SteamID):
+                user = await self._state._maybe_user(parse_id64(id))
+                if type(user) is ID:
                     continue
-            member = ClanMember(self._state, self, users[id], member)
-            self._members[member.id] = member
-
+            self._members[user.id] = ClanMember(self._state, self, user, member)  # type: ignore  # pyright being daft
         return await super().chunk()
 
     @property
     def _commentable_kwargs(self) -> _CommentableKwargs:
         return {
             "id64": self.id64,
-            "thread_type": 12,
         }
 
-    async def fetch_members(self) -> list[SteamID]:
+    async def fetch_members(self) -> list[ID]:
         """Fetches a clan's member list.
 
         Note
         ----
         This can be a very slow operation due to the rate limits on this endpoint.
         """
 
@@ -301,48 +314,27 @@
                     f"{self.community_url}/members", params={"p": i + 1, "content_only": "true"}
                 )
             except HTTPException:
                 await asyncio.sleep(20)
                 return await getter(i)
             else:
                 soup = BeautifulSoup(resp, HTML_PARSER)
-                for s in soup.find_all("div", id="memberList"):
-                    for user in s.find_all("div", class_="member_block"):
-                        ret.append(SteamID(user["data-miniprofile"]))
-
+                ret.extend(
+                    ID(user["data-miniprofile"])
+                    for s in soup.find_all("div", id="memberList")
+                    for user in s.find_all("div", class_="member_block")
+                )
                 return soup
 
-        ret: list[SteamID] = []
+        ret: list[ID] = []
         soup = await getter(0)
         number_of_pages = int(re.findall(r"\d* - (\d*)", soup.find("div", class_="group_paging").text)[0])
         await asyncio.gather(*(getter(i) for i in range(1, number_of_pages)))
         return ret
 
-    @property
-    def description(self) -> str:
-        """An alias to :attr:`content`.
-
-        .. deprecated:: 0.8.0
-
-            Use :attr:`content` instead.
-        """
-        warnings.warn("Clan.description is deprecated, use Clan.content instead", DeprecationWarning, stacklevel=2)
-        return self.content
-
-    @property
-    def icon_url(self) -> str:
-        """An alias to :attr:`avatar_url`.
-
-        .. deprecated:: 0.8.0
-
-            Use :attr:`avatar_url` instead.
-        """
-        warnings.warn("Clan.icon_url is deprecated, use Clan.avatar_url instead", DeprecationWarning, stacklevel=2)
-        return self.avatar_url
-
     async def join(self, *, invite_code: str | None = None) -> None:
         """Joins the clan."""
         await self._state.http.join_clan(self.id64)
         await super().join(invite_code=invite_code)
 
     async def leave(self) -> None:
         """Leaves the clan."""
@@ -356,39 +348,38 @@
 
         Parameters
         ----------
         id
             The ID of the event.
         """
         data = await self._state.http.get_clan_events(self.id, [id])
-        events = data["events"]
-        if not events:
-            raise ValueError(f"Event {id} not found")
-        return await Event(self._state, self, events[0])
+        if events := data["events"]:
+            return await Event(self._state, self, events[0])
+
+        raise ValueError(f"Event {id} not found")
 
     async def fetch_announcement(self, id: int) -> Announcement:
         """Fetch an announcement from its ID.
 
         Parameters
         ----------
         id
             The ID of the announcement.
         """
         data = await self._state.http.get_clan_announcement(self.id, id)
-        announcement = data["events"][0]
-        return await Announcement(self._state, self, announcement)
+        return await Announcement(self._state, self, data["event"])
 
-    def events(
+    async def events(
         self,
         *,
         limit: int | None = 100,
         before: datetime | None = None,
         after: datetime | None = None,
-    ) -> EventIterator:
-        """An :class:`~steam.iterators.AsyncIterator` over a clan's :class:`steam.Event`\\s.
+    ) -> AsyncGenerator[Event[EventType], None]:
+        """An :term:`async iterator` over a clan's :class:`steam.Event`\\s.
 
         Examples
         --------
 
         Usage:
 
         .. code-block:: python3
@@ -404,44 +395,104 @@
             The maximum number of events to search through. Default is ``100``. Setting this to ``None`` will fetch all
             the clan's events, but this will be a very slow operation.
         before
             A time to search for events before.
         after
             A time to search for events after.
 
+            Warning
+            -------
+            If this is ``None`` and :attr:`created_at` is ``None``, this has to fetch events all the way back until 2007
+
         Yields
         ---------
         :class:`~steam.Event`
         """
-        return EventIterator(self, self._state, limit, before, after)
 
-    def announcements(
+        after = after or self.created_at or datetime(2007, 7, 1, tzinfo=timezone.utc)
+        # uh-oh I really hope you have a created_at cause I have no way of telling if this request is done
+        # date from https://www.ign.com/articles/2007/08/06/steam-community-beta-opens (public release of steamcommunity)
+        before = before or DateTime.now()
+        start_at_month = after.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
+        stop_at_month = after.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
+
+        dates: list[date] = []
+        start_month = start_at_month.month
+        stop_month = 13
+
+        for year in range(start_at_month.year, stop_at_month.year + 1):
+            if year == stop_at_month.year:
+                stop_month = stop_at_month.month + 1
+            dates.extend(date(year, month, 1) for month in range(start_month, stop_month))
+            start_month = 1
+
+        ids: list[int] = []
+        for date_chunk in utils.as_chunks(dates, 12):
+            for xml in await asyncio.gather(
+                *(self._state.http.get_clan_events_for(self.id64, date) for date in date_chunk)
+            ):
+                soup = BeautifulSoup(xml, HTML_PARSER)
+                ids.extend(
+                    int(url.rpartition("/")[2])
+                    for event_title in soup.find_all("div", class_="eventBlockTitle")
+                    for url in event_title.a.get("href")
+                    if url
+                )
+
+        yielded = 0
+
+        for id_chunk in utils.as_chunks(ids, 15):
+            events: list[Event[EventType]] = []
+            for event in ids:
+                resp = await self._state.http.get_clan_events(self.id, id_chunk)
+                data = resp["events"]
+                for event_ in data:
+                    event = Event(self._state, self, event_)
+                    if not after < event.starts_at < before:
+                        break
+                    events.append(event)
+
+            authors = utils.as_chunks(
+                await self._state._maybe_users(
+                    itertools.chain.from_iterable(
+                        (
+                            e.author.id64,
+                            e.last_edited_by.id64 if e.last_edited_by is not None else ID64(0),
+                        )
+                        for e in events
+                    )
+                ),
+                2,
+            )
+            for event in events:
+                if limit is not None and yielded >= limit:
+                    return
+                event.author, event.last_edited_by = next(authors)
+                yield event
+                yielded += 1
+
+    async def announcements(
         self,
         *,
         limit: int | None = 100,
         before: datetime | None = None,
         after: datetime | None = None,
-    ) -> AnnouncementsIterator:
-        """An :class:`~steam.iterators.AsyncIterator` over a clan's :class:`steam.Announcement`\\s.
+        # hidden: bool = False,
+    ) -> AsyncGenerator[Announcement, None]:
+        """An :term:`async iterator` over a clan's :class:`steam.Announcement`\\s.
 
         Examples
         --------
 
         Usage:
 
         .. code-block:: python3
 
             async for announcement in clan.announcements(limit=10):
-                print(
-                    announcement.author,
-                    "made an announcement",
-                    announcement.name,
-                    "at",
-                    announcement.created_at,
-                )
+                print(announcement.author, "made an announcement", announcement.name, "at", announcement.created_at)
 
         All parameters are optional.
 
         Parameters
         ----------
         limit
             The maximum number of announcements to search through. Default is ``100``. Setting this to ``None`` will
@@ -451,26 +502,74 @@
         after
             A time to search for announcements after.
 
         Yields
         ---------
         :class:`~steam.Announcement`
         """
-        return AnnouncementsIterator(self, self._state, limit, before, after)
+        rss = await self._state.http.get_clan_rss(
+            self.id64
+        )  # TODO make this use the calendar? does that work for announcements
+        after = after or UNIX_EPOCH
+        before = before or DateTime.now()
+        soup = BeautifulSoup(rss, HTML_PARSER)
+
+        ids: list[int] = []
+        for url in soup.find_all("guid"):
+            if match := re.findall(r"announcements/detail/(\d+)", url.text):
+                ids.append(int(match[0]))
+
+        if not ids:
+            return
+
+        announcements: list[Announcement] = []
+        for announcement_ in itertools.chain.from_iterable(
+            map(
+                itemgetter("event"),
+                await asyncio.gather(*(self._state.http.get_clan_announcement(self.id, id) for id in ids)),
+            )
+        ):
+            announcement = Announcement(self._state, self, announcement_)
+            if not after < announcement.starts_at < before:
+                break
+            announcements.append(announcement)
+
+        for yielded, (announcement, (author, last_edited_by)) in enumerate(
+            zip(
+                announcements,
+                utils.as_chunks(
+                    await self._state._maybe_users(
+                        itertools.chain.from_iterable(
+                            (
+                                a.author.id64,
+                                a.last_edited_by.id64 if a.last_edited_by is not None else ID64(0),
+                            )
+                            for a in announcements
+                        )
+                    ),
+                    2,
+                ),
+            )
+        ):
+            if limit is not None and yielded >= limit:
+                return
+            announcement.author = author
+            announcement.last_edited_by = last_edited_by if last_edited_by.id != 0 else None
+            yield announcement
 
     @overload
     async def create_event(
         self,
         name: str,
         content: str,
         *,
         type: Literal[EventType.Game] = ...,
         starts_at: datetime | None = ...,
-        game: Game,
-        server_address: str | None = ...,
+        app: App,
+        server_address: IPAdress | str | None = ...,
         server_password: str | None = ...,
     ) -> Event[Literal[EventType.Game]]:
         ...
 
     @overload
     async def create_event(
         self,
@@ -487,72 +586,73 @@
         name: str,
         content: str,
         *,
         type: Literal[
             EventType.Other,
             EventType.Chat,
             EventType.Game,
-            # ClanEvent.Broadcast,  # TODO need to wait until implementing stream support for this
+            # EventType.Broadcast,  # TODO need to wait until implementing stream support for this
             EventType.Party,
             EventType.Meeting,
             EventType.SpecialCause,
             EventType.MusicAndArts,
             EventType.Sports,
             EventType.Trip,
         ] = EventType.Other,
-        game: Game | None = None,
+        app: App | None = None,
         starts_at: datetime | None = None,
-        server_address: str | None = None,
+        server_address: IPAdress | str | None = None,
         server_password: str | None = None,
-    ) -> Event[EventType]:
+    ) -> Event[CreateableEvents]:
         """Create an event.
 
         Parameters
         ----------
         name
             The name of the event
         content
             The content for the event.
         type
-            The type of the event, defaults to :attr:`ClanEvent.Other`.
-        game
-            The game that will be played in the event. Required if type is :attr:`ClanEvent.Game`.
+            The type of the event, defaults to :attr:`EventType.Other`.
+        app
+            The app that will be played in the event. Required if type is :attr:`EventType.Game`.
         starts_at
             The time the event will start at.
         server_address
             The address of the server that the event will be played on. This is only allowed if ``type`` is
-            :attr:`ClanEvent.Game`.
+            :attr:`EventType.App`.
         server_password
             The password for the server that the event will be played on. This is only allowed if ``type`` is
-            :attr:`ClanEvent.Game`.
+            :attr:`EventType.App`.
 
         Note
         ----
         It is recommended to use a timezone aware datetime for ``start``.
 
         Returns
         -------
         The created event.
         """
+        server_address = IPv4Address(server_address) if server_address is not None else ""
 
         resp = await self._state.http.create_clan_event(
             self.id64,
             name,
             content,
             f"{type.name}Event",
-            str(game.id) if game is not None else "",
-            server_address or "",
+            str(app.id) if app is not None else "",
+            str(server_address),
             server_password or "",
             starts_at,
         )
         soup = BeautifulSoup(resp, HTML_PARSER)
         for element in soup.find_all("div", class_="eventBlockTitle"):
             a = element.a
             if a is not None and a.text == name:  # this is bad?
-                _, __, id = a["href"].rpartition("/")
+                _, _, id = a["href"].rpartition("/")
                 event = await self.fetch_event(int(id))
                 self._state.dispatch("event_create", event)
                 return event
         raise ValueError
 
     async def create_announcement(
         self,
@@ -577,13 +677,13 @@
         """
         await self._state.http.create_clan_announcement(self.id64, name, content, hidden)
         resp = await self._state.http.get(f"{self.community_url}/announcements", params={"content_only": "true"})
         soup = BeautifulSoup(resp, HTML_PARSER)
         for element in soup.find_all("div", class_="announcement"):
             a = element.a
             if a is not None and a.text == name:  # this is bad?
-                _, __, id = a["href"].rpartition("/")
+                _, _, id = a["href"].rpartition("/")
                 announcement = await self.fetch_announcement(int(id))
                 self._state.dispatch("announcement_create", announcement)
                 return announcement
 
         raise ValueError
```

### Comparing `steamio-0.9.9/steam/client.py` & `steamio-1.0.0a0/steam/client.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,63 +7,67 @@
 """
 
 from __future__ import annotations
 
 import asyncio
 import datetime
 import logging
+import math
 import random
 import sys
 import time
 import traceback
-from collections.abc import Callable, Collection, Coroutine, Sequence
-from typing import TYPE_CHECKING, Any, TypeVar, overload
+from collections.abc import AsyncGenerator, Callable, Collection, Coroutine, Sequence
+from typing import TYPE_CHECKING, Any, Literal, TypeAlias, TypeVar, final, overload
 
 import aiohttp
-from typing_extensions import Literal, TypeAlias, final
+from bs4 import BeautifulSoup
 
 from . import errors, utils
-from ._const import DOCS_BUILDING, TASK_HAS_NAME, URL
-from .abc import SteamID
+from ._const import DOCS_BUILDING, MISSING, STATE, UNIX_EPOCH, URL
+from .app import App, FetchedApp, PartialApp
 from .enums import Language, PersonaState, PersonaStateFlag, PublishedFileRevision, Type, UIMode
-from .game import FetchedGame, Game, StatefulGame
 from .game_server import GameServer, Query
 from .gateway import *
 from .guard import generate_one_time_code
 from .http import HTTPClient
-from .iterators import TradesIterator
-from .manifest import GameInfo, PackageInfo
+from .id import ID
+from .manifest import AppInfo, PackageInfo
 from .models import PriceOverview, return_true
-from .package import FetchedPackage, License, Package, StatefulPackage
+from .package import FetchedPackage, License, Package, PartialPackage
+from .post import Post
 from .published_file import PublishedFile
-from .reaction import ClientEmoticon, ClientSticker, Emoticon
+from .reaction import ClientEmoticon, ClientSticker
 from .state import ConnectionState
-from .utils import make_id64
+from .types.id import AppID, BundleID, Intable, PackageID
+from .utils import DateTime, TradeURLInfo, parse_id64
 
 if TYPE_CHECKING:
     import steam
 
     from .abc import Message
     from .clan import Clan
     from .comment import Comment
     from .event import Announcement, Event
     from .friend import Friend
     from .group import Group
     from .invite import ClanInvite, UserInvite
-    from .protobufs import Msg, MsgProto
+    from .protobufs import Message, ProtobufMessage
     from .reaction import MessageReaction
     from .trade import TradeOffer
+    from .types.http import IPAdress
     from .user import ClientUser, User
 
 __all__ = ("Client",)
 
 log = logging.getLogger(__name__)
-EventType: TypeAlias = "Callable[..., Coroutine[Any, Any, Any]]"
-EventDeco: TypeAlias = "Callable[[E], E] | E"
+
+EventType: TypeAlias = Callable[..., Coroutine[Any, Any, Any]]
 E = TypeVar("E", bound=EventType)
+EventDeco: TypeAlias = Callable[[E], E] | E
 
 
 class Client:
     """Represents a client connection that connects to Steam. This class is used to interact with the Steam API and CMs.
 
     Parameters
     ----------
@@ -71,18 +75,18 @@
         A proxy URL to use for requests.
     proxy_auth
         The proxy authentication to use with requests.
     connector
         The connector to use with the :class:`aiohttp.ClientSession`.
     max_messages
         The maximum number of messages to store in the internal cache, default is 1000.
-    game
-        A games to set your status as on connect.
-    games
-        A list of games to set your status to on connect.
+    app
+        An app to set your status as on connect.
+    apps
+        A list of apps to set your status to on connect.
     state
         The state to show your account as on connect.
 
         Note
         ----
         Setting your status to :attr:`~steam.PersonaState.Offline`, will stop you receiving persona state updates
         and by extension :meth:`on_user_update` will stop being dispatched.
@@ -107,16 +111,16 @@
     def __init__(  # type: ignore
         self,
         *,
         proxy: str | None = ...,
         proxy_auth: aiohttp.BasicAuth | None = ...,
         connector: aiohttp.BaseConnector | None = ...,
         max_messages: int | None = 1000,
-        game: Game | None = ...,
-        games: list[Game] = ...,
+        app: App | None = ...,
+        apps: list[App] = ...,
         state: PersonaState | None = PersonaState.Online,
         ui_mode: UIMode | None = UIMode.Desktop,
         flags: PersonaStateFlag | None = PersonaStateFlag.NONE,
         force_kick: bool = False,
         language: Language = Language.English,
         auto_chunk_chat_groups: bool = False,
     ):
@@ -131,86 +135,84 @@
             warnings.warn(
                 "The loop argument is deprecated and scheduled for removal in V.1",
                 stacklevel=len(inspect.stack())
                 + 1,  # make sure its always at the top of the stack most likely where the Client was created
             )
         self.loop = asyncio.get_event_loop()
         self.http = HTTPClient(client=self, **options)
-        self._connection = self._get_state(**options)
-        self.ws: SteamWebSocket = None  # type: ignore
+        self._state = self._get_state(**options)
+        STATE.set(self._state)
+        self.ws: SteamWebSocket | None = None
 
         self.username: str | None = None
         self.password: str | None = None
         self.shared_secret: str | None = None
         self.identity_secret: str | None = None
 
         self._closed = True
-        self._cm_list: CMServerList | None = None
-        self._listeners: dict[str, list[tuple[asyncio.Future, Callable[..., bool]]]] = {}
+        self._listeners: dict[str, list[tuple[asyncio.Future[Any], Callable[..., bool]]]] = {}
         self._ready = asyncio.Event()
 
     def _get_state(self, **options: Any) -> ConnectionState:
         return ConnectionState(client=self, **options)
 
     @property
     def user(self) -> ClientUser:
         """Represents the connected client. ``None`` if not logged in."""
         return self.http.user
 
     @property
     def users(self) -> Sequence[User]:
         """A read-only list of all the users the connected client can see."""
-        return self._connection.users
+        return self._state.users
 
     @property
     def trades(self) -> Sequence[TradeOffer]:
         """A read-only list of all the trades the connected client can see."""
-        return self._connection.trades
+        return self._state.trades
 
     @property
     def groups(self) -> Sequence[Group]:
         """A read-only list of all the groups the connected client is in."""
-        return self._connection.groups
+        return self._state.groups
 
     @property
     def messages(self) -> Sequence[Message]:
         """A read-only list of all the messages the client has."""
-        return self._connection._messages
+        return self._state._messages
 
     @property
     def clans(self) -> Sequence[Clan]:
         """A read-only list of all the clans the connected client is in."""
-        return self._connection.clans
+        return self._state.clans
 
     @property
     def licenses(self) -> Sequence[License]:
         """A read-only list of licenses the client has access to."""
-        return list(self._connection.licenses.values())
+        return list(self._state.licenses.values())
 
     @property
     def emoticons(self) -> Sequence[ClientEmoticon]:
         """A read-only list of all the emoticons the client has."""
-        return self._connection.emoticons
+        return self._state.emoticons
 
     @property
     def stickers(self) -> Sequence[ClientSticker]:
         """A read-only list of all the stickers the client has."""
-        return self._connection.stickers
+        return self._state.stickers
 
     @property
     def latency(self) -> float:
         """Measures latency between a heartbeat send and the heartbeat interval in seconds."""
         return float("nan") if self.ws is None else self.ws.latency
 
-    async def token(self) -> str:
-        resp = await self.http.get(URL.COMMUNITY / "chat/clientjstoken")
-        if not resp["logged_in"]:  # we got logged out :(
-            await self.http.login(self.username, self.password, shared_secret=self.shared_secret)  # type: ignore
-            return await self.token()
-        return resp["token"]
+    @property
+    def refresh_token(self) -> str | None:
+        """The refresh token for the logged in account, can be used to login."""
+        return None if self.ws is None else self.ws.refresh_token
 
     async def code(self) -> str:
         """Get the current steam guard code.
 
         Warning
         -------
         This function will wait for a Steam guard code using :func:`input` in an executor if no shared_secret is passed
@@ -275,52 +277,48 @@
             pass
         except Exception as exc:
             try:
                 await self.on_error(event_name, exc, *args, **kwargs)
             except asyncio.CancelledError:
                 pass
 
-    def _schedule_event(self, coro: EventType, event_name: str, *args: Any, **kwargs: Any) -> asyncio.Task:
-        wrapped = self._run_event(coro, event_name, *args, **kwargs)
-        return (
-            self.loop.create_task(wrapped, name=f"task_{event_name}")
-            if TASK_HAS_NAME
-            else self.loop.create_task(wrapped)
+    def _schedule_event(self, coro: EventType, event_name: str, *args: Any, **kwargs: Any) -> asyncio.Task[None]:
+        return asyncio.create_task(
+            self._run_event(coro, event_name, *args, **kwargs), name=f"steam.py task: {event_name}"
         )
 
     def dispatch(self, event: str, *args: Any, **kwargs: Any) -> None:
         log.debug(f"Dispatching event {event}")
         method = f"on_{event}"
 
-        listeners = self._listeners.get(event)
         # remove the dispatched listener
-        if listeners:
-            removed = []
+        if listeners := self._listeners.get(event):
+            removed: list[int] = []
             for idx, (future, condition) in enumerate(listeners):
                 if future.cancelled():
                     removed.append(idx)
                     continue
 
                 try:
                     result = condition(*args)
                 except Exception as exc:
                     future.set_exception(exc)
                     removed.append(idx)
                 else:
                     if result:
-                        if len(args) == 0:
+                        if not args:
                             future.set_result(None)
                         elif len(args) == 1:
                             future.set_result(args[0])
                         else:
                             future.set_result(args)
                         removed.append(idx)
 
             if len(removed) == len(listeners):
-                self._listeners.pop(event)
+                del self._listeners[event]
             else:
                 for idx in reversed(removed):
                     del listeners[idx]
 
         # schedule the event (if possible)
         try:
             coro = getattr(self, method)
@@ -331,24 +329,29 @@
 
     async def _handle_ready(self) -> None:
         self._ready.set()
         self.dispatch("ready")
 
     @overload
     @final
-    def run(  # type: ignore
+    def run(
         self,
         username: str,
         password: str,
         *,
-        shared_secret: str | None = None,
-        identity_secret: str | None = None,
+        shared_secret: str = MISSING,
+        identity_secret: str = MISSING,
     ) -> object:
         ...
 
+    @overload
+    @final
+    def run(self, *, refresh_token: str) -> object:
+        ...
+
     @final
     def run(self, *args: Any, **kwargs: Any) -> object:
         """A blocking call that abstracts away the event loop initialisation from you.
 
         It is not recommended to subclass this method, it is normally favourable to subclass :meth:`start` as it is a
         :ref:`coroutine <coroutine>`.
 
@@ -356,121 +359,151 @@
         ----
         This takes the same arguments as :meth:`start`.
         """
 
         async def runner() -> None:
             asyncio.events.new_event_loop = old_new_event_loop
             try:
-                await self.start(*args, **kwargs)
+                await self.login(*args, **kwargs)
             finally:
                 if not self.is_closed():
                     await self.close()
 
         # we just have to monkey patch in support for using get_event_loop
         old_new_event_loop = asyncio.new_event_loop
         asyncio.events.new_event_loop = asyncio.get_event_loop
         try:
             asyncio.run(runner())
         except KeyboardInterrupt:
             log.info("Closing the event loop")
 
-    async def login(self, username: str, password: str, *, shared_secret: str | None = None) -> None:
-        """Login a Steam account and the Steam API with the specified credentials.
-
-        Parameters
-        ----------
-        username
-            The username of the user's account.
-        password
-            The password of the user's account.
-        shared_secret
-            The shared_secret of the desired Steam account, used to generate the 2FA code for login. If ``None`` is
-            passed, the code will need to be inputted by the user via :meth:`code`.
-
-        Raises
-        ------
-        :exc:`.InvalidCredentials`
-            Invalid credentials were passed.
-        :exc:`.LoginError`
-            An unknown login related error occurred.
-        :exc:`.NoCMsFound`
-            No community managers could be found to connect to.
-        """
-        log.info("Logging in to steamcommunity.com")
-        self.username = username
-        self.password = password
-        self.shared_secret = shared_secret
-
-        await self.http.login(username, password, shared_secret=shared_secret)
-        self._closed = False
-        self.loop.create_task(self._connection.__ainit__())
-
     async def close(self) -> None:
         """Close the connection to Steam."""
         if self.is_closed():
             return
 
         self._closed = True
 
         if self.ws is not None:
             try:
-                await self.change_presence(game=Game(id=0))  # disconnect from games
+                await self.change_presence(app=App(id=0))  # disconnect from games
                 await self.ws.handle_close()
             except ConnectionClosed:
                 pass
 
         await self.http.close()
         self._ready.clear()
 
     def clear(self) -> None:
         """Clears the internal state of the bot. After this, the bot can be considered "re-opened", i.e.
         :meth:`is_closed` and :meth:`is_ready` both return ``False``. This also clears the internal cache.
         """
         self._closed = False
         self._ready.clear()
-        self._connection.clear()
+        self._state.clear()
         self.http.clear()
 
-    async def start(
+    @overload
+    async def login(
         self,
         username: str,
         password: str,
         *,
-        shared_secret: str | None = None,
-        identity_secret: str | None = None,
+        shared_secret: str = ...,
+        identity_secret: str = ...,
     ) -> None:
-        """A shorthand coroutine for :meth:`login` and :meth:`connect`.
+        ...
+
+    @overload
+    async def login(
+        self,
+        *,
+        refresh_token: str,
+    ) -> None:
+        ...
+
+    async def login(
+        self,
+        username: str = MISSING,
+        password: str = MISSING,
+        *,
+        shared_secret: str = MISSING,
+        identity_secret: str = MISSING,
+        refresh_token: str = MISSING,
+    ) -> None:
+        """Initialize a connection to a Steam CM and login.
 
         If no ``shared_secret`` is passed, you will have to manually enter a Steam guard code using :meth:`code`.
 
         Parameters
         ----------
         username
             The username of the account to login to.
         password
             The password of the account to login to.
         shared_secret
             The shared secret for the account to login to.
         identity_secret
             The identity secret for the account to login to.
-        """
 
+        Other Parameters
+        ----------------
+        refresh_token
+            The refresh token of the account to login to.
+        """
         self.username = username
         self.password = password
         self.shared_secret = shared_secret
         self.identity_secret = identity_secret
 
+        self._closed = False
+
         if identity_secret is None:
             log.info("Trades will not be automatically accepted when sent as no identity_secret was passed.")
 
-        await self.login(username, password, shared_secret=shared_secret)
-        await self.connect()
+        exceptions = (
+            OSError,
+            ConnectionClosed,
+            aiohttp.ClientError,
+            asyncio.TimeoutError,
+            errors.HTTPException,
+        )
+
+        async def throttle() -> None:
+            now = time.monotonic()
+            between = now - last_connect
+            sleep = random.random() * 4 if between > 600 else 100 / between**0.5
+            log.info(f"Attempting to connect to another CM in {sleep}")
+            await asyncio.sleep(sleep)
+
+        self.http.clear()
+        while not self.is_closed():
+            last_connect = time.monotonic()
+
+            try:
+                self.ws = await asyncio.wait_for(SteamWebSocket.from_client(self, refresh_token), timeout=60)
+            except exceptions:
+                await throttle()
+                continue
+
+            try:
+                while True:
+                    await self.ws.poll_event()
+            except exceptions as exc:
+                if isinstance(exc, ConnectionClosed):
+                    self._state._connected_cm = exc.cm
+                self.dispatch("disconnect")
+            finally:
+                if not self.is_closed():
+                    await throttle()
+
+    async def anonymous_login(self) -> None:
+        """Initialize a connection to a Steam CM and login anonymously."""
+        self._closed = False
 
-    async def connect(self) -> None:
-        """Initialize a connection to a Steam CM after logging in."""
         exceptions = (
             OSError,
             ConnectionClosed,
             aiohttp.ClientError,
             asyncio.TimeoutError,
             errors.HTTPException,
         )
@@ -478,253 +511,256 @@
         async def throttle() -> None:
             now = time.monotonic()
             between = now - last_connect
             sleep = random.random() * 4 if between > 600 else 100 / between**0.5
             log.info(f"Attempting to connect to another CM in {sleep}")
             await asyncio.sleep(sleep)
 
+        self.http.clear()
         while not self.is_closed():
             last_connect = time.monotonic()
 
             try:
-                self.ws = await asyncio.wait_for(SteamWebSocket.from_client(self, cm_list=self._cm_list), timeout=60)
+                self.ws = await asyncio.wait_for(SteamWebSocket.anonymous_login_from_client(self), timeout=60)
             except exceptions:
                 await throttle()
                 continue
 
             try:
                 while True:
                     await self.ws.poll_event()
             except exceptions as exc:
                 if isinstance(exc, ConnectionClosed):
-                    self._cm_list = exc.cm_list
+                    self._state._connected_cm = exc.cm
                 self.dispatch("disconnect")
             finally:
                 if not self.is_closed():
                     await throttle()
 
     # state stuff
-
-    def get_user(self, id: utils.Intable) -> User | None:
+    # TODO decide on where this should take id32s
+    def get_user(self, id: Intable) -> User | None:
         """Returns a user from cache with a matching ID or ``None`` if the user was not found.
 
         Parameters
         ----------
         id
-            The ID of the user, can be an :attr:`.SteamID.id64`, :attr:`.SteamID.id`, :attr:`.SteamID.id2` or an
-            :attr:`.SteamID.id3`.
+            The ID of the user, can be an :attr:`.ID.id64`, :attr:`.ID.id`, :attr:`.ID.id2` or an
+            :attr:`.ID.id3`.
         """
-        steam_id = SteamID(id=id, type=Type.Individual)
-        return self._connection.get_user(steam_id.id)
+        steam_id = ID(id=id, type=Type.Individual)
+        return self._state.get_user(steam_id.id)
 
-    async def fetch_user(self, id: utils.Intable) -> User | None:
+    async def fetch_user(self, id: Intable) -> User | None:
         """Fetches a user with a matching ID or ``None`` if the user was not found.
 
         Parameters
         ----------
         id
-            The ID of the user, can be an :attr:`.SteamID.id64`, :attr:`.SteamID.id`, :attr:`.SteamID.id2` or an
-            :attr:`.SteamID.id3`.
+            The ID of the user, can be an :attr:`.ID.id64`, :attr:`.ID.id`, :attr:`.ID.id2` or an
+            :attr:`.ID.id3`.
         """
-        id64 = make_id64(id=id, type=Type.Individual)
-        return await self._connection.fetch_user(id64)
+        id64 = parse_id64(id=id, type=Type.Individual)
+        return await self._state.fetch_user(id64)
 
-    async def fetch_users(self, *ids: utils.Intable) -> list[User | None]:
+    async def fetch_users(self, *ids: Intable) -> list[User]:
         """Fetches a list of :class:`~steam.User` or ``None`` if the user was not found, from their IDs.
 
         Note
         ----
         The :class:`~steam.User` objects returned are unlikely to retain the order they were originally in.
 
         Parameters
         ----------
         ids
             The user's IDs.
         """
-        id64s = [make_id64(id, type=Type.Individual) for id in ids]
-        return await self._connection.fetch_users(id64s)
+        id64s = [parse_id64(id, type=Type.Individual) for id in ids]
+        return await self._state.fetch_users(id64s)
 
     async def fetch_user_named(self, name: str) -> User | None:
         """Fetches a user from https://steamcommunity.com from their community URL name.
 
         Parameters
         ----------
         name
             The name of the user after https://steamcommunity.com/id
         """
         id64 = await utils.id64_from_url(URL.COMMUNITY / f"id/{name}", self.http._session)
-        return await self._connection.fetch_user(id64) if id64 is not None else None
+        return await self._state.fetch_user(id64) if id64 is not None else None
 
     def get_trade(self, id: int) -> TradeOffer | None:
         """Get a trade from cache with a matching ID or ``None`` if the trade was not found.
 
         Parameters
         ----------
         id
             The id of the trade to search for from the cache.
         """
-        return self._connection.get_trade(id)
+        return self._state.get_trade(id)
 
     async def fetch_trade(self, id: int, *, language: Language | None = None) -> TradeOffer | None:
         """Fetches a trade with a matching ID or ``None`` if the trade was not found.
 
         Parameters
         ----------
         id
             The ID of the trade to search for from the API.
         language
             The language to fetch the trade in. ``None`` uses the current language.
         """
-        return await self._connection.fetch_trade(id, language)
+        return await self._state.fetch_trade(id, language)
 
-    def get_group(self, id: utils.Intable) -> Group | None:
+    def get_group(self, id: Intable) -> Group | None:
         """Get a group from cache with a matching ID or ``None`` if the group was not found.
 
         Parameters
         ----------
         id
-            The ID of the group, can be an :attr:`.SteamID.id64`, :attr:`.SteamID.id`, :attr:`.SteamID.id2` or an
-            :attr:`.SteamID.id3`.
+            The ID of the group, can be an :attr:`.ID.id64`, :attr:`.ID.id`, :attr:`.ID.id2` or an
+            :attr:`.ID.id3`.
         """
-        steam_id = SteamID(id=id, type=Type.Chat)
-        return self._connection.get_group(steam_id.id)
+        steam_id = ID(id=id, type=Type.Chat)
+        return self._state.get_group(steam_id.id)
 
-    def get_clan(self, id: utils.Intable) -> Clan | None:
+    def get_clan(self, id: Intable) -> Clan | None:
         """Get a clan from cache with a matching ID or ``None`` if the group was not found.
 
         Parameters
         ----------
         id
-            The ID of the clan, can be an :attr:`.SteamID.id64`, :attr:`.SteamID.id`, :attr:`.SteamID.id2` or an
-            :attr:`.SteamID.id3`.
+            The ID of the clan, can be an :attr:`.ID.id64`, :attr:`.ID.id`, :attr:`.ID.id2` or an
+            :attr:`.ID.id3`.
         """
-        steam_id = SteamID(id=id, type=Type.Clan)
-        return self._connection.get_clan(steam_id.id)
+        steam_id = ID(id=id, type=Type.Clan)
+        return self._state.get_clan(steam_id.id)
 
-    async def fetch_clan(self, id: utils.Intable) -> Clan | None:
+    async def fetch_clan(self, id: Intable) -> Clan | None:
         """Fetches a clan from the websocket with a matching ID or ``None`` if the clan was not found.
 
         Parameters
         ----------
         id
-            The ID of the clan, can be an :attr:`.SteamID.id64`, :attr:`.SteamID.id`, :attr:`.SteamID.id2` or an
-            :attr:`.SteamID.id3`.
+            The ID of the clan, can be an :attr:`.ID.id64`, :attr:`.ID.id`, :attr:`.ID.id2` or an
+            :attr:`.ID.id3`.
         """
-        id64 = make_id64(id=id, type=Type.Clan)
-        return await self._connection.fetch_clan(id64)
+        id64 = parse_id64(id=id, type=Type.Clan)
+        return await self._state.fetch_clan(id64)
 
     async def fetch_clan_named(self, name: str) -> Clan | None:
         """Fetches a clan from https://steamcommunity.com with a matching name or ``None`` if the clan was not found.
 
         Parameters
         ----------
         name
             The name of the Steam clan.
         """
-        steam_id = await SteamID.from_url(URL.COMMUNITY / "clans" / name, self.http._session)
-        return await self._connection.fetch_clan(steam_id.id64) if steam_id is not None else None
+        steam_id = await ID.from_url(URL.COMMUNITY / "clans" / name, self.http._session)
+        return await self._state.fetch_clan(steam_id.id64) if steam_id is not None else None
 
-    def get_game(self, id: int | Game) -> StatefulGame:
-        """Creates a stateful game from its ID.
+    def get_app(self, id: int | App) -> PartialApp:
+        """Creates a stateful app from its ID.
 
         Parameters
         ----------
         id
-            The app id of the game or a :class:`~steam.Game` instance.
+            The app id of the app or a :class:`~steam.App` instance.
         """
-        return StatefulGame(self._connection, id=getattr(id, "id", id))
+        return PartialApp(self._state, id=getattr(id, "id", id))
 
-    async def fetch_game(self, id: int | Game, *, language: Language | None = None) -> FetchedGame | None:
-        """Fetch a game from its ID or ``None`` if the game was not found.
+    async def fetch_app(self, id: int | App, *, language: Language | None = None) -> FetchedApp | None:
+        """Fetch an app from its ID or ``None`` if the app was not found.
 
         Parameters
         ----------
         id
-            The app id of the game or a :class:`~steam.Game` instance.
+            The app id of the app or a :class:`~steam.App` instance.
         language
-            The language to fetch the game in. If ``None`` uses the current language.
+            The language to fetch the app in. If ``None`` uses the current language.
         """
         id = id if isinstance(id, int) else id.id
-        resp = await self.http.get_game(id, language)
+        resp = await self.http.get_app(id, language)
         if resp is None:
             return None
         data = resp[str(id)]
-        return FetchedGame(self._connection, data["data"]) if data["success"] else None
+        return FetchedApp(self._state, data["data"], language or self._state.language) if data["success"] else None
 
-    def get_package(self, id: int) -> StatefulPackage:
+    def get_package(self, id: int) -> PartialPackage:
         """Creates a package from its ID.
 
         Parameters
         ----------
         id
             The ID of the package.
         """
-        return StatefulPackage(self._connection, id=id)
+        return PartialPackage(self._state, id=id)
 
-    async def fetch_package(self, id: int, *, language: Language | None = None) -> FetchedPackage | None:
+    async def fetch_package(self, id: int | Package, *, language: Language | None = None) -> FetchedPackage | None:
         """Fetch a package from its ID.
 
         Parameters
         ----------
         id
             The ID of the package.
         language
             The language to fetch the package in. If ``None`` uses the current language.
         """
+        id = PackageID(id) if isinstance(id, int) else id.id
         resp = await self.http.get_package(id, language)
         if resp is None:
             return None
         data = resp[str(id)]
-        return FetchedPackage(self._connection, data["data"]) if data["success"] else None
+        return FetchedPackage(self._state, data["data"]) if data["success"] else None
 
     @overload
-    async def fetch_server(self, *, id: utils.Intable) -> GameServer | None:
+    async def fetch_server(self, *, id: Intable) -> GameServer | None:
         ...
 
     @overload
     async def fetch_server(
         self,
         *,
-        ip: str,
-        port: int | None = ...,
+        ip: IPAdress | str,
+        port: int = ...,
     ) -> GameServer | None:
         ...
 
     async def fetch_server(
         self,
         *,
-        id: utils.Intable | None = None,
-        ip: str | None = None,
-        port: int | str | None = None,
+        id: Intable = MISSING,
+        ip: IPAdress | str = MISSING,
+        port: int | str = MISSING,
     ) -> GameServer | None:
-        """Fetch a :class:`.GameServer` from its ip and port or its SteamID or ``None`` if fetching the server failed.
+        """Fetch a :class:`.GameServer` from its ip and port or its Steam ID or ``None`` if fetching the server failed.
 
         Parameters
         ----------
         ip
             The ip of the server.
         port
             The port of the server.
         id
-            The ID of the game server, can be an :attr:`.SteamID.id64`, :attr:`.SteamID.id2` or an :attr:`.SteamID.id3`.
+            The ID of the game server, can be an :attr:`.ID.id64`, :attr:`.ID.id2` or an :attr:`.ID.id3`.
             If this is passed, it makes a call to the master server to fetch its ip and port.
 
         Note
         ----
         Passing an ``ip``, ``port`` and ``id`` to this function will raise an :exc:`TypeError`.
         """
 
         if all((id, ip, port)):
             raise TypeError("Too many arguments passed to fetch_server")
         if id:
             # we need to fetch the ip and port
-            servers = await self._connection.fetch_server_ip_from_steam_id(make_id64(id, type=Type.GameServer))
+            servers = await self._state.fetch_server_ip_from_steam_id(parse_id64(id, type=Type.GameServer))
             if not servers:
                 raise ValueError(f"The master server didn't find a matching server for {id}")
-            ip, _, port = servers[0].addr.partition(":")
+            ip_, _, port = servers[0].addr.rpartition(":")
+            ip = IPAdress(ip_)
         elif not ip:
             raise TypeError("fetch_server missing argument ip")
 
         servers = await self.fetch_servers(Query.ip / f"{ip}{f':{port}' if port is not None else ''}", limit=1)
         return servers[0] if servers else None
 
     async def fetch_servers(self, query: Query[Any], *, limit: int = 100) -> list[GameServer]:
@@ -733,54 +769,54 @@
         Parameters
         ----------
         query
             The query to match servers with.
         limit
             The maximum amount of servers to return.
         """
-        servers = await self._connection.fetch_servers(query.query, limit)
-        return [GameServer(self._connection, server) for server in servers]
+        servers = await self._state.fetch_servers(query.query, limit)
+        return [GameServer(self._state, server) for server in servers]
 
     # content server related stuff
 
     @overload
-    async def fetch_product_info(self, *, games: Collection[Game]) -> list[GameInfo]:
+    async def fetch_product_info(self, *, apps: Collection[App]) -> list[AppInfo]:
         ...
 
     @overload
     async def fetch_product_info(self, *, packages: Collection[Package]) -> list[PackageInfo]:
         ...
 
     @overload
     async def fetch_product_info(
-        self, *, games: Collection[Game], packages: Collection[Package]
-    ) -> tuple[list[GameInfo], list[PackageInfo]]:
+        self, *, apps: Collection[App], packages: Collection[Package]
+    ) -> tuple[list[AppInfo], list[PackageInfo]]:
         ...
 
     async def fetch_product_info(
-        self, *, games: Collection[Game] = (), packages: Collection[Package] = ()
-    ) -> list[GameInfo] | list[PackageInfo] | tuple[list[GameInfo], list[PackageInfo]]:
+        self, *, apps: Collection[App] = (), packages: Collection[Package] = ()
+    ) -> list[AppInfo] | list[PackageInfo] | tuple[list[AppInfo], list[PackageInfo]]:
         """Fetch product info.
 
         Parameters
         ----------
-        games
-            The games to fetch info on.
+        apps
+            The apps to fetch info on.
         packages
             The packages to fetch info on.
         """
 
-        game_infos, package_infos = await self._connection.fetch_product_info(
-            (game.id for game in games), (package.id for package in packages)
+        app_infos, package_infos = await self._state.fetch_product_info(
+            (app.id for app in apps), (package.id for package in packages)
         )
 
-        if games and packages:
-            return game_infos, package_infos
+        if apps and packages:
+            return app_infos, package_infos
 
-        return game_infos if games else package_infos
+        return app_infos if apps else package_infos
 
     # miscellaneous stuff
 
     async def fetch_published_file(
         self,
         id: int,
         *,
@@ -794,15 +830,15 @@
         id
             The ID of the published file.
         revision
             The revision of the published file to fetch.
         language
             The language to fetch the published file in. If ``None``, the current language is used.
         """
-        (file,) = await self._connection.fetch_published_files((id,), revision, language)
+        (file,) = await self._state.fetch_published_files((id,), revision, language)
         return file
 
     async def fetch_published_files(
         self,
         *ids: int,
         revision: PublishedFileRevision = PublishedFileRevision.Default,
         language: Language | None = None,
@@ -814,47 +850,66 @@
         ids
             The IDs of the published files.
         revision
             The revision of the published files to fetch.
         language
             The language to fetch the published files in. If ``None``, the current language is used.
         """
-        return await self._connection.fetch_published_files(ids, revision, language)
+        return await self._state.fetch_published_files(ids, revision, language)
 
-    def trade_history(
+    async def create_post(self, content: str, app: App | None = None) -> Post:
+        """Create a post.
+
+        Parameters
+        ----------
+        content
+            The content of the post.
+        app
+            The app to create the post for.
+        """
+        await self._state.create_user_post(content, app_id=AppID(0) if app is None else app.id)
+        # TODO if ws ever gives the post id switch to just this
+        # for now steam is broken and thinks I'm logged out even though /my seems to resolve to the right account
+        resp = await self.http.get(URL.COMMUNITY / "my/myactivity")
+        soup = BeautifulSoup(resp, "html.parser")
+        for post in soup.find_all("div", class_="blotter_userstatus"):
+            if (
+                content_element := post.find("div", class_="blotter_userstatus_content responsive_body_text")
+            ) is not None and content_element.text.strip() == content:
+                id, _, _ = post["id"].removeprefix("userstatus_").partition("_")
+                return Post(
+                    self._state, int(id), content, self.user, PartialApp(self._state, id=app.id) if app else None
+                )
+
+        raise RuntimeError("Post created has no ID, this should be unreachable")
+
+    async def trade_history(
         self,
         *,
         limit: int | None = 100,
         before: datetime.datetime | None = None,
         after: datetime.datetime | None = None,
         language: Language | None = None,
-    ) -> TradesIterator:
-        """An :class:`~steam.iterators.AsyncIterator` for accessing a :class:`steam.ClientUser`'s
+    ) -> AsyncGenerator[TradeOffer, None]:
+        """An :term:`async iterator` for accessing a :class:`steam.ClientUser`'s
         :class:`steam.TradeOffer` objects.
 
         Examples
         --------
 
         Usage:
 
         .. code-block:: python3
 
             async for trade in client.trade_history(limit=10):
-                items = [getattr(item, "name", str(item.asset_id)) for item in trade.items_to_receive]
+                items = [getattr(item, "name", str(item.id)) for item in trade.items_to_receive]
                 items = ", ".join(items) or "Nothing"
                 print("Partner:", trade.partner)
                 print("Sent:", items)
 
-        Flattening into a list:
-
-        .. code-block:: python3
-
-            trades = await client.trade_history(limit=50).flatten()
-            # trades is now a list of TradeOffer
-
         All parameters are optional.
 
         Parameters
         ----------
         limit
             The maximum number of trades to search through. Default is ``100``. Setting this to ``None`` will fetch all
             of the user's trades, but this will be a very slow operation.
@@ -865,34 +920,91 @@
         language
             The language to fetch the trade in. ``None`` uses the current language.
 
         Yields
         ---------
         :class:`~steam.TradeOffer`
         """
-        return TradesIterator(state=self._connection, limit=limit, before=before, after=after, language=language)
+        from .trade import TradeOffer
+
+        total = 100
+        previous_time = 0
+        after = after or UNIX_EPOCH
+        before = before or DateTime.now()
+        after_timestamp = after.timestamp()
+        before_timestamp = before.timestamp()
+        yielded = 0
+
+        async def get_trades(page: int = 100) -> list[TradeOffer]:
+            nonlocal total, previous_time
+            resp = await self._state.http.get_trade_history(page, previous_time, language)
+            data = resp["response"]
+            if total is None:
+                total = data.get("total_trades", 0)
+            if not total:
+                return []
+
+            trades: list[TradeOffer] = []
+            descriptions = data.get("descriptions", ())
+            trade = None
+            for trade in data.get("trades", []):
+                if not after_timestamp < trade["time_init"] < before_timestamp:
+                    break
+                for item in descriptions:
+                    for asset in trade.get("assets_received", []):
+                        if item["classid"] == asset["classid"] and item["instanceid"] == asset["instanceid"]:
+                            asset.update(item)
+                    for asset in trade.get("assets_given", []):
+                        if item["classid"] == asset["classid"] and item["instanceid"] == asset["instanceid"]:
+                            asset.update(item)
+
+                trades.append(TradeOffer._from_history(state=self._state, data=trade))
+
+            assert trade is not None
+            previous_time = trade["time_init"]
+            for trade, partner in zip(trades, await self._state._maybe_users(trade.partner for trade in trades)):
+                trade.partner = partner
+            return trades
+
+        for trade in await get_trades():
+            for item in trade.items_to_receive:
+                item.owner = trade.partner
+            if limit is not None and yielded >= limit:
+                return
+            yield trade
+            yielded += 1
+
+        if total < 100:
+            for page in range(200, math.ceil((total + 100) / 100) * 100, 100):
+                for trade in await get_trades(page):
+                    for item in trade.items_to_receive:
+                        item.owner = trade.partner
+                    if limit is not None and yielded >= limit:
+                        return
+                    yield trade
+                    yielded += 1
 
     async def change_presence(
         self,
         *,
-        game: Game | None = None,
-        games: list[Game] | None = None,
+        app: App | None = None,
+        apps: list[App] | None = None,
         state: PersonaState | None = None,
         ui_mode: UIMode | None = None,
         flags: PersonaStateFlag | None = None,
         force_kick: bool = False,
     ) -> None:
         """Set your status.
 
         Parameters
         ----------
-        game
-            A games to set your status as.
-        games
-            A list of games to set your status to.
+        app
+            An app to set your status as.
+        apps
+            A list of apps to set your status to.
         state
             The state to show your account as.
 
             Warning
             -------
             Setting your status to :attr:`~steam.PersonaState.Offline`, will stop you receiving persona state updates
             and by extension :meth:`on_user_update` will stop being dispatched.
@@ -900,51 +1012,53 @@
         ui_mode
             The UI mode to set your status to.
         flags
             The flags to update your account with.
         force_kick
             Whether to forcefully kick any other playing sessions.
         """
-        games_ = [game.to_dict() for game in games] if games is not None else []
-        if game is not None:
-            games_.append(game.to_dict())
-        await self.ws.change_presence(games=games_, state=state, flags=flags, ui_mode=ui_mode, force_kick=force_kick)
+        apps_ = [app.to_proto() for app in apps] if apps is not None else []
+        if app is not None:
+            apps_.append(app.to_proto())
+        await self.ws.change_presence(apps=apps_, state=state, flags=flags, ui_mode=ui_mode, force_kick=force_kick)
 
-    async def trade_url(self, generate_new: bool = False) -> str:
+    async def trade_url(self, generate_new: bool = False) -> TradeURLInfo:
         """Fetches this account's trade url.
 
         Parameters
         ----------
         generate_new
             Whether or not to generate a new trade token, defaults to ``False``.
         """
-        return await self._connection.fetch_trade_url(generate_new)
+        info = utils.parse_trade_url(await self._state.fetch_trade_url(generate_new))
+        assert info is not None
+        return info
 
     async def wait_until_ready(self) -> None:
         """Waits until the client's internal cache is all ready."""
         await self._ready.wait()
 
-    async def fetch_price(self, name: str, game: Game, currency: int | None = None) -> PriceOverview:
+    async def fetch_price(self, name: str, app: App, currency: int | None = None) -> PriceOverview:
         """Fetch the :class:`PriceOverview` for an item.
 
         Parameters
         ----------
         name
             The name of the item.
-        game
-            The game the item is from.
+        app
+            The app the item is from.
         currency
             The currency to fetch the price in.
         """
-        price = await self.http.get_price(game.id, name, currency)
+        price = await self.http.get_price(app.id, name, currency)
         return PriceOverview(price)
 
     # events to be subclassed
 
-    async def on_error(self, event: str, error: Exception, *args, **kwargs):
+    async def on_error(self, event: str, error: Exception, *args: object, **kwargs: object):
         """The default error handler provided by the client.
 
         Usually when an event raises an uncaught exception, a traceback is printed to :attr:`sys.stderr` and the
         exception is ignored. If you want to change this behaviour and handle the exception yourself, this event can
         be overridden. Which, when done, will suppress the default action of printing the traceback.
 
         If you want exception to propagate out of the :class:`Client` class you can define an ``on_error`` handler
@@ -1146,15 +1260,15 @@
                 - :attr:`~steam.User.name`
                 - :attr:`~steam.User.state`
                 - :attr:`~steam.User.flags`
                 - :attr:`~steam.User.avatar_url`
                 - :attr:`~steam.User.last_logon`
                 - :attr:`~steam.User.last_logoff`
                 - :attr:`~steam.User.last_seen_online`
-                - :attr:`~steam.User.game`
+                - :attr:`~steam.User.app`
 
             Parameters
             ----------
             before
                 The user's state before it was updated.
             after
                 The user's state now.
@@ -1285,25 +1399,25 @@
 
             Parameters
             ----------
             announcement
                 The announcement that was created.
             """
 
-        async def on_socket_receive(self, msg: "Msg | MsgProto") -> None:
-            """Called when the connected CM parses a received ``Msg``/``MsgProto``
+        async def on_socket_receive(self, msg: "Message | ProtobufMessage") -> None:
+            """Called when the connected CM parses a received a message.
 
             Parameters
             ----------
             msg
                 The received message.
             """
 
-        async def on_socket_send(self, msg: "Msg | MsgProto") -> None:
-            """Called when the client sends a ``Msg``/``MsgProto`` to the connected CM.
+        async def on_socket_send(self, msg: "Message | ProtobufMessage") -> None:
+            """Called when the client sends a message to the connected CM.
 
             Parameters
             ----------
             msg
                 The sent message.
             """
```

### Comparing `steamio-0.9.9/steam/comment.py` & `steamio-1.0.0a0/steam/comment.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 from dataclasses import dataclass
 from datetime import datetime
-from typing import TYPE_CHECKING, Generic, TypeVar
+from typing import TYPE_CHECKING, ClassVar, Generic
 
-from typing_extensions import Never
+from typing_extensions import Never, TypeVar
 
 from .abc import Awardable
 
 if TYPE_CHECKING:
     from .abc import Commentable
     from .message import Authors
     from .reaction import Award, AwardReaction
     from .state import ConnectionState
 
 
 __all__ = ("Comment",)
 
-OwnerT = TypeVar("OwnerT", bound="Commentable")
+OwnerT = TypeVar("OwnerT", bound="Commentable", default="Commentable", covariant=True)
 
 
-@dataclass(repr=False)
+@dataclass(repr=False, slots=True)
 class Comment(Awardable, Generic[OwnerT]):
     """Represents a comment on a Steam profile.
 
     .. container:: operations
 
         .. describe:: x == y
 
@@ -48,16 +48,15 @@
         The time the comment was posted at.
     owner
         The comment sections owner.
     reactions
         The comment's reactions.
     """
 
-    _AWARDABLE_TYPE = 5
-    __slots__ = ("_state", "content", "id", "created_at", "reactions", "author", "owner")
+    _AWARDABLE_TYPE: ClassVar = 5
 
     _state: ConnectionState
     id: int
     content: str
     created_at: datetime
     reactions: list[AwardReaction]
     author: Authors
```

### Comparing `steamio-0.9.9/steam/enums.py` & `steamio-1.0.0a0/steam/enums.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 from collections.abc import Callable, Generator, Mapping
 from enum import Enum as _Enum, EnumMeta as _EnumMeta, IntEnum as _IntEnum
 from types import MappingProxyType, new_class
-from typing import TYPE_CHECKING, Any, Generic, NoReturn, TypeVar, cast
+from typing import TYPE_CHECKING, Any, Final, Generic, Literal, TypeVar, cast
 
-from typing_extensions import Final, Literal, Self
+from typing_extensions import Never, Self
 
 from ._const import DOCS_BUILDING
 
 __all__ = (
     "Enum",
     "IntEnum",
     "Flags",
@@ -25,19 +25,17 @@
     "PersonaState",
     "PersonaStateFlag",
     "CommunityVisibilityState",
     "TradeOfferState",
     "ChatMemberRank",
     "ChatEntryType",
     "UIMode",
-    "UserBadge",
     "ReviewType",
     "GameServerRegion",
     "EventType",
-    "ClanEvent",
     "ProfileItemType",
     "ProfileCustomisationStyle",
     "ProfileItemClass",
     "DepotFileFlag",
     "AppFlag",
     "LicenseFlag",
     "LicenseType",
@@ -51,16 +49,14 @@
     "PublishedFileQueryFileType",
 )
 
 T = TypeVar("T")
 
 T_co = TypeVar("T_co")
 TT_co = TypeVar("TT_co", bound="type[Any]")
-# if sys.version_info >= (3, 9):
-#     classproperty = lambda func: classmethod(property(func))
 
 
 class classproperty(Generic[TT_co, T_co]):
     def __init__(self, func: Callable[[TT_co], T_co]):
         self.__func__ = func
 
     def __get__(self, instance: Any, type: TT_co) -> T_co:
@@ -68,117 +64,121 @@
 
 
 def _is_descriptor(obj: object) -> bool:
     """Returns True if obj is a descriptor, False otherwise."""
     return hasattr(obj, "__get__") or hasattr(obj, "__set__") or hasattr(obj, "__delete__")
 
 
-class EnumMeta(_EnumMeta if TYPE_CHECKING else type):
+class EnumType(_EnumMeta if TYPE_CHECKING else type):
     _value_map_: Mapping[Any, Enum]
     _member_map_: Mapping[str, Enum]
 
-    def __new__(mcs, name: str, bases: tuple[type, ...], attrs: dict[str, Any]) -> Self:
-        enum_class: type[Enum] = super().__new__(mcs, name, bases, attrs)  # type: ignore
+    def __new__(mcs, name: str, bases: tuple[type, ...], namespace: dict[str, Any]) -> type[Enum]:
+        value_map: dict[Any, Enum] = {}
+        member_map: dict[str, Enum] = {}
+
+        new_mcs: type[Self] = type(
+            f"{name}Type",
+            tuple(
+                dict.fromkeys([base.__class__ for base in bases if base.__class__ is not type] + [EnumType, type])
+            ),  # reorder the bases so EnumType and type are last to avoid conflicts
+            {"_value_map_": value_map, "_member_map_": member_map},
+        )  # type: ignore
+
+        members = {name: value for name, value in namespace.items() if not _is_descriptor(value) and name[0] != "_"}
+
+        cls = cast(
+            "type[Enum]",
+            type.__new__(new_mcs, name, bases, {key: value for key, value in namespace.items() if key not in members}),
+        )  # this allows us to disallow member access from other members as members become proper class variables
+
+        for name, value in members.items():
+            if (member := value_map.get(value)) is None:
+                member = cls.__new__(cls, name=name, value=value)
+                value_map[value] = member
 
-        value_mapping: dict[Any, Enum] = {}
-        member_mapping: dict[str, Enum] = {}
+            member_map[name] = member
+            type.__setattr__(new_mcs, name, member)
 
-        for key, value in attrs.items():
-            if key[0] == "_" or _is_descriptor(value):
-                continue
-
-            member = value_mapping.get(value)
-            if member is None:
-                member = enum_class.__new__(enum_class, name=key, value=value)
-                value_mapping[member.value] = member
-
-            member_mapping[key] = member
-            type.__setattr__(enum_class, key, member)
-
-        type.__setattr__(enum_class, "_value_map_", value_mapping)
-        type.__setattr__(enum_class, "_member_map_", member_mapping)
-        return enum_class
+        return cls
 
     if not TYPE_CHECKING:
 
         def __call__(cls, value: Any) -> Enum:
             try:
                 return cls._value_map_[value]
             except (KeyError, TypeError):
                 raise ValueError(f"{value!r} is not a valid {cls.__name__}")
 
         def __iter__(cls) -> Generator[Enum, None, None]:
             yield from cls._member_map_.values()
 
         def __reversed__(cls) -> Generator[Enum, None, None]:
-            yield from reversed(tuple(cls._member_map_.values()))  # can remove tuple cast after 3.7
+            yield from reversed(cls._member_map_.values())
 
         def __getitem__(cls, key: str) -> Enum:
             return cls._member_map_[key]
 
         @property
         def __members__(cls) -> MappingProxyType[str, Enum]:
             return MappingProxyType(cls._member_map_)
 
     def __repr__(cls) -> str:
         return f"<enum {cls.__name__!r}>"
 
     def __len__(cls) -> int:
         return len(cls._member_map_)
 
-    def __setattr__(cls, name: str, value: Any) -> NoReturn:
+    def __setattr__(cls, name: str, value: Any) -> Never:
         raise AttributeError(f"{cls.__name__}: cannot reassign Enum members.")
 
-    def __delattr__(cls, name: str) -> NoReturn:
+    def __delattr__(cls, name: str) -> Never:
         raise AttributeError(f"{cls.__name__}: cannot delete Enum members.")
 
     def __contains__(cls, member: object) -> bool:
         return (
             isinstance(member, cls) and member.name in cls._member_map_ if isinstance(member, Enum) else NotImplemented
         )
 
 
 # pretending these are enum subclasses makes things much nicer for linters as enums have custom behaviour you can't
 # replicate in the current type system
-class Enum(_Enum if TYPE_CHECKING else object, metaclass=EnumMeta):
+class Enum(_Enum if TYPE_CHECKING else object, metaclass=EnumType):
     """A general enumeration, emulates `enum.Enum`."""
 
-    name: str
-    value: Any
-
     def __new__(cls, *, name: str, value: Any) -> Self:
         # N.B. this method is not ever called after enum creation as it is shadowed by EnumMeta.__call__ and is just
         # for creating Enum members
         super_ = super()
         self = (
             super_.__new__(cls, value)
             if any(not issubclass(base, Enum) for base in cls.__mro__[:-1])  # is it is a mixin enum
             else super_.__new__(cls)  # type: ignore
         )
         super_.__setattr__(self, "name", name)
         super_.__setattr__(self, "value", value)
         return self
 
-    def __setattr__(self, key: str, value: Any) -> NoReturn:
+    def __setattr__(self, key: str, value: Any) -> Never:
         raise AttributeError(f"{self.__class__.__name__} Cannot reassign an Enum members attribute's.")
 
-    def __delattr__(self, item: Any) -> NoReturn:
+    def __delattr__(self, item: Any) -> Never:
         raise AttributeError(f"{self.__class__.__name__} Cannot delete an Enum members attribute's.")
 
     def __bool__(self) -> Literal[True]:
         return True  # an enum member with a zero value would return False otherwise
 
     def __str__(self) -> str:
-        return f"{self.__class__.__name__}.{self.name}"
+        return self.name
 
     def __repr__(self) -> str:
-        return f"<{self.__class__.__name__}.{self.name}: {self.value!r}>"
+        return f"{self.__class__.__name__}.{self.name}"
 
     @classmethod
-    def try_value(cls: type[Self], value: Any) -> Self:
+    def try_value(cls, value: Any) -> Self:
         try:
             return cls._value_map_[value]
         except (KeyError, TypeError):
             return cls.__new__(cls, name=f"{cls.__name__}UnknownValue", value=value)
 
 
 class IntEnum(Enum, int):
@@ -512,40 +512,38 @@
         try:
             return _REVERSE_API_LANGUAGE_MAP[string.lower()]
         except KeyError:
             return cls.__new__(cls, name=string.title(), value=-1)
 
 
 _REVERSE_API_LANGUAGE_MAP: Final = cast(
-    "Mapping[str, Language]", {value: key for key, value in Language.API_LANGUAGE_MAP.items()}
+    Mapping[str, Language], {value: key for key, value in Language.API_LANGUAGE_MAP.items()}
 )
 
 
 class Universe(IntEnum):
     Invalid  = 0  #: Invalid.
     Public   = 1  #: The standard public universe.
     Beta     = 2  #: Beta universe used inside Valve.
     Internal = 3  #: Internal universe used inside Valve.
     Dev      = 4  #: Dev universe used inside Valve.
-    Max      = 6  #: Total number of universes, used for sanity checks.
 
 
 class Type(IntEnum):
     Invalid        = 0   #: Used for invalid Steam IDs.
     Individual     = 1   #: Single user account.
     Multiseat      = 2   #: Multiseat (e.g. cybercafe) account.
     GameServer     = 3   #: Game server account.
     AnonGameServer = 4   #: Anonymous game server account.
     Pending        = 5   #: Pending.
     ContentServer  = 6   #: Valve internal content server account.
     Clan           = 7   #: Steam clan.
     Chat           = 8   #: Steam group chat or lobby.
     ConsoleUser    = 9   #: Fake SteamID for local PSN account on PS3 or Live account on 360, etc.
     AnonUser       = 10  #: Anonymous user account. (Used to create an account or reset a password)
-    Max            = 11  #: Max of 16 items in this field
 
 
 class TypeChar(IntEnum):
     I = Type.Invalid         #: The character used for :class:`~steam.Type.Invalid`.
     U = Type.Individual      #: The character used for :class:`~steam.Type.Individual`.
     M = Type.Multiseat       #: The character used for :class:`~steam.Type.Multiseat`.
     G = Type.GameServer      #: The character used for :class:`~steam.Type.GameServer`.
@@ -592,27 +590,25 @@
     NONE             = 0  #: The user has no relationship to you.
     Blocked          = 1  #: The user has been blocked.
     RequestRecipient = 2  #: The user has requested to be friends with you.
     Friend           = 3  #: The user is friends with you.
     RequestInitiator = 4  #: You have requested to be friends with the user.
     Ignored          = 5  #: You have explicitly blocked this other user from comments/chat/etc.
     IgnoredFriend    = 6  #: The user has ignored the current user.
-    Max              = 8  #: The total number of friend relationships used for looping and verification.
 
 
 class PersonaState(IntEnum):
     Offline        = 0  #: The user is not currently logged on.
     Online         = 1  #: The user is logged on.
     Busy           = 2  #: The user is on, but busy.
     Away           = 3  #: The user has been marked as AFK for a short period of time.
     Snooze         = 4  #: The user has been marked as AFK for a long period of time.
     LookingToTrade = 5  #: The user is online and wanting to trade.
     LookingToPlay  = 6  #: The user is online and wanting to play.
     Invisible      = 7  #: The user is invisible.
-    Max            = 8  #: The total number of states. Only used for looping and validation.
 
 
 class PersonaStateFlag(Flags):
     NONE                 = 0
     HasRichPresence      = 1 << 0
     InJoinableGame       = 1 << 1
     Golden               = 1 << 2
@@ -688,68 +684,14 @@
 class UIMode(IntEnum):
     Desktop    = 0  #: The UI mode for the desktop client.
     BigPicture = 1  #: The UI mode for big picture mode.
     Mobile     = 2  #: The UI mode for mobile.
     Web        = 3  #: The UI mode for the web client.
 
 
-class UserBadge(IntEnum):
-    Invalid                           = 0  #: Invalid Badge.
-    YearsOfService                    = 1  #: The years of service badge.
-    Community                         = 2  #: The pillar of the community badge.
-    Portal2PotatoARG                  = 3  #: The portal to potato badge.
-    TreasureHunt                      = 4  #: The treasure hunter badge.
-    SummerSale2011                    = 5  #: The Summer sale badge for 2011.
-    WinterSale2011                    = 6  #: The Winter sale badge for 2011.
-    SummerSale2012                    = 7  #: The Summer sale badge for 2012.
-    WinterSale2012                    = 8  #: The Winter sale badge for 2012.
-    CommunityTranslator               = 9  #: The community translator badge.
-    CommunityModerator                = 10  #: The community moderator badge.
-    ValveEmployee                     = 11  #: The Valve employee badge.
-    GameDeveloper                     = 12  #: The game developer badge.
-    GameCollector                     = 13  #: The game collector badge.
-    TradingCardBetaParticipant        = 14  #: The trading card beta participant badge.
-    SteamBoxBeta                      = 15  #: The Steam box beta badge.
-    Summer2014RedTeam                 = 16  #: The Summer sale badge for 2014 for the red team.
-    Summer2014BlueTeam                = 17  #: The Summer sale badge for 2014 for the blue team.
-    Summer2014PinkTeam                = 18  #: The Summer sale badge for 2014 for the pink team.
-    Summer2014GreenTeam               = 19  #: The Summer sale badge for 2014 for the green team.
-    Summer2014PurpleTeam              = 20  #: The Summer sale badge for 2014 for the purple team.
-    Auction2014                       = 21  #: The auction badge for 2014.
-    GoldenProfile2014                 = 22  #: The golden profile for 2014.
-    TowerAttackMiniGame               = 23  #: The tower attack mini-game badge.
-    Winter2015ARGRedHerring           = 24  #: The Winter ARG red herring badge for 2015.
-    SteamAwards2016Nominations        = 25  #: The Steam Awards Nominations badge for 2016.
-    StickerCompletionist2017          = 26  #: The sticker completionist badge for 2017.
-    SteamAwards2017Nominations        = 27  #: The Steam Awards Nominations badge for 2017.
-    SpringCleaning2018                = 28  #: The Spring cleaning badge for 2018.
-    Salien                            = 29  #: The Salien badge.
-    RetiredModerator                  = 30  #: The retired moderator badge.
-    SteamAwards2018Nominations        = 31  #: The Steam Awards Nominations badge for 2018.
-    ValveModerator                    = 32  #: The Valve moderator badge.
-    WinterSale2018                    = 33  #: The Winter sale badge for 2018.
-    LunarNewYearSale2019              = 34  #: The lunar new years sale badge for 2019.
-    LunarNewYearSale2019GoldenProfile = 35  #: The lunar new year golden profile sale badge for 2019.
-    SpringCleaning2019                = 36  #: The Spring cleaning badge for 2019.
-    Summer2019                        = 37  #: The Summer sale badge for 2019.
-    Summer2019TeamHare                = 38  #: The Summer sale badge for 2014 for team hare.
-    Summer2019TeamTortoise            = 39  #: The Summer sale badge for 2014 for team tortoise.
-    Summer2019TeamCorgi               = 40  #: The Summer sale badge for 2014 for team corgi.
-    Summer2019TeamCockatiel           = 41  #: The Summer sale badge for 2014 for team cockatiel.
-    Summer2019TeamPig                 = 42  #: The Summer sale badge for 2014 for team pig.
-    SteamAwards2019Nominations        = 43  #: The Steam Awards Nominations badge for 2019.
-    WinterSaleEvent2019               = 44  #: The Winter sale badge for 2019.
-    WinterSale2019Steamville          = 45  #: The Winter sale Steamville badge for 2019.
-    LunarNewYearSale2020              = 46  #: The lunar new years sale badge for 2020.
-    SpringCleaning2020                = 47  #: The Spring cleaning badge for 2020.
-    AwardsCommunityContributor        = 48  #: The Steam Awards Community Contributor badge.
-    AwardsCommunityPatron             = 49  #: The Steam Awards Community Patron badge.
-    SteamAwards2020Nominations        = 50  #: The Steam Awards Nominations badge for 2020.
-
-
 class ReviewType(IntEnum):
     NONE                   = 0  #: No reviews.
     OverwhelminglyNegative = 1  #: 0 - 19% positive reviews and few of them.
     VeryNegative           = 2  #: 0 - 19% positive reviews.
     Negative               = 3  #: 0 - 39% positive reviews.
     MostlyNegative         = 4  #: 20 - 39% positive reviews but few of them.
     Mixed                  = 5  #: 40 - 69% positive reviews.
@@ -806,21 +748,14 @@
     FreeTrial              = 31  #: A free trial event.
     SeasonRelease          = 32  #: A season release event.
     SeasonUpdate           = 33  #: A season update event.
     Crosspost              = 34  #: A cross post event.
     InGameGeneral          = 35  #: An in game general event.
 
 
-if not DOCS_BUILDING:
-    class ClanEvent(IntEnum):
-        for _member in EventType:
-            locals()[_member.name] = _member.value
-        del _member
-
-
 class ProfileItemType(IntEnum):
     Invalid                   = 0   #: An invalid item type.
     RareAchievementShowcase   = 1   #: A rare achievements showcase.
     GameCollector             = 2   #: A game collector section.
     ItemShowcase              = 3   #: An item showcase.
     TradeShowcase             = 4   #: A trade info showcase.
     Badges                    = 5   #: A badges showcase.
@@ -883,15 +818,15 @@
     Executable          = 1 << 5
     Directory           = 1 << 6
     CustomExecutable    = 1 << 7
     InstallScript       = 1 << 8
     Symlink             = 1 << 9
 
 
-TYPE_TRANSFORM_MAP: Final = cast("Mapping[str, str]", {
+TYPE_TRANSFORM_MAP: Final = cast(Mapping[str, str], {
     "Dlc": "DLC",
 })
 
 
 class AppFlag(Flags):
     Game        = 1 << 0
     Application = 1 << 1
@@ -1076,15 +1011,15 @@
     Latest                = 1
     ApprovedSnapshot      = 2
     ApprovedSnapshotChina = 3
     RejectedSnapshot      = 4
     RejectedSnapshotChina = 5
 
 
-class PublishedFileQueryType:
+class PublishedFileQueryType(IntEnum):
     RankedByVote                                  = 0
     RankedByPublicationDate                       = 1
     AcceptedForGameRankedByAcceptanceDate         = 2
     RankedByTrend                                 = 3
     FavouritedByFriendsRankedByPublicationDate    = 4
     CreatedByFriendsRankedByPublicationDate       = 5
     RankedByNumTimesReported                      = 6
@@ -1118,15 +1053,14 @@
     WebGuide               = 9   #: Steam web guide
     IntegratedGuide        = 10  #: Application integrated guide
     Merch                  = 11  #: Workshop merchandise meant to be voted on for the purpose of being sold
     ControllerBinding      = 12  #: Steam Controller bindings
     SteamworksAccessInvite = 13  #: Internal
     SteamVideo             = 14  #: Steam video
     GameManagedItem        = 15  #: Managed completely by the game, not the user, and not shown on the web
-    Max                    = 16
 
 
 class PublishedFileVisibility(IntEnum):
     Public      = 0
     FriendsOnly = 1
     Private     = 2
     Unlisted    = 3
@@ -1156,20 +1090,7 @@
     GameManagedItems        = 20  #: Managed completely by the game, not the user, and not shown on the web.
 # fmt: on
 
 
 if __debug__:
     _ENUM_NAMES = {enum.__name__ for enum in Enum.__subclasses__() + IntEnum.__subclasses__()}
     assert _ENUM_NAMES.issubset(__all__), f"__all__ is not complete, missing {_ENUM_NAMES - set(__all__)}"
-
-
-# shim for old enum names
-def __getattr__(name: str) -> Any:
-    if name == "ClanEvent":
-        return EventType
-    if name[0] == "E" and name[1:] in __all__:
-        import warnings
-
-        warnings.warn('Enums with "E" prefix are depreciated and scheduled for removal in V.1', DeprecationWarning)
-        return globals()[name[1:]]
-
-    raise AttributeError(name)
```

### Comparing `steamio-0.9.9/steam/errors.py` & `steamio-1.0.0a0/steam/errors.py`

 * *Files 3% similar despite different names*

```diff
@@ -26,15 +26,15 @@
     "ClientException",
     "ConfirmationError",
     "AuthenticatorError",
     "InvalidCredentials",
     "WSException",
     "WSForbidden",
     "WSNotFound",
-    "InvalidSteamID",
+    "InvalidID",
 )
 
 CODE_FINDER = re.compile(r"\S(\d+)\S")
 
 
 class SteamException(Exception):
     """Base exception class for steam.py."""
@@ -70,36 +70,37 @@
         self.status = response.status
         self.code = Result.Invalid
 
         if data:
             if isinstance(data, dict):
                 message = data.get("message")
                 if message is None:
-                    truthy_str_values = [  # ignore {'success': False} as the message
+                    if truthy_str_values := [  # ignore {'success': False} as the message
                         value for value in data.values() if value and isinstance(value, str)
-                    ]
-                    if truthy_str_values:
+                    ]:
                         message = str(truthy_str_values[0])
                 self.message = message or ""
-                code = (
+                if code := (
                     data.get("eresult")  # try the data if possible
                     or response.headers.get("X-EResult")  # then the headers
                     or CODE_FINDER.findall(message)  # finally the message
-                )
-                if code:
+                ):
                     if isinstance(code, list):
                         self.message = CODE_FINDER.sub("", message)
                         code = code[0]
                     self.code = Result.try_value(int(code))
             else:
                 text = BeautifulSoup(data, HTML_PARSER).get_text("\n")
                 self.message = text or ""
         else:
             self.message = ""
 
+        if response.headers.get("X-Error_Message"):
+            self.message = response.headers["X-Error_Message"]
+
         self.message = self.message.replace("  ", " ").strip()
         super().__init__(
             f"{response.status} {response.reason} (error code: {self.code})"
             f"{f': {self.message}' if self.message else ''}"
         )
 
 
@@ -131,17 +132,17 @@
     code
         The Steam specific error code for the failure.
     """
 
     def __init__(self, msg: Msgs):
         self.msg = msg
         self.code = msg.result
-        self.message: str | None = getattr(msg.header.body, "error_message", None)
+        self.message: str | None = getattr(msg.header, "error_message", None)
         super().__init__(
-            f"The request {msg.header.body.job_name_target or msg.msg} failed. (error code: {self.code!r})"
+            f"The request {msg.header.job_name_target or msg.MSG} failed. (error code: {self.code!r})"
             f"{f': {self.message}' if self.message else ''}"
         )
 
 
 class WSForbidden(WSException):
     """Exception that's thrown when the websocket returns an :class:`.Result` that means we do not have permission
     to perform an action. Similar to :exc:`Forbidden`.
@@ -189,21 +190,21 @@
 class NoCMsFound(LoginError):
     """Exception that's thrown when no CMs can be found to connect to.
 
     Subclass of :exc:`LoginError`.
     """
 
 
-class InvalidSteamID(SteamException):
-    """Exception that's thrown when a SteamID cannot be valid.
+class InvalidID(SteamException):
+    """Exception that's thrown when a Steam ID cannot be valid.
 
     Subclass of :exc:`SteamException`.
 
     Attributes
     ----------
     id
         The invalid id.
     """
 
     def __init__(self, id: Any, msg: str | None = None):
         self.id = id
-        super().__init__(f"{id!r} cannot be converted to any valid SteamID{f' as {msg}' if msg is not None else ''}")
+        super().__init__(f"{id!r} cannot be converted to any valid Steam ID{f' as {msg}' if msg is not None else ''}")
```

### Comparing `steamio-0.9.9/steam/event.py` & `steamio-1.0.0a0/steam/event.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,78 +1,82 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import abc
 from collections.abc import Sequence
 from datetime import datetime
-from typing import TYPE_CHECKING, Any, Generic, TypeVar, overload
+from ipaddress import IPv4Address
+from typing import TYPE_CHECKING, Any, Generic, Literal, cast, overload
 
-from typing_extensions import Literal
+from typing_extensions import TypeVar
 
 from . import utils
-from .abc import Commentable, SteamID, _CommentableKwargs
+from .abc import Commentable, _CommentableKwargs
+from .app import App, PartialApp
 from .enums import EventType
-from .game import Game, StatefulGame
+from .id import ID
 from .utils import DateTime
 
 if TYPE_CHECKING:
     from .clan import Clan
     from .game_server import GameServer
     from .state import ConnectionState
+    from .types.http import IPAdress
     from .user import User
 
 __all__ = (
     "Event",
     "Announcement",
 )
 
 
-ClanEventT = TypeVar("ClanEventT", bound=EventType, covariant=True)
+EventTypeT = TypeVar("EventTypeT", bound=EventType, default=EventType, covariant=True)
 
 
-class BaseEvent(Commentable, utils.AsyncInit, Generic[ClanEventT], metaclass=abc.ABCMeta):
+class BaseEvent(Commentable, utils.AsyncInit, Generic[EventTypeT], metaclass=abc.ABCMeta):
     __slots__ = (
         "clan",
         "id",
         "author",
         "name",
         "content",
-        "game",
+        "app",
         "starts_at",
         "becomes_visible",
         "stops_being_visible",
         "ends_at",
         "type",
         "last_edited_at",
         "last_edited_by",
         "hidden",
         "published",
         "upvotes",
         "downvotes",
         "comment_count",
         "server_address",
         "server_password",
+        "_feature",
+        "_feature2",
         "_state",
     )
 
     # data here is of type steammessages_base.CClanEventData.to_dict()
     # TODO keep checking if there is a way to get CClanEventData directly from ws
     def __init__(self, state: ConnectionState, clan: Clan, data: dict[str, Any]):
         self._state = state
         self.clan = clan
         self.id: int = int(data["gid"])
-        author = data.get("creator_steamid")
-        self.author: User | SteamID | None = int(author) if author is not None else None  # type: ignore
+        self.author: User | ID = ID(data["creator_steamid"])
         edited_by = data.get("last_update_steamid")
-        self.last_edited_by: User | SteamID | None = int(edited_by) if edited_by is not None else None  # type: ignore
+        self.last_edited_by: User | ID | None = ID(edited_by) if edited_by is not None else None
         self.name: str = data["event_name"]
         self.content: str = data["event_notes"]
-        self.game = StatefulGame(state, id=data["appid"]) if data["appid"] else None
-        self.type: ClanEventT = EventType.try_value(data["event_type"])
+        self.app = PartialApp(state, id=data["appid"]) if data["appid"] else None
+        self.type = cast(EventTypeT, EventType.try_value(data["event_type"]))
 
         self.starts_at = DateTime.from_timestamp(data["rtime32_start_time"])
         becomes_visible = data.get("rtime32_visibility_start")
         self.becomes_visible = DateTime.from_timestamp(becomes_visible) if becomes_visible else None
         stops_being_visible = data.get("rtime32_visibility_end")
         self.stops_being_visible = DateTime.from_timestamp(stops_being_visible) if stops_being_visible else None
         ends_at = data.get("rtime32_end_time")
@@ -89,42 +93,44 @@
         self.server_password: str | None = data.get("server_password")
 
         self._feature = int(data["gidfeature"])
         self._feature2 = int(data.get("gidfeature2", 0) or 0)
 
     async def __ainit__(self) -> None:
         if self.last_edited_by:
-            self.author, self.last_edited_by = await self._state._maybe_users((self.author, self.last_edited_by))  # type: ignore
+            self.author, self.last_edited_by = await self._state._maybe_users(
+                (self.author.id64, self.last_edited_by.id64)
+            )
         else:
-            self.author = await self._state._maybe_user(self.author)  # type: ignore
+            self.author = await self._state._maybe_user(self.author.id64)
 
     def __repr__(self) -> str:
         attrs = ("id", "name", "type", "author", "clan")
         resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
         return f"<{self.__class__.__name__} {' '.join(resolved)}>"
 
     def __eq__(self, other: object) -> bool:
         return self.id == other.id and self.clan == other.clan if isinstance(other, self.__class__) else NotImplemented
 
 
-class Event(BaseEvent[ClanEventT]):
+class Event(BaseEvent[EventTypeT]):
     """Represents an event in a clan.
 
     Attributes
     ----------
     id
         The event's id.
     author
         The event's author.
     name
         The event's name.
     content
         The event's content.
-    game
-        The game that the event is going to play in.
+    app
+        The app that the event is going to play in.
     clan
         The event's clan.
     starts_at
         The event's start time.
     becomes_visible
         The time at which the event becomes visible.
     stops_being_visible
@@ -149,48 +155,51 @@
         The number of comments on the event.
     server_address
         The event's server address.
     server_password
         The event's server password.
     """
 
-    server_address: str
+    __slots__ = ()
+
+    server_address: IPAdress | None
     server_password: str
 
     @property
     def _commentable_kwargs(self) -> _CommentableKwargs:
         return {
-            "thread_type": 14,
             "id64": self.clan.id64,
-            "gidfeature": self._feature,
+            "forum_id": self._feature,
         }
 
-    async def server(self) -> GameServer | None:
-        """The server that the game will be run on, ``None`` if not found.
+    async def server(self) -> GameServer:
+        """The server that the app will be run on.
 
         Note
         ----
         This is shorthand for
 
         .. code-block:: python3
 
             await client.fetch_server(ip=event.server_address)
         """
 
-        if self.server_address == "0":
-            return
-        return await self._state.client.fetch_server(ip=self.server_address)
+        if self.server_address is None:
+            raise ValueError("Event has no server address")
+        server = await self._state.client.fetch_server(ip=self.server_address)
+        assert server is not None
+        return server
 
     @overload
     async def edit(
         self: Event[Literal[EventType.Game]],
         name: str,
         content: str,
         *,
-        game: Game | None = None,
+        app: App | None = None,
         starts_at: datetime | None = ...,
         server_address: str | None = ...,
         server_password: str | None = ...,
     ) -> None:
         ...
 
     @overload
@@ -218,41 +227,41 @@
     async def edit(
         self,
         name: str,
         content: str,
         *,
         type: Literal[EventType.Game] = ...,
         starts_at: datetime | None = ...,
-        game: Game,
-        server_address: str | None = ...,
+        app: App,
+        server_address: IPAdress | str | None = ...,
         server_password: str | None = ...,
     ) -> None:
         ...
 
     async def edit(
         self,
         name: str,
         content: str,
         *,
         type: Literal[
             EventType.Other,
             EventType.Chat,
             EventType.Game,
-            # ClanEvent.Broadcast,  # TODO need to wait until implementing stream support for this
+            # EventType.Broadcast,  # TODO need to wait until implementing stream support for this
             EventType.Party,
             EventType.Meeting,
             EventType.SpecialCause,
             EventType.MusicAndArts,
             EventType.Sports,
             EventType.Trip,
         ]
         | None = None,
-        game: Game | None = None,
+        app: App | None = None,
         starts_at: datetime | None = None,
-        server_address: str | None = None,
+        server_address: IPAdress | str | None = None,
         server_password: str | None = None,
     ) -> None:
         """Edit the event's details.
 
         Note
         ----
         If parameters are omitted they use what they are currently set to.
@@ -261,43 +270,49 @@
         ----------
         name
             The event's name.
         content
             The event's content.
         type
             The event's type.
-        game
-            The event's game.
+        app
+            The event's app.
         starts_at
             The event's start time.
         server_address
             The event's server's address.
         server_password
             The event's server's password.
         """
         type_ = type or self.type
-        new_game = game or self.game
-        game_id = str(new_game) if new_game is not None else None
+        new_app = app or self.app
+        app_id = str(new_app) if new_app is not None else None
+        try:
+            ip_address_ = IPv4Address(server_address)
+        except ValueError:
+            ip_address_ = None
+        server_address = ip_address_ if server_address is not None else self.server_address or ""
+
         await self._state.http.edit_clan_event(
             self.clan.id64,
             name or self.name,
             content or self.content,
             f"{type_.name}Event",
-            game_id or "",
-            server_address or self.server_address if self.server_address else "",
+            app_id or "",
+            str(server_address),
             server_password or self.server_password if self.server_password else "",
             starts_at or self.starts_at,
             event_id=self.id,
         )
         self.name = name or self.name
         self.content = content or self.content
         self.type = type_
-        self.server_address = server_address or self.server_address
+        self.server_address = server_address or None
         self.server_password = server_password or self.server_password
-        self.game = StatefulGame(self._state, id=game_id) if game_id is not None else None
+        self.app = PartialApp(self._state, id=app_id) if app_id is not None else None
         self.last_edited_at = DateTime.now()
         self.last_edited_by = self._state.user
 
     async def delete(self) -> None:
         """Delete this event."""
         await self._state.http.delete_clan_event(self.clan.id64, self.id)
 
@@ -311,16 +326,16 @@
         The announcement's ID.
     author
         The announcement's author.
     name
         The announcement's name.
     content
         The announcement's content.
-    game
-        The game that the announcement is for.
+    app
+        The app that the announcement is for.
     clan
         The announcement's clan.
     starts_at
         The announcement's start time.
     becomes_visible
         The time at which the announcement becomes visible.
     stops_being_visible
@@ -358,15 +373,15 @@
     __slots__ = (
         "topic_id",
         "created_at",
         "updated_at",
         "approved_at",
         "tags",
     )
-    approved_by: User
+    # approved_by: User
     server_ip: None
     server_password: None
 
     def __init__(self, state: ConnectionState, clan: Clan, data: dict[str, Any]):
         super().__init__(state, clan, data)
         body: dict[str, Any] = data["announcement_body"]
         self.id: int = int(body["gid"])
@@ -375,20 +390,19 @@
         self.updated_at = DateTime.from_timestamp(body["updatetime"])  # this is different to self.edited_at?
         self.approved_at = DateTime.from_timestamp(data["rtime_mod_reviewed"]) if data["rtime_mod_reviewed"] else None
         self.content: str = body["body"]
         self.tags: Sequence[str] = body["tags"]
 
     @property
     def _commentable_kwargs(self) -> _CommentableKwargs:
-        if self.clan.is_game_clan:
-            raise NotImplementedError("Fetching a game announcement's comments is not currently supported")
+        if self.clan.is_app_clan:
+            raise NotImplementedError("Fetching an app announcement's comments is not currently supported")
         return {
-            "thread_type": 13,
             "id64": self.clan.id64,
-            "gidfeature": self._feature,
+            "forum_id": self._feature,
         }
 
     async def edit(self, name: str | None = None, content: str | None = None) -> None:
         """Edit the announcement's details.
 
         Note
         ----
@@ -424,7 +438,13 @@
     async def upvote(self) -> None:
         """Upvote this announcement."""
         return await self._state.rate_clan_announcement(self.clan.id, self.id, True)
 
     async def downvote(self) -> None:
         """Downvote this announcement."""
         return await self._state.rate_clan_announcement(self.clan.id, self.id, False)
+
+    # async def topic(self) -> Topic:
+    #     """Fetch the forum topic for this announcement."""
+    #     topic = await self.clan.fetch_topic(self.topic_id)
+    #     assert topic
+    #     return topic
```

### Comparing `steamio-0.9.9/steam/ext/_gc/client.py` & `steamio-1.0.0a0/steam/ext/_gc/client.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,84 +1,83 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import asyncio
 from typing import Any
 
-from typing_extensions import ClassVar
+from typing_extensions import ClassVar, Never
 
+from ...app import App
 from ...client import Client as Client_
-from ...game import Game
-from ...protobufs import GCMsg, GCMsgProto
+from ...enums import Language
+from ...protobufs import GCMessage, GCProtobufMessage
 from ...trade import Inventory
 from ...user import ClientUser as ClientUser_
-from .enums import Language
 from .state import GCState
 
 __all__ = ("Client",)
 
 
 class ClientUser(ClientUser_):
     _state: GCState
 
-    async def inventory(self, game: Game, *, language: Language | None = None) -> Inventory:
+    async def inventory(self, app: App, *, language: Language | None = None) -> Inventory:
         return (
             self._state.backpack
-            if game == self._state.client.__class__._GAME and self._state._gc_ready.is_set()
-            else await super().inventory(game, language=language)
+            if app == self._state.client.__class__._APP and self._state._gc_ready.is_set()
+            else await super().inventory(app, language=language)
         )
 
 
 class Client(Client_):
-    _connection: GCState
-    _GAME: ClassVar[Game]
+    _state: GCState
+    _APP: ClassVar[App]
     _GC_HEART_BEAT: ClassVar = 30.0
 
     _ClientUserCls: ClassVar[type[ClientUser]] = ClientUser
     user: ClientUser
 
     def __init__(self, **options: Any):
-        game = options.pop("game", None)
-        if game is not None:  # don't let them overwrite the main game
+        app = options.pop("app", None)
+        if app is not None:  # don't let them overwrite the main app
             try:
-                options["games"].append(game)
+                options["apps"].append(app)
             except (TypeError, KeyError):
-                options["games"] = [game]
-        options["game"] = self._GAME
-        self._original_games: list[Game] | None = options.get("games")
+                options["apps"] = [app]
+        options["app"] = self._APP
+        self._original_apps: list[App] | None = options.get("apps")
         super().__init__(**options)
 
     # things to override
-    def _get_gc_message(self) -> GCMsgProto[Any] | GCMsg[Any]:
+    def _get_gc_message(self) -> GCProtobufMessage | GCMessage:
         raise NotImplementedError()
 
-    def _get_state(self, **options: Any) -> None:
+    def _get_state(self, **options: Any) -> Never:
         raise NotImplementedError("cannot instantiate Client without a state")
 
-    async def connect(self) -> None:
+    async def login(self) -> None:
         if self._get_gc_message():
 
             async def ping_gc() -> None:
-                await self.wait_until_ready()
+                await self._state.login_complete.wait()
                 while not self.is_closed():
-                    await self.ws.send_gc_message(self._get_gc_message())
+                    await self._state.ws.send_gc_message(self._get_gc_message())
                     await asyncio.sleep(self._GC_HEART_BEAT)
 
             await asyncio.gather(
-                super().connect(),
+                super().login(),
                 ping_gc(),
             )
         else:
-            await super().connect()
+            await super().login()
 
     async def _handle_ready(self) -> None:
-        data = await self.http.get_user(self.user.id64)
-        assert data is not None
-        self.http.user = self.__class__._ClientUserCls(self._connection, data)
+        (us,) = await self._state.ws.fetch_users((self.user.id64,))
+        self.http.user = self.__class__._ClientUserCls(self._state, us)
         await super()._handle_ready()
 
     async def wait_for_gc_ready(self) -> None:
-        await self._connection._gc_ready.wait()
+        await self._state._gc_ready.wait()
 
     # async def buy_item(self, def_id: int, price: int, def_ids: list[int], prices: int) -> None:
     #     ...
```

### Comparing `steamio-0.9.9/steam/ext/_gc/state.py` & `steamio-1.0.0a0/steam/ext/_gc/state.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,78 +3,74 @@
 from __future__ import annotations
 
 import asyncio
 import logging
 from collections.abc import Callable, Coroutine
 from typing import TYPE_CHECKING, Any, ClassVar, TypeVar, overload
 
-from ... import utils
+from ..._const import CLEAR_PROTO_BIT, IS_PROTO
 from ...abc import BaseUser
 from ...enums import IntEnum
-from ...gateway import EventListener, GCMsgsT
+from ...gateway import EventListener, GCMsgProtoT, GCMsgsT, GCMsgT
 from ...models import register, return_true
-from ...protobufs import EMsg, GCMsg, GCMsgProto, MsgProto
+from ...protobufs import EMsg, GCMessage, GCProtobufMessage
 from ...state import ConnectionState
 from ...trade import BaseInventory, Inventory
 
 if TYPE_CHECKING:
-    from ...game import Game
+    from ...app import App
     from ...gateway import GCMsgsT
-    from ...protobufs.client_server_2 import CMsgGcClient
+    from ...protobufs.client_server_2 import CMsgGcClientFromGC
     from .client import Client
 
 log = logging.getLogger(__name__)
 Inv = TypeVar("Inv", bound=BaseInventory[Any])
-GCMsgProtoT = TypeVar("GCMsgProtoT", bound=GCMsgProto)
-GCMsgT = TypeVar("GCMsgT", bound=GCMsg)
 
 
 class GCState(ConnectionState):
     Language: ClassVar[type[IntEnum]]
     gc_parsers: dict[IntEnum, Callable[..., Any]]
     client: Client
 
     def __init__(self, client: Client, **kwargs: Any):
         super().__init__(client, **kwargs)
         self._gc_connected = asyncio.Event()
         self._gc_ready = asyncio.Event()
         self.backpack: Inventory = None  # type: ignore
-        self._unpatched_inventory: Callable[[BaseUser, Game], Coroutine[Any, Any, Inventory]]
+        self._unpatched_inventory: Callable[[BaseUser, App], Coroutine[Any, Any, Inventory]]
         self.gc_listeners: list[EventListener[Any]] = []
 
     @register(EMsg.ClientFromGC)
-    async def parse_gc_message(self, msg: MsgProto[CMsgGcClient]) -> None:
-        if msg.body.appid != self.client._GAME.id:
+    async def parse_gc_message(self, msg: CMsgGcClientFromGC) -> None:
+        if msg.appid != self.client._APP.id:
             return
 
         try:
-            language = self.__class__.Language(utils.clear_proto_bit(msg.body.msgtype))
+            language = self.__class__.Language(CLEAR_PROTO_BIT(msg.msgtype))
         except ValueError:
-            return log.info(
-                f"Ignoring unknown msg type: {msg.body.msgtype} ({utils.clear_proto_bit(msg.body.msgtype)})"
-            )
+            return log.info(f"Ignoring unknown msg type: {msg.msgtype} ({CLEAR_PROTO_BIT(msg.msgtype)})")
 
         try:
             gc_msg = (
-                GCMsgProto(language, msg.body.payload)
-                if utils.is_proto(msg.body.msgtype)
-                else GCMsg(language, msg.body.payload)
+                GCProtobufMessage().parse(msg.payload, language)
+                if IS_PROTO(msg.msgtype)
+                else GCMessage().parse(msg.payload, language)
             )
         except Exception as exc:
-            return log.error("Failed to deserialize message: %r, %r", language, msg.body.payload, exc_info=exc)
+            return log.error("Failed to deserialize message: %r, %r", language, msg.payload, exc_info=exc)
         else:
             log.debug("Socket has received GC message %r from the websocket.", gc_msg)
 
         self.dispatch("gc_message_receive", gc_msg)
-        self.run_parser(language, gc_msg)
+        self.run_parser(gc_msg)
 
         # remove the dispatched listener
-        removed = []
+        removed: list[int] = []
         for idx, entry in enumerate(self.gc_listeners):
-            if entry.emsg != language:
+            if entry.msg != language:
                 continue
 
             future = entry.future
             if future.cancelled():
                 removed.append(idx)
                 continue
 
@@ -88,29 +84,47 @@
                     future.set_result(gc_msg)
                     removed.append(idx)
 
         for idx in reversed(removed):
             del self.gc_listeners[idx]
 
     @overload
-    def gc_wait_for(self, emsg: IntEnum | None, check: Callable[[GCMsgT], bool]) -> asyncio.Future[GCMsgT]:
+    def gc_wait_for(
+        self, *, emsg: IntEnum | None, check: Callable[[GCMsgsT], bool] = return_true
+    ) -> asyncio.Future[GCMsgsT]:
+        ...
+
+    @overload
+    def gc_wait_for(
+        self, msg: type[GCMsgT], *, check: Callable[[GCMsgT], bool] = return_true
+    ) -> asyncio.Future[GCMsgT]:
         ...
 
     @overload
-    def gc_wait_for(self, emsg: IntEnum | None, check: Callable[[GCMsgProtoT], bool]) -> asyncio.Future[GCMsgProtoT]:
+    def gc_wait_for(
+        self, msg: type[GCMsgProtoT], *, check: Callable[[GCMsgProtoT], bool] = return_true
+    ) -> asyncio.Future[GCMsgProtoT]:
         ...
 
     def gc_wait_for(
-        self, emsg: IntEnum | None, check: Callable[[GCMsgsT], bool] = return_true
+        self,
+        msg: type[GCMsgsT] | None = None,
+        *,
+        emsg: IntEnum | None = None,
+        check: Callable[[GCMsgsT], bool] = return_true,
     ) -> asyncio.Future[GCMsgsT]:
         future: asyncio.Future[GCMsgsT] = self.loop.create_future()
-        entry = EventListener(emsg=emsg, check=check, future=future)
+        entry = EventListener(msg=msg.MSG if msg else emsg, check=check, future=future)
         self.gc_listeners.append(entry)
         return future
 
     async def fetch_backpack(self, backpack_cls: type[Inv]) -> Inv:
-        resp = await self.http.get_client_user_inventory(
-            self.client._GAME.id, self.client._GAME.context_id, self.http.language
-        )
-        return backpack_cls(
-            state=self, data=resp, owner=self.client.user, game=self.client._GAME, language=self.http.language
-        )
+        try:
+            lock = self.user._inventory_locks[self.client._APP.id]
+        except KeyError:
+            lock = self.user._inventory_locks[self.client._APP.id] = asyncio.Lock()
+
+        async with lock:  # requires a per-app lock to avoid Result.DuplicateRequest
+            resp = await self.fetch_user_inventory(
+                self.user.id64, self.client._APP.id, self.client._APP.context_id, self.language
+            )
+        return backpack_cls(state=self, data=resp, owner=self.user, app=self.client._APP, language=self.language)
```

### Comparing `steamio-0.9.9/steam/ext/commands/bot.py` & `steamio-1.0.0a0/steam/ext/commands/bot.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,17 +13,15 @@
 import os
 import sys
 import traceback
 import warnings
 from collections.abc import Callable, Coroutine, Iterable
 from pathlib import Path
 from types import MappingProxyType, ModuleType
-from typing import TYPE_CHECKING, Any, TypeVar
-
-from typing_extensions import Literal, TypeAlias, overload
+from typing import TYPE_CHECKING, Any, Literal, TypeAlias, TypeVar, overload
 
 from ... import _const, utils
 from ...client import Client, E, EventType, log
 from .cog import Cog
 from .commands import CHR, CheckReturnType, CheckType, Command, GroupMixin, InvokeT, check
 from .context import Context
 from .converters import CONVERTERS, Converters
@@ -146,16 +144,16 @@
     ):
         super().__init__(**options)
         self.__cogs__: dict[str, Cog] = {}
         self.__listeners__: dict[str, list[EventType]] = {}
         self.__extensions__: dict[str, ModuleType] = {}
 
         self.command_prefix = command_prefix
-        self.owner_id = utils.make_id64(options.get("owner_id", 0))
-        self.owner_ids = {utils.make_id64(owner_id) for owner_id in options.get("owner_ids", ())}
+        self.owner_id = utils.parse_id64(options.get("owner_id", 0))
+        self.owner_ids = {utils.parse_id64(owner_id) for owner_id in options.get("owner_ids", ())}
         if self.owner_id and self.owner_ids:
             raise ValueError("You cannot have both owner_id and owner_ids")
 
         for member in dir(self):
             try:
                 command = getattr(self, member)
             except AttributeError:
@@ -399,15 +397,15 @@
         Parameters
         ----------
         name: :class:`str`
             The name of the event to listen for. Will default to ``func.__name__``.
         """
 
         def decorator(coro: E) -> E:
-            self.add_listener(coro, name if not callable(name) else coro.__name__)
+            self.add_listener(coro, coro.__name__ if callable(name) else name)
             return coro
 
         return decorator(name) if callable(name) else decorator
 
     def check(self, predicate: Check | CHR | None = None) -> Check | CHR:
         """|maybecallabledeco|
         Register a global check for all commands. This is similar to :func:`commands.check`.
```

### Comparing `steamio-0.9.9/steam/ext/commands/cog.py` & `steamio-1.0.0a0/steam/ext/commands/cog.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,17 +2,15 @@
 
 from __future__ import annotations
 
 import inspect
 import sys
 import traceback
 from collections.abc import Callable
-from typing import TYPE_CHECKING, Any, overload
-
-from typing_extensions import Final
+from typing import TYPE_CHECKING, Any, Final, overload
 
 from ... import ClientException
 from .commands import Command, Group
 
 if TYPE_CHECKING:
     from steam.ext import commands
 
@@ -134,15 +132,15 @@
         name: :class:`str`
             The name of the event to listen for. Defaults to ``func.__name__``.
         """
 
         def decorator(coro: E) -> E:
             if not inspect.iscoroutinefunction(coro):
                 raise TypeError(f"Listeners must be coroutine functions, {coro.__name__} is {type(coro).__name__}")
-            coro.__event_name__ = name if not callable(name) else coro.__name__
+            coro.__event_name__ = coro.__name__ if callable(name) else name
             return coro
 
         return decorator(name) if callable(name) else decorator
 
     async def cog_command_error(self, ctx: "commands.Context", error: Exception) -> None:
         """A special method that is called when an error is dispatched inside this cog. This is similar to
         :func:`~commands.Bot.on_command_error` except it only applies to the commands inside this cog.
```

### Comparing `steamio-0.9.9/steam/ext/commands/commands.py` & `steamio-1.0.0a0/steam/ext/commands/commands.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,19 +7,34 @@
 """
 
 from __future__ import annotations
 
 import asyncio
 import functools
 import inspect
-from collections.abc import Coroutine, Iterable
+from collections.abc import Callable, Coroutine, Iterable
 from time import time
-from typing import TYPE_CHECKING, Any, Callable, ForwardRef, Generic, TypeVar, Union, get_type_hints, overload
+from typing import (
+    TYPE_CHECKING,
+    Any,
+    ForwardRef,
+    Generic,
+    Literal,
+    ParamSpec,
+    Protocol,
+    TypeAlias,
+    TypeVar,
+    Union,
+    get_args,
+    get_origin,
+    get_type_hints,
+    overload,
+)
 
-from typing_extensions import Literal, ParamSpec, Protocol, Self, TypeAlias, get_args, get_origin
+from typing_extensions import Self
 
 from ...channel import DMChannel
 from ...errors import ClientException
 from ...utils import cached_property, maybe_coroutine
 from . import converters
 from .cooldown import BucketType, Cooldown
 from .errors import (
@@ -81,17 +96,17 @@
     async def __call__(self, *args: P.args, **kwargs: P.kwargs) -> Any:
         ...
 
 
 @converters.converter_for(bool)
 def to_bool(argument: str) -> bool:
     lowered = argument.lower()
-    if lowered in ("yes", "y", "true", "t", "1", "enable", "on"):
+    if lowered in {"yes", "y", "true", "t", "1", "enable", "on"}:
         return True
-    elif lowered in ("no", "n", "false", "f", "0", "disable", "off"):
+    elif lowered in {"no", "n", "false", "f", "0", "disable", "off"}:
         return False
     raise BadArgument(f"{argument!r} is not a recognised boolean option")
 
 
 class Command(Generic[P]):
     """A class to represent a command.
 
@@ -239,17 +254,15 @@
 
         Returns
         -------
         :class:`list`\\[:class:`Command`]
         """
         commands = []
         command = self
-        while command is not None:
-            if not isinstance(command, Command):
-                break
+        while command is not None and isinstance(command, Command):
             commands.append(command)
             command = command.parent
 
         return commands
 
     async def __call__(self, ctx: Context, *args: P.args, **kwargs: P.kwargs) -> object:
         """Calls the internal callback that the command holds.
@@ -391,16 +404,15 @@
         if not self.enabled:
             return False
         for check in self.checks:
             if not await maybe_coroutine(check, ctx):
                 return False
         for cooldown in self.cooldown:
             bucket = cooldown.bucket.get_bucket(ctx)
-            retry_after = cooldown.get_retry_after(bucket, time())
-            if retry_after:
+            if retry_after := cooldown.get_retry_after(bucket, time()):
                 return False
 
         return True
 
     async def _call_before_invoke(self, ctx: Context) -> None:
         if self._before_hook is not None:
             await self._before_hook(ctx)
@@ -448,21 +460,18 @@
 
         key_converter = self._get_converter(key_type)
         value_converter = self._get_converter(value_type)
         try:
             for key_arg, value_arg in kv_pairs:
                 if key_arg in kwargs:
                     raise DuplicateKeywordArgument(key_arg)
-                kwargs.update(
-                    {
-                        await self._convert(ctx, key_converter, param, key_arg.strip()): await self._convert(
-                            ctx, value_converter, param, value_arg.strip()
-                        )
-                    }
+                kwargs[await self._convert(ctx, key_converter, param, key_arg.strip())] = await self._convert(
+                    ctx, value_converter, param, value_arg.strip()
                 )
+
         except ValueError:
             raise UnmatchedKeyValuePair("Unmatched key-value pair passed") from None
 
     async def _parse_var_position_argument(self, ctx: Context, param: inspect.Parameter, args: list) -> None:
         for arg in ctx.lex:
             transformed = await self._transform(ctx, param, arg)
             args.append(transformed)
```

### Comparing `steamio-0.9.9/steam/ext/commands/context.py` & `steamio-1.0.0a0/steam/ext/commands/context.py`

 * *Files identical despite different names*

### Comparing `steamio-0.9.9/steam/ext/commands/converters.py` & `steamio-1.0.0a0/steam/ext/commands/converters.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,37 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import types
 import warnings
 from abc import ABC, abstractmethod
-from collections.abc import Callable, Generator
-from typing import TYPE_CHECKING, Any, Dict, ForwardRef, Generic, NoReturn, Sequence, TypeVar, Union, overload
+from collections.abc import Callable, Generator, Sequence
+from typing import (
+    TYPE_CHECKING,
+    Any,
+    ForwardRef,
+    Generic,
+    Protocol,
+    TypeAlias,
+    TypeVar,
+    Union,
+    get_args,
+    get_origin,
+    overload,
+    runtime_checkable,
+)
 
-from typing_extensions import Literal, Protocol, TypeAlias, get_args, get_origin, runtime_checkable
+from typing_extensions import Never
 
 from ... import _const, utils
+from ...app import App, PartialApp
 from ...channel import Channel
 from ...clan import Clan
-from ...errors import HTTPException, InvalidSteamID
-from ...game import Game, StatefulGame
+from ...errors import HTTPException, InvalidID
 from ...group import Group
 from ...user import User
 from .errors import BadArgument
 
 if TYPE_CHECKING:
     from steam.ext import commands
 
@@ -28,30 +41,30 @@
 __all__ = (
     "converter_for",
     "Converter",
     "UserConverter",
     "ChannelConverter",
     "ClanConverter",
     "GroupConverter",
-    "GameConverter",
+    "AppConverter",
     "Default",
     "DefaultAuthor",
     "DefaultChannel",
     "DefaultClan",
     "DefaultGroup",
-    "DefaultGame",
+    "DefaultApp",
     "Greedy",
 )
 
 T = TypeVar("T")
 T_co = TypeVar("T_co", covariant=True)
 Converters: TypeAlias = "ConverterBase | BasicConverter[Any]"
 
 
-class ConverterDict(Dict[type, "tuple[Converters, ...]"]):
+class ConverterDict(dict[type, "tuple[Converters, ...]"]):
     def __setitem__(self, key: Any, value: Converters) -> None:
         old_value = super().get(key, ())
         super().__setitem__(key, old_value + (value,))
 
 
 class BasicConverter(Protocol[T]):
     converter_for: type[T]
@@ -138,15 +151,15 @@
 
     Some custom dataclasses from this library can be type-hinted without the need for a custom converter:
 
         - :class:`~steam.User`.
         - :class:`~steam.abc.Channel`
         - :class:`~steam.Clan`
         - :class:`~steam.Group`
-        - :class:`~steam.Game`
+        - :class:`~steam.App`
 
     Examples
     --------
 
     Builtin:
 
     .. code-block:: python3
@@ -267,15 +280,15 @@
         - Name
         - URLs
     """
 
     async def convert(self, ctx: Context, argument: str) -> User:
         try:
             user = await ctx.bot.fetch_user(argument)
-        except (InvalidSteamID, HTTPException):
+        except (InvalidID, HTTPException):
             if argument.startswith("@"):  # probably a mention
                 try:
                     account_id = ctx.message.mentions.ids[0]
                 except (IndexError, AttributeError):
                     pass
                 else:
                     user = await ctx.bot.fetch_user(account_id)
@@ -319,15 +332,15 @@
         - Name
         - URLs
     """
 
     async def convert(self, ctx: Context, argument: str) -> Clan:
         try:
             clan = await ctx.bot.fetch_clan(argument)
-        except (InvalidSteamID, HTTPException):
+        except (InvalidID, HTTPException):
             clan = utils.find(lambda c: c.name == argument, ctx.bot.clans)
             if clan is None:
                 id64 = await utils.id64_from_url(argument, session=ctx._state.http._session)
                 return await self.convert(ctx, id64)
         if clan is None:
             raise BadArgument(f'Failed to convert "{argument}" to a Steam clan')
         return clan
@@ -340,30 +353,30 @@
         - ID
         - Name
     """
 
     async def convert(self, ctx: Context, argument: str) -> Group:
         try:
             group = ctx.bot.get_group(argument)
-        except InvalidSteamID:
+        except InvalidID:
             group = utils.find(lambda c: c.name == argument, ctx.bot.groups)
         if group is None:
             raise BadArgument(f'Failed to convert "{argument}" to a Steam group')
         return group
 
 
-class GameConverter(Converter[Game]):
-    """The converter that is used when the type-hint passed is :class:`~steam.Game`.
+class AppConverter(Converter[App]):
+    """The converter that is used when the type-hint passed is :class:`~steam.App`.
 
-    If the param is a digit it is assumed that the argument is the :attr:`Game.id` else it is assumed it is the
-    :attr:`Game.title`.
+    If the param is a digit it is assumed that the argument is the :attr:`App.id` else it is assumed it is the
+    :attr:`App.name`.
     """
 
-    async def convert(self, ctx: Context, argument: str) -> Game:
-        return Game(id=int(argument)) if argument.isdigit() else Game(name=argument)
+    async def convert(self, ctx: Context, argument: str) -> App:
+        return App(id=int(argument)) if argument.isdigit() else App(name=argument)
 
 
 @runtime_checkable
 class Default(Protocol):
     """A custom way to specify a default values for commands.
 
     Examples
@@ -423,19 +436,19 @@
 class DefaultClan(Default):
     """Returns the :attr:`.Context.clan`"""
 
     async def default(self, ctx: Context) -> Clan:
         return ctx.clan
 
 
-class DefaultGame(Default):
-    """Returns the :attr:`.Context.author`'s :attr:`~steam.User.game`"""
+class DefaultApp(Default):
+    """Returns the :attr:`.Context.author`'s :attr:`~steam.User.app`"""
 
-    async def default(self, ctx: Context) -> StatefulGame:
-        return ctx.author.game
+    async def default(self, ctx: Context) -> PartialApp:
+        return ctx.author.app
 
 
 def flatten_greedy(item: T | Greedy[Any]) -> Generator[T, None, None]:
     if get_origin(item) in (Greedy, Union):
         for arg in get_args(item):
             if arg in INVALID_GREEDY_TYPES:
                 raise TypeError(f"Greedy[{arg.__name__}] is invalid")
@@ -467,15 +480,15 @@
     ``reason``.
     """
 
     converter: T  #: The converter the Greedy type holds.
 
     def __new__(
         cls, *args: Any, **kwargs: Any
-    ) -> NoReturn:  # give a more helpful message than typing._BaseGenericAlias.__call__
+    ) -> Never:  # give a more helpful message than typing._BaseGenericAlias.__call__
         raise TypeError("Greedy cannot be instantiated directly, instead use Greedy[...]")
 
     def __class_getitem__(cls, converter: GreedyTypes[T]) -> Greedy[T]:
         """The entry point for creating a Greedy type.
 
         Note
         ----
```

### Comparing `steamio-0.9.9/steam/ext/commands/cooldown.py` & `steamio-1.0.0a0/steam/ext/commands/cooldown.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import asyncio
 import time
-from typing import TYPE_CHECKING, Generic, TypeVar, Union
+from typing import TYPE_CHECKING, Generic, TypeVar
 
 from ...enums import IntEnum
 from .errors import CommandOnCooldown
 
 if TYPE_CHECKING:
     from ...abc import Message, Messageable
 
@@ -110,10 +110,9 @@
         ----------
         ctx
             The context for invocation to check for a cooldown on.
         """
         bucket = self.bucket.get_bucket(ctx)
         now = time.time()
         asyncio.create_task(self.expire_cache(bucket, now))
-        retry_after = self.get_retry_after(bucket, now)
-        if retry_after:
+        if retry_after := self.get_retry_after(bucket, now):
             raise CommandOnCooldown(retry_after)
```

### Comparing `steamio-0.9.9/steam/ext/commands/errors.py` & `steamio-1.0.0a0/steam/ext/commands/errors.py`

 * *Files identical despite different names*

### Comparing `steamio-0.9.9/steam/ext/commands/help.py` & `steamio-1.0.0a0/steam/ext/commands/help.py`

 * *Files 1% similar despite different names*

```diff
@@ -24,16 +24,15 @@
 
 class HelpCommand(Command):
     """The base implementation of the help command."""
 
     context: Context  #: The context for the command's invocation.
 
     def __init__(self, **kwargs: Any):
-        default = dict(name="help", help="Shows this message.", cog=self)
-        default.update(kwargs)
+        default = dict(name="help", help="Shows this message.", cog=self) | kwargs
         super().__init__(self.command_callback, **default)
 
     @final
     async def command_callback(self, ctx: Context, *, content: str = None) -> None:
         """The actual implementation of the help command.
 
         This method should not directly subclassed instead you should change the behaviour through the methods that
@@ -57,15 +56,15 @@
         if command is not None:
             return await (
                 self.send_group_help(command) if isinstance(command, Group) else self.send_command_help(command)
             )
 
         await self.command_not_found(content)
 
-    def get_bot_mapping(self) -> "Mapping[str | None, list[commands.Command]]":
+    def get_bot_mapping(self) -> Mapping[str | None, list[commands.Command]]:
         """
         Generate a mapping of the bot's commands. It's not normally necessary to subclass this. This is passed to
         :meth:`send_help`.
         """
         bot = self.context.bot
         mapping = {cog.qualified_name: list(cog.commands) for name, cog in bot.cogs.items() if cog.commands}
         categorized_commands = [command for c in mapping.values() for command in c]
@@ -161,32 +160,33 @@
         message = ["/pre"]
         for cog_name, commands in mapping.items():
             (
                 message.append(f"\n{cog_name}'s commands")
                 if cog_name is not None
                 else message.append("\nUn-categorized commands")
             )
-            for command in commands:
-                message.append(f'{command.name}{f": {self._get_doc(command)}" if command.help else ""}')
+            message.extend(
+                f'{command.name}{f": {self._get_doc(command)}" if command.help else ""}' for command in commands
+            )
+
         await self.context.send("\n".join(message))
 
     async def send_cog_help(self, cog: "commands.Cog") -> None:
         message = [f"/pre {cog.qualified_name}'s commands"]
         for name in sorted(c.name for c in cog.commands):
             command = cog.__commands__[name]
             message.append(f'{name}{f": {self._get_doc(command)}" if command.help else ""}')
         await self.context.send("\n".join(message))
 
     async def send_command_help(self, command: "commands.Command") -> None:
         await self.context.send(f"/pre Help with {command.name}:\n\n{command.help}")
 
     async def send_group_help(self, command: "commands.Group") -> None:
         msg = [f"/pre Help with {command.name}:\n\n{command.help}"]
-        sub_commands = "\n".join(c.name for c in command.children)
-        if sub_commands:
+        if sub_commands := "\n".join(c.name for c in command.children):
             msg.append(f"\nAnd its sub commands:\n{sub_commands}")
         await self.context.send("\n".join(msg))
 
     async def command_not_found(self, command: str) -> None:
         """The default implementation for when a command isn't found.
 
         This by default sends "The command {command} was not found."
```

### Comparing `steamio-0.9.9/steam/ext/commands/utils.py` & `steamio-1.0.0a0/steam/ext/commands/utils.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 from collections import deque
-from typing import Dict, Generator, TypeVar, overload
+from collections.abc import Generator
+from typing import TypeVar, overload
 
 from .errors import MissingClosingQuotation
 
 _T = TypeVar("_T")
 _VT = TypeVar("_VT")
 
 
-class CaseInsensitiveDict(Dict[str, _VT]):
+class CaseInsensitiveDict(dict[str, _VT]):
     """A dictionary where keys are case insensitive."""
 
     def __init__(self, **kwargs: _VT):
         super().__init__(**{k.lower(): v for k, v in kwargs.items()})
 
     def __repr__(self) -> str:
         return f"CaseInsensitiveDict({', '.join(f'{k}={v!r}' for k, v in self.items())})"
@@ -107,16 +108,15 @@
                         self.position = end_of_quote + 2
                         self._undo_pushback.append(start)
                         return remove_quotes(self.in_stream[before:end_of_quote])
 
                     characters.pop()
                 characters.append(character)
 
-            ret = remove_quotes("".join(characters))
-            if ret:
+            if ret := remove_quotes("".join(characters)):
                 self._undo_pushback.append(start)
                 return ret
 
     def undo(self) -> None:
         try:
             self.position = self._undo_pushback.pop()
         except IndexError:
@@ -132,12 +132,9 @@
             "position",
             "end",
         )
         resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
         return f"<Shlex {' '.join(resolved)}>"
 
     def __iter__(self) -> Generator[str, None, None]:
-        while True:
-            token = self.read()
-            if token is None:
-                break
+        while (token := self.read()) is not None:
             yield token
```

### Comparing `steamio-0.9.9/steam/friend.py` & `steamio-1.0.0a0/steam/friend.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,24 +1,22 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import asyncio
 from collections.abc import Callable
-from typing import TYPE_CHECKING
-
-from typing_extensions import Literal
+from typing import TYPE_CHECKING, Literal
 
 from .enums import Language
 from .profile import FriendProfile
 from .user import ClientUser, WrapsUser
 
 if TYPE_CHECKING:
+    from .app import App
     from .clan import Clan
-    from .game import Game
     from .group import Group
 
 __all__ = ("Friend",)
 
 
 class Friend(WrapsUser):
     """Represents a friend of the :class:`ClientUser`."""
@@ -28,27 +26,27 @@
     profile_info = ClientUser.profile_info
 
     async def profile(self, *, language: Language | None = None) -> FriendProfile:
         return FriendProfile(
             *await asyncio.gather(
                 self.equipped_profile_items(language=language),
                 self.profile_info(),
-                self.profile_customisation_info(language=language),
+                self.profile_customisation_info(),
             )
         )
 
-    async def owns(self, game: Game) -> bool:
-        """Whether the game is owned by this friend.
+    async def owns(self, app: App) -> bool:
+        """Whether the app is owned by this friend.
 
         Parameters
         ----------
-        game
-            The game you want to check the ownership of.
+        app
+            The app you want to check the ownership of.
         """
-        return self.id64 in await self._state.fetch_friends_who_own(game.id)
+        return self.id64 in await self._state.fetch_friends_who_own(app.id)
 
     async def invite_to_group(self, group: Group) -> None:
         """Invites the user to a :class:`Group`.
 
         Parameters
         -----------
         group
```

### Comparing `steamio-0.9.9/steam/game_server.py` & `steamio-1.0.0a0/steam/game_server.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,21 +2,21 @@
 
 from __future__ import annotations
 
 import warnings
 from collections.abc import Callable
 from datetime import timedelta
 from ipaddress import IPv4Address
-from typing import TYPE_CHECKING, Any, Generic, NamedTuple, TypeVar, overload
+from typing import TYPE_CHECKING, Any, Generic, Literal, NamedTuple, TypeAlias, TypeVar
 
-from typing_extensions import Literal, TypeAlias, Unpack
+from typing_extensions import Unpack
 
-from .abc import SteamID
+from .app import App, PartialApp
 from .enums import Enum, GameServerRegion, Type
-from .game import Game, StatefulGame
+from .id import ID
 from .protobufs.game_servers import EQueryType, GetServerListResponseServer, QueryResponse
 
 if TYPE_CHECKING:
     from .state import ConnectionState
 
 T = TypeVar("T")
 T_co = TypeVar("T_co", covariant=True)
@@ -128,22 +128,22 @@
         See Also
         --------
         :meth:`Client.fetch_server` for a Query free version of this.
         """
         return Query["str"]("\\gameaddr\\", type=str)
 
     @property
-    def running(cls) -> Query[Game | int]:
-        """Fetches servers running a :class:`.Game` or an :class:`int` app id."""
-        return Query["Game | int"]("\\appid\\", type=(Game, int), callback=lambda game: getattr(game, "id", game))
+    def running(cls) -> Query[App | int]:
+        """Fetches servers running a :class:`.App` or an :class:`int` app id."""
+        return Query["App | int"]("\\appid\\", type=(App, int), callback=lambda app: getattr(app, "id", app))
 
     @property
-    def not_running(cls) -> Query[Game | int]:
-        """Fetches servers not running a :class:`.Game` or an :class:`int` app id."""
-        return Query["Game | int"]("\\nappid\\", type=(Game, int), callback=lambda game: getattr(game, "id", game))
+    def not_running(cls) -> Query[App | int]:
+        """Fetches servers not running a :class:`.App` or an :class:`int` app id."""
+        return Query["App | int"]("\\nappid\\", type=(App, int), callback=lambda app: getattr(app, "id", game))
 
     @property
     def match_tags(cls) -> Query[list[str]]:
         """Fetches servers with all the given tag(s) in :attr:`GameServer.tags`."""
         return Query["list[str]"]("\\gametype\\", type=list, callback=lambda items: f"[{','.join(items)}]")
 
     @property
@@ -187,37 +187,38 @@
         .. describe:: x & y
 
             Combines the two queries in ``\nand\[x\y]`` (not and).
 
     Examples
     --------
 
-    Match games running TF2, that are not empty and are using VAC
+    Match servers running TF2, that are not empty and are using VAC
 
     .. code-block:: pycon
 
         >>> Query.running / TF2 / Query.not_empty / Query.secure
         <Query query='\\appid\\440\\empty\\1\\secure\\1'>
 
 
-    Matches games that are not empty, not full and are not using VAC
+    Matches servers that are not empty, not full and are not using VAC
 
     .. code-block:: pycon
 
         >>> Query.not_empty / Query.not_full | Query.secure
         <Query query='\\empty\\1\\nor\\[\\full\\1\\secure\\1]'>
 
-    Match games where the server name is not "A cool Server" or the server doesn't support alltalk or increased max players
+    Match servers where the server name is not "A cool Server" or the server doesn't support alltalk or increased max
+    players
 
     .. code-block:: pycon
 
         >>> Query.name_match / "A not cool server" | Query.match_tags / ["alltalk", "increased_maxplayers"]
         <Query query='\\nor\\[\\name_match\\A not cool server\\gametype\\[alltalk,increased_maxplayers]]'>
 
-    Match games where the server is not on linux and the server doesn't have no password (has a password)
+    Match servers where the server is not on linux and the server doesn't have no password (has a password)
 
     .. code-block:: pycon
 
         >>> Query.linux & Query.no_password
     """
 
     # simple specification:
@@ -289,23 +290,23 @@
 class ServerPlayer(NamedTuple):
     index: int
     name: str
     score: int
     play_time: timedelta
 
 
-class GameServer(SteamID):
+class GameServer(ID):
     """Represents a game server.
 
     Attributes
     ----------
     name
         The name of the server.
-    game
-        The game of the server.
+    app
+        The app of the server.
     ip
         The ip of the server.
     port
         The port of the server.
     tags
         The tags of the server.
     map
@@ -320,15 +321,15 @@
         The region the server is in.
     version
         The version of the server.
     """
 
     __slots__ = (
         "name",
-        "game",
+        "app",
         "ip",
         "port",
         "tags",
         "map",
         "bot_count",
         "player_count",
         "max_player_count",
@@ -339,31 +340,31 @@
         "_loop",
         "_state",
     )
 
     def __init__(self, state: ConnectionState, server: GetServerListResponseServer):
         super().__init__(server.steamid, type=Type.GameServer)
         self.name = server.name
-        self.game = StatefulGame(state, id=server.appid)
-        self.ip = server.addr.split(":")[0]  # TODO change to IPv4Address
+        self.app = PartialApp(state, id=server.appid)
+        self.ip = IPv4Address(server.addr.rpartition(":")[0])
         self.port = server.gameport
         self.tags = server.gametype.split(",")
         self.map = server.map
         self.bot_count = server.bots
         self.player_count = server.players
         self.max_player_count = server.max_players
         self.region = GameServerRegion.try_value(server.region)
         self.version = server.version
 
         self._secure = server.secure
         self._dedicated = server.dedicated
         self._state = state
 
     def __repr__(self) -> str:
-        attrs = ("name", "game", "ip", "port", "region", "id", "universe", "instance")
+        attrs = ("name", "app", "ip", "port", "region", "id", "universe", "instance")
         resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
         return f"<{self.__class__.__name__} {' '.join(resolved)}>"
 
     def __str__(self) -> str:
         return self.name
 
     def is_secure(self) -> bool:
@@ -371,65 +372,37 @@
         return self._secure
 
     def is_dedicated(self) -> bool:
         """Whether the sever is dedicated."""
         return self._dedicated
 
     async def _query(self, type: EQueryType) -> QueryResponse:
-        return await self._state.query_server(int(IPv4Address(self.ip)), self.port, self.game.id, type)
+        return await self._state.query_server(int(self.ip), self.port, self.app.id, type)
 
     # async def ping(self):  # FIXME not sure how to expose this
     #     proto = await self._query(EQueryType.Ping)
     #     proto.ping_data
 
-    async def players(self, *, challenge: Literal[-1, 0] = 0) -> list[ServerPlayer]:
+    async def players(self) -> list[ServerPlayer]:
         """Fetch a server's players.
 
-        Parameters
-        ----------
-        challenge
-            The challenge for the request default is 0 can also be -1. You may need to change if the server doesn't seem
-            to respond.
-
-            .. deprecated:: 0.9.0
-
-                This parameter no longer does anything.
-
         Returns
         -------
         ServerPlayer is a :class:`typing.NamedTuple` defined as:
 
         .. source:: steam.ServerPlayer
         """
-        if challenge:
-            warnings.warn("challenge parameter is deprecated and will be removed in V1", stacklevel=1)
-
         proto = await self._query(EQueryType.Players)
         return [
             ServerPlayer(
                 index=index,
                 name=player.name,
                 score=player.score,
                 play_time=timedelta(seconds=player.time_played),
             )
             for index, player in enumerate(proto.players_data.players)
         ]
 
-    async def rules(self, *, challenge: Literal[-1, 0] = 0) -> dict[str, str]:
-        """Fetch a console variables. e.g. ``sv_gravity`` or ``sv_voiceenable``.
-
-        Parameters
-        ----------
-        challenges
-            The challenge for the request default is 0 can also be -1. You may need to change if the server doesn't seem
-            to respond.
-
-            .. deprecated:: 0.9.0
-
-                This parameter no longer does anything.
-        """
-
-        if challenge:
-            warnings.warn("challenge parameter is deprecated and will be removed in V1", stacklevel=1)
-
+    async def rules(self) -> dict[str, str]:
+        """Fetch a console variables. e.g. ``sv_gravity`` or ``sv_voiceenable``."""
         proto = await self._query(EQueryType.Rules)
         return proto.rules_data.rules
```

### Comparing `steamio-0.9.9/steam/gateway.py` & `steamio-1.0.0a0/steam/gateway.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,95 +1,102 @@
 """
 Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE
 
 Contains large portions of:
-https://github.com/ValvePython/steam/blob/master/steam/core/cm.py
 https://github.com/Rapptz/discord.py/tree/master/discord/gateway.py
-The appropriate licenses are in LICENSE
+The appropriate license is in LICENSE
 """
 
 from __future__ import annotations
 
 import asyncio
+import base64
 import concurrent.futures
 import logging
 import random
-import struct
 import sys
 import threading
 import time
 import traceback
-from collections.abc import AsyncGenerator, Callable
+from collections.abc import AsyncGenerator, Callable, Iterable
 from dataclasses import dataclass
 from datetime import timedelta
-from gzip import FCOMMENT, FEXTRA, FHCRC, FNAME  # type: ignore
+from functools import partial
+from gzip import FCOMMENT, FEXTRA, FHCRC, FNAME
 from operator import attrgetter
-from typing import TYPE_CHECKING, Any, Generic, TypeVar, overload
+from typing import TYPE_CHECKING, Any, Final, Generic, TypeAlias, TypeVar, overload
 from zlib import MAX_WBITS, decompress
 
 import aiohttp
 import async_timeout
-import attr
-from typing_extensions import TypeAlias
+from cryptography.hazmat.primitives.asymmetric import padding, rsa
 
 from . import utils
-from ._const import DEFAULT_CMS
-from .enums import IntEnum, PersonaState, PersonaStateFlag, Result
-from .errors import NoCMsFound
-from .iterators import AsyncIterator
+from ._const import CLEAR_PROTO_BIT, DEFAULT_CMS, IS_PROTO, MISSING, READ_U32, SET_PROTO_BIT
+from .enums import *
+from .errors import NoCMsFound, WSException
+from .id import parse_id64
 from .models import Registerable, register, return_true
-from .protobufs import EMsg, GCMsg, GCMsgProto, Msg, MsgProto, login
-from .protobufs.client_server_2 import CMsgGcClient
+from .protobufs import (
+    EMsg,
+    GCMessage,
+    GCProtobufMessage,
+    Message,
+    ProtobufMessage,
+    UnifiedMessage,
+    auth,
+    chat,
+    client_server,
+    client_server_2,
+    friends,
+    login,
+)
+from .types.id import ID64
+from .user import AnonymousClientUser, ClientUser
 
 if TYPE_CHECKING:
     from .client import Client
     from .enums import UIMode
     from .protobufs.base import CMsgMulti
     from .state import ConnectionState
-    from .types.game import GameToDict
     from .types.http import Coro
 
 
 __all__ = (
     "ConnectionClosed",
-    "CMServerList",
     "SteamWebSocket",
+    "CMServer",
     "Msgs",
 )
 
 log = logging.getLogger(__name__)
-ProtoMsgs: TypeAlias = "MsgProto[Any] | Msg[Any]"
-GCMsgs: TypeAlias = "GCMsgProto[Any] | GCMsg[Any]"
-GCMsgsT = TypeVar("GCMsgsT", GCMsgProto[Any], GCMsg[Any])
-ProtoMsgsT = TypeVar("ProtoMsgsT", MsgProto[Any], Msg[Any])
+ProtoMsgs: TypeAlias = ProtobufMessage | Message
+GCMsgs: TypeAlias = GCProtobufMessage | GCMessage
+GCMsgsT = TypeVar("GCMsgsT", GCProtobufMessage, GCMessage)
+ProtoMsgsT = TypeVar("ProtoMsgsT", ProtobufMessage, Message)
 Msgs: TypeAlias = "ProtoMsgs | GCMsgs"
-MsgsT = TypeVar("MsgsT", MsgProto[Any], Msg[Any], GCMsgProto[Any], GCMsg[Any])
-M = TypeVar("M", bound=MsgProto[Any])
-MsgProtoT = TypeVar("MsgProtoT", bound=MsgProto[Any])
-MsgT = TypeVar("MsgT", bound=Msg[Any])
-GCMsgT = TypeVar("GCMsgT", bound=GCMsg[Any])
-GCMsgProtoT = TypeVar("GCMsgProtoT", bound=GCMsgProto[Any])
-
-READ_U32 = struct.Struct("<I").unpack_from
+MsgsT = TypeVar("MsgsT", ProtobufMessage, Message, GCProtobufMessage, GCMessage)
+ProtoMsgT = TypeVar("ProtoMsgT", bound=ProtobufMessage)
+UnifiedMsgT = TypeVar("UnifiedMsgT", bound=UnifiedMessage)
+MsgT = TypeVar("MsgT", bound=Message)
+GCMsgT = TypeVar("GCMsgT", bound=GCMessage)
+GCMsgProtoT = TypeVar("GCMsgProtoT", bound=GCProtobufMessage)
 
 
-@dataclass
+@dataclass(slots=True)
 class EventListener(Generic[MsgsT]):
-    __slots__ = ("emsg", "check", "future")
-
-    emsg: IntEnum | None
+    msg: IntEnum | None
     check: Callable[[MsgsT], bool]
     future: asyncio.Future[MsgsT]
 
+    if not TYPE_CHECKING:
+        __class_getitem__ = classmethod(lambda cls, params: cls)
 
-if not TYPE_CHECKING:
-    EventListener.__class_getitem__ = classmethod(lambda cls, params: cls)
 
-
-@attr.dataclass(slots=True)
+@dataclass(slots=True)
 class CMServer:
     _state: ConnectionState
     url: str
     weighted_load: float
 
     def connect(self) -> Coro[aiohttp.ClientWebSocketResponse]:
         return self._state.http.connect_to_cm(self.url)
@@ -101,73 +108,69 @@
                     if resp.status != 200:
                         raise KeyError
                     return int(resp.headers["X-Steam-CMLoad"])
         except (KeyError, asyncio.TimeoutError, aiohttp.ClientError):
             return float("inf")
 
 
+async def fetch_cm_list(state: ConnectionState, cell_id: int = 0) -> AsyncGenerator[CMServer, None]:
+    if state._connected_cm is not None:
+        yield state._connected_cm
+    log.debug("Attempting to fetch servers from the WebAPI")
+    state.cell_id = cell_id
+    try:
+        data = await state.http.get_cm_list(cell_id)
+    except Exception:
+        servers = [CMServer(state, url=cm_url, weighted_load=0) for cm_url in DEFAULT_CMS]
+        random.shuffle(servers)
+        log.debug("Error occurred when fetching CM server list, falling back to internal list", exc_info=True)
+        for cm in servers:
+            yield cm
+        return
+
+    resp = data["response"]
+    if not resp["success"]:
+        servers = [CMServer(state, url=cm_url, weighted_load=0) for cm_url in DEFAULT_CMS]
+        random.shuffle(servers)
+        log.debug("Error occurred when fetching CM server list, falling back to internal list", exc_info=True)
+        for cm in servers:
+            yield cm
+        return
+
+    hosts: list[dict[str, Any]] = resp["serverlist"]
+    log.debug(f"Received {len(hosts)} servers from WebAPI")
+    for cm in sorted(
+        (CMServer(state, url=server["endpoint"], weighted_load=server["wtd_load"]) for server in hosts),
+        key=attrgetter("weighted_load"),
+    ):  # they should already be sorted but oh well
+        yield cm
+
+
 class ConnectionClosed(Exception):
-    def __init__(self, cm: CMServer, cms: CMServerList):
+    def __init__(self, cm: CMServer):
         self.cm = cm
-        self.cm_list = cms
         super().__init__(f"Connection to {self.cm.url}, has closed.")
 
 
 class WebSocketClosure(Exception):
     """An exception to make up for the fact that aiohttp doesn't signal closure."""
 
 
-class CMServerList(AsyncIterator[CMServer]):
-    def __init__(self, state: ConnectionState, first_cm_to_try: CMServer | None = None):
-        super().__init__(state)
-        self.cell_id = 0
-        self._first_cm = first_cm_to_try
-
-    async def fill(self, cell_id: int = 0) -> AsyncGenerator[CMServer, None]:
-        if self._first_cm is not None:
-            yield self._first_cm
-        log.debug("Attempting to fetch servers from the WebAPI")
-        self.cell_id = cell_id
-        try:
-            data = await self._state.http.get_cm_list(cell_id)
-        except Exception:
-            servers = [CMServer(self._state, url=cm_url, weighted_load=0) for cm_url in DEFAULT_CMS]
-            random.shuffle(servers)
-            log.debug("Error occurred when fetching CM server list, falling back to internal list", exc_info=True)
-            for server in servers:
-                yield server
-            return
-
-        resp = data["response"]
-        if not resp["success"]:
-            servers = [CMServer(self._state, url=cm_url, weighted_load=0) for cm_url in DEFAULT_CMS]
-            random.shuffle(servers)
-            log.debug("Error occurred when fetching CM server list, falling back to internal list", exc_info=True)
-            for server in servers:
-                yield server
-            return
-
-        hosts: list[dict[str, Any]] = resp["serverlist"]
-        log.debug(f"Received {len(hosts)} servers from WebAPI")
-        servers = [CMServer(self._state, url=server["endpoint"], weighted_load=server["wtd_load"]) for server in hosts]
-        for server in sorted(servers, key=attrgetter("weighted_load")):  # they should already be sorted but oh well
-            yield server
-
-
 class KeepAliveHandler(threading.Thread):
     def __init__(self, ws: SteamWebSocket, interval: int):
         super().__init__()
         self.ws = ws
         self.interval = interval
         self._main_thread_id = self.ws.thread_id
-        self.heartbeat = MsgProto[login.CMsgClientHeartBeat](EMsg.ClientHeartBeat, send_reply=True)
+        self.heartbeat = login.CMsgClientHeartBeat(send_reply=True)
         self.msg = "Keeping websocket alive with heartbeat %s."
         self.block_msg = "Heartbeat blocked for more than {total} seconds."
         self.behind_msg = "Can't keep up, websocket is {total:.1f}s behind."
         self._stop_ev = threading.Event()
+        self._last_recv = float("-inf")
         self._last_ack = time.perf_counter()
         self._last_send = time.perf_counter()
         self.latency = float("inf")
 
     def run(self) -> None:
         while not self._stop_ev.wait(self.interval):
             if self._last_recv + 60 < time.perf_counter():
@@ -179,14 +182,17 @@
                     f.result()
                 except Exception:
                     log.exception("An error occurred while stopping the gateway. Ignoring.")
                 finally:
                     return self.stop()
 
             log.debug(self.msg, self.heartbeat)
+            if self.ws.loop.is_closed():
+                return self.stop()
+
             coro = self.ws.send_proto(self.heartbeat)
             f = asyncio.run_coroutine_threadsafe(coro, loop=self.ws.loop)
             # block until sending is complete
             total = 0
             try:
                 while True:
                     try:
@@ -222,124 +228,334 @@
             log.warning(self.behind_msg.format(total=self.latency))
 
 
 class SteamWebSocket(Registerable):
     parsers: dict[EMsg, Callable[..., Any]]
 
     def __init__(
-        self, state: ConnectionState, socket: aiohttp.ClientWebSocketResponse, cm_list: CMServerList, cm: CMServer
+        self,
+        state: ConnectionState,
+        socket: aiohttp.ClientWebSocketResponse,
+        cm_list: AsyncGenerator[CMServer, None],
+        cm: CMServer,
     ):
         self.socket = socket
 
         # state stuff
-        self._connection = state
+        self._state = state
         self.cm_list = cm_list
         self.cm = cm
         # the keep alive
         self._keep_alive: KeepAliveHandler
         self._dispatch = state.dispatch
         self.thread_id = threading.get_ident()
 
         # ws related stuff
         self.listeners: list[EventListener[Any]] = []
         self.parsers.update(state.parsers)
         self.closed = False
 
         self.session_id = 0
-        self.steam_id = state.user.id64
+        self.id64 = ID64(0)
         self._current_job_id = 0
         self._gc_current_job_id = 0
+        self.server_offset = timedelta()
+        self.refresh_token: str
+        self.access_token: str
+        self.client_id: int
 
     @property
     def latency(self) -> float:
         """Measures latency between a heartbeat send and the heartbeat interval in seconds."""
         return self._keep_alive.latency
 
     @overload
-    def wait_for(self, emsg: EMsg | None, check: Callable[[MsgT], bool] = ...) -> asyncio.Future[MsgT]:
+    def wait_for(
+        self, *, emsg: EMsg | None, check: Callable[[ProtoMsgsT], bool] = return_true
+    ) -> asyncio.Future[ProtoMsgsT]:
         ...
 
     @overload
-    def wait_for(self, emsg: EMsg | None, check: Callable[[MsgProtoT], bool] = ...) -> asyncio.Future[MsgProtoT]:
+    def wait_for(self, msg: type[MsgT], *, check: Callable[[MsgT], bool] = return_true) -> asyncio.Future[MsgT]:
         ...
 
+    @overload
     def wait_for(
-        self, emsg: EMsg | None, check: Callable[[ProtoMsgsT], bool] = return_true
+        self, msg: type[ProtoMsgT], *, check: Callable[[ProtoMsgT], bool] = return_true
+    ) -> asyncio.Future[ProtoMsgT]:
+        ...
+
+    def wait_for(
+        self,
+        msg: type[ProtoMsgs] | None = None,
+        *,
+        emsg: EMsg | None = None,
+        check: Callable[[ProtoMsgsT], bool] = return_true,
     ) -> asyncio.Future[ProtoMsgsT]:
         future: asyncio.Future[ProtoMsgsT] = self.loop.create_future()
-        entry = EventListener(emsg=emsg, check=check, future=future)
+        entry = EventListener(msg=msg.MSG if msg else emsg, check=check, future=future)
         self.listeners.append(entry)
         return future
 
     @classmethod
-    async def from_client(
-        cls, client: Client, cm: CMServer | None = None, cm_list: CMServerList | None = None
-    ) -> SteamWebSocket:
-        state = client._connection
-        cm_list = cm_list or CMServerList(state, cm)
-        token = await client.token()
+    async def from_client(cls, client: Client, refresh_token: str = MISSING) -> SteamWebSocket:
+        PROTOCOL_VERSION: Final = 65580
+        state = client._state
+        cm_list = fetch_cm_list(state)
         async for cm in cm_list:
             log.info(f"Attempting to create a websocket connection to: {cm}")
             socket = await cm.connect()
             log.debug(f"Connected to {cm}")
 
             self = cls(state, socket, cm_list, cm)
-            await self.send_proto(
-                MsgProto(
-                    EMsg.ClientLogon,
-                    account_name=client.username,
-                    web_logon_nonce=token,
-                    client_os_type=4294966596,
-                    client_language=self._connection.http.language.api_name,
-                    protocol_version=65580,
+            self._dispatch("connect")
+
+            async def poll():
+                while True:
+                    await self.poll_event()
+
+            task = asyncio.create_task(poll())
+            await self.send_proto(login.CMsgClientHello(PROTOCOL_VERSION))
+
+            if refresh_token is MISSING:
+                self.refresh_token = await self.fetch_refresh_token()
+                # steam_id is set in fetch_refresh_token
+            else:
+                self.refresh_token = refresh_token
+                self.id64 = parse_id64(utils.decode_jwt(refresh_token)["sub"])
+
+            msg: login.CMsgClientLogonResponse = await self.send_proto_and_wait(
+                login.CMsgClientLogon(
+                    protocol_version=PROTOCOL_VERSION,
+                    client_package_version=1561159470,
+                    client_os_type=16,
+                    client_language=state.language.api_name,
+                    supports_rate_limit_response=True,
                     chat_mode=2,
-                    ui_mode=self._connection._ui_mode,
-                    qos_level=2,
-                )
+                    access_token=self.refresh_token,  # lol
+                ),
+                check=lambda msg: isinstance(msg, login.CMsgClientLogonResponse),
+            )
+            if msg.result != Result.OK:
+                log.debug(f"Failed to login with result: {msg.result}")
+                await self.handle_close()
+                return await self.from_client(client)
+
+            self.session_id = msg.header.session_id
+
+            (us,) = await self.fetch_users((self.id64,))
+            client.http.user = ClientUser(state, us)
+            state._users[client.user.id] = client.user  # type: ignore
+            self._state.cell_id = msg.cell_id
+
+            self._keep_alive = KeepAliveHandler(ws=self, interval=msg.heartbeat_seconds)
+            self._keep_alive.start()
+            log.debug("Heartbeat started.")
+
+            client.ws = self
+            state.login_complete.set()
+
+            await self.send_um(chat.GetMyChatRoomGroupsRequest())
+            await self.send_proto(friends.CMsgClientGetEmoticonList())
+            await self.send_proto(
+                client_server_2.CMsgClientRequestCommentNotifications()
+            )  # TODO Use notifications.GetSteamNotificationsRequest() instead (maybe?)
+            await self.send_proto(
+                login.CMsgClientServerTimestampRequest(client_request_timestamp=int(time.time() * 1000))
+            )
+            await self.change_presence(
+                apps=self._state._apps,
+                state=self._state._state,
+                flags=self._state._flags,
+                force_kick=self._state._force_kick,
+            )
+
+            self._dispatch("login")
+            log.debug("Logon completed")
+
+            def shallow_cancelled_error(_: object) -> None:
+                try:
+                    task.exception()
+                except (asyncio.CancelledError, asyncio.InvalidStateError):
+                    pass
+
+            task.add_done_callback(shallow_cancelled_error)
+            task.cancel()  # we let Client.connect handle poll_event from here on out
+
+            return self
+        raise NoCMsFound("No CMs found could be connected to. Steam is likely down")
+
+    async def fetch_refresh_token(self) -> str:
+        client = self._state.client
+        assert client.username
+        assert client.password
+        rsa_msg: auth.GetPasswordRsaPublicKeyResponse = await self.send_um_and_wait(
+            auth.GetPasswordRsaPublicKeyRequest(client.username)
+        )
+
+        begin_resp: auth.BeginAuthSessionViaCredentialsResponse = await self.send_um_and_wait(
+            auth.BeginAuthSessionViaCredentialsRequest(
+                account_name=client.username,
+                encrypted_password=base64.b64encode(
+                    rsa.RSAPublicNumbers(int(rsa_msg.publickey_exp, 16), int(rsa_msg.publickey_mod, 16))
+                    .public_key()
+                    .encrypt(client.password.encode(), padding.PKCS1v15())
+                ).decode(),
+                encryption_timestamp=rsa_msg.timestamp,
+                platform_type=auth.EAuthTokenPlatformType.SteamClient,
+                persistence=auth.ESessionPersistence.Persistent,
+                website_id="Client",
             )
+        )
+
+        for allowed_confirmation in begin_resp.allowed_confirmations:
+            match allowed_confirmation.confirmation_type:
+                case auth.EAuthSessionGuardType.NONE:
+                    raise NotImplementedError()  # no guard
+                case auth.EAuthSessionGuardType.EmailCode | auth.EAuthSessionGuardType.DeviceCode:
+                    code = await client.code()
+                    code_msg: auth.UpdateAuthSessionWithSteamGuardCodeResponse = await self.send_proto_and_wait(
+                        auth.UpdateAuthSessionWithSteamGuardCodeRequest(
+                            client_id=begin_resp.client_id,
+                            steamid=begin_resp.steamid,
+                            code=code,
+                            code_type=allowed_confirmation.confirmation_type,
+                        )
+                    )
+                    if code_msg.result != Result.OK:
+                        raise WSException(code_msg)
+                    poll_resp: auth.PollAuthSessionStatusResponse = await self.send_um_and_wait(
+                        auth.PollAuthSessionStatusRequest(
+                            client_id=begin_resp.client_id,
+                            request_id=begin_resp.request_id,
+                        )
+                    )
+                    break
+                case auth.EAuthSessionGuardType.EmailConfirmation | auth.EAuthSessionGuardType.DeviceConfirmation:
+                    raise NotImplementedError("Email and Device confirmation support is not implemented yet")
+                case auth.EAuthSessionGuardType.MachineToken:
+                    raise NotImplementedError("Machine tokens are not supported yet")
+                case _:
+                    raise NotImplementedError(
+                        f"Unknown auth session guard type: {allowed_confirmation.confirmation_type}"
+                    )
+        else:
+            raise ValueError("No valid auth session guard type was found")
+
+        self.id64 = ID64(begin_resp.steamid)
+        self.client_id = poll_resp.new_client_id or begin_resp.client_id
+        self.access_token = poll_resp.access_token
+        return poll_resp.refresh_token
+
+    @classmethod
+    async def anonymous_login_from_client(cls, client: Client) -> SteamWebSocket:
+        PROTOCOL_VERSION: Final = 65580
+        state = client._state
+        cm_list = fetch_cm_list(state)
+        async for cm in cm_list:
+            log.info(f"Attempting to create an anonymous websocket connection to: {cm}")
+            socket = await cm.connect()
+            log.debug(f"Connected to {cm}")
+
+            self = cls(state, socket, cm_list, cm)
             self._dispatch("connect")
+
+            async def poll():
+                while True:
+                    await self.poll_event()
+
+            task = asyncio.create_task(poll())
+
+            self.id64 = parse_id64(0, type=Type.AnonUser, universe=Universe.Public)
+
+            msg: login.CMsgClientLogonResponse = await self.send_proto_and_wait(
+                login.CMsgClientLogon(
+                    protocol_version=PROTOCOL_VERSION,
+                    client_package_version=1561159470,
+                    client_language=state.language.api_name,
+                ),
+                check=lambda msg: isinstance(msg, login.CMsgClientLogonResponse),
+            )
+            if msg.result != Result.OK:
+                log.debug(f"Failed to login with result: {msg.result}")
+                await self.handle_close()
+                return await self.from_client(client)
+
+            self.session_id = msg.header.session_id
+            self.id64 = msg.header.steam_id
+            self._state.cell_id = msg.cell_id
+
+            self._keep_alive = KeepAliveHandler(ws=self, interval=msg.heartbeat_seconds)
+            self._keep_alive.start()
+            log.debug("Heartbeat started.")
+
+            client.ws = self
+            state.login_complete.set()
+            state.http.user = AnonymousClientUser(state, self.id64)  # type: ignore
+
+            await self.send_proto(
+                login.CMsgClientServerTimestampRequest(client_request_timestamp=int(time.time() * 1000))
+            )
+
+            self._dispatch("login")
+            log.debug("Logon completed")
+
+            def shallow_cancelled_error(_: object) -> None:
+                try:
+                    task.exception()
+                except (asyncio.CancelledError, asyncio.InvalidStateError):
+                    pass
+
+            task.add_done_callback(shallow_cancelled_error)
+            task.cancel()  # we let Client.connect handle poll_event from here on out
+            await client._handle_ready()
+
             return self
         raise NoCMsFound("No CMs found could be connected to. Steam is likely down")
 
     async def poll_event(self) -> None:
         try:
             message = await self.socket.receive()
-            if message.type is aiohttp.WSMsgType.BINARY and message.data:  # it can sometimes be None/empty
-                return self.receive(message.data)
+            if message.type is aiohttp.WSMsgType.BINARY:
+                return self.receive(bytearray(message.data))
             if message.type is aiohttp.WSMsgType.ERROR:
                 log.debug(f"Received {message}")
                 raise message.data
             if message.type in (aiohttp.WSMsgType.CLOSED, aiohttp.WSMsgType.CLOSE, aiohttp.WSMsgType.CLOSING):
                 log.debug(f"Received {message}")
                 raise WebSocketClosure
             log.debug(f"Dropped unexpected message type: {message}")
         except WebSocketClosure:
             await self.handle_close()
 
-    def receive(self, message: bytes) -> None:
-        (emsg_value,) = READ_U32(message)
-        emsg = EMsg(utils.clear_proto_bit(emsg_value))
-
+    def receive(self, message: bytearray) -> None:
+        emsg_value = READ_U32(message)
         try:
-            msg = MsgProto(emsg, message) if utils.is_proto(emsg_value) else Msg(emsg, message, extended=True)
+            msg = (
+                ProtobufMessage().parse(message[4:], CLEAR_PROTO_BIT(emsg_value))
+                if IS_PROTO(emsg_value)
+                else Message().parse(message[4:], emsg_value)
+            )
         except Exception as exc:
-            return log.error(f"Failed to deserialize message: {emsg!r}, {message!r}", exc_info=exc)
+            return log.error(
+                f"Failed to deserialize message: {EMsg(CLEAR_PROTO_BIT(emsg_value))!r}, {message!r}", exc_info=exc
+            )
 
         log.debug("Socket has received %r from the websocket.", msg)
 
         if hasattr(self, "_keep_alive"):
             self._keep_alive.tick()
 
         self._dispatch("socket_receive", msg)
-        self.run_parser(emsg, msg)
+        self.run_parser(msg)
 
         # remove the dispatched listener
         removed: list[int] = []
         for idx, entry in enumerate(self.listeners):
-            if entry.emsg != emsg and entry.emsg is not None:
+            if entry.msg != msg.MSG and entry.msg is not None:
                 continue
 
             future = entry.future
             if future.cancelled():
                 removed.append(idx)
                 continue
 
@@ -360,211 +576,215 @@
         try:
             await self.socket.send_bytes(data)
         except ConnectionResetError:
             log.info("Connection closed")
             await self.handle_close()
 
     async def send_proto(self, message: ProtoMsgs) -> None:
-        message.steam_id = self.steam_id
-        message.session_id = self.session_id
+        message.header.steam_id = self.id64
+        message.header.session_id = self.session_id
 
         self._dispatch("socket_send", message)
         await self.send(bytes(message))
 
     async def send_gc_message(self, msg: GCMsgs) -> int:  # for ext's to send GC messages
-        client = self._connection.client
+        client = self._state.client
         if __debug__ or TYPE_CHECKING:
             from .ext._gc import Client as GCClient
 
             assert isinstance(client, GCClient), "Attempting to send a GC message without a GC client"
 
-        app_id = client._GAME.id
-        message = MsgProto[CMsgGcClient](
-            EMsg.ClientToGC,
+        app_id = client._APP.id
+        message = client_server_2.CMsgGcClientToGC(
             appid=app_id,
-            msgtype=utils.set_proto_bit(msg.msg) if isinstance(msg, GCMsgProto) else msg.msg,
+            msgtype=SET_PROTO_BIT(msg.MSG) if isinstance(msg, GCProtobufMessage) else msg.MSG,
             payload=bytes(msg),
         )
-        message.header.body.routing_app_id = app_id
-        message.header.body.job_id_source = self._gc_current_job_id = (self._gc_current_job_id + 1) % 10000 or 1
+        message.header.routing_app_id = app_id
+        message.header.job_id_source = self._gc_current_job_id = (self._gc_current_job_id + 1) % 10000 or 1
 
         log.debug("Sending GC message %r", msg)
         self._dispatch("gc_message_send", msg)
         await self.send_proto(message)
-        return message.header.body.job_id_source
+        return message.header.job_id_source
 
     async def close(self, code: int = 1000) -> None:
-        message = MsgProto(EMsg.ClientLogOff)
-        message.steam_id = self.steam_id
-        message.session_id = self.session_id
+        message = login.CMsgClientLogOff()
+        message.header.steam_id = self.id64
+        message.header.session_id = self.session_id
         await self.socket.close(code=code, message=bytes(message))
 
     @register(EMsg.ClientLoggedOff)
     async def handle_close(self, _: Any = None) -> None:
         if self.closed:  # don't want ConnectionClosed to be raised multiple times
             return
         if not self.socket.closed:
             await self.close()
-            try:
-                await self.cm_list.__anext__()  # pop the disconnected cm
-            except StopAsyncIteration:
-                pass
         if hasattr(self, "_keep_alive"):
             self._keep_alive.stop()
             del self._keep_alive
         log.info("Websocket closed, cannot reconnect.")
         self.closed = True
-        raise ConnectionClosed(self.cm, self.cm_list)
-
-    @register(EMsg.ClientLogOnResponse)
-    async def handle_logon(self, msg: MsgProto[login.CMsgClientLogonResponse]) -> None:
-        if msg.result != Result.OK:
-            log.debug(f"Failed to login with result: {msg.result}")
-            if msg.result == Result.InvalidPassword:
-                http = self._connection.http
-                await http.logout()
-                await http.login(http.username, http.password, shared_secret=http.shared_secret)
-            return await self.handle_close()
-
-        self.session_id = msg.session_id
-        self.cm_list.cell_id = msg.body.cell_id
-
-        interval = msg.body.out_of_game_heartbeat_seconds
-        self._keep_alive = KeepAliveHandler(ws=self, interval=interval)
-        self._keep_alive.start()
-        log.debug("Heartbeat started.")
-
-        await self.send_um("ChatRoom.GetMyChatRoomGroups")
-        await self.change_presence(
-            games=self._connection._games,
-            state=self._connection._state,
-            flags=self._connection._flags,
-            force_kick=self._connection._force_kick,
-        )
-        await self.send_proto(MsgProto(EMsg.ClientGetEmoticonList))
-        await self.send_proto(MsgProto(EMsg.ClientRequestCommentNotifications))
-        await self.send_proto(MsgProto(EMsg.ClientServerTimestampRequest, client_request_timestamp=time.time() * 1000))
-
-        log.debug("Logon completed")
+        raise ConnectionClosed(self.cm)
 
     @register(EMsg.ClientHeartBeat)
-    def ack_heartbeat(self, msg: MsgProto[login.CMsgClientHeartBeat]) -> None:
+    def ack_heartbeat(self, msg: login.CMsgClientHeartBeat) -> None:
         self._keep_alive.ack()
 
     @register(EMsg.ClientServerTimestampResponse)
-    def set_steam_time(self, msg: MsgProto[login.CMsgClientServerTimestampResponse]) -> None:
-        self.server_offset = timedelta(milliseconds=msg.body.server_timestamp_ms - msg.body.client_request_timestamp)
+    def set_steam_time(self, msg: login.CMsgClientServerTimestampResponse) -> None:
+        self.server_offset = timedelta(milliseconds=msg.server_timestamp_ms - msg.client_request_timestamp)
 
     @staticmethod
-    def unpack_multi(msg: MsgProto[CMsgMulti]) -> bytes | None:
-        data = msg.body.message_body
-        log.debug(f"Decompressing payload ({len(data)} -> {msg.body.size_unzipped})")
+    def unpack_multi(msg: CMsgMulti) -> bytearray | None:
+        data = msg.message_body
+        log.debug(f"Decompressing payload ({len(data)} -> {msg.size_unzipped})")
         if data[:2] != b"\037\213":
             return log.info("Received a file that's not GZipped")
 
-        flag = int.from_bytes(data[3:4], byteorder="little")
         position = 10
 
-        if flag:  # this isn't ever hit, might as well save a few nanos
+        if flag := data[3]:  # this isn't ever hit, might as well save a few nanos
             if flag & FEXTRA:
-                extra_len = int.from_bytes(data[position:2], byteorder="little")
+                extra_len = int.from_bytes(data[position : position + 2], byteorder="little")
                 position += 2 + extra_len
             if flag & FNAME:
-                while True:
-                    terminator = data[position:1]
+                while data[position:]:
                     position += 1
-                    if not terminator or terminator == b"\000":
-                        break
             if flag & FCOMMENT:
-                while True:
-                    terminator = data[position:1]
+                while data[position:]:
                     position += 1
-                    if not terminator or terminator == b"\000":
-                        break
             if flag & FHCRC:
                 position += 2
 
         decompressed = decompress(data[position:], wbits=-MAX_WBITS)
 
-        if len(decompressed) != msg.body.size_unzipped:
+        if len(decompressed) != msg.size_unzipped:
             return log.info(f"Unzipped size mismatch for multi payload {msg}, discarding")
 
-        return decompressed
+        return bytearray(decompressed)
 
     @register(EMsg.Multi)
-    def handle_multi(self, msg: MsgProto[CMsgMulti]) -> None:
+    def handle_multi(self, msg: CMsgMulti) -> None:
         log.debug("Received a multi")
-        data = self.unpack_multi(msg) if msg.body.size_unzipped else msg.body.message_body
+        data: bytearray = self.unpack_multi(msg) if msg.size_unzipped else msg.message_body  # type: ignore
 
         while data:
-            (size,) = READ_U32(data)
+            size = READ_U32(data)
             self.receive(data[4 : 4 + size])
             data = data[4 + size :]
 
+    @register(EMsg.ClientLoggedOff)
+    async def handle_logoff(self, msg: login.CMsgClientLoggedOff):
+        await self.handle_close()
+
     @property
     def next_job_id(self) -> int:
         self._current_job_id = (self._current_job_id + 1) % 10000 or 1
         return self._current_job_id
 
-    async def send_um(self, __name: str, **kwargs: Any) -> int:
-        msg = MsgProto(EMsg.ServiceMethodCallFromClient, um_name=__name, **kwargs)
-        msg.header.body.job_id_source = self.next_job_id
-        await self.send_proto(msg)
-        return msg.header.body.job_id_source
+    async def send_um(self, um: UnifiedMessage) -> int:
+        um.header.job_id_source = job_id = self.next_job_id
+        await self.send_proto(um)
+        return job_id
 
+    # desperately needs TypeVar defaults
     async def send_um_and_wait(
         self,
-        __name: str,
-        check: Callable[[M], bool] | None = None,
-        **kwargs: Any,
-    ) -> M:
-        job_id = await self.send_um(__name, **kwargs)
-        check = check or (lambda msg: msg.header.body.job_id_target == job_id)
-        return await self.wait_for(EMsg.ServiceMethodResponse, check=check)
+        um: UnifiedMessage,
+        check: Callable[[UnifiedMsgT], bool] = MISSING,
+    ) -> UnifiedMsgT:
+        job_id = await self.send_um(um)
+        check = check or (lambda um: um.header.job_id_target == job_id)
+        return await self.wait_for(emsg=EMsg.ServiceMethodSendToClient, check=check)
 
+    # TypeVar defaults would be nice here too
     @overload
-    async def send_proto_and_wait(self, msg: MsgT, check: Callable[[MsgT], bool] | None = ...) -> MsgT:
+    async def send_proto_and_wait(self, msg: Message, check: Callable[[MsgT], bool] = ...) -> MsgT:
         ...
 
     @overload
-    async def send_proto_and_wait(self, msg: MsgProtoT, check: Callable[[MsgProtoT], bool] | None = ...) -> MsgProtoT:
+    async def send_proto_and_wait(self, msg: ProtobufMessage, check: Callable[[ProtoMsgT], bool] = ...) -> ProtoMsgT:
         ...
 
-    async def send_proto_and_wait(
-        self, msg: ProtoMsgs, check: Callable[[ProtoMsgsT], bool] | None = None
-    ) -> ProtoMsgsT:
-        msg.header.body.job_id_source = job_id = self.next_job_id
+    async def send_proto_and_wait(self, msg: ProtoMsgs, check: Callable[[ProtoMsgsT], bool] = MISSING) -> ProtoMsgsT:
+        msg.header.job_id_source = job_id = self.next_job_id
+        future = self.wait_for(emsg=None, check=check or (lambda msg: msg.header.job_id_target == job_id))
         await self.send_proto(msg)
-        check = check or (lambda msg: msg.header.body.job_id_target == job_id)
-        return await self.wait_for(None, check=check)
+        return await future
 
     async def change_presence(
         self,
         *,
-        games: list[GameToDict] | None = None,
+        apps: list[client_server.CMsgClientGamesPlayedGamePlayed] | None = None,
         state: PersonaState | None = None,
         flags: PersonaStateFlag | None = None,
         ui_mode: UIMode | None = None,
         force_kick: bool = False,
     ) -> None:
-        self._connection._games = games or self._connection._games
-        self._connection._state = state or self._connection._state
-        self._connection._ui_mode = ui_mode or self._connection._ui_mode
-        self._connection._flags = flags or self._connection._flags
-        self._connection._force_kick = force_kick
+        self._state._apps = apps or self._state._apps
+        self._state._state = state or self._state._state
+        self._state._ui_mode = ui_mode or self._state._ui_mode
+        self._state._flags = flags or self._state._flags
+        self._state._force_kick = force_kick
 
         if force_kick:
-            kick_msg = MsgProto(EMsg.ClientKickPlayingSession)
             log.debug("Kicking any currently playing sessions")
-            await self.send_proto(kick_msg)
-        if games:
-            games_msg = MsgProto(EMsg.ClientGamesPlayedWithDataBlob, games_played=games)
-            log.debug("Sending %r to change activity", games_msg)
-            await self.send_proto(games_msg)
+            await self.send_proto(client_server_2.CMsgClientKickPlayingSession())
+        if apps:
+            apps_msg = client_server.CMsgClientGamesPlayed(games_played=apps)
+            log.debug("Sending %r to change activity", apps_msg)
+            await self.send_proto(apps_msg)
         if state is not None or flags is not None:
-            state_msg = MsgProto(EMsg.ClientChangeStatus, persona_state=state, persona_state_flags=flags)
+            state_msg = friends.CMsgClientChangeStatus(
+                persona_state=state or self._state._state, persona_state_flags=flags or self._state._flags
+            )  # TODO what does need_persona_response do?
             log.debug("Sending %r to change state", state_msg)
             await self.send_proto(state_msg)
         if ui_mode is not None:
-            ui_mode_msg = MsgProto(EMsg.ClientCurrentUIMode, uimode=ui_mode)
+            ui_mode_msg = client_server_2.CMsgClientUiMode(uimode=ui_mode)
             log.debug("Sending %r to change UI mode", ui_mode_msg)
             await self.send_proto(ui_mode_msg)
+
+    async def fetch_users(self, user_id64s: Iterable[ID64]) -> list[friends.CMsgClientPersonaStateFriend]:
+        futs: list[asyncio.Future[friends.CMsgClientPersonaState]] = []
+        users: list[friends.CMsgClientPersonaStateFriend] = []
+        user_id64s = tuple(dict.fromkeys(user_id64s))
+
+        def callback(msg: friends.CMsgClientPersonaState, user_id64: ID64) -> bool:
+            return any(friend.friendid == user_id64 for friend in msg.friends)
+
+        for user_id64_chunk in utils.as_chunks(user_id64s, 100):
+            futs += [
+                self.wait_for(friends.CMsgClientPersonaState, check=partial(callback, user_id64=user_id64))
+                for user_id64 in user_id64_chunk
+            ]
+            await self.send_proto(
+                friends.CMsgClientRequestFriendData(
+                    # enum EClientPersonaStateFlag {
+                    #     Status = 1;
+                    #     PlayerName = 2;
+                    #     QueryPort = 4;
+                    #     SourceID = 8;
+                    #     Presence = 16;
+                    #     LastSeen = 64;
+                    #     UserClanRank = 128;
+                    #     ExtraInfo = 256;
+                    #     DataBlob = 512;
+                    #     ClanData = 1024;
+                    #     Facebook = 2048;
+                    #     RichPresence = 4096;
+                    #     Broadcast = 8192;
+                    #     Watching = 16384;
+                    # };
+                    persona_state_requested=0b1111111011111,  # all except watching and broadcast (for now)
+                    friends=user_id64_chunk,  # type: ignore
+                ),
+            )
+
+        for msg in await asyncio.wait_for(asyncio.gather(*futs), timeout=60):
+            if msg.result not in (Result.OK, Result.Invalid):  # not sure if checking this is even useful
+                raise WSException(msg)
+
+            users += [user for user in msg.friends if user.friendid in user_id64s]
+
+        return users
```

### Comparing `steamio-0.9.9/steam/group.py` & `steamio-1.0.0a0/steam/group.py`

 * *Files 11% similar despite different names*

```diff
@@ -31,16 +31,15 @@
 
 class Group(ChatGroup[GroupMember, GroupChannel]):
     """Represents a Steam group."""
 
     __slots__ = ()
 
     def __init__(self, state: ConnectionState, id: ChatGroupID):
-        super().__init__(id, type=Type.Chat)
-        self._state = state
+        super().__init__(state, id, type=Type.Chat)
         self._id = id
 
     async def chunk(self) -> Sequence[GroupMember]:
         self._members = dict.fromkeys(self._partial_members)  # type: ignore
         for id, member in self._partial_members.items():
             user = self._state.get_user(id)
             while user is None:
```

### Comparing `steamio-0.9.9/steam/guard.py` & `steamio-1.0.0a0/steam/guard.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import base64
-import dataclasses
 import hmac
 import struct
+from dataclasses import dataclass
 from hashlib import sha1
 from time import time
 from typing import TYPE_CHECKING, Any
 
 from ._const import URL
 from .errors import ConfirmationError
-from .utils import Intable
+from .types.id import Intable
 
 if TYPE_CHECKING:
     from .state import ConnectionState
 
 
 __all__ = (
     "generate_one_time_code",
@@ -37,18 +37,18 @@
         The unix timestamp to generate the key for.
     """
     timestamp = timestamp or int(time())
     time_buffer = struct.pack(">Q", timestamp // 30)  # pack as Big endian, uint64
     time_hmac = hmac.new(base64.b64decode(shared_secret), time_buffer, digestmod=sha1).digest()
     begin = time_hmac[19] & 0xF
 
-    full_code = struct.unpack(">I", time_hmac[begin : begin + 4])[0] & 0x7FFFFFFF  # unpack as Big endian uint32
+    full_code: int = struct.unpack(">I", time_hmac[begin : begin + 4])[0] & 0x7FFFFFFF  # unpack as Big endian uint32
 
     chars = "23456789BCDFGHJKMNPQRTVWXY"
-    code = []
+    code: list[str] = []
     for _ in range(5):
         full_code, i = divmod(full_code, len(chars))
         code.append(chars[i])
     return "".join(code)
 
 
 def generate_confirmation_code(identity_secret: str, tag: str, timestamp: int | None = None) -> str:
@@ -85,55 +85,60 @@
         hexed_steam_id[12:16],
         hexed_steam_id[16:20],
         hexed_steam_id[20:32],
     ]
     return f'android:{"-".join(partial_id)}'
 
 
-@dataclasses.dataclass
+@dataclass(repr=False, slots=True)
 class Confirmation:
-    __slots__ = (
-        "_state",
-        "id",
-        "nonce",
-        "creator_id",
-    )
     _state: ConnectionState
-    id: int
-    nonce: int
-    creator_id: int  # this isn't really always the trade ID, but for our purposes this is fine
+    id: str
+    data_conf_id: int
+    data_key: str
+    trade_id: int  # this isn't really always the trade ID, but for our purposes this is fine
 
     def __repr__(self) -> str:
-        return f"<Confirmation id={self.id} creator_id={self.creator_id}>"
+        return f"<Confirmation id={self.id!r} trade_id={self.trade_id}>"
 
     def __eq__(self, other: object) -> bool:
-        return isinstance(other, Confirmation) and self.creator_id == other.creator_id and self.id == other.id
+        return isinstance(other, Confirmation) and self.trade_id == other.trade_id and self.id == other.id
+
+    @property
+    def tag(self) -> str:
+        return f"details{self.data_conf_id}"
 
     async def _confirm_params(self, tag: str) -> dict[str, str | int]:
         code, timestamp = await self._state._generate_confirmation_code(tag)
         return {
             "p": self._state._device_id,
             "a": self._state.user.id64,
             "k": code,
             "t": timestamp,
             "m": "android",
             "tag": tag,
         }
 
+    def _assert_valid(self, resp: dict[str, Any]) -> None:
+        if not resp.get("success", False):
+            self._state._confirmations_to_ignore.append(self.trade_id)
+            raise ConfirmationError
+
     async def _perform_op(self, op: str) -> None:
-        params = await self._confirm_params(op) | {"op": op, "cid": self.id, "ck": self.nonce}
+        params = await self._confirm_params(op)
+        params["op"] = op
+        params["cid"] = self.data_conf_id
+        params["ck"] = self.data_key
         resp = await self._state.http.get(URL.COMMUNITY / "mobileconf/ajaxop", params=params)
-        if not resp["success"]:
-            raise ConfirmationError(resp.get("message", "Unknown error"))
+        self._assert_valid(resp)
 
     async def confirm(self) -> None:
         await self._perform_op("allow")
 
     async def cancel(self) -> None:
         await self._perform_op("cancel")
 
     async def details(self) -> str:
-        params = await self._confirm_params(f"details{self.id}")
+        params = await self._confirm_params(self.tag)
         resp = await self._state.http.get(URL.COMMUNITY / f"mobileconf/details/{self.id}", params=params)
-        if not resp["success"]:
-            raise ConfirmationError(resp.get("message", "Unknown error"))
+        self._assert_valid(resp)
         return resp["html"]
```

### Comparing `steamio-0.9.9/steam/http.py` & `steamio-1.0.0a0/steam/http.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,44 +1,40 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import asyncio
-import copy
 import logging
 import re
 import urllib.parse
-import warnings
-from base64 import b64encode
 from collections.abc import Callable, Iterable
-from datetime import datetime
+from datetime import date, datetime
+from http.cookies import SimpleCookie
+from random import randbytes
 from sys import version_info
 from time import time
 from typing import TYPE_CHECKING, Any, TypeVar
 
 import aiohttp
-from cryptography.hazmat.primitives.asymmetric import padding, rsa
-from yarl import URL as _URL
+from yarl import URL as URL_
 
 from . import errors, utils
 from .__metadata__ import __version__
 from ._const import JSON_DUMPS, JSON_LOADS, URL
-from .abc import SteamID
 from .enums import Language
-from .guard import generate_one_time_code
+from .id import ID
 from .models import PriceOverviewDict, api_route
-from .user import ClientUser, _BaseUser
-from .utils import cached_property
+from .user import ClientUser
 
 if TYPE_CHECKING:
     from .client import Client
     from .image import Image
-    from .types import game, trade
-    from .types.http import Coro, ResponseType, StrOrURL
-    from .types.package import FetchedPackage
+    from .types import trade
+    from .types.http import Coro, ResponseDict, StrOrURL
+    from .types.id import ID64
     from .types.user import User
 
 
 T = TypeVar("T")
 log = logging.getLogger(__name__)
 
 
@@ -56,18 +52,17 @@
     """The HTTP Client that interacts with the Steam web API."""
 
     def __init__(self, client: Client, **options: Any):
         self._session: aiohttp.ClientSession = None  # type: ignore  # filled in login
         self.user: ClientUser = None  # type: ignore
         self._client = client
 
-        self.username: str
-        self.password: str
         self.api_key: str | None = None
-        self.shared_secret: str | None
+        self.login_event = asyncio.Event()
+        self._logging_in = False
         self.language: Language = options.get("language", Language.English)
 
         self._one_time_code = ""
         self._email_code = ""
         self._captcha_id = "-1"
         self._captcha_text = ""
         self._steam_id = ""
@@ -77,71 +72,71 @@
             f"steam.py/{__version__} client (https://github.com/Gobot1234/steam.py), "
             f"Python/{version_info.major}.{version_info.minor}, aiohttp/{aiohttp.__version__}"
         )
 
         self.proxy: str | None = options.get("proxy")
         self.proxy_auth: aiohttp.BasicAuth | None = options.get("proxy_auth")
         self.connector: aiohttp.BaseConnector | None = options.get("connector")
-        self.personal_inventory_lock = asyncio.Lock()
 
     def clear(self) -> None:
         self._session = aiohttp.ClientSession(
-            cookies={"Steam_Language": self.language.api_name},
             connector=self.connector,
             json_serialize=JSON_DUMPS,
         )
 
     async def request(self, method: str, url: StrOrURL, **kwargs: Any) -> Any:  # adapted from d.py
         kwargs["headers"] = {"User-Agent": self.user_agent, **kwargs.get("headers", {})}
         payload = kwargs.get("data")
 
+        url = url if isinstance(url, URL_) else URL_(url)
+
+        if url.host == URL.COMMUNITY.host and not self.logged_in:
+            if self._client.ws is None:
+                raise RuntimeError("Not logged in and not connected to CM")
+            await self.login(self._client.ws.refresh_token)
+
         for tries in range(5):
             async with self._session.request(method, url, **kwargs, proxy=self.proxy, proxy_auth=self.proxy_auth) as r:
                 log.debug("%s %s with PAYLOAD: %s has returned %d", method, r.url, payload, r.status)
 
                 # even errors have text involved in them so this is safe to call
                 data = await json_or_text(r)
 
                 # the request was successful so just return the text/json
                 if 200 <= r.status < 300:
                     log.debug("%s %s has received %s", method, r.url, data)
                     return data
 
                 # we are being rate limited
                 elif r.status == 429:
-                    # I haven't been able to get any X-Retry-After headers from the API but we should probably still
-                    # handle it
-                    log.warning("We are being Rate limited")
                     try:
-                        await asyncio.sleep(float(r.headers["X-Retry-After"]))
+                        # I haven't been able to get any X-Retry-After headers from the API, but we should probably still
+                        # handle it
+                        delay = float(r.headers["X-Retry-After"])
                     except KeyError:  # steam being un-helpful as usual
-                        await asyncio.sleep(2**tries)
+                        delay = 2**tries
+                    log.warning("We are being Rate limited sleeping for %s seconds", delay)
+                    await asyncio.sleep(delay)
                     continue
 
                 # we've received a 500 or 502, an unconditional retry
                 elif r.status in {500, 502}:
                     await asyncio.sleep(1 + tries * 3)
                     continue
 
-                # been logged out
-                elif 300 <= r.status <= 399 and "login" in r.headers.get("location", ""):
-                    log.debug("Logged out of session re-logging in")
-                    await self.login(self.username, self.password, self.shared_secret)
-                    continue
-
                 elif r.status == 401:
-                    if not data:
-                        raise errors.HTTPException(r, data)
-                    # api key either got revoked or it was never valid
-                    if "Access is denied. Retrying will not help. Please verify your <pre>key=</pre>" in data:
-                        # time to fetch a new key
+                    if "key" in kwargs.get("params", ()) and (
+                        isinstance(data, str)
+                        and "Access is denied. Retrying will not help. Please verify your <pre>key=</pre>" in data
+                    ):  # api key either got revoked or it was never valid, time to fetch a new key
                         key = await self.get_api_key()
                         assert key is not None
-                        self.api_key = kwargs["key"] = key
-                        # retry with our new key
+                        kwargs["params"]["key"] = key
+                        continue  # retry with our new key
+                    raise errors.HTTPException(r, data)
 
                 # the usual error cases
                 elif r.status == 403:
                     raise errors.Forbidden(r, data)
                 elif r.status == 404:
                     raise errors.NotFound(r, data)
                 else:
@@ -158,288 +153,150 @@
 
     def connect_to_cm(self, cm: str) -> Coro[aiohttp.ClientWebSocketResponse]:
         headers = {"User-Agent": self.user_agent}
         return self._session.ws_connect(
             f"wss://{cm}/cmsocket/", headers=headers, proxy=self.proxy, proxy_auth=self.proxy_auth
         )
 
-    async def login(self, username: str, password: str, shared_secret: str | None) -> None:
-        self.username = username
-        self.password = password
-        self.shared_secret = shared_secret
-        self.clear()
-
-        try:
-            resp = await self._send_login_request()
-
-            if resp.get("captcha_needed") and resp.get("message") != "Please wait and try again later.":
-                self._captcha_id = resp["captcha_gid"]
-                print(
-                    "Please enter the captcha text at "
-                    f"https://steamcommunity.com/login/rendercaptcha/?gid={resp['captcha_gid']}"
-                )
-                captcha_text = await utils.ainput(">>> ")
-                self._captcha_text = captcha_text.strip()
-                return await self.login(username, password, shared_secret)
-
-            if not resp["success"]:
-                raise errors.InvalidCredentials(resp.get("message", "An unexpected error occurred"))
-
-            jar = self._session.cookie_jar
-            cookies = jar.filter_cookies(URL.COMMUNITY)
-            for url in resp["transfer_urls"]:
-                jar.update_cookies(copy.deepcopy(cookies), _URL(url).origin())
-
-            self.api_key = await self.get_api_key()
-            if self.api_key is None:
-                log.info("Failed to get API key")
-
-                async def get_user(user_id64: int) -> User:  # this is a lie
-                    user_id = user_id64 & 0xFFFFFFFF
-                    ret = await self.get(URL.COMMUNITY / f"miniprofile/{user_id}/json")
-                    ret["steamid"] = user_id64
-                    return ret
-
-                async def get_users(user_id64s: Iterable[int]) -> list[User]:
-                    return await asyncio.gather(*(self.get_user(user_id64) for user_id64 in user_id64s))  # type: ignore
-
-                _BaseUser._patch_without_api()
-                self.get_user = get_user
-                self.get_users = get_users
-                warnings.warn(
-                    "Some methods of User objects are not available as no API key can be generated", UserWarning
+    async def login(self, refresh_token: str) -> None:
+        if self._logging_in:
+            await self.login_event.wait()
+            return
+
+        self._logging_in = True
+
+        resp = await self.post(
+            URL.LOGIN / "jwt/finalizelogin",
+            data={
+                "nonce": refresh_token,
+                "sessionid": self.session_id,
+                "redir": URL.COMMUNITY / "login/home/?goto=",
+            },
+        )
+
+        for fut in asyncio.as_completed(
+            [
+                self._session.post(
+                    info["url"],
+                    headers={
+                        "Origin": str(URL.COMMUNITY),
+                        "Referer": str(URL.COMMUNITY),
+                        "Accept": "application/json, text/plain, */*",
+                    },
+                    data=info["params"] | {"steamID": self.user.id64},
                 )
-                await self.get(URL.COMMUNITY / "home")
+                for info in resp["transfer_info"]
+            ]
+        ):
+            try:
+                resp = await fut
+            except Exception:
+                continue
+            else:
+                break
+        else:
+            raise errors.LoginError("Failed to login")
 
-            data = await self.get_user(int(resp["transfer_parameters"]["steamid"]))
-            state = self._client._connection
-            assert data
-            self.user = ClientUser(state=state, data=data)
-            state._users[self.user.id64] = self.user
-            self.logged_in = True
-            self._client.dispatch("login")
-
-        except:
-            await self._session.close()
-            raise
+        jar = self._session.cookie_jar
+        for cookie in resp.headers.getall("Set-Cookie", ()):
+            cookie = SimpleCookie[str](cookie)
+            for url in (URL.COMMUNITY, URL.STORE, URL.HELP):
+                jar.update_cookies(cookie.copy(), url)
+                jar.update_cookies(SimpleCookie[str](f"sessionid={self.session_id}"), url)
+
+        self.login_event.set()
+
+    async def get_api_key(self) -> str | None:
+        if self.api_key is not None:
+            return self.api_key
+
+        resp = await self.get(URL.COMMUNITY / "dev/apikey")
+        if (
+            "<h2>Access Denied</h2>" in resp
+            or "You must have a validated email address to create a Steam Web API key" in resp
+        ):
+            raise RuntimeError("You must have a premium Steam account or validated email address to use this method")
+
+        key_re = re.compile(r"<p>Key: ([0-9A-F]+)</p>")
+        if match := key_re.findall(resp):
+            return match[0]
+
+        payload = {
+            "domain": "steam.py",
+            "agreeToTerms": "agreed",
+            "sessionid": self.session_id,
+            "Submit": "Register",
+        }
+        resp = await self.post(URL.COMMUNITY / "dev/registerkey", data=payload)
+        return key_re.findall(resp)[0]
 
-    @cached_property  # should always be called after making at least one request
+    @utils.cached_property
     def session_id(self) -> str:
-        cookies = self._session.cookie_jar.filter_cookies(URL.COMMUNITY)
-        return cookies["sessionid"].value
+        return randbytes(16).hex()
 
     async def close(self) -> None:
-        await self.logout()
+        if self.logged_in:
+            await self.logout()
         await self._session.close()
 
     async def logout(self) -> None:
         log.debug("Logging out of session")
         payload = {"sessionid": self.session_id}
         await self.post(URL.COMMUNITY / "login/logout", data=payload)
         self.logged_in = False
         self.user = None  # type: ignore
         self._client.dispatch("logout")
 
-    async def _get_rsa_params(self) -> tuple[bytes, int]:
-        payload = {"username": self.username, "donotcache": int(time() * 1000)}
-        try:
-            key_response = await self.post(URL.COMMUNITY / "login/getrsakey", data=payload)
-        except Exception as exc:
-            raise errors.LoginError("Could not obtain RSA key") from exc
-        try:
-            n = int(key_response["publickey_mod"], 16)
-            e = int(key_response["publickey_exp"], 16)
-            rsa_timestamp = key_response["timestamp"]
-        except KeyError:
-            raise errors.LoginError("Could not obtain rsa-key") from None
-        else:
-            return (
-                b64encode(
-                    rsa.RSAPublicNumbers(e, n).public_key().encrypt(self.password.encode("utf-8"), padding.PKCS1v15())
-                ),
-                rsa_timestamp,
-            )
-
-    async def _send_login_request(self) -> dict[str, Any]:
-        password, timestamp = await self._get_rsa_params()
-        payload = {
-            "username": self.username,
-            "password": password.decode(),
-            "emailauth": self._email_code,
-            "emailsteamid": self._steam_id,
-            "twofactorcode": (
-                generate_one_time_code(self.shared_secret) if self.shared_secret is not None else self._one_time_code
-            ),
-            # attempting this straight away makes login a bit faster for everyone with a shared_secret and doesn't
-            # hurt performance for others
-            "captchagid": self._captcha_id,
-            "captcha_text": self._captcha_text,
-            "loginfriendlyname": self.user_agent,
-            "rsatimestamp": timestamp,
-            "remember_login": True,
-            "donotcache": int(time() * 1000),
-        }
-        try:
-            resp = await self.post(URL.COMMUNITY / "login/dologin", data=payload)
-            if resp.get("requires_twofactor"):
-                self._one_time_code = await self._client.code()
-            elif resp.get("emailauth_needed"):
-                self._steam_id = resp.get("emailsteamid")
-                self._email_code = await self._client.code()
-            else:
-                return resp
-            return await self._send_login_request()
-        except errors.LoginError:
-            raise
-        except Exception as exc:
-            try:
-                msg = exc.args[0]
-            except IndexError:
-                msg = None
-            raise errors.LoginError(msg) from exc
-
     async def get_user(self, user_id64: int) -> User | None:
-        params = {"key": self.api_key, "steamids": user_id64}
+        params = {"key": await self.get_api_key(), "steamids": user_id64}
         resp = await self.get(api_route("ISteamUser/GetPlayerSummaries", version=2), params=params)
         return resp["response"]["players"][0] if resp["response"]["players"] else None
 
     async def get_users(self, user_id64s: Iterable[int]) -> list[User]:
         ret: list[User] = []
 
         for resp in await asyncio.gather(  # gather all the requests concurrently
             *(
                 self.get(
                     api_route("ISteamUser/GetPlayerSummaries", version=2),
-                    params={"key": self.api_key, "steamids": ",".join(map(str, sublist))},
+                    params={"key": await self.get_api_key(), "steamids": ",".join(map(str, sublist))},
                 )
-                for sublist in utils.chunk(user_id64s, 100)
+                for sublist in utils.as_chunks(user_id64s, 100)
             )
         ):
             ret.extend(resp["response"]["players"])
         return ret
 
-    def add_user(self, user_id64: int) -> Coro[None]:
-        payload = {
-            "sessionID": self.session_id,
-            "steamid": user_id64,
-            "accept_invite": 0,
-        }
-        return self.post(URL.COMMUNITY / "actions/AddFriendAjax", data=payload)
-
-    def remove_user(self, user_id64: int) -> Coro[None]:
-        payload = {
-            "sessionID": self.session_id,
-            "steamid": user_id64,
-        }
-        return self.post(URL.COMMUNITY / "actions/RemoveFriendAjax", data=payload)
-
-    def block_user(self, user_id64: int) -> Coro[None]:
-        payload = {"sessionID": self.session_id, "steamid": user_id64, "block": 1}
-        return self.post(URL.COMMUNITY / "actions/BlockUserAjax", data=payload)
-
-    def unblock_user(self, user_id64: int) -> Coro[None]:
-        payload = {"sessionID": self.session_id, "steamid": user_id64, "block": 0}
-        return self.post(URL.COMMUNITY / "actions/BlockUserAjax", data=payload)
-
-    def accept_user_invite(self, user_id64: int) -> Coro[None]:
-        payload = {
-            "sessionID": self.session_id,
-            "steamid": user_id64,
-            "accept_invite": 1,
-        }
-        return self.post(URL.COMMUNITY / "actions/AddFriendAjax", data=payload)
-
-    def decline_user_invite(self, user_id64: int) -> Coro[None]:
-        payload = {
-            "sessionID": self.session_id,
-            "steamid": user_id64,
-            "accept_invite": 0,
-        }
-        return self.post(URL.COMMUNITY / "actions/IgnoreFriendInviteAjax", data=payload)
-
-    def get_user_games(self, user_id64: int) -> ResponseType[game.GetOwnedGames]:
+    async def get_user_escrow(self, user_id64: int, token: str | None) -> ResponseDict[dict[str, Any]]:
         params = {
-            "key": self.api_key,
-            "steamid": user_id64,
-            "include_appinfo": 1,
-            "include_played_free_games": 1,
-        }
-        return self.get(api_route("IPlayerService/GetOwnedGames"), params=params)
-
-    async def get_user_inventory(
-        self, user_id64: int, app_id: int, context_id: int, language: Language | None
-    ) -> trade.Inventory:
-        count = 2000
-        ret: trade.Inventory = {"assets": [], "descriptions": [], "last_assetid": 0, "more_items": True}  # type: ignore
-        while ret["more_items"]:
-            params = {
-                "count": count,
-                "l": (language or self.language).api_name,
-                "start_assetid": ret["last_assetid"],
-            }
-            resp: trade.Inventory = await self.get(
-                URL.COMMUNITY / f"inventory/{user_id64}/{app_id}/{context_id}", params=params
-            )
-            ret["assets"].extend(resp["assets"])
-            ret["descriptions"].extend(resp["descriptions"])
-            ret["last_assetid"] = resp.get("last_assetid", 0)
-            ret["more_items"] = resp.get("more_items", False)
-        return ret
-
-    async def get_client_user_inventory(
-        self, app_id: int, context_id: int, language: Language | None
-    ) -> trade.Inventory:
-        async with self.personal_inventory_lock:  # requires a lock
-            return await self.get_user_inventory(self.user.id64, app_id, context_id, language)
-
-    async def get_item_info(
-        self, app_id: int, items: Iterable[tuple[int, int]], language: Language | None
-    ) -> dict[tuple[int, int], trade.Description]:
-        result: dict[tuple[int, int], trade.Description] = {}
-
-        for chunk in utils.chunk(items, 100):
-            params = {
-                "key": self.api_key,
-                "appid": app_id,
-                "class_count": len(chunk),
-                "language": (language or self.language).web_api_name,
-            }
-
-            for i, (class_id, instance_id) in enumerate(chunk):
-                params[f"classid{i}"] = class_id
-                params[f"instanceid{i}"] = instance_id
-
-            data = await self.get(api_route("ISteamEconomy/GetAssetClassInfo"), params=params)
-            result.update({tuple(map(int, key.split("_"))): value for key, value in data["result"].items()})
-
-        return result
-
-    def get_user_escrow(self, user_id64: int, token: str | None) -> ResponseType[dict[str, Any]]:
-        params = {
-            "key": self.api_key,
+            "key": await self.get_api_key(),
             "steamid_target": user_id64,
             "trade_offer_access_token": token if token is not None else "",
         }
-        return self.get(api_route("IEconService/GetTradeHoldDurations"), params=params)
+        return await self.get(api_route("IEconService/GetTradeHoldDurations"), params=params)
 
-    async def get_friends(self, user_id64: int) -> list[User]:
-        params = {"key": self.api_key, "steamid": user_id64, "relationship": "friend"}
+    async def get_friends_ids(self, user_id64: int) -> list[ID64]:
+        params = {
+            "key": await self.get_api_key(),
+            "steamid": user_id64,
+            "relationship": "friend",
+        }
         friends = await self.get(api_route("ISteamUser/GetFriendList"), params=params)
-        return await self.get_users([friend["steamid"] for friend in friends["friendslist"]["friends"]])
+        return [friend["steamid"] for friend in friends["friendslist"]["friends"]]
 
     async def get_trade_offers(
         self,
         active_only: bool = True,
         sent: bool = True,
         received: bool = True,
         updated_only: bool = True,
         language: Language | None = None,
     ) -> dict[str, Any]:  # TODO consider making async iter?
         params = {
-            "key": self.api_key,
+            "key": await self.get_api_key(),
             "active_only": str(active_only).lower(),
             "get_sent_offers": str(sent).lower(),
             "get_received_offers": str(received).lower(),
             "get_descriptions": "true",
             "cursor": 0,
             "language": (language or self.language).api_name,
         }
@@ -468,30 +325,35 @@
                 break
 
         if updated_only:
             self.trades_last_fetched = int(time())
 
         return first_page
 
-    def get_trade_history(
+    async def get_trade_history(
         self, limit: int, previous_time: int = 0, language: Language | None = None
-    ) -> ResponseType[trade.GetTradeOfferHistory]:
+    ) -> ResponseDict[trade.GetTradeOfferHistory]:
         params = {
-            "key": self.api_key,
+            "key": await self.get_api_key(),
             "max_trades": limit,
             "get_descriptions": "true",
             "include_total": "true",
             "start_after_time": previous_time,
             "language": (language or self.language).api_name,
         }
-        return self.get(api_route("IEconService/GetTradeHistory"), params=params)
+        return await self.get(api_route("IEconService/GetTradeHistory"), params=params)
 
-    def get_trade(self, trade_id: int, language: Language | None = None) -> ResponseType[trade.GetTradeOffer]:
-        params = {"key": self.api_key, "tradeofferid": trade_id, "get_descriptions": "true"}
-        return self.get(api_route("IEconService/GetTradeOffer"), params=params)
+    async def get_trade(self, trade_id: int, language: Language | None = None) -> ResponseDict[trade.GetTradeOffer]:
+        params = {
+            "key": await self.get_api_key(),
+            "tradeofferid": trade_id,
+            "get_descriptions": "true",
+            "language": (language or self.language).api_name,
+        }
+        return await self.get(api_route("IEconService/GetTradeOffer"), params=params)
 
     def accept_user_trade(self, user_id64: int, trade_id: int) -> Coro[dict[str, Any]]:
         payload = {
             "sessionid": self.session_id,
             "tradeofferid": trade_id,
             "serverid": 1,
             "partner": user_id64,
@@ -508,15 +370,15 @@
         return self._cancel_user_trade(trade_id, "decline")
 
     def cancel_user_trade(self, trade_id: int) -> Coro[None]:
         return self._cancel_user_trade(trade_id, "cancel")
 
     def send_trade_offer(
         self,
-        user: SteamID,
+        user: ID,
         to_send: list[trade.AssetToDict],
         to_receive: list[trade.AssetToDict],
         token: str | None,
         offer_message: str,
         **kwargs: Any,
     ) -> Coro[trade.TradeOfferCreateResponse]:
         payload = {
@@ -532,37 +394,37 @@
                     "them": {"assets": to_receive, "currency": [], "ready": False},
                 }
             ),
             "captcha": "",
             "trade_offer_create_params": JSON_DUMPS({"trade_offer_access_token": token}) if token is not None else "{}",
             **kwargs,
         }
-        referer = URL.COMMUNITY / "tradeoffer/new/" % {"partner": str(user.id)}
+        referer = URL.COMMUNITY / f"tradeoffer/new/?partner={user.id}"
         if token is not None:
             referer %= {"token": token}
         headers = {"Referer": str(referer)}
         return self.post(URL.COMMUNITY / "tradeoffer/new/send", data=payload, headers=headers)
 
-    def get_trade_receipt(self, trade_id: int, language: Language | None = None) -> Coro[dict[str, Any]]:
+    async def get_trade_receipt(self, trade_id: int, language: Language | None = None) -> dict[str, Any]:
         params = {
-            "key": self.api_key,
+            "key": await self.get_api_key(),
             "tradeid": trade_id,
             "get_descriptions": "true",
             "language": (language or self.language).api_name,
         }
-        return self.get(api_route("IEconService/GetTradeStatus"), params=params)
+        return await self.get(api_route("IEconService/GetTradeStatus"), params=params)
 
     def get_cm_list(self, cell_id: int) -> Coro[dict[str, Any]]:
         params = {
             "cellid": cell_id,
             "cmtype": "websockets",
         }
         return self.get(api_route("ISteamDirectory/GetCMListForConnect"), params=params)
 
-    def join_clan(self, clan_id64: int) -> Coro[None]:
+    async def join_clan(self, clan_id64: int) -> Coro[None]:
         payload = {
             "sessionID": self.session_id,
             "action": "join",
         }
         return self.post(URL.COMMUNITY / f"gid/{clan_id64}", data=payload)
 
     def leave_clan(self, clan_id64: int) -> Coro[None]:
@@ -578,70 +440,76 @@
             "sessionID": self.session_id,
             "group": clan_id64,
             "invitee": user_id64,
             "type": "groupInvite",
         }
         return self.post(URL.COMMUNITY / "actions/GroupInvite", data=payload)
 
-    def get_user_clans(self, user_id64: int) -> Coro[dict[str, Any]]:
-        params = {"key": self.api_key, "steamid": user_id64}
-        return self.get(api_route("ISteamUser/GetUserGroupList"), params=params)
-
-    def get_user_bans(self, user_id64: int) -> Coro[dict[str, Any]]:
-        params = {"key": self.api_key, "steamids": user_id64}
-        return self.get(api_route("ISteamUser/GetPlayerBans"), params=params)
-
-    def get_user_level(self, user_id64: int) -> Coro[dict[str, Any]]:
-        params = {"key": self.api_key, "steamid": user_id64}
-        return self.get(api_route("IPlayerService/GetSteamLevel"), params=params)
-
-    def get_user_badges(self, user_id64: int) -> Coro[dict[str, Any]]:
-        params = {"key": self.api_key, "steamid": user_id64}
-        return self.get(api_route("IPlayerService/GetBadges"), params=params)
+    async def get_user_clans(self, user_id64: int) -> dict[str, Any]:
+        params = {"key": await self.get_api_key(), "steamid": user_id64}
+        return await self.get(api_route("ISteamUser/GetUserGroupList"), params=params)
+
+    async def get_user_bans(self, user_id64: int) -> dict[str, Any]:
+        params = {"key": await self.get_api_key(), "steamids": user_id64}
+        return await self.get(api_route("ISteamUser/GetPlayerBans"), params=params)
+
+    async def get_user_level(self, user_id64: int) -> dict[str, Any]:
+        params = {"key": await self.get_api_key(), "steamid": user_id64}
+        return await self.get(api_route("IPlayerService/GetSteamLevel"), params=params)
+
+    async def get_user_badges(self, user_id64: int) -> dict[str, Any]:
+        params = {"key": await self.get_api_key(), "steamid": user_id64}
+        return await self.get(api_route("IPlayerService/GetBadges"), params=params)
 
     def clear_nickname_history(self) -> Coro[None]:
         payload = {"sessionid": self.session_id}
         return self.post(URL.COMMUNITY / "my/ajaxclearaliashistory", data=payload)
 
     def get_price(self, app_id: int, item_name: str, currency: int) -> Coro[PriceOverviewDict]:
         payload = {
             "appid": app_id,
             "market_hash_name": item_name,
-        }
-        payload.update({"currency": currency} if currency is not None else {})
+        } | ({"currency": currency} if currency is not None else {})
+
         return self.post(URL.COMMUNITY / "market/priceoverview", data=payload)
 
     def get_wishlist(self, user_id64: int) -> Coro[dict[str, Any]]:
         return self.get(URL.STORE / f"wishlist/profiles/{user_id64}/wishlistdata")
 
-    def get_game(self, game_id: int, language: Language | None) -> Coro[dict[str, Any]]:
+    def get_app(self, app_id: int, language: Language | None) -> Coro[dict[str, Any]]:
         params = {
-            "appids": game_id,
+            "appids": app_id,
             "l": (language or self.language).api_name,
         }
         return self.get(URL.STORE / "api/appdetails", params=params)
 
-    def get_game_dlc(self, game_id: int, language: Language | None) -> Coro[dict[str, Any]]:
+    def get_app_dlc(self, app_id: int, language: Language | None) -> Coro[dict[str, Any]]:
         params = {
-            "appid": game_id,
+            "appid": app_id,
             "l": (language or self.language).api_name,
         }
         return self.get(URL.STORE / "api/dlcforapp", params=params)
 
     def get_clan_rss(self, clan_id64: int) -> Coro[str]:
         return self.get(URL.COMMUNITY / f"gid/{clan_id64}/rss")
 
+    def get_clan_events_for(self, clan_id64: ID64, date: date) -> Coro[str]:
+        return self.post(
+            URL.COMMUNITY / f"gid/{clan_id64}/events",
+            data={"xml": 1, "action": "eventFeed", "month": date.month, "year": date.year},
+        )
+
     def _edit_clan_event(
         self,
         action: str,
         clan_id64: int,
         name: str,
         description: str,
         event_type: str,
-        game_id: str,
+        app_id: str,
         server_ip: str,
         server_password: str,
         start: datetime | None,
         event_id: int | None,
     ) -> Coro[str]:
         if start is None:
             tz_offset = int((datetime.now().astimezone().tzinfo.utcoffset()).total_seconds())
@@ -665,15 +533,15 @@
 
         data = {
             "sessionid": self.session_id,
             "action": action,
             "tzOffset": tz_offset,
             "name": name,
             "type": event_type,
-            "appID": game_id,
+            "appID": app_id,
             "serverIP": server_ip,
             "serverPassword": server_password,
             "notes": description,
             "eventQuickTime": "now",
             "startDate": start_date,
             "startHour": start_hour,
             "startMinute": start_minute,
@@ -746,51 +614,59 @@
     ) -> Coro[dict[str, Any]]:
         params = {
             "clan_accountid": clan_id,
             "announcement_gid": announcement_id,
         }
         return self.get(URL.STORE / "events/ajaxgetpartnerevent", params=params)
 
+    def vote_on_user_post(self, user_id64: ID64, post_id: int, vote: int) -> Coro[None]:
+        data = {
+            "sessionid": self.session_id,
+            "vote": vote,
+        }
+
+        return self.post(URL.COMMUNITY / f"comment/UserStatusPublished/voteup/{user_id64}/{post_id}", data=data)
+
     def post_review(
         self,
-        game_id: int,
+        app_id: int,
         content: str,
         upvoted: bool,
         public: bool,
         commentable: bool,
         received_compensation: bool,
         language: str,
     ) -> Coro[None]:
         data = {
-            "appid": game_id,
-            "steamworksappid": game_id,
+            "appid": app_id,
+            "steamworksappid": app_id,
             "comment": content,
             "rated_up": str(upvoted).lower(),
             "is_public": str(public).lower(),
             "language": language,
             "received_compensation": int(received_compensation),
             "disable_comments": int(not commentable),
             "sessionid": self.session_id,
         }
 
         return self.post(URL.STORE / "friends/recommendgame", data=data)
 
     def get_reviews(
-        self, game_id: int, filter: str, review_type: str, purchase_type: str, cursor: str = "*"
+        self, app_id: int, filter: str, review_type: str, purchase_type: str, cursor: str = "*"
     ) -> Coro[dict[str, Any]]:
         params = {
             "json": 1,
             "num_per_page": 100,
             "cursor": urllib.parse.quote(cursor),
             "filter": filter,
             "review_type": review_type,
             "purchase_type": purchase_type,
         }
 
-        return self.get(URL.STORE / f"appreviews/{game_id}", params=params)
+        return self.get(URL.STORE / f"appreviews/{app_id}", params=params)
 
     def mark_review_as_helpful(self, review_id: int, rated_up: bool) -> Coro[None]:
         data = {
             "rateup": str(rated_up).lower(),
             "sessionid": self.session_id,
         }
         return self.post(URL.COMMUNITY / f"userreviews/rate/{review_id}", data=data)
@@ -799,18 +675,18 @@
         data = {
             "tagid": 1,
             "rateup": "true",
             "sessionid": self.session_id,
         }
         return self.post(URL.COMMUNITY / f"userreviews/votetag/{review_id}", data=data)
 
-    def delete_review(self, game_id: int) -> Coro[None]:
+    def delete_review(self, app_id: int) -> Coro[None]:
         data = {
             "action": "delete",
-            "appid": game_id,
+            "appid": app_id,
             "sessionid": self.session_id,
         }
         return self.post(URL.COMMUNITY / "my/recommended", data=data)
 
     def get_package(self, package_id: int, language: Language | None) -> Coro[dict[str, Any]]:
         params = {
             "packageids": package_id,
@@ -844,15 +720,15 @@
             "customURL": url or self.user.community_url,
             "country": country or info.country_name,
             "state": state or info.state_name,
             "city": city or info.city_name,
             "summary": summary or info.summary,
         }
 
-        await self.post(f"{self.user.community_url}/edit", data=payload)
+        await self.post(URL.COMMUNITY / "my/edit", data=payload)
 
     async def update_avatar(self, avatar: Image) -> None:
         with avatar:
             payload = aiohttp.FormData()
             payload.add_field("MAX_FILE_SIZE", str(avatar.size))
             payload.add_field("type", "player_avatar_image")
             payload.add_field("sId", str(self.user.id64))
@@ -878,24 +754,23 @@
             resp = await self.post(URL.COMMUNITY / "chat/beginfileupload", data=payload)
 
             result = resp["result"]
             url = f'{"https" if result["use_https"] else "http"}://{result["url_host"]}{result["url_path"]}'
             headers = {header["name"]: header["value"] for header in result["request_headers"]}
             await self.request("PUT", url=url, headers=headers, data=image.read())
 
-            payload.update(
-                {
-                    "success": 1,
-                    "ugcid": result["ugcid"],
-                    "timestamp": resp["timestamp"],
-                    "hmac": resp["hmac"],
-                    "friend_steamid": user_id64,
-                    "spoiler": int(image.spoiler),
-                }
-            )
+            payload |= {
+                "success": 1,
+                "ugcid": result["ugcid"],
+                "timestamp": resp["timestamp"],
+                "hmac": resp["hmac"],
+                "friend_steamid": user_id64,
+                "spoiler": int(image.spoiler),
+            }
+
             await self.post(URL.COMMUNITY / "chat/commitfileupload", data=payload)
 
     async def send_chat_image(self, chat_id: int, channel_id: int, image: Image) -> None:
         with image:
             payload = {
                 "sessionid": self.session_id,
                 "l": "english",
@@ -909,41 +784,18 @@
             resp = await self.post(URL.COMMUNITY / "chat/beginfileupload", data=payload)
 
             result = resp["result"]
             url = f'{"https" if result["use_https"] else "http"}://{result["url_host"]}{result["url_path"]}'
             headers = {header["name"]: header["value"] for header in result["request_headers"]}
             await self.request("PUT", url=url, headers=headers, data=image.read())
 
-            payload.update(
-                {
-                    "success": 1,
-                    "ugcid": result["ugcid"],
-                    "timestamp": resp["timestamp"],
-                    "hmac": resp["hmac"],
-                    "chat_group_id": channel_id,
-                    "chat_id": chat_id,
-                    "spoiler": int(image.spoiler),
-                }
-            )
-            await self.post(URL.COMMUNITY / "chat/commitfileupload", data=payload)
-
-    async def get_api_key(self) -> str | None:
-        resp = await self.get(URL.COMMUNITY / "dev/apikey")
-        if (
-            "<h2>Access Denied</h2>" in resp
-            or "You must have a validated email address to create a Steam Web API key" in resp
-        ):
-            return
-
-        key_re = re.compile(r"<p>Key: ([0-9A-F]+)</p>")
-        match = key_re.findall(resp)
-        if match:
-            return match[0]
+            payload |= {
+                "success": 1,
+                "ugcid": result["ugcid"],
+                "timestamp": resp["timestamp"],
+                "hmac": resp["hmac"],
+                "chat_group_id": channel_id,
+                "chat_id": chat_id,
+                "spoiler": int(image.spoiler),
+            }
 
-        payload = {
-            "domain": "steam.py",
-            "agreeToTerms": "agreed",
-            "sessionid": self.session_id,
-            "Submit": "Register",
-        }
-        resp = await self.post(URL.COMMUNITY / "dev/registerkey", data=payload)
-        return key_re.findall(resp)[0]
+            await self.post(URL.COMMUNITY / "chat/commitfileupload", data=payload)
```

### Comparing `steamio-0.9.9/steam/image.py` & `steamio-1.0.0a0/steam/image.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,24 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import hashlib
 import imghdr
-import io
 import struct
 from time import time
-from typing import TYPE_CHECKING, Any
-
-from typing_extensions import Protocol
+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable
 
 __all__ = ("Image",)
 
 if TYPE_CHECKING:
     from _typeshed import StrOrBytesPath
 
 
+@runtime_checkable
 class ImageIO(Protocol):
     def seekable(self) -> bool:
         ...
 
     def seek(self, __offset: int, __whence: int = ...) -> Any:
         ...
 
@@ -57,15 +55,15 @@
 
     # TODO add support for "webm", "mpg", "mp4", "mpeg", "ogv"
 
     __slots__ = ("fp", "spoiler", "name", "width", "height", "type", "hash", "size", "_tell")
     fp: ImageIO
 
     def __init__(self, fp: ImageIO | StrOrBytesPath | int, *, spoiler: bool = False):
-        self.fp = fp if isinstance(fp, io.BufferedIOBase) else open(fp, "rb")
+        self.fp = fp if isinstance(fp, ImageIO) else open(fp, "rb")
         if not (self.fp.seekable() and self.fp.readable()):
             raise ValueError(f"File buffer {fp!r} must be seekable and readable")
 
         self._tell = self.fp.tell()
         contents = self.read()
         self.size = len(contents)
         if self.size > 1024 * 1024 * 10:  # 10MiB
```

### Comparing `steamio-0.9.9/steam/invite.py` & `steamio-1.0.0a0/steam/invite.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 from typing import TYPE_CHECKING
 
 if TYPE_CHECKING:
-    from .abc import SteamID
     from .clan import Clan
     from .enums import FriendRelationship
+    from .id import ID
     from .state import ConnectionState
     from .user import User
 
 
 __all__ = (
     "Invite",
     "UserInvite",
     "ClanInvite",
 )
 
 
 class Invite:
     __slots__ = ("invitee", "relationship", "_state")
 
-    def __init__(self, state: ConnectionState, invitee: User | SteamID, relationship: FriendRelationship | None):
+    def __init__(self, state: ConnectionState, invitee: User | ID, relationship: FriendRelationship | None):
         self._state = state
         self.invitee = invitee
         self.relationship = relationship
 
     async def accept(self) -> None:
         raise NotImplementedError()
 
@@ -50,19 +50,19 @@
     def __repr__(self) -> str:
         attrs = ("invitee",)
         resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
         return f"<UserInvite {' '.join(resolved)}>"
 
     async def accept(self) -> None:
         """Accept the invite request."""
-        await self._state.http.accept_user_invite(self.invitee.id64)
+        await self._state.add_user(self.invitee.id64)
 
     async def decline(self) -> None:
         """Decline the invite request."""
-        await self._state.http.decline_user_invite(self.invitee.id64)
+        await self._state.remove_user(self.invitee.id64)
 
 
 class GroupInvite(Invite):
     ...
 
 
 class ClanInvite(Invite):
@@ -79,16 +79,16 @@
     """
 
     __slots__ = ("clan",)
 
     def __init__(
         self,
         state: ConnectionState,
-        invitee: User | SteamID,
-        clan: Clan | SteamID,
+        invitee: User | ID,
+        clan: Clan | ID,
         relationship: FriendRelationship | None,
     ):
         super().__init__(state, invitee, relationship)
         self.clan = clan
 
     def __repr__(self) -> str:
         attrs = ("invitee", "clan")
```

### Comparing `steamio-0.9.9/steam/iterators.py` & `steamio-1.0.0a0/steam/abc.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,823 +1,962 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
+import abc
 import asyncio
-import itertools
-import math
 import re
-from collections.abc import AsyncGenerator, Callable, Coroutine, Iterable
+from collections.abc import AsyncGenerator, Coroutine
+from dataclasses import dataclass
 from datetime import datetime
-from typing import TYPE_CHECKING, Any, Generic, TypeVar
+from ipaddress import IPv4Address, IPv6Address
+from typing import TYPE_CHECKING, Any, ClassVar, Protocol, TypedDict, TypeVar, runtime_checkable
 
 from bs4 import BeautifulSoup
-from typing_extensions import ClassVar, Self, TypeAlias
+from typing_extensions import Required, Self
 from yarl import URL as URL_
 
-from . import utils
-from ._const import HTML_PARSER, URL
-from .enums import EventType, Language, PublishedFileQueryFileType, PublishedFileRevision, PublishedFileType
-from .utils import DateTime
+from ._const import HTML_PARSER, JSON_LOADS, MISSING, STEAM_EPOCH, UNIX_EPOCH, URL
+from .app import App, PartialApp, UserApp, UserInventoryInfoApp, UserInventoryInfoContext, WishlistApp
+from .badge import FavouriteBadge, UserBadges
+from .enums import *
+from .errors import WSException
+from .game_server import GameServer
+from .id import ID
+from .models import Avatar, Ban
+from .profile import *
+from .reaction import Award, AwardReaction, Emoticon, MessageReaction, PartialMessageReaction, Sticker
+from .trade import Inventory
+from .types.id import ContextID
+from .utils import DateTime, cached_slot_property, classproperty
 
 if TYPE_CHECKING:
-    from .abc import Authors, BaseUser, Commentable, Message
-    from .channel import DMChannel, UserMessage
-    from .chat import Chat, ChatMessage
     from .clan import Clan
     from .comment import Comment
-    from .event import Announcement, Event
-    from .game import Game, StatefulGame
     from .group import Group
-    from .manifest import Manifest
-    from .protobufs import friend_messages
+    from .image import Image
+    from .message import Authors
+    from .protobufs.chat import Mentions
     from .published_file import PublishedFile
     from .review import Review
     from .state import ConnectionState
-    from .trade import TradeOffer
     from .user import User
 
-T = TypeVar("T")
-TT = TypeVar("TT")
-CommentableT = TypeVar("CommentableT", bound="Commentable")
-M = TypeVar("M", bound="Message", covariant=True)
+__all__ = (
+    "Message",
+    "Channel",
+)
+
+C = TypeVar("C", bound="Commentable")
+M_co = TypeVar("M_co", bound="Message", covariant=True)
+
+
+class _CommentableKwargs(TypedDict, total=False):
+    id64: Required[int]
+    topic_id: int
+    forum_id: int
+
+
+class _CommentableThreadType(IntEnum):
+    # these just came from bashing the API and seeing what works, although they can now be reliably determined using
+    # ConnectionState.fetch_notifications() and observing body_data["type"] if it's a comment.
+    # AFAIK there aren't any more Commentable types
+    PublishedFile = 5
+    Topic = 7
+    Review = 8
+    User = 10
+    Clan = 12
+    Announcement = 13
+    Event = 14
+    Post = 15
+
+
+class Commentable(Protocol):
+    """A mixin that implements commenting functionality."""
+
+    __slots__ = ()
+    _state: ConnectionState
+
+    @property
+    @abc.abstractmethod
+    def _commentable_kwargs(self) -> _CommentableKwargs:
+        raise NotImplementedError
 
-MaybeCoro: TypeAlias = "Callable[[T], bool | Coroutine[Any, Any, bool]]"
-UNIX_EPOCH = DateTime.from_timestamp(0)
+    @classproperty
+    def _commentable_type(cls: type[Self]) -> _CommentableThreadType:
+        return _CommentableThreadType[cls.__name__]
 
+    async def fetch_comment(self, id: int) -> Comment[Self]:
+        """Fetch a comment by its ID.
 
-class AsyncIterator(Generic[T]):
-    """A class from which async iterators (see :pep:`525`) can ben easily derived.
+        Parameters
+        ----------
+        id
+            The ID of the comment to fetch.
+        """
+        from .comment import Comment
 
-    .. container:: operations
+        comment = await self._state.fetch_comment(self, id)
+        return Comment(
+            self._state,
+            id=comment.id,
+            content=comment.content,
+            created_at=DateTime.from_timestamp(comment.timestamp),
+            author=await self._state._maybe_user(comment.author_id64),
+            owner=self,
+            reactions=[AwardReaction(self._state, reaction) for reaction in comment.reactions],
+        )
 
-        .. describe:: async for y in x
+    async def comment(self, content: str, *, subscribe: bool = True) -> Comment[Self]:
+        """Post a comment to a comments section.
 
-            Iterates over the contents of the async iterator.
+        Parameters
+        ----------
+        content
+            The message to add to the comment section.
+        subscribe
+            Whether to subscribe to notifications on any future activity in this comment's thread.
 
-    Attributes
-    ----------
-    before
-        When to find objects before.
-    after
-        When to find objects after.
-    limit
-        The maximum number of elements to be yielded.
-    """
+        Returns
+        -------
+        The created comment.
+        """
+        return await self._state.post_comment(self, content, subscribe)
 
-    def __init__(
+    async def comments(
         self,
-        state: ConnectionState,
+        *,
+        oldest_first: bool = False,
         limit: int | None = None,
         before: datetime | None = None,
         after: datetime | None = None,
-    ):
-        self._state = state
-        self.before = before or DateTime.now()
-        self.after = after or UNIX_EPOCH
-        self._is_filled = False
-        self.limit = limit
-        self._fill = self.fill()
-        self._seen = 0
-
-    async def _fill_queue_users(
-        self,
-        iterable: Iterable[T],
-        attributes: tuple[str, ...] = ("author",),
-        *,
-        user_attribute_name: str | None = None,
-    ) -> None:
-        user_attribute_name = user_attribute_name or attributes[0]
-        users = await self._state._maybe_users(getattr(element, user_attribute_name) for element in iterable)
-        for user, element in itertools.product(
-            users,
-            iterable,
-        ):
-            for attribute in attributes:
-                if getattr(element, attribute, None) == user:
-                    setattr(element, attribute, user)
+    ) -> AsyncGenerator[Comment[Self], None]:
+        """An :term:`async iterator` for accessing a comment section's :class:`~steam.Comment` objects.
 
-    async def get(self, **attrs: Any) -> T | None:
-        """A helper function which is similar to :func:`~steam.utils.get` except it runs over the async iterator.
+        Examples
+        --------
 
-        This is roughly equivalent to:
+        Usage:
 
         .. code-block:: python3
 
+            async for comment in commentable.comments(limit=10):
+                print("Author:", comment.author, "Said:", comment.content)
 
-            elements = await async_iterator.flatten()
-            element = steam.utils.get(elements, name="Item")
-
-        Example
-        -------
-        Getting the last comment from a user named 'Dave' or None:
-
-        .. code-block:: python3
-
-            comment = await user.comments().get(author__name="Dave")
+        All parameters are optional.
 
         Parameters
         ----------
-        attrs
-            Keyword arguments that denote attributes to match.
-
-        Returns
-        -------
-        The first element from the ``iterable`` which matches all the traits passed in ``attrs`` or ``None`` if no
-        matching element was found.
+        oldest_first
+            Whether or not to request comments with the oldest comments first or last. Defaults to ``False``.
+        limit
+            The maximum number of comments to search through.
+            Default is ``None`` which will fetch the all the comments in the comments section.
+        before
+            A time to search for comments before.
+        after
+            A time to search for comments after.
+
+        Yields
+        ---------
+        :class:`~steam.Comment`
         """
+        from .comment import Comment
+        from .reaction import AwardReaction
 
-        def predicate(elem: T) -> bool:
-            for attr, val in attrs.items():
-                nested = attr.split("__")
-                obj = elem
-                for attribute in nested:
-                    obj = getattr(obj, attribute)
+        after = after or UNIX_EPOCH
+        before = before or DateTime.now()
+        count: int | None = None
+        total_count = 0
+        yielded = 0
 
-                if obj != val:
-                    return False
-            return True
+        async def get_comments(chunk: int) -> list[Comment[Self]]:
+            nonlocal after, before, count, total_count, yielded
+
+            starting_from = total_count - count if total_count and count else 0
+            proto = await self._state.fetch_comments(self, chunk, starting_from, oldest_first)
 
-        return await self.find(predicate)
+            if count is None:
+                total_count = count = proto.total_count
 
-    async def find(self, predicate: MaybeCoro[T]) -> T | None:
-        """A helper function which is similar to :func:`~steam.utils.find` except it runs over the async iterator.
-        However, unlike :func:`~steam.utils.find`, the predicate provided can be a |coroutine_link|_.
+            comments: list[Comment[Self]] = []
+            comment = None
+            for comment in proto.comments:
+                comment = Comment(
+                    self._state,
+                    id=comment.id,
+                    content=comment.content,
+                    created_at=DateTime.from_timestamp(comment.timestamp),
+                    reactions=[AwardReaction(self._state, reaction) for reaction in comment.reactions],
+                    author=ID(comment.author_id64),
+                    owner=self,
+                )
+                if after < comment.created_at < before:
+                    if limit is not None and yielded >= limit:
+                        break
+                    comments.append(comment)
+                    yielded += 1
+                else:
+                    break
 
-        This is roughly equivalent to:
+            count -= len(comments)
+            return comments
 
-        .. code-block:: python3
+        comments = await get_comments(min(limit or 100, 100))
+        for comment, author in zip(
+            comments, await self._state._maybe_users(comment.author.id64 for comment in comments)
+        ):
+            comment.author = author
+            yield comment
 
-            elements = await async_iterator.flatten()
-            element = steam.utils.find(elements, lambda e: e.name == "Item")
+        assert count is not None
+        while count > 0:
+            comments = await get_comments(min(limit or 100, 100))
+            for comment, author in zip(
+                comments, await self._state._maybe_users(comment.author.id64 for comment in comments)
+            ):
+                comment.author = author
+                yield comment
 
-        Example
-        -------
-        Getting the last trade with a message or None:
 
-        .. code-block:: python3
+class Awardable(Protocol):
+    """A mixin that implements award functionality."""
 
-            def predicate(trade: steam.TradeOffer) -> bool:
-                return trade.message is not None
+    __slots__ = ()
 
+    id: int
+    _state: ConnectionState
+    _AWARDABLE_TYPE: ClassVar[int]
 
-            trade = await client.trade_history().find(predicate)
+    async def award(self, award: Award) -> None:
+        """Add an :class:`Award` to this piece of user generated content.
 
         Parameters
         ----------
-        predicate
-            A callable/coroutine that returns a boolean.
+        award
+            The award to add.
+        """
+        await self._state.add_award(self, award)
+
+    # async def fetch_reactions(self) -> list[AwardReaction]:
+    #     """Fetch the reactions on this piece of user generated content."""
+    #     reactions = await self._state.fetch_award_reactions(self)
+    #     return [AwardReaction(self._state, reaction) for reaction in reactions]
+
+
+@dataclass(slots=True)
+class UserInventoryInfo:
+    user: BaseUser
+    app: UserInventoryInfoApp
+    total_count: int
+    trade_permissions: str
+    load_failed: bool
+    store_vetted: bool
+    owner_only: bool
+    contexts: list[UserInventoryInfoContext]
+
+    async def all_inventories(self) -> AsyncGenerator[Inventory, None]:
+        """An :term:`async iterator` for accessing a user's full inventory in an app."""
+        for context in self.contexts:
+            yield await self.user.inventory(App(id=self.app.id, context_id=context.id))
+
+
+class BaseUser(ID, Commentable):
+    """An ABC that details the common operations on a Steam user.
+    The following classes implement this ABC:
+
+        - :class:`~steam.User`
+        - :class:`~steam.ClientUser`
+
+    .. container:: operations
+
+        .. describe:: x == y
+
+            Checks if two users are equal.
+
+        .. describe:: str(x)
+
+            Returns the user's name.
+
+    Attributes
+    ----------
+    name
+        The user's username.
+    state
+        The current persona state of the account (e.g. LookingToTrade).
+    app
+        The App instance attached to the user. Is ``None`` if the user isn't in an app or one that is recognised by the
+        api.
+    last_logoff
+        The last time the user logged into steam. Could be None (e.g. if they are currently online).
+    flags
+        The persona state flags of the account.
+    rich_presence
+        The user's rich presence.
+    """
+
+    __slots__ = ()
+
+    name: str
+    last_logoff: datetime | None
+    last_logon: datetime | None
+    last_seen_online: datetime | None
+    app: PartialApp | None
+    state: PersonaState | None
+    flags: PersonaStateFlag | None
+    rich_presence: dict[str, str] | None
+    game_server_ip: IPv4Address | IPv6Address | None
+    game_server_port: int | None
+    _avatar_sha: bytes
+    _state: ConnectionState
+
+    def __repr__(self) -> str:
+        attrs = ("name", "state", "id", "universe", "instance")
+        resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
+        return f"<{self.__class__.__name__} {' '.join(resolved)}>"
+
+    def __str__(self) -> str:
+        return self.name
+
+    @property
+    def _commentable_kwargs(self) -> _CommentableKwargs:
+        return {
+            "id64": self.id64,
+        }
+
+    @property
+    def mention(self) -> str:
+        """The string used to mention the user in chat."""
+        return f"[mention={self.id}]@{self.name}[/mention]"
+
+    @property
+    def avatar(self) -> Avatar:
+        return Avatar(self._state, self._avatar_sha)
+
+    async def server(self) -> GameServer:
+        """Fetch the game server this user is currently playing on."""
+        if self.game_server_ip is None:
+            raise ValueError("User is not playing on a game server")
+        server = await self._state.client.fetch_server(
+            ip=self.game_server_ip, port=self.game_server_port if self.game_server_port is not None else MISSING
+        )
+        assert server is not None
+        return server
+
+    async def inventory_info(self) -> list[UserInventoryInfo]:
+        """Fetch the inventory info of the user.
 
         Returns
         -------
-        The first element from the iterator for which the ``predicate`` returns ``True`` or ``None`` if no matching
-        element was found.
+        UserInventoryInfo is a dataclass defined as:
+
+        .. source:: UserInventoryInfo
         """
-        async for elem in self:
-            ret = await utils.maybe_coroutine(predicate, elem)
-            if ret:
-                return elem
-
-    async def flatten(self) -> list[T]:
-        """A helper function that iterates over the :class:`AsyncIterator` returning a list of all the elements in the
-        iterator.
+        resp = await self._state.http.get(URL.COMMUNITY / f"profiles/{self.id64}/inventory")
+        soup = BeautifulSoup(resp, "html.parser")
+        for script in soup.find_all("script", type="text/javascript"):
+            if match := re.search(r"var g_rgAppContextData\s*=\s*(?P<json>{.*?});\s*", script.text):
+                break
+        else:
+            raise ValueError("Could not find inventory info")
+
+        app_context_data = JSON_LOADS(match["json"])
+
+        return [
+            UserInventoryInfo(
+                user=self,
+                app=UserInventoryInfoApp(
+                    self._state,
+                    id=info["appid"],
+                    name=info["name"],
+                    inventory_logo_url=info["inventory_logo"],
+                    icon_url=info["icon"],
+                ),
+                total_count=info["asset_count"],
+                trade_permissions=info["trade_permissions"],
+                load_failed=bool(info["load_failed"]),
+                store_vetted=bool(info["store_vetted"]),
+                owner_only=info["owner_only"],
+                contexts=[
+                    UserInventoryInfoContext(ContextID(ctx["id"]), ctx["name"], ctx["asset_count"])
+                    for ctx in info["rgContexts"].values()
+                ],
+            )
+            for info in app_context_data.values()
+        ]
 
-        This is equivalent to:
+    async def inventory(self, app: App, *, language: Language | None = None) -> Inventory:
+        """Fetch a user's :class:`~steam.Inventory` for trading.
 
-        .. code-block:: python3
+        Parameters
+        -----------
+        app
+            The app to fetch the inventory for.
+        language
+            The language to fetch the inventory in. If ``None`` will default to the current language.
 
-            elements = [element async for element in async_iterator]
+        Raises
+        ------
+        :exc:`~steam.Forbidden`
+            The user's inventory is private.
         """
-        return [element async for element in self]
+        resp = await self._state.fetch_user_inventory(self.id64, app.id, app.context_id, language)
+        return Inventory(state=self._state, data=resp, owner=self, app=app, language=language)
 
-    def filter(self, predicate: Callable[[T], bool]) -> FilteredIterator[T]:
-        """Filter members of the async iterator according to a predicate. This function acts similarly to :func:`filter`.
+    async def friends(self) -> list[User | ID]:
+        """Fetch the list of the users friends."""
+        friends = await self._state.http.get_friends_ids(self.id64)
+        return await self._state._maybe_users(friends)
 
-        Examples
-        --------
-        .. code-block:: python3
-
-            for dave in async_iterator.filter(lambda x: x.name == "Dave"):
-                ...  # the element now has to have a name of Dave.
+    async def apps(self, *, include_free: bool = True) -> list[UserApp]:
+        r"""Fetches the :class:`~steam.App`\s the user owns.
 
         Parameters
         ----------
-        predicate
-            The predicate to filter elements through.
+        include_free
+            Whether to include free apps in the list. Defaults to ``True``.
         """
-        return FilteredIterator(predicate, self)
+        apps = await self._state.fetch_user_apps(self.id64, include_free)
+        return [UserApp(self._state, app) for app in apps]
 
-    def map(self, func: Callable[[TT], Any]) -> MappedIterator[T, TT]:
-        """Map the elements of the async iterator through a function. This function acts similarly to :func:`map`.
+    async def wishlist(self) -> list[WishlistApp]:
+        r"""Get the :class:`.WishlistApp`\s the user has on their wishlist."""
+        data = await self._state.http.get_wishlist(self.id64)
+        return [WishlistApp(self._state, id=id, data=app_info) for id, app_info in data.items()]
+
+    async def clans(self) -> list[Clan]:
+        r"""Fetches a list of :class:`~steam.Clan`\s the user is in."""
+
+        async def getter(gid: int) -> Clan:
+            try:
+                clan = await self._state.client.fetch_clan(gid)
+                assert clan is not None
+                return clan
+            except WSException as exc:
+                if exc.code == Result.RateLimitExceeded:
+                    await asyncio.sleep(20)
+                    return await getter(gid)
+                raise
+
+        resp = await self._state.http.get_user_clans(self.id64)
+        return await asyncio.gather(*(getter(int(clan["gid"])) for clan in resp["response"]["groups"]))  # type: ignore
+
+    async def bans(self) -> Ban:
+        r"""Fetches the user's :class:`.Ban`\s."""
+        resp = await self._state.http.get_user_bans(self.id64)
+        resp = resp["players"][0]
+        resp["EconomyBan"] = resp["EconomyBan"] != "none"
+        return Ban(data=resp)
+
+    async def is_banned(self) -> bool:
+        """Specifies if the user is banned from any part of Steam.
+
+        Shorthand for:
 
-        Examples
-        --------
         .. code-block:: python3
 
-            for name in async_iterator.map(lambda x: x.name):
-                ...  # name is now the iterators element's name.
+            bans = await user.bans()
+            bans.is_banned()
+        """
+        bans = await self.bans()
+        return bans.is_banned()
+
+    async def level(self) -> int:
+        """Fetches the user's level."""
+        badges = await self.badges()
+        return badges.level
+
+    async def badges(self) -> UserBadges:
+        r"""Fetches the user's :class:`.UserBadges`\s."""
+        resp = await self._state.http.get_user_badges(self.id64)
+        return UserBadges(self._state, self, data=resp["response"])
+
+    async def favourite_badge(self) -> FavouriteBadge | None:
+        """The user's favourite badge."""
+        badge = await self._state.fetch_user_favourite_badge(self.id64)
+        if not badge.has_favorite_badge:
+            return
+
+        return FavouriteBadge(
+            id=badge.badgeid,
+            community_item_id=badge.communityitemid,
+            type=badge.item_type,
+            border_colour=badge.border_color,
+            app=PartialApp(self._state, id=badge.appid) if badge.appid else None,
+            level=badge.level,
+        )
+
+    async def equipped_profile_items(self, *, language: Language | None = None) -> EquippedProfileItems:
+        """The user's equipped profile items.
 
         Parameters
         ----------
-        func
-            The function to map the elements through.
+        language
+            The language to fetch the profile items in. If ``None`` the current language is used
         """
-        return MappedIterator(func, self)
+        items = await self._state.fetch_user_equipped_profile_items(self.id64, language)
+        return EquippedProfileItems(
+            background=ProfileItem(self._state, self, items.profile_background) if items.profile_background else None,
+            mini_profile_background=(
+                ProfileItem(self._state, self, items.mini_profile_background) if items.mini_profile_background else None
+            ),
+            avatar_frame=ProfileItem(self._state, self, items.avatar_frame) if items.avatar_frame else None,
+            animated_avatar=ProfileItem(self._state, self, items.animated_avatar) if items.animated_avatar else None,
+            modifier=ProfileItem(self._state, self, items.profile_modifier) if items.profile_modifier else None,
+        )
 
-    def __aiter__(self) -> Self:
-        return self
+    async def profile_customisation_info(self) -> ProfileCustomisation:
+        """Fetch a user's profile customisation information."""
+        info = await self._state.fetch_user_profile_customisation(self.id64)
+        return ProfileCustomisation(self._state, self, info)
 
-    def __anext__(self) -> Coroutine[None, None, T]:
-        self._seen += 1
-        if self.limit and self._seen > self.limit:
-            raise StopAsyncIteration
-        return self._fill.__anext__()  # type: ignore  # this is typed wrong
+    async def profile(self, *, language: Language | None = None) -> Profile:
+        """Fetch a user's entire profile information.
 
-    async def next(self) -> T:
-        """Advances the iterator by one, if possible.
+        Parameters
+        ----------
+        language
+            The language to fetch the profile items in. If ``None`` the current language is used
 
-        Raises
-        ------
-        :exc:`StopAsyncIteration`
-            There are no more elements in the iterator.
+        Note
+        ----
+        This calls all the profile related functions to return a Profile object which has all the info set.
         """
-        return await self.__anext__()
 
-    async def fill(self) -> AsyncGenerator[T, None]:
-        raise NotImplementedError
-        yield
+        return Profile(
+            *await asyncio.gather(
+                self.equipped_profile_items(language=language),
+                self.profile_customisation_info(),
+            )
+        )
 
+    async def reviews(
+        self,
+        *,
+        limit: int | None = None,
+        before: datetime | None = None,
+        after: datetime | None = None,
+    ) -> AsyncGenerator[Review, None]:
+        """An :term:`async iterator` for accessing a user's :class:`~steam.Review`\\s.
 
-class FilteredIterator(AsyncIterator[T]):
-    def __init__(self, predicate: MaybeCoro[T], async_iterator: AsyncIterator[T]):
-        self.predicate = predicate
-        self.iterator = async_iterator
+        Examples
+        --------
+        Usage:
 
-    async def next(self) -> T:
-        while True:
-            item = await self.iterator.next()
-            if await utils.maybe_coroutine(self.predicate, item):
-                return item
+        .. code-block:: python3
 
+            async for review in user.reviews(limit=10):
+                print(f"Author: {review.author} {'recommended' if review.recommend 'doesn\\'t recommend'} {review.app}")
 
-class MappedIterator(AsyncIterator[TT], Generic[T, TT]):
-    def __init__(self, map_func: Callable[[Any], TT | Coroutine[Any, Any, TT]], async_iterator: AsyncIterator[T]):
-        self.map_func = map_func
-        self.iterator = async_iterator
+        All parameters are optional.
 
-    async def next(self) -> TT:
-        item = await self.iterator.next()
-        return await utils.maybe_coroutine(self.map_func, item)
+        Parameters
+        ----------
+        limit
+            The maximum number of reviews to search through. Setting this to ``None`` will fetch all the
+            user's reviews.
+        before
+            A time to search for reviews before.
+        after
+            A time to search for reviews after.
 
+        Yields
+        ------
+        :class:`~steam.Review`
+        """
+        from .review import Review
 
-class CommentsIterator(AsyncIterator["Comment[CommentableT]"]):
-    def __init__(
-        self,
-        owner: CommentableT,
-        oldest_first: bool,
-        state: ConnectionState,
-        limit: int | None,
-        before: datetime | None,
-        after: datetime | None,
-    ):
-        self.owner = owner
-        self.oldest_first = oldest_first
-        super().__init__(state, limit, before, after)
+        pages = 1
+        after = after or UNIX_EPOCH
+        before = before or DateTime.now()
+        yielded = 0
 
-    async def fill(self) -> AsyncGenerator["Comment[CommentableT]", None]:
-        from .comment import Comment
-        from .reaction import AwardReaction
+        async def get_reviews(page_number: int = 1) -> AsyncGenerator[Review, None]:
+            nonlocal yielded, pages
 
-        after = self.after
-        before = self.before
-        count: int | None = None
-        total_count = 0
+            # ideally I'd like to find an actual api for these
+            page = await self._state.http.get(
+                URL.COMMUNITY / f"profiles/{self.id64}/recommended", params={"p": page_number}
+            )
+            soup = BeautifulSoup(page, HTML_PARSER)
+            if pages == 1:
+                *_, pages = [1] + [int(a["href"].removeprefix("?p=")) for a in soup.find_all("a", class_="pagelink")]
+            app_ids = [
+                int(URL_(review.find("div", class_="leftcol").a["href"]).parts[-1])
+                for review in soup.find_all("div", class_="review_box_content")
+            ]
 
-        async def get_comments(chunk: int) -> list[Comment[CommentableT]]:
-            nonlocal after, before, count, total_count
+            for review_ in await self._state.fetch_user_reviews(self.id64, app_ids):
+                review = Review._from_proto(self._state, review_, self)
+                if not after < review.created_at < before:
+                    return
+                if limit is not None and yielded >= limit:
+                    return
 
-            starting_from = total_count - count if total_count and count else 0
-            proto = await self._state.fetch_comments(self.owner, chunk, starting_from, self.oldest_first)
+                yield review
+                yielded += 1
 
-            if count is None:
-                total_count = count = proto.total_count
+        async for review in get_reviews():
+            yield review
 
-            comments: list[Comment[CommentableT]] = []
-            comment = None
-            for comment in proto.comments:
-                comment = Comment(
-                    self._state,
-                    id=comment.id,
-                    content=comment.content,
-                    created_at=DateTime.from_timestamp(comment.timestamp),
-                    reactions=[AwardReaction(self._state, reaction) for reaction in comment.reactions],
-                    author=comment.author_id64,  # type: ignore
-                    owner=self.owner,
-                )
-                if self.after < comment.created_at < self.before:
-                    comments.append(comment)
-                else:
-                    break
+        for page in range(2, pages + 1):
+            async for review in get_reviews(page):
+                yield review
 
-            await self._fill_queue_users(comments)
-            count -= len(comments)
-            return comments
+    async def fetch_review(self, app: App) -> Review:
+        """Fetch this user's review for an app.
 
-        for comment in await get_comments(min(self.limit or 100, 100)):
-            yield comment
+        Parameters
+        ----------
+        app
+            The apps to fetch the reviews for.
+        """
+        (review,) = await self.fetch_reviews(app)
+        return review
 
-        assert count is not None
-        while count > 0:
-            for comment in await get_comments(min(count, 100)):
-                yield comment
+    async def fetch_reviews(self, *apps: App) -> list[Review]:
+        """Fetch this user's review for apps.
 
+        Parameters
+        ----------
+        apps
+            The apps to fetch the reviews for.
+        """
+        from .review import Review
+
+        reviews = await self._state.fetch_user_reviews(self.id64, (app.id for app in apps))
+        return [Review._from_proto(self._state, review, self) for review in reviews]
 
-class TradesIterator(AsyncIterator["TradeOffer"]):
-    def __init__(
+    async def published_files(
         self,
-        state: ConnectionState,
-        limit: int | None,
-        before: datetime | None,
-        after: datetime | None,
-        language: Language | None,
-    ):
-        super().__init__(state, limit, before, after)
-        self.language = language
-
-    async def fill(self) -> AsyncGenerator[TradeOffer, None]:
-        from .trade import TradeOffer
-
-        total = 100
-        previous_time = 0
-        after_timestamp = self.after.timestamp()
-        before_timestamp = self.before.timestamp()
-
-        async def get_trades(page: int = 100) -> list[TradeOffer]:
-            nonlocal total, previous_time
-            resp = await self._state.http.get_trade_history(page, previous_time, self.language)
-            data = resp["response"]
-            if total is None:
-                total = data.get("total_trades", 0)
-            if not total:
-                return []
-
-            trades: list[TradeOffer] = []
-            descriptions = data.get("descriptions", ())
-            trade = None
-            for trade in data.get("trades", []):
-                if not after_timestamp < trade["time_init"] < before_timestamp:
-                    break
-                for item in descriptions:
-                    for asset in trade.get("assets_received", []):
-                        if item["classid"] == asset["classid"] and item["instanceid"] == asset["instanceid"]:
-                            asset.update(item)
-                    for asset in trade.get("assets_given", []):
-                        if item["classid"] == asset["classid"] and item["instanceid"] == asset["instanceid"]:
-                            asset.update(item)
-
-                trades.append(TradeOffer._from_history(state=self._state, data=trade))
-
-            assert trade is not None
-            previous_time = trade["time_init"]
-            await self._fill_queue_users(trades, ("partner",))
-            return trades
-
-        for trade in await get_trades():
-            for item in trade.items_to_receive:
-                item.owner = trade.partner
-            yield trade
-
-        if total < 100:
-            for page in range(200, math.ceil((total + 100) / 100) * 100, 100):
-                for trade in await get_trades(page):
-                    for item in trade.items_to_receive:
-                        item.owner = trade.partner
-                    yield trade
+        *,
+        app: App | None = None,
+        revision: PublishedFileRevision = PublishedFileRevision.Default,
+        type: PublishedFileType = PublishedFileType.Community,
+        language: Language | None = None,
+        limit: int | None = None,
+        before: datetime | None = None,
+        after: datetime | None = None,
+    ) -> AsyncGenerator[PublishedFile, None]:
+        """An :term:`async iterator` for accessing a user's :class:`~steam.PublishedFile`\\s.
 
+        Examples
+        --------
 
-class DMChannelHistoryIterator(AsyncIterator["UserMessage"]):
-    def __init__(
-        self,
-        channel: DMChannel,
-        state: ConnectionState,
-        limit: int | None,
-        before: datetime | None,
-        after: datetime | None,
-    ):
-        super().__init__(state, limit, before, after)
-        self.channel = channel
-        self.participant = channel.participant
+        Usage:
 
-    async def fill(self) -> AsyncGenerator[UserMessage, None]:
-        from .message import Message, UserMessage
-        from .reaction import Emoticon, MessageReaction, Sticker
+        .. code-block:: python3
 
-        after_timestamp = int(self.after.timestamp())
-        before_timestamp = int(self.before.timestamp())
+            async for file in user.published_files(limit=10):
+                print("Author:", file.author, "Published:", file.name)
 
-        last_message_timestamp = before_timestamp
-        ordinal = 0
+        All parameters are optional.
 
-        while True:
-            resp = await self._state.fetch_user_history(
-                self.participant.id64, start=after_timestamp, last=last_message_timestamp, start_ordinal=ordinal
-            )
+        Parameters
+        ----------
+        app
+            The app to fetch published files in.
+        type
+            The type of published file to fetch.
+        revision
+            The desired revision of the published file to fetch.
+        language
+            The language to fetch the published file in. If ``None``, the current language is used.
+        limit
+            The maximum number of published files to search through. Setting this to ``None`` will fetch all of the
+            user's published files.
+        before
+            A time to search for published files before.
+        after
+            A time to search for published files after.
+
+        Yields
+        ------
+        :class:`~steam.PublishedFile`
+        """
+        from .published_file import PublishedFile
 
-            message: friend_messages.GetRecentMessagesResponseFriendMessage | None = None
+        before = before or DateTime.now()
+        after = after or UNIX_EPOCH
+        app_id = app.id if app else 0
+        total = 30
+        yielded = 0
+
+        while yielded < total:
+            page = yielded // 30 + 1
+            msg = await self._state.fetch_user_published_files(self.id64, app_id, page, type, revision, language)
+            if msg.total:
+                total = msg.total
 
-            for message in resp.messages:
-                new_message = UserMessage.__new__(UserMessage)
-                new_message.created_at = DateTime.from_timestamp(message.timestamp)
-                if not self.after < new_message.created_at < self.before:
+            for file in msg.publishedfiledetails:
+                file = PublishedFile(self._state, file, self)
+                if not after < file.created_at < before:
+                    return
+                if limit is not None and yielded >= limit:
                     return
+                yield file
+                yielded += 1
 
-                Message.__init__(new_message, channel=self.channel, proto=message)
-                new_message.author = self.participant if message.accountid == self.participant.id else self._state.user
-                emoticon_reactions = [
-                    MessageReaction(
-                        self._state,
-                        new_message,
-                        Emoticon(self._state, r.reaction),
-                        None,
-                        self.participant if reactor == self.participant.id else self._state.user,
-                    )
-                    for r in message.reactions
-                    if r.reaction_type == 1
-                    for reactor in r.reactors
-                ]
-                sticker_reactions = [
-                    MessageReaction(
-                        self._state,
-                        new_message,
-                        None,
-                        Sticker(self._state, r.reaction),
-                        self.participant if reactor == self.participant.id else self._state.user,
-                    )
-                    for r in message.reactions
-                    if r.reaction_type == 2
-                    for reactor in r.reactors
-                ]
-                new_message.reactions = emoticon_reactions + sticker_reactions
-
-                yield new_message
-
-            if message is None:
-                return
-
-            last_message_timestamp = message.timestamp
-            ordinal = message.ordinal
-
-            if not resp.more_available:
-                return
+    async def fetch_post(self, id: int) -> Post:
+        ...
 
+    def posts(self) -> AsyncIterator[Post]:
+        ...
 
-ChatMessageT = TypeVar("ChatMessageT", bound="ChatMessage", covariant=True)
-ChatT = TypeVar("ChatT", bound="Chat[Any]", covariant=True)
 
+@runtime_checkable
+class Messageable(Protocol[M_co]):
+    """An ABC that details the common operations on a Steam message.
+    The following classes implement this ABC:
 
-class ChatHistoryIterator(AsyncIterator[ChatMessageT], Generic[ChatMessageT, ChatT]):
-    def __init__(
-        self,
-        channel: ChatT,
-        state: ConnectionState,
-        limit: int | None,
-        before: datetime | None,
-        after: datetime | None,
-    ):
-        super().__init__(state, limit, before, after)
-        self.channel = channel
-        self.group: Group | Clan = channel.group or channel.clan  # type: ignore
+        - :class:`~steam.User`
+        - :class:`~steam.ClanChannel`
+        - :class:`~steam.GroupChannel`
+        - :class:`~steam.DMChannel`
+    """
 
-    async def fill(self) -> AsyncGenerator[ChatMessageT, None]:
-        from .abc import SteamID
-        from .message import Message
-        from .reaction import Emoticon, PartialMessageReaction, Sticker
-
-        after_timestamp = int(self.after.timestamp())
-        before_timestamp = int(self.before.timestamp())
-        last_message_timestamp = before_timestamp
-        last_ordinal: int = getattr(self.channel.last_message, "ordinal", 0)
-        message_cls: type[ChatMessageT] = self.channel._type_args[0]
-
-        while True:
-            resp = await self._state.fetch_group_history(
-                *self.channel._location, start=after_timestamp, last=last_message_timestamp, last_ordinal=last_ordinal
-            )
-            message = None
-            messages: list[ChatMessageT] = []
+    __slots__ = ()
 
-            for message in resp.messages:
-                new_message = message_cls.__new__(message_cls)
-                Message.__init__(new_message, channel=self.channel, proto=message)
-                new_message.created_at = DateTime.from_timestamp(message.server_timestamp)
-                if not self.after < new_message.created_at < self.before:
-                    return
+    @abc.abstractmethod
+    def _message_func(self, content: str) -> Coroutine[Any, Any, M_co]:
+        raise NotImplementedError
 
-                new_message.author = SteamID(message.sender)
-                emoticon_reactions = [
-                    PartialMessageReaction(
-                        self._state,
-                        new_message,
-                        Emoticon(self._state, r.reaction),
-                        None,
-                    )
-                    for r in message.reactions
-                    if r.reaction_type == 1
-                ]
-                sticker_reactions = [
-                    PartialMessageReaction(
-                        self._state,
-                        new_message,
-                        None,
-                        Sticker(self._state, r.reaction),
-                    )
-                    for r in message.reactions
-                    if r.reaction_type == 2
-                ]
-                new_message.partial_reactions = emoticon_reactions + sticker_reactions
-
-                messages.append(new_message)
-
-            if message is None:
-                return
-
-            await self._fill_queue_users(messages)
-            for message in messages:
-                yield message
-
-            last_message_timestamp = message.server_timestamp
-            last_ordinal = message.ordinal
+    @abc.abstractmethod
+    def _image_func(self, image: Image) -> Coroutine[Any, Any, None]:
+        raise NotImplementedError
 
-            if not resp.more_available:
-                return
+    async def send(self, content: Any = None, image: Image | None = None) -> M_co | None:
+        """Send a message to a certain destination.
 
+        Parameters
+        ----------
+        content
+            The content of the message to send.
+        image
+            The image to send to the user.
+
+        Note
+        ----
+        Anything as passed to ``content`` is implicitly cast to a :class:`str`.
 
-class GameReviewsIterator(AsyncIterator["Review"]):
-    def __init__(
-        self,
-        state: ConnectionState,
-        game: StatefulGame,
-        limit: int | None = None,
-        before: datetime | None = None,
-        after: datetime | None = None,
-    ):  # TODO add support for the other params and make this more efficient
-        super().__init__(state, limit, before, after)
-        self.game = game
-
-    async def fill(self) -> AsyncGenerator[Review, None]:
-        from .review import Review, ReviewGame
-
-        cursor = "*"
-        while True:
-            data = await self._state.http.get_reviews(self.game.id, "all", "all", "all", cursor)
-            if cursor == "*":
-                self.game = ReviewGame(self._state, self.game.id, data["query_summary"]["review_score"])
-            assert isinstance(self.game, ReviewGame)
-            cursor = data["cursor"]
-            reviews = data["reviews"]
-
-            for review, user in zip(
-                reviews,
-                await self._state.fetch_users(int(review["author"]["steamid"]) for review in reviews),
-            ):
-                if user is None:
-                    continue
-                review = Review._from_data(self._state, review, self.game, user)
-                if not self.after < review.created_at < self.before:
-                    return
+        Raises
+        ------
+        :exc:`~steam.HTTPException`
+            Sending the message failed.
+        :exc:`~steam.Forbidden`
+            You do not have permission to send the message.
 
-                yield review
+        Returns
+        -------
+        The sent message, only applicable if ``content`` is passed.
+        """
+        message = None if content is None else await self._message_func(str(content))
+        if image is not None:
+            await self._image_func(image)
+
+        return message
 
 
-class UserReviewsIterator(AsyncIterator["Review"]):
-    def __init__(
+@dataclass(slots=True)
+class Channel(Messageable[M_co]):
+    _state: ConnectionState
+    clan: Clan | None = None
+    group: Group | None = None
+
+    @abc.abstractmethod
+    def history(
         self,
-        state: ConnectionState,
-        user: BaseUser,
-        limit: int | None = None,
+        *,
+        limit: int | None = 100,
         before: datetime | None = None,
         after: datetime | None = None,
-    ):
-        super().__init__(state, limit, before, after)
-        self.user = user
-
-    async def fill(self) -> AsyncGenerator[Review, None]:
-        from .review import Review
-
-        pages = 1
-
-        # ideally I'd like to find an actual api for these
-        async def get_app_ids(page_number: int = 1) -> list[int]:
-            nonlocal pages
-            page = await self._state.http.get(
-                URL.COMMUNITY / f"profiles/{self.user.id64}/recommended", params={"p": page_number}
-            )
-            soup = BeautifulSoup(page, HTML_PARSER)
-            if pages == 1:
-                *_, pages = [1] + [
-                    int(a["href"][len("?p=") :]) for a in soup.find_all("a", class_="pagelink")
-                ]  # str.removeprefix
-            return [
-                int(URL_(review.find("div", class_="leftcol").a["href"]).parts[-1])
-                for review in soup.find_all("div", class_="review_box_content")
-            ]
+    ) -> AsyncGenerator[M_co, None]:
+        """An :term:`async iterator` for accessing a channel's :class:`steam.Message`\\s.
 
-        for review_ in await self._state.fetch_user_review(self.user.id64, await get_app_ids()):
-            review = Review._from_proto(self._state, review_, self.user)
-            if not self.after < review.created_at < self.before:
-                return
+        Examples
+        --------
 
-            yield review
+        Usage:
 
-        for page in range(2, pages + 1):
-            for review_ in await self._state.fetch_user_review(self.user.id64, await get_app_ids(page)):
-                review = Review._from_proto(self._state, review_, self.user)
-                if not self.after < review.created_at < self.before:
-                    return
+        .. code-block:: python3
 
-                yield review
+            async for message in channel.history(limit=10):
+                print("Author:", message.author, "Said:", message.content)
 
+        All parameters are optional.
 
-class _EventIterator(AsyncIterator[T]):
-    ID_PARSE_REGEX: ClassVar[re.Pattern[str]]
+        Parameters
+        ----------
+        limit
+            The maximum number of messages to search through. Setting this to ``None`` will fetch all of the channel's
+            messages, but this will be a very slow operation.
+        before
+            A time to search for messages before.
+        after
+            A time to search for messages after.
 
-    def __init__(
-        self, clan: Clan, state: ConnectionState, limit: int | None, before: datetime | None, after: datetime | None
-    ):
-        super().__init__(state, limit, before, after)
-        self.clan = clan
-
-    async def fill(self) -> AsyncGenerator[T, None]:
-        cls = self.__class__
-        rss = await self._state.http.get_clan_rss(
-            self.clan.id64
-        )  # TODO make this use the calendar? does that work for announcements
-
-        soup = BeautifulSoup(rss, HTML_PARSER)
-
-        ids = []
-        for url in soup.find_all("guid"):
-            match = cls.ID_PARSE_REGEX.findall(url.text)
-            if match:
-                ids.append(int(match[0]))
+        Yields
+        ------
+        :class:`~steam.Message`
+        """
+        raise NotImplementedError
 
-        if not ids:
-            return
 
-        from . import event
+def _clean_up_content(content: str) -> str:  # steam does weird stuff with content
+    return content.replace(r"\[", "[").replace("\\\\", "\\")
 
-        event_cls: type[Announcement | Event[EventType]] = getattr(
-            event, cls.__orig_bases__[0].__args__[0].__forward_arg__  # type: ignore
-        )
-        events = []
-        for event_ in await self.get_events(ids):
-            event = event_cls(self._state, self.clan, event_)
-            if not self.after < event.starts_at < self.before:
-                return
-            events.append(event)
 
-        await self._fill_queue_users(events, ("author", "last_edited_by", "approved_by"))
+class Message(metaclass=abc.ABCMeta):
+    """Represents a message from a :class:`~steam.User`. This is a base class from which all messages inherit.
 
-        for event in events:
-            yield event
+    The following classes implement this:
 
-    async def get_events(self, ids: list[int]) -> list[dict[str, Any]]:
-        raise NotImplementedError
+        - :class:`~steam.UserMessage`
+        - :class:`~steam.GroupMessage`
+        - :class:`~steam.ClanMessage`
 
+    .. container:: operations
 
-class EventIterator(_EventIterator["Event[EventType]"]):
-    ID_PARSE_REGEX = re.compile(r"events/+(\d+)")
+        .. describe:: x == y
 
-    async def get_events(self, ids: list[int]) -> list[dict[str, Any]]:
-        data = await self._state.http.get_clan_events(self.clan.id, ids)
-        return data["events"]
+            Checks if two messages are equal
 
+        .. describe:: hash(x)
 
-class AnnouncementsIterator(_EventIterator["Announcement"]):
-    ID_PARSE_REGEX = re.compile(r"announcements/detail/(\d+)")
+            Returns the hash of a message.
 
-    async def get_events(self, ids: list[int]) -> list[dict[str, Any]]:
-        announcements = await asyncio.gather(*(self._state.http.get_clan_announcement(self.clan.id, id) for id in ids))
-        events = []
-        for announcement in announcements:
-            events += announcement["events"]
-        return events
+    """
 
+    __slots__ = (
+        "author",
+        "content",
+        "channel",
+        "clean_content",
+        "created_at",
+        "ordinal",
+        "group",
+        "clan",
+        "mentions",
+        "reactions",
+        "partial_reactions",
+        "_id_cs",
+        "_state",
+    )
+
+    author: Authors
+    """The message's author."""
+    channel: Channel[Self]
+    """The channel the message was sent in."""
+    content: str
+    """The message's content.
+
+    Note
+    ----
+    This is **not** what you will see in the steam client see :attr:`clean_content` for that.
+    """
+    clean_content: str
+    """The message's clean content without BBCode."""
+    created_at: datetime
+    """The time this message was sent at."""
+    clan: Clan | None
+    """The clan the message was sent in. Will be ``None`` if the message wasn't sent in a :class:`~steam.Clan`."""
+    group: Group | None
+    """The group the message was sent in. Will be ``None`` if the message wasn't sent in a :class:`~steam.Group`."""
+    reactions: list[MessageReaction]
+    """The message's reactions."""
+    ordinal: int
+    """A per-channel incremented integer up to ``1000`` for every message sent in a second window."""
+    mentions: Mentions | None
+    """An object representing mentions in this message."""
+    reactions: list[MessageReaction]
+    """The reactions this message has received."""
+    partial_reactions: list[PartialMessageReaction]
 
-class ManifestIterator(AsyncIterator["Manifest"]):
-    def __init__(
-        self,
-        state: ConnectionState,
-        limit: int | None,
-        before: datetime | None,
-        after: datetime | None,
-        game: StatefulGame,
-        branch: str,
-        password: str | None,
-        password_hash: str,
-    ):
-        super().__init__(state, limit, before, after)
-        self.game = game
-        self.branch = branch
-        self.password = password
-        self.password_hash = password_hash
-
-    async def fill(self) -> AsyncGenerator[Manifest, None]:
-        manifest_coros = await self._state.fetch_manifests(
-            self.game.id, self.branch, self.password, self.limit, self.password_hash
+    def __init__(self, channel: Channel[Self], proto: Any):
+        self._state: ConnectionState = channel._state
+        self.channel = channel
+        self.group = channel.group
+        self.clan = channel.clan
+        self.content = _clean_up_content(proto.message)
+        self.ordinal = proto.ordinal
+        self.clean_content = getattr(proto, "message_no_bbcode", "") or self.content
+        self.mentions = getattr(proto, "mentions", None)
+        self.partial_reactions = []
+        self.reactions = []
+
+    def __repr__(self) -> str:
+        attrs = ("author", "id", "channel")
+        resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
+        return f"<{self.__class__.__name__} {' '.join(resolved)}>"
+
+    def __eq__(self, other: object) -> bool:
+        return (
+            self.channel == other.channel and self.id == other.id
+            if isinstance(other, self.__class__)
+            else NotImplemented
         )
-        for chunk in utils.chunk(manifest_coros, 100):
-            for manifest in await asyncio.gather(*chunk):
-                if self.after < manifest.created_at < self.before:
-                    yield manifest
 
+    def __hash__(self) -> int:
+        return hash((self.channel, self.id))
 
-class UserPublishedFilesIterator(AsyncIterator["PublishedFile"]):
-    def __init__(
-        self,
-        state: ConnectionState,
-        user: BaseUser,
-        game: Game | None,
-        type: PublishedFileType = PublishedFileType.Community,
-        revision: PublishedFileRevision = PublishedFileRevision.Default,
-        language: Language | None = None,
-        limit: int | None = None,
-        before: datetime | None = None,
-        after: datetime | None = None,
-    ):
-        super().__init__(state, limit, before, after)
-        self.user = user
-        self.app_id = getattr(game, "id", 0)
-        self.revision = revision
-        self.type = type
-        self.language = language
-
-    async def fill(self):
-        from .published_file import PublishedFile
-
-        initial = await self._state.fetch_user_published_files(
-            self.user.id64, self.app_id, 1, self.type, self.revision, self.language
+    @cached_slot_property
+    def id(self) -> int:
+        """A unique identifier for every message sent in a channel.
+
+        Note
+        ----
+        This is **not** something Steam provides, this is meant to be a simple way to compare messages.
+        """
+        # a u64 "snowflake-esk" id measuring of the number of seconds passed since Steam's EPOCH and then the
+        # "sequence"/ordinal of the message.
+        return int(
+            f"{int((self.created_at - STEAM_EPOCH).total_seconds()):032b}{self.ordinal:032b}",
+            base=2,
         )
 
-        for file in initial.publishedfiledetails:
-            file = PublishedFile(self._state, file, self.user)
-            if not self.after < file.created_at < self.before:
-                return
-            yield file
-
-        for page in range(2, math.ceil((initial.total + 30) / 30)):
-            msg = await self._state.fetch_user_published_files(
-                self.user.id64, self.app_id, page, self.type, self.revision, self.language
-            )
+    # @abc.abstractmethod
+    # async def delete(self) -> None:
+    #     raise NotImplementedError()
+
+    @abc.abstractmethod
+    async def add_emoticon(self, emoticon: Emoticon) -> None:
+        """Adds an emoticon to this message.
 
-            for file in msg.publishedfiledetails:
-                file = PublishedFile(self._state, file, self.user)
-                if not self.after < file.created_at < self.before:
-                    return
-                yield file
+        Parameters
+        ----------
+        emoticon
+            The emoticon to add to this message.
+        """
+        raise NotImplementedError()
 
+    @abc.abstractmethod
+    async def remove_emoticon(self, emoticon: Emoticon) -> None:
+        """Removes an emoticon from this message.
 
-class GamePublishedFilesIterator(AsyncIterator["PublishedFile"]):
-    def __init__(
-        self,
-        state: ConnectionState,
-        game: Game,
-        type: PublishedFileQueryFileType = PublishedFileQueryFileType.Items,
-        revision: PublishedFileRevision = PublishedFileRevision.Default,
-        language: Language | None = None,
-        limit: int | None = 100,
-        before: datetime | None = None,
-        after: datetime | None = None,
-    ):
-        super().__init__(state, limit, before, after)
-        self.game = game
-        self.type = type
-        self.revision = revision
-        self.language = language
+        Parameters
+        ----------
+        emoticon
+            The emoticon to remove from this message.
+        """
+        raise NotImplementedError()
 
-    async def fill(self):
-        from .published_file import PublishedFile
+    @abc.abstractmethod
+    async def add_sticker(self, sticker: Sticker) -> None:
+        """Adds a sticker to this message.
 
-        remaining = None
-        cursor = "*"
+        Parameters
+        ----------
+        sticker
+            The sticker to add to this message.
+        """
+        raise NotImplementedError()
 
-        while remaining is None or remaining > 0:
-            protos = await self._state.fetch_game_published_files(
-                self.game.id, self.after, self.before, self.type, self.revision, self.language, self.limit, cursor
-            )
-            if remaining is None:
-                remaining = protos.total
-            remaining -= len(protos.publishedfiledetails)
-            cursor = protos.next_cursor
-
-            files: list[PublishedFile] = []
-            for file in protos.publishedfiledetails:
-                author: Authors = file.creator  # type: ignore
-                file = PublishedFile(self._state, file, author)
-                if not self.after < file.created_at < self.before:
-                    remaining = 0
-                    break
-                files.append(file)
+    @abc.abstractmethod
+    async def remove_sticker(self, sticker: Sticker) -> None:
+        """Adds a sticker to this message.
 
-            await self._fill_queue_users(files)
-            for file in files:
-                yield file
+        Parameters
+        ----------
+        sticker
+            The sticker to remove from this message.
+        """
+        raise NotImplementedError()
```

### Comparing `steamio-0.9.9/steam/manifest.py` & `steamio-1.0.0a0/steam/manifest.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,53 +5,39 @@
 import asyncio
 import errno
 import logging
 import lzma
 import struct
 import sys
 from base64 import b64decode
-from collections.abc import AsyncGenerator, Generator, Mapping
+from collections.abc import AsyncGenerator, Generator, Sequence
 from contextlib import asynccontextmanager
 from dataclasses import dataclass
 from datetime import datetime
 from io import BytesIO
 from operator import attrgetter, methodcaller
-from typing import TYPE_CHECKING, Any, Sequence, TypeVar, overload
+from typing import TYPE_CHECKING, Any, Final, cast
 from zipfile import BadZipFile, ZipFile
 from zlib import crc32
 
 from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
 from multidict import MultiDict
-from typing_extensions import Final, Never, Self, TypeGuard
+from typing_extensions import Never, Self
 from yarl import URL
 
 from . import utils
-from ._const import VDF_LOADS, VDFDict
-from .abc import SteamID
-from .enums import (
-    AppFlag,
-    BillingType,
-    DepotFileFlag,
-    Language,
-    LicenseType,
-    PackageStatus,
-    ReviewType,
-)
-from .game import StatefulGame
+from ._const import MISSING, VDF_LOADS, VDFDict
+from .app import PartialApp
+from .enums import AppFlag, BillingType, DepotFileFlag, Language, LicenseType, PackageStatus, ReviewType
+from .id import ID
 from .models import _IOMixin
-from .package import StatefulPackage
+from .package import PartialPackage
 from .protobufs import app_info
-from .protobufs.content_manifest import (
-    Metadata,
-    Payload,
-    PayloadFileMapping,
-    PayloadFileMappingChunkData,
-    Signature,
-)
-from .utils import DateTime
+from .protobufs.content_manifest import Metadata, Payload, PayloadFileMapping, PayloadFileMappingChunkData, Signature
+from .utils import DateTime, cached_slot_property
 
 if sys.platform == "win32":
     from pathlib import PureWindowsPath as PurePathBase
 else:
     from pathlib import PurePosixPath as PurePathBase
 
 
@@ -65,28 +51,27 @@
     "Manifest",
     "ManifestPath",
     "Branch",
     "ManifestInfo",
     "PrivateManifestInfo",
     "HeadlessDepot",
     "Depot",
-    "GameInfo",
+    "AppInfo",
     "PackageInfo",
 )
 
 log = logging.getLogger(__name__)
-NameT = TypeVar("NameT", bound="str | None", covariant=True)
 
 
 def unzip(data: bytes) -> bytes:
     if data[:2] == b"VZ":
         if data[-2:] != b"zv":
             raise RuntimeError(f"VZ: Invalid footer: {data[-2:]!r}")
-        if data[2:3] != b"a":
-            raise RuntimeError(f"VZ: Invalid version: {data[2:3]!r}")
+        if data[2] != 97:
+            raise RuntimeError(f"VZ: Invalid version: {data[2]!r}")
 
         filters = (lzma._decode_filter_properties(lzma.FILTER_LZMA1, data[7:12]),)  # type: ignore
         decompressor = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=filters)
         checksum, decompressed_size = struct.unpack("<II", data[-10:-2])
         data = decompressor.decompress(data[12:-9], max_length=decompressed_size)
 
         if crc32(data) != checksum:
@@ -98,45 +83,32 @@
                 data = zf.read(zf.filelist[0])
         except BadZipFile:
             pass
 
     return data
 
 
-@dataclass
-class ManifestPathParents(Sequence["ManifestPath"]):
-    # this class is mostly a copy and paste from pathlib.py
-    __slots__ = ("path",)
-    path: ManifestPath  # we don't care about reference cycles
+@dataclass(slots=True)
+class ManifestPathParents(cast(type[Sequence["ManifestPath"]], type(PurePathBase().parents))):
+    _path_cls: ManifestPath  # names lie
 
-    def __len__(self) -> int:
-        if self.path.drive or self.path.root:  # this should never be True but w/e
-            return len(self.path.parts) - 1
-        else:
-            return len(self.path.parts)
-
-    @overload
-    def __getitem__(self, idx: int) -> ManifestPath:
-        ...
-
-    @overload
-    def __getitem__(self, idx: slice) -> tuple[ManifestPath, ...]:
-        ...
-
-    def __getitem__(self, idx: int | slice) -> ManifestPath | tuple[ManifestPath, ...]:
-        if isinstance(idx, slice):
-            return tuple(self[i] for i in range(*idx.indices(len(self))))
+    @property
+    def _drv(self) -> str:
+        return self._path_cls.drive
 
-        if idx >= len(self) or idx < -len(self):
-            raise IndexError(idx)
+    @property
+    def _root(self) -> str:
+        return self._path_cls.root
 
-        return self.path._from_parsed_parts(self.path.drive, self.path.root, self.path.parts[: -idx - 1])
+    @property
+    def _parts(self) -> tuple[str, ...]:
+        return self._path_cls.parts
 
     def __repr__(self) -> str:
-        return f"<{self.path!r}.parents>"
+        return f"<{self._path_cls!r}.parents>"
 
 
 class ManifestPath(PurePathBase, _IOMixin):
     """A :class:`pathlib.PurePath` subclass representing a binary file in a Manifest. This class is broadly compatible
     with :class:`pathlib.Path`.
 
     .. container:: operations
@@ -209,15 +181,25 @@
         return self._mapping.chunks
 
     @utils.cached_slot_property
     def flags(self) -> DepotFileFlag:
         """This path's flags."""
         return DepotFileFlag.try_value(self._mapping.flags)
 
-    def is_dir(self) -> bool:
+    @property
+    def sha_content(self) -> bytes:
+        """This path's SHA1 content hash."""
+        return self._mapping.sha_content
+
+    @property
+    def sha_filename(self) -> bytes:
+        """This path's SHA1 filename hash."""
+        return self._mapping.sha_filename
+
+    def is_dir(self) -> bool:  # TODO do these need to handle symlinks?
         """Whether the path is a directory."""
         return self.flags & DepotFileFlag.Directory > 0
 
     def is_symlink(self) -> bool:
         """Whether this path is a symlink."""
         return self.flags & DepotFileFlag.Symlink > 0
 
@@ -235,36 +217,78 @@
 
     def readlink(self) -> Self:
         """If this path is a symlink where it points to. Similar to :meth:`pathlib.Path.readlink`
 
         Raises
         ------
         OSError
-            this path isn't a symlink.
+            This path isn't a symlink.
         """
         if not self.is_symlink():
             raise OSError(errno.EINVAL, f"Invalid argument: {str(self)!r}")
 
         link_parts = tuple(self._mapping.linktarget.rstrip("\x00 \n\t").split("\\"))
         return self._manifest._paths[link_parts]
 
     def iterdir(self) -> Generator[Self, None, None]:
         """Iterate over this path. Similar to :meth:`pathlib.Path.iterdir`."""
         for path in self._manifest._paths.values():
             if path.parent == self:
                 yield path
 
+    def walk(
+        self, *, top_down: bool = True, follow_symlinks: bool = False
+    ) -> Generator[tuple[Self, list[str], list[str]], None, None]:
+        """Walk this path. Similar to :meth:`pathlib.Path.walk`.
+
+        Parameters
+        ----------
+        top_down
+            Whether to walk top down or bottom up.
+        follow_symlinks
+            Whether to follow symlinks.
+
+        Note
+        ----
+        Unlike :meth:`pathlib.Path.walk`, this method does not have a ``on_error`` parameter as it should never error.
+
+        Yields
+        ------
+        The path currently being traversed, directories and files (``(dirpath, dirnames, filenames)``).
+        """
+        dirnames: list[str] = []
+        filenames: list[str] = []
+        for entry in self.iterdir():
+            if follow_symlinks:
+                is_dir = entry.is_dir()
+            else:
+                is_dir = entry.flags & DepotFileFlag.Directory > 0
+
+            if is_dir:
+                dirnames.append(entry.name)
+            else:
+                filenames.append(entry.name)
+
+        if top_down:
+            yield self, dirnames, filenames
+
+        for dirname in dirnames:
+            dirpath: Self = self._make_child_relpath(dirname)  # type: ignore
+            yield from dirpath.walk(top_down=top_down, follow_symlinks=follow_symlinks)
+
+        if not top_down:
+            yield self, dirnames, filenames
+
     def glob(self, pattern: str) -> Generator[Self, None, None]:
         """Perform a glob operation on this path. Similar to :meth:`pathlib.Path.glob`."""
         if not pattern:
             raise ValueError(f"Unacceptable pattern: {pattern!r}")
 
-        # str.removeprefix
         yield from filter(
-            methodcaller("match", f"{self.as_posix().rstrip('/')}/{pattern}"), self._manifest._paths.values()
+            methodcaller("match", f"{self.as_posix().removesuffix('/')}/{pattern}"), self._manifest._paths.values()
         )
 
     def rglob(self, pattern: str) -> Generator[Self, None, None]:
         """Perform a recursive glob operation on this path. Similar to :meth:`pathlib.Path.rglob`."""
         yield from self.glob(f"**/{pattern}")
 
     @asynccontextmanager
@@ -300,22 +324,25 @@
 
     read_bytes = _IOMixin.read
     """Read the contents of the file. Similar to :meth:`pathlib.Path.read_bytes`"""
 
     async def read(self) -> Never:
         raise NotImplementedError("use read_bytes() instead of read()")
 
-    async def read_text(self, encoding: str | None = None) -> str:
+    async def read_text(self, encoding: str = MISSING, errors: str = MISSING) -> str:
         """Read the contents of the file. Similar to :meth:`pathlib.Path.read_text`"""
         contents = await self.read_bytes()
-        return contents.decode() if encoding is None else contents.decode(encoding)
+        if encoding is MISSING:
+            return contents.decode() if errors is MISSING else contents.decode(errors=errors)
+
+        return contents.decode(encoding) if errors is MISSING else contents.decode(encoding, errors)
 
-    async def read_vdf(self, encoding: str | None = None) -> VDFDict:
+    async def read_vdf(self, encoding: str = MISSING, errors: str = MISSING) -> VDFDict:
         """Read the contents of the file into a VDFDict."""
-        return VDF_LOADS(await self.read_text(encoding))
+        return VDF_LOADS(await self.read_text(encoding, errors))
 
 
 PAYLOAD_MAGIC: Final = 0x71F617D0
 METADATA_MAGIC: Final = 0x1F4812BE
 SIGNATURE_MAGIC: Final = 0x1B81B817
 END_OF_MANIFEST_MAGIC: Final = 0x32C415AB
 
@@ -333,40 +360,39 @@
 
             Returns the number of files this manifest holds.
 
     Attributes
     ----------
     name
         The name of the manifest.
-    game
-        The game that this manifest was fetched from.
+    app
+        The app that this manifest was fetched from.
     created_at
         The time at which the depot was created at.
     """
 
     __slots__ = (
         "name",
-        "game",
+        "app",
         "server",
         "created_at",
         "_key",
         "_metadata",
         "_payload",
         "_signature",
-        "_paths",
         "_state",
+        "_cs_paths",
     )
 
-    def __init__(self, state: ConnectionState, server: ContentServer, game_id: int, data: bytes):
+    def __init__(self, state: ConnectionState, server: ContentServer, app_id: int, data: bytes):
         self._state = state
         self.name: str | None = None
-        self.game = StatefulGame(state, id=game_id)
+        self.app = PartialApp(state, id=app_id)
         self.server = server
         self._key: bytes | None = None
-        self._paths: dict[tuple[str, ...], ManifestPath] = {}
 
         with utils.StructIO(unzip(data)) as io:
             if io.read_u32() != PAYLOAD_MAGIC:
                 raise RuntimeError("Expecting protobuf payload")
             length = io.read_u32()
             self._payload = Payload().parse(io.read(length))
 
@@ -390,25 +416,22 @@
 
     def __eq__(self, other: object) -> bool:
         return self.id == other.id if isinstance(other, self.__class__) else NotImplemented
 
     def __len__(self) -> int:
         return len(self._payload.mappings)
 
+    @cached_slot_property("_cs_paths")
+    def _paths(self) -> dict[tuple[str, ...], ManifestPath]:
+        return {(path := ManifestPath(self, mapping)).parts: path for mapping in self._payload.mappings}
+
     @property
     def paths(self) -> Sequence[ManifestPath]:
         """The depot's files."""
-        if self._paths:
-            return list(self._paths.values())
-
-        paths = self._paths
-        for mapping in self._payload.mappings:
-            path = ManifestPath(self, mapping)
-            self._paths[path.parts] = path
-        return list(paths.values())
+        return list(self._paths.values())
 
     @property
     def id(self) -> int:
         """The ID of this manifest. This is randomly generated by Steam."""
         return self._metadata.gid_manifest
 
     @property
@@ -428,41 +451,41 @@
 
     @property
     def compressed(self) -> bool:
         """Whether the depot is compressed."""
         return self.size_original != self.size_compressed if self.size_compressed else False
 
 
-@dataclass
-class ContentServer(SteamID):  # is there any point having this inherit steamid?
+@dataclass(slots=True)
+class ContentServer(ID):  # is there any point having this inherit steamid?
     _state: ConnectionState
     url: URL
     weighted_load: float
 
     async def get(self, path: str) -> bytes:
         async with self._state.http._session.get(self.url / path) as r:
             return await r.read()
 
     async def fetch_manifest(
         self,
-        game_id: int,
+        app_id: int,
         id: int,
         depot_id: int,
         name: str | None = None,
         branch: str = "public",
         password_hash: str = "",
     ) -> Manifest:
         branch = branch if branch != "public" else ""
-        code = await self._state.fetch_manifest_request_code(id, depot_id, game_id, branch, password_hash)
+        code = await self._state.fetch_manifest_request_code(id, depot_id, app_id, branch, password_hash)
         data = await self.get(f"depot/{depot_id}/manifest/{id}/5{f'/{code}' if code else ''}")
 
-        manifest = Manifest(self._state, self, game_id, data)
+        manifest = Manifest(self._state, self, app_id, data)
         encrypted = manifest._metadata.filenames_encrypted
         if encrypted:
-            key = manifest._key = await self._state.fetch_depot_key(game_id, depot_id)
+            key = manifest._key = await self._state.fetch_depot_key(app_id, depot_id)
         for mapping in manifest._payload.mappings:
             if encrypted:
                 mapping.filename = utils.symmetric_decrypt(b64decode(mapping.filename), key).decode()  # type: ignore # key is never unbound
                 if mapping.linktarget:
                     mapping.linktarget = utils.symmetric_decrypt(b64decode(mapping.linktarget), key).decode()  # type: ignore
 
             mapping.chunks.sort(key=attrgetter("offset"), reverse=False)
@@ -528,15 +551,15 @@
 
     @property
     def manifests(self) -> list[ManifestInfo]:
         """This branch's manifests."""
         return [depot.manifest for depot in self.depots]
 
     async def fetch_manifests(self) -> list[Manifest]:
-        """Fetch this branch's manifests. Similar to :meth:`StatefulGame.manifests`."""
+        """Fetch this branch's manifests. Similar to :meth:`PartialApp.manifests`."""
         return await asyncio.gather(*(manifest.fetch() for manifest in self.manifests))  # type: ignore  # typeshed lies
 
 
 class ManifestInfo:
     """Represents information about a manifest.
 
     Attributes
@@ -568,15 +591,15 @@
     @property
     def name(self) -> str | None:
         """The manifest's name."""
         return self.depot.name
 
     async def fetch(self) -> Manifest:
         """Resolves this manifest info into a full :class:`Manifest`."""
-        return await self._state.fetch_manifest(self.depot.game.id, self.id, self.depot.id, self.name)
+        return await self._state.fetch_manifest(self.depot.app.id, self.id, self.depot.id, self.name)
 
 
 class PrivateManifestInfo(ManifestInfo):
     __slots__ = ("encrypted_id",)
 
     def __init__(self, state: ConnectionState, encrypted_id: str, branch: Branch):
         self._state = state
@@ -596,49 +619,47 @@
     def _get_id(depots: manifest.Depot, branch: Branch) -> VDFInt | None:
         try:
             return depots["encryptedmanifests"][branch.name]["encrypted_gid_2"]
         except KeyError:
             return None
 
 
-@dataclass
+@dataclass(repr=False, slots=True)
 class HeadlessDepot:
     """Represents a depot without a branch."""
 
-    __slots__ = ("id", "name", "game", "max_size", "config", "shared_install", "system_defined")
     id: int
     """The depot's ID."""
-    name: str | None
+    name: str
     """The depot's name."""
-    game: GameInfo
-    """The depot's game."""
-    max_size: int | None
+    app: AppInfo
+    """The depot's app."""
+    max_size: int
     """The depot's maximum size."""
     config: MultiDict[str]
     """The depot's configuration settings."""
-    shared_install: bool | None
+    shared_install: bool
     """Whether this depot supports shared installs"""
-    system_defined: bool | None
+    system_defined: bool
     """Whether this depot is system defined."""
 
     def __repr__(self):
-        return f"<{self.__class__.__name__} name={self.name!r} id={self.id} game={self.game!r}>"
+        return f"<{self.__class__.__name__} name={self.name!r} id={self.id} app={self.app!r}>"
 
     def __eq__(self, other: object) -> bool:
         return self.id == other.id if isinstance(other, self.__class__) else NotImplemented
 
 
-@dataclass
+@dataclass(repr=False, slots=True)
 class Depot(HeadlessDepot):
     """Represents a depot which is a grouping of files.
 
     Read more on `steamworks <https://partner.steamgames.com/doc/store/application/depots>`_.
     """
 
-    __slots__ = ("manifest", "branch")
     manifest: ManifestInfo
     """The depot's associated manifest."""
     branch: Branch
     """The branch the depot is for."""
 
 
 class ProductInfo:
@@ -658,79 +679,62 @@
     ):
         super().__init__(state, **kwargs)  # type: ignore  # this is a mixin
         self.sha = proto.sha.hex()
         self.size = proto.size
         self.change_number = proto.change_number
 
     # async def changes(self) -> ...:
-    #     """A method to fetch the changes to this game since this change number"""
+    #     """A method to fetch the changes to this app since this change number"""
     #     changes = await self._state.fetch_changes_since(self.change_number, True, True)
     #     return changes.app_changes[0].change_number
 
 
-def is_depot(item: tuple[str, Any]) -> TypeGuard[tuple[str, manifest.Depot]]:
-    try:
-        int(item[0])  # only the integer keys are depots
-    except ValueError:
-        return False
-    else:
-        return True
-
-
-def maybe_get(map: Mapping[str, str | None] | str, key: str) -> int | None:
-    if isinstance(map, str):
-        return int(map)
-    value = map.get(key)
-    if value is not None:
-        return int(value)
-
-
-class GameInfo(ProductInfo, StatefulGame):
-    """Represents a collection of information on a game.
+class AppInfo(ProductInfo, PartialApp):
+    """Represents a collection of information on an app.
 
     Attributes
     ----------
     type
-        The game's type.
+        The app's type.
     has_adult_content
-        Whether this game has adult content according to Steam.
+        Whether this app has adult content according to Steam.
     has_adult_content_violence
-        Whether this game has adult violence according to Steam.
+        Whether this app has adult violence according to Steam.
     market_presence
-        Whether this game has a market presence.
+        Whether this app has a market presence.
     workshop_visible
-        Whether this game has a market presence.
+        Whether this app has a market presence.
     community_hub_visible
-        Whether this game has a content hub visible.
+        Whether this app has a content hub visible.
     controller_support
-        This game's level of controller support.
+        This app's level of controller support.
     publishers
-        This game's publishers.
+        This app's publishers.
     developers
-        This game's developers.
+        This app's developers.
     supported_languages
-        This game's supported languages.
+        This app's supported languages.
     created_at
-        The time this game was created.
+        The time this app was created.
     review_score
-        This game's review score.
+        This app's review score.
     review_percentage
-        This game's review percentage.
+        This app's review percentage.
     partial_dlc
-        This game's downloadable content.
+        This app's downloadable content.
     icon_url
-        This game's icon URL.
+        This app's icon URL.
     logo_url
-        This game's logo URL.
+        This app's logo URL.
     website_url
-        This game's URL.
+        This app's URL.
     headless_depots
-        The depots for this game without a branch.
+        The depots for this app without a branch.
     sha
-        The game's SHA for this product info.
+        The app's SHA for this product info.
     size
         The product info's size.
     change_number
         The product info's change number.
     """
 
     __slots__ = (
@@ -764,15 +768,15 @@
         "_on_linux",
     )
     name: str
 
     def __init__(
         self,
         state: ConnectionState,
-        data: manifest.GameInfo,
+        data: manifest.AppInfo,
         proto: app_info.CMsgClientPicsProductInfoResponseAppInfo,
     ):
         common = data["common"]
         extended = data.get("extended", {})
         super().__init__(state, proto, id=proto.appid, name=common["name"])
         self.type = AppFlag.from_str(common["type"])
         self.has_adult_content = common.get("has_adult_content", "0") == "1"
@@ -802,15 +806,15 @@
         # TODO categories/genres
         self.created_at = (
             DateTime.from_timestamp(int(common["steam_release_date"])) if "steam_release_date" in common else None
         )
         self.review_score = ReviewType.try_value(int(common.get("review_score", 0)))
         self.review_percentage = int(common.get("review_percentage", 0))
         dlc = extended.get("listofdlc", "")
-        self.partial_dlc = [StatefulGame(state, id=int(id)) for id in dlc.split(",")] if dlc else []
+        self.partial_dlc = [PartialApp(state, id=int(id)) for id in dlc.split(",")] if dlc else []
 
         os_list = common.get("oslist", "")
         self._on_windows = "windows" in os_list
         self._on_mac_os = "macos" in os_list
         self._on_linux = "linux" in os_list
 
         self.icon_url = (
@@ -820,15 +824,15 @@
         )
         self.logo_url = (
             f"https://media.steampowered.com/steamcommunity/public/images/apps/{self.id}/{common['logo']}.jpg"
             if "logo" in common
             else None
         )
         self.website_url = extended.get("homepage")
-        self.parent = StatefulGame(state, id=int(common["parent"])) if "parent" in common else None
+        self.parent = PartialApp(state, id=int(common["parent"])) if "parent" in common else None
 
         depots: manifest.Depot = data.get("depots", {})  # type: ignore
         self._branches: dict[str, Branch] = {}
 
         for name, value in depots.get("branches", {}).items():
             try:
                 build_id = int(value["buildid"])
@@ -840,131 +844,108 @@
                     build_id=build_id,
                     updated_at=DateTime.from_timestamp(int(value["timeupdated"])) if "timeupdated" in value else None,
                     password_required=bool(int(value.get("pwdrequired", False))),
                     description=value.get("description") or None,
                 )
         self.headless_depots: Sequence[HeadlessDepot] = []
 
-        for key, depot in filter(is_depot, depots.items()):
-            id = int(key)
-            name = depot.get("name")
-            config = depot.get("config", MultiDict())
-            max_size = int(depot["maxsize"]) if "maxsize" in depot else None
-            shared_install = bool(int(shared_install)) if (shared_install := depot.get("sharedinstall")) else None
-            system_defined = bool(int(system_defined)) if (system_defined := depot.get("system_defined")) else None
+        for key, depot in depots.items():  # type: ignore
             try:
-                manifests = depot["manifests"]
-            except KeyError:
-                self.headless_depots.append(
-                    HeadlessDepot(
-                        id=id,
-                        name=name,
-                        config=config,
-                        game=self,
-                        max_size=max_size,
-                        shared_install=shared_install,
-                        system_defined=system_defined,
-                    )
-                )
-            else:
-                if "public" not in manifests:
-                    return  # we don't own the app, no branch info available
-                public_manifest_info = manifests["public"]
-                public_id = int(
-                    public_manifest_info if isinstance(public_manifest_info, str) else public_manifest_info["gid"]
-                )
-                for branch_name, manifest_info in manifests.items():
-                    branch = self._branches[branch_name]
-                    manifest_id = manifest_info if isinstance(manifest_info, str) else manifest_info["gid"]
-                    if not branch.password_required:
-                        manifest = ManifestInfo(
-                            state,
-                            int(manifest_id),
-                            branch=branch,
-                        )
-                    else:
-                        encrypted_id = PrivateManifestInfo._get_id(depot, branch)
-                        if encrypted_id is not None:
-                            manifest = PrivateManifestInfo(state, encrypted_id, branch)
-                        else:  # fall back to the public version
-                            manifest = ManifestInfo(
-                                state,
-                                public_id,
-                                branch=self.public_branch,
-                            )
-
-                    depot_ = Depot(
-                        id=id,
-                        name=name,
-                        config=config,
-                        game=self,
-                        max_size=max_size,
-                        shared_install=shared_install,
-                        system_defined=system_defined,
-                        branch=branch,
-                        manifest=manifest,
-                    )
-                    manifest.depot = depot_
-                    branch.depots.append(depot_)
+                id = int(key)
+            except ValueError:
+                continue
+            else:  # only the int keys have VDFDicts
+                depot: manifest.Depot
+                kwargs = {
+                    "id": id,
+                    "name": depot.get("name"),
+                    "config": depot.get("config", MultiDict()),
+                    "max_size": int(depot["maxsize"]) if "maxsize" in depot else None,
+                    "app": self,
+                    "shared_install": bool(int(depot.get("sharedinstall", False))),
+                    "system_defined": bool(int(depot.get("system_defined", False))),
+                }
+                try:
+                    manifests = depot["manifests"]
+                except KeyError:
+                    self.headless_depots.append(HeadlessDepot(**kwargs))  # type: ignore
+                else:
+                    for branch_name, manifest_id in manifests.items():
+                        branch = self._branches[branch_name]
+                        if not branch.password_required:
+                            manifest = ManifestInfo(state, int(manifest_id), branch=branch)
+                        else:
+                            encrypted_id = PrivateManifestInfo._get_id(depot, branch)
+                            if encrypted_id is not None:
+                                manifest = PrivateManifestInfo(state, encrypted_id, branch)
+                            else:  # fall back to the public version
+                                manifest = ManifestInfo(
+                                    state,
+                                    int(manifests["public"]),
+                                    branch=self.public_branch,
+                                )
+                        depot_ = Depot(**kwargs, branch=branch, manifest=manifest)  # type: ignore
+                        manifest.depot = depot_
+                        branch.depots.append(depot_)
 
     def get_branch(self, name: str) -> Branch | None:
         """Get a branch by its name."""
         return self._branches.get(name)
 
     @property
     def branches(self) -> Sequence[Branch]:
-        """The branches for this game."""
+        """The branches for this app."""
         return list(self._branches.values())
 
     @property
     def public_branch(self) -> Branch:
         """The public branch. Shorthand for:
 
         .. code-block:: python3
 
-            game.get_branch("public")
+            app.get_branch("public")
         """
         return self._branches["public"]
 
     async def depots(self) -> Sequence[Depot | HeadlessDepot]:
         return [depot for branch in self._branches.values() for depot in branch.depots] + self.headless_depots  # type: ignore
 
     def is_on_windows(self) -> bool:
-        """Whether the game is playable on Windows."""
+        """Whether the app is playable on Windows."""
         return self._on_windows
 
     def is_on_mac_os(self) -> bool:
-        """Whether the game is playable on macOS."""
+        """Whether the app is playable on macOS."""
         return self._on_mac_os
 
     def is_on_linux(self) -> bool:
-        """Whether the game is playable on Linux."""
+        """Whether the app is playable on Linux."""
         return self._on_linux
 
     def has_visible_stats(self) -> bool:
-        """Whether the game has publicly visible stats."""
+        """Whether the app has publicly visible stats."""
         return self._stats_visible
 
     def is_free(self) -> bool:
-        """Whether the game is free to download."""
+        """Whether the app is free to download."""
         return self._free
 
     def __repr__(self) -> str:
         attrs = ("name", "id", "type", "sha", "change_number")
         resolved = [f"{name}={getattr(self, name)!r}" for name in attrs]
         return f"<{self.__class__.__name__} {' '.join(resolved)}>"
 
 
-class PackageInfo(ProductInfo, StatefulPackage):
+class PackageInfo(ProductInfo, PartialPackage):
     """Represents a collection of information on a package.
 
     Attributes
     ----------
-    games
-        The games included in the package.
+    apps
+        The apps included in the package.
     billing_type
         The billing type for the package.
     license_type
         The license type for the package.
     status
         The status for the package.
     depot_ids
@@ -973,36 +954,38 @@
         The app items in the package.
     """
 
     __slots__ = (
         "sha",
         "size",
         "change_number",
-        "_games",
+        "_apps",
         "billing_type",
         "license_type",
         "status",
         "depot_ids",
         "app_items",
     )
 
     def __init__(
         self,
         state: ConnectionState,
         data: manifest.PackageInfo,
         proto: app_info.CMsgClientPicsProductInfoResponsePackageInfo,
     ):
         super().__init__(state, proto, id=proto.packageid)
-        self._games = [StatefulGame(state, id=id) for id in data["appids"].values()]
+        self._apps = [PartialApp(state, id=id) for id in data["appids"].values()]
         self.billing_type = BillingType.try_value(data["billingtype"])
         self.license_type = LicenseType.try_value(data["licensetype"])
         self.status = PackageStatus.try_value(data["status"])
         self.depot_ids = list(data["depotids"].values())
         self.app_items = list(data["appitems"].values())
 
     def __repr__(self) -> str:
         attrs = ("id", "sha", "change_number")
         resolved = [f"{name}={getattr(self, name)!r}" for name in attrs]
         return f"<{self.__class__.__name__} {' '.join(resolved)}>"
 
-    async def games(self) -> list[StatefulGame]:
-        return self._games
+    async def apps(self, *, language: Language | None = None) -> list[PartialApp]:
+        if language is not None:
+            return await super().apps(language=language)
+        return self._apps
```

### Comparing `steamio-0.9.9/steam/message.py` & `steamio-1.0.0a0/steam/message.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,34 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
-from typing import TYPE_CHECKING
+from typing import TYPE_CHECKING, TypeAlias
 
-from typing_extensions import TypeAlias
-
-from .abc import Message, SteamID
+from .abc import Message
 from .chat import ChatMessage
+from .id import ID
 from .reaction import Emoticon, MessageReaction, Sticker
 from .utils import DateTime
 
 if TYPE_CHECKING:
     from .channel import ClanChannel, DMChannel, GroupChannel
-    from .clan import Clan
-    from .group import Group
+    from .clan import Clan, ClanMember
+    from .group import Group, GroupMember
     from .protobufs import chat, friend_messages
     from .user import ClientUser, User
 
 
 __all__ = (
     "UserMessage",
     "GroupMessage",
     "ClanMessage",
 )
 
-Authors: TypeAlias = "User | ClientUser | SteamID"
+Authors: TypeAlias = "User | ClientUser | ID"
 
 
 class UserMessage(Message):
     """Represents a message from a user."""
 
     channel: DMChannel
     mentions: None
@@ -37,82 +36,84 @@
     def __init__(self, proto: friend_messages.IncomingMessageNotification, channel: DMChannel):
         super().__init__(channel, proto)
         self.author = channel.participant
         self.created_at = DateTime.from_timestamp(proto.rtime32_server_timestamp)
 
     async def add_emoticon(self, emoticon: Emoticon) -> None:
         await self._state.react_to_user_message(
-            self.channel.participant.id64,
+            self.author.id64,
             int(self.created_at.timestamp()),
             self.ordinal,
-            str(emoticon),
-            reaction_type=1,
+            emoticon.name,
+            reaction_type=emoticon._TYPE,
             is_add=True,
         )
         self._state.dispatch(
             "reaction_add",
             MessageReaction(self._state, self, emoticon, None, self._state.user, DateTime.now(), self.ordinal),
         )
 
     async def remove_emoticon(self, emoticon: Emoticon):
         await self._state.react_to_user_message(
-            self.channel.participant.id64,
+            self.author.id64,
             int(self.created_at.timestamp()),
             self.ordinal,
-            str(emoticon),
-            reaction_type=1,
+            emoticon.name,
+            reaction_type=emoticon._TYPE,
             is_add=False,
         )
         self._state.dispatch(
             "reaction_remove",
             MessageReaction(self._state, self, emoticon, None, self._state.user, DateTime.now(), self.ordinal),
         )
 
     async def add_sticker(self, sticker: Sticker):
         await self._state.react_to_user_message(
-            self.channel.participant.id64,
+            self.author.id64,
             int(self.created_at.timestamp()),
             self.ordinal,
             sticker.name,
-            reaction_type=2,
+            reaction_type=sticker._TYPE,
             is_add=True,
         )
         self._state.dispatch(
             "reaction_add",
             MessageReaction(self._state, self, None, sticker, self._state.user, DateTime.now(), self.ordinal),
         )
 
     async def remove_sticker(self, sticker: Sticker):
         await self._state.react_to_user_message(
-            self.channel.participant.id64,
+            self.author.id64,
             int(self.created_at.timestamp()),
             self.ordinal,
             sticker.name,
-            reaction_type=2,
+            reaction_type=sticker._TYPE,
             is_add=False,
         )
         self._state.dispatch(
             "reaction_remove",
             MessageReaction(self._state, self, None, sticker, self._state.user, DateTime.now(), self.ordinal),
         )
 
 
 class GroupMessage(ChatMessage):
     """Represents a message in a group."""
 
+    author: GroupMember
     channel: GroupChannel
     group: Group
     clan: None
 
     def __init__(self, proto: chat.IncomingChatMessageNotification, channel: GroupChannel, author: Authors):
         super().__init__(proto, channel, author)
 
 
 class ClanMessage(ChatMessage):
     """Represents a message in a clan."""
 
+    author: ClanMember
     channel: ClanChannel
     clan: Clan
     group: None
 
     def __init__(self, proto: chat.IncomingChatMessageNotification, channel: ClanChannel, author: Authors):
         super().__init__(proto, channel, author)
```

### Comparing `steamio-0.9.9/steam/models.py` & `steamio-1.0.0a0/steam/models.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,35 +7,37 @@
 import logging
 import re
 import traceback
 from collections.abc import AsyncGenerator, Callable
 from contextlib import asynccontextmanager
 from datetime import timedelta
 from io import BytesIO
-from typing import TYPE_CHECKING, Any, TypeVar
+from types import CoroutineType
+from typing import TYPE_CHECKING, Any, Literal, ParamSpec, TypedDict, TypeVar
 
-from typing_extensions import Literal, ParamSpec, Self, TypedDict
+from typing_extensions import Self
 from yarl import URL as _URL
 
 from . import utils
-from ._const import TASK_HAS_NAME, URL
+from ._const import URL
 from .enums import IntEnum
 from .image import Image
 from .protobufs import EMsg
 
 if TYPE_CHECKING:
     from _typeshed import StrOrBytesPath
 
     from .gateway import Msgs
     from .state import ConnectionState
 
 
 __all__ = (
     "PriceOverview",
     "Ban",
+    "Avatar",
 )
 
 F = TypeVar("F", bound="Callable[..., Any]")
 P = ParamSpec("P")
 
 
 def api_route(path: str, version: int = 1) -> _URL:
@@ -52,20 +54,18 @@
         return "<return_true>"
 
 
 return_true = _ReturnTrue()
 
 
 class Registerable:
-    __slots__ = ("loop", "parsers_name")
-    loop: asyncio.AbstractEventLoop
+    __slots__ = ("parsers_name",)
 
     def __new__(cls, *args: Any, **kwargs: Any) -> Self:
         self = super().__new__(cls)
-        self.loop = asyncio.get_event_loop()
         cls.parsers_name = tuple(cls.__annotations__)[0]
         bases = tuple(reversed(cls.__mro__[:-2]))  # skip Registerable and object
         for idx, base in enumerate(bases):
             parsers_name = tuple(base.__annotations__)[0]
             for name, attr in base.__dict__.items():
                 if not hasattr(attr, "msg"):
                     continue
@@ -77,40 +77,52 @@
                 msg_parser = getattr(self, name)
                 if idx != 0 and isinstance(attr.msg, EMsg):
                     parsers = getattr(self, tuple(bases[0].__annotations__)[0])
                 parsers[attr.msg] = msg_parser
 
         return self
 
+    @utils.cached_property
+    def loop(self) -> asyncio.AbstractEventLoop:
+        return asyncio.get_running_loop()
+
+    @utils.cached_property
+    def _logger(self) -> logging.Logger:
+        return logging.getLogger(self.__class__.__module__)
+
     @staticmethod
     def _run_parser_callback(task: asyncio.Task[object]) -> None:
         try:
             exception = task.exception()
         except asyncio.CancelledError:
             return
         if exception:
-            traceback.print_exception(exception.__class__, exception, exception.__traceback__)
+            traceback.print_exception(exception)
 
-    def run_parser(self, emsg: IntEnum, msg: Msgs) -> None:
+    def run_parser(self, msg: Msgs) -> None:
         try:
-            event_parser = getattr(self, self.parsers_name)[emsg]
-        except KeyError:
-            log = logging.getLogger(self.__class__.__module__)
+            event_parser: Callable[[Msgs], CoroutineType[Any, Any, object] | object] = getattr(self, self.parsers_name)[
+                msg.__class__.MSG
+            ]
+        except (KeyError, TypeError):
             try:
-                log.debug("Ignoring event %r", msg)
+                self._logger.debug("Ignoring event %r", msg, exc_info=True)
             except Exception:
-                log.debug("Ignoring event %s", msg.msg)
+                self._logger.debug("Ignoring event with %r", msg.__class__)
         else:
-            coro = utils.maybe_coroutine(event_parser, msg)
 
-            (
-                self.loop.create_task(coro, name=f"task_{event_parser.__name__}")
-                if TASK_HAS_NAME
-                else self.loop.create_task(coro)
-            ).add_done_callback(self._run_parser_callback)
+            try:
+                result = event_parser(msg)
+            except Exception:
+                return traceback.print_exc()
+
+            if isinstance(result, CoroutineType):
+                asyncio.create_task(result, name=f"steam.py: {event_parser.__name__}").add_done_callback(
+                    self._run_parser_callback
+                )
 
 
 EventParser = None
 
 
 def register(msg: IntEnum) -> Callable[[F], F]:  # this afaict is not type able currently without HKT
     def wrapper(callback: F) -> F:
@@ -258,7 +270,31 @@
             with file, open(filename, "wb") as actual_fp:
                 return actual_fp.write(file.getvalue())
 
     async def image(self, *, spoiler: bool = False, **kwargs: Any) -> Image:
         """Return this file as an image for uploading."""
         async with self.open(**kwargs) as file:
             return Image(file, spoiler=spoiler)
+
+
+class Avatar(_IOMixin):
+    __slots__ = (
+        "sha",
+        "_state",
+    )
+
+    def __init__(self, state: ConnectionState, sha: bytes):
+        sha = bytes(sha)
+        self.sha = (
+            sha
+            if sha != b"\x00" * 20
+            else b"\xfe\xf4\x9e\x7f\xa7\xe1\x99s\x10\xd7\x05\xb2\xa6\x15\x8f\xf8\xdc\x1c\xdf\xeb"
+        )
+        self._state = state
+
+    @property
+    def url(self):
+        """The URL of the avatar. Uses the large (184x184 px) image url."""
+        return f"https://avatars.cloudflare.steamstatic.com/{self.sha.hex()}_full.jpg"
+
+    def __eq__(self, other: object) -> bool:
+        return self.sha == other.sha if isinstance(other, self.__class__) else NotImplemented
```

### Comparing `steamio-0.9.9/steam/package.py` & `steamio-1.0.0a0/steam/package.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,203 +1,203 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import re
+from collections.abc import Sequence
 from dataclasses import dataclass
 from datetime import timedelta
-from typing import TYPE_CHECKING, Any, Sequence
+from typing import TYPE_CHECKING, Any
 
-from .enums import LicenseFlag, LicenseType, PaymentMethod
-from .game import PartialGamePriceOverview, StatefulGame
-from .utils import DateTime, Intable
+from .app import PartialApp, PartialAppPriceOverview
+from .enums import Language, LicenseFlag, LicenseType, PaymentMethod
+from .types.id import Intable, PackageID
+from .utils import DateTime
 
 if TYPE_CHECKING:
-    from .manifest import Depot, GameInfo, HeadlessDepot, PackageInfo
+    from .manifest import AppInfo, Depot, HeadlessDepot, PackageInfo
     from .message import Authors
     from .protobufs.client_server import CMsgClientLicenseListLicense
     from .protobufs.store import PurchaseReceiptInfo
     from .state import ConnectionState
-    from .types import game, package
+    from .types import app, package
 
 
 __all__ = (
     "Package",
     "FetchedPackage",
-    "FetchedGamePackage",
+    "FetchedAppPackage",
     "License",
 )
 
 
 class Package:
-    """Represents information on a package which is a collection of one or more applications and depots.
+    """Represents a package, a collection of one or more apps and depots.
 
     Read more on `steamworks <https://partner.steamgames.com/doc/store/application/packages>`_.
     """
 
     __slots__ = (
         "id",
         "name",
     )
 
     def __init__(self, id: Intable, name: str | None = None):
-        self.id = int(id)
+        self.id = PackageID(int(id))
         """The package's ID."""
         self.name = name
         """The package's name."""
 
     def __eq__(self, other: object) -> bool:
         return self.id == other.id if isinstance(other, Package) else NotImplemented
 
     def __hash__(self) -> int:
         return hash(self.id)
 
     def __repr__(self) -> str:
         return f"{self.__class__.__name__}(id={self.id}, name={self.name!r})"
 
 
-class StatefulPackage(Package):
+class PartialPackage(Package):
     """A package with state."""
 
     __slots__ = ("_state",)
 
     def __init__(self, state: ConnectionState, **kwargs: Any):
         super().__init__(**kwargs)
         self._state = state
 
     def __repr__(self) -> str:
         return f"<{self.__class__.__name__} name={self.name!r} id={self.id}>"
 
-    async def games(self) -> list[StatefulGame]:
-        """Fetches this package's games."""
-        fetched = await self.fetch()
-        return fetched._games
+    async def apps(self, *, language: Language | None = None) -> list[PartialApp]:
+        """Fetches this package's apps."""
+        fetched = await self.fetch(language=language)
+        return fetched._apps
 
-    async def fetch(self) -> FetchedPackage:
+    async def fetch(self, *, language: Language | None = None) -> FetchedPackage:
         """Fetches this package's information. Shorthand for:
 
         .. code-block:: python3
 
             package = await client.fetch_package(package)
         """
-        package = await self._state.client.fetch_package(self.id)
+        package = await self._state.client.fetch_package(self.id, language=language)
         if package is None:
             raise ValueError("Fetched package was not valid.")
         return package
 
     async def info(self) -> PackageInfo:
         """Shorthand for:
 
         .. code-block:: python3
 
             (info,) = await client.fetch_product_info(packages=[package])
         """
         _, (info,) = await self._state.fetch_product_info(package_ids=(self.id,))
         return info
 
-    async def games_info(self) -> list[GameInfo]:
+    async def apps_info(self) -> list[AppInfo]:
         """Shorthand for:
 
         .. code-block:: python3
 
-            infos = await client.fetch_product_info(games=await package.games())
+            infos = await client.fetch_product_info(apps=await package.apps())
         """
-        games = await self.games()
-        if not games:
+        apps = await self.apps()
+        if not apps:
             return []
-        infos, _ = await self._state.fetch_product_info(game.id for game in games)
+        infos, _ = await self._state.fetch_product_info(app.id for app in apps)
         return infos
 
     async def depots(self) -> Sequence[Depot | HeadlessDepot]:
         """Fetches this package's depots."""
         try:
             depot_ids = self.depot_ids  # type: ignore
         except AttributeError:
             info = await self.info()
             depot_ids = info.depot_ids
 
-        games_info = await self.games_info()
+        apps_info = await self.apps_info()
 
         return [
             depot
-            for game_info in games_info
-            for branch in game_info._branches.values()
+            for app_info in apps_info
+            for branch in app_info._branches.values()
             for depot in branch.depots
             if depot.id in depot_ids
-        ] + [
-            depot for game_info in games_info for depot in game_info.headless_depots if depot.id in depot_ids
-        ]  # type: ignore
+        ] + [depot for app_info in apps_info for depot in app_info.headless_depots if depot.id in depot_ids]
 
     # TODO .manifests, fetch_manifest
 
 
-@dataclass
-class PackagePriceOverview(PartialGamePriceOverview):
+@dataclass(slots=True)
+class PackagePriceOverview(PartialAppPriceOverview):
     individual: int
 
 
-class FetchedPackage(StatefulPackage):
+class FetchedPackage(PartialPackage):
     name: str
 
     def __init__(self, state: ConnectionState, data: package.FetchedPackage):
         super().__init__(state, name=data["name"], id=data["packageid"])
-        self._games = [StatefulGame(state, id=app["id"], name=app["name"]) for app in data["apps"]]
+        self._apps = [PartialApp(state, id=app["id"], name=app["name"]) for app in data["apps"]]
         self.description = data["page_content"]
         self.created_at = DateTime.parse_steam_date(data["release_date"]["date"], full_month=False)
         self.logo_url = data["small_logo"]
         self.logo_url = data["header_image"]
         platforms = data["platforms"]
         self._on_windows = platforms["windows"]
         self._on_mac_os = platforms["mac"]
         self._on_linux = platforms["linux"]
         self.price_overview = PackagePriceOverview(**data["price"])
 
     def is_free(self) -> bool:
-        """Whether the game is free."""
+        """Whether the package is free."""
         return self.price_overview.final == 0
 
     def is_on_windows(self) -> bool:
-        """Whether the game is playable on Windows."""
+        """Whether the package is playable on Windows."""
         return self._on_windows
 
     def is_on_mac_os(self) -> bool:
-        """Whether the game is playable on macOS."""
+        """Whether the package is playable on macOS."""
         return self._on_mac_os
 
     def is_on_linux(self) -> bool:
-        """Whether the game is playable on Linux."""
+        """Whether the package is playable on Linux."""
         return self._on_linux
 
 
-@dataclass
-class FetchedGamePackagePriceOverview:
+@dataclass(slots=True)
+class FetchedAppPackagePriceOverview:
     percent_discount: int
     final: int
 
 
-class FetchedGamePackage(StatefulPackage):
+class FetchedAppPackage(PartialPackage):
     __slots__ = (
         "_is_free",
         "price_overview",
     )
 
-    def __init__(self, state: ConnectionState, data: game.PackageGroupSub):
+    def __init__(self, state: ConnectionState, data: app.PackageGroupSub):
         name, _, _ = data["option_text"].rpartition(" - ")
         super().__init__(state, name=name, id=data["packageid"])
         self._is_free = data["is_free_license"]
-        self.price_overview = FetchedGamePackagePriceOverview(
+        self.price_overview = FetchedAppPackagePriceOverview(
             int(re.search(r"-?(\d)", data["percent_savings_text"])[0]),
             data["price_in_cents_with_discount"],  # this isn't always in cents
         )
 
     def is_free(self) -> bool:
         return self._is_free
 
 
-class License(StatefulPackage):
+class License(PartialPackage):
     """Represents a License to a package the client user has access to."""
 
     __slots__ = (
         "owner",
         "type",
         "flags",
         "created_at",
@@ -222,15 +222,15 @@
         """The license's owner."""
         self.type = LicenseType.try_value(proto.license_type)
         """The license's type."""
         self.flags = LicenseFlag.try_value(proto.flags)
         """The license's flags."""
         self.created_at = DateTime.from_timestamp(proto.time_created) if proto.time_created else None
         """The license's creation date."""
-        self.master_package = StatefulPackage(state, id=proto.master_package_id) if proto.master_package_id else None
+        self.master_package = PartialPackage(state, id=proto.master_package_id) if proto.master_package_id else None
         """The license's master package."""
         self.next_process_at = DateTime.from_timestamp(proto.time_next_process)
         """The date when the license will be processed."""
         self.time_limit = timedelta(minutes=proto.minute_limit) if proto.minute_limit else None
         """The time limit for the license."""
         self.time_used = timedelta(minutes=proto.minutes_used)
         """The time the license has been used."""
@@ -260,36 +260,7 @@
     def time_remaining(self) -> timedelta | None:
         """The amount of time that this license can be used for."""
         if self.flags & LicenseFlag.Expired:
             return
         if self.time_limit is None:
             return
         return self.time_limit - self.time_used
-
-
-# class Transaction:
-#     def __init__(self, state: ConnectionState, proto: PurchaseReceiptInfo):
-#         self.id = proto.transactionid
-#         self.items = [
-#             TransactionItem(
-#                 Package(state, item.packageid), StatefulGame(state, id=item.appid), item.line_item_description
-#             )
-#             for item in proto.line_items
-#         ]
-#
-#         self.package = Package(state, proto.packageid)
-#         self.purchase_status = proto.purchase_status
-#         self.created_at = DateTime.from_timestamp(proto.transaction_time)
-#         self.payment_method = PaymentMethod.try_value(proto.payment_method)
-#         self.base_price = proto.base_price
-#         self.total_discount = proto.total_discount
-#         self.tax = proto.tax
-#         self.shipping = proto.shipping
-#         self.currency_code = proto.currency_code
-#         self.country_code = proto.country_code
-#
-#
-# @dataclass
-# class TransactionItem:
-#     package_id: Package
-#     game: StatefulGame
-#     description: str
```

### Comparing `steamio-0.9.9/steam/profile.py` & `steamio-1.0.0a0/steam/profile.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,37 +1,31 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 from collections import defaultdict
 from dataclasses import dataclass
 from datetime import datetime
-from typing import TYPE_CHECKING
+from typing import TYPE_CHECKING, Protocol
 
 from . import utils
-from .badge import Badge
-from .enums import (
-    Language,
-    ProfileCustomisationStyle,
-    ProfileItemClass,
-    ProfileItemType,
-    PublishedFileRevision,
-    Result,
-    UserBadge,
-)
+from .app import PartialApp
+from .badge import UserBadge
+from .enums import Language, ProfileCustomisationStyle, ProfileItemClass, ProfileItemType, PublishedFileRevision, Result
 from .errors import WSException
-from .game import StatefulGame
+from .protobufs import UnifiedMessage, econ
 from .trade import Asset, Item
 
 if TYPE_CHECKING:
     from .abc import BaseUser
+    from .clan import Clan
     from .protobufs import player
     from .published_file import PublishedFile
     from .state import ConnectionState
-    from .types import trade
+    from .types import id
 
 __all__ = (
     "ProfileInfo",
     "ProfileItem",
     "OwnedProfileItems",
     "EquippedProfileItems",
     "ProfileShowcaseSlot",
@@ -60,81 +54,93 @@
     summary: str
     """The user's summary."""
 
     def __repr__(self) -> str:
         return f"<{self.__class__.__name__} real_name={self.real_name!r}>"
 
 
-@dataclass
+@dataclass(slots=True)
 class ProfileMovie:
     url: str  # TODO add more attributes like maybe created_at?
 
 
+class SupportsEquip(Protocol):
+    def __init__(self, *, communityitemid: int) -> None:
+        ...
+
+
 class ProfileItem:
     """Represents an item on/in a user's profile."""
 
     __slots__ = (
         "id",
         "url",
         "name",
         "title",
         "description",
-        "game",
+        "app",
         "type",
         "class_",
         "movie",
         "equipped_flags",
         "owner",
         "_state",
-        "_um_name",
+        "_um",
     )
 
     def __init__(
-        self, state: ConnectionState, owner: BaseUser, item: player.ProfileItem, *, um_name: str | None = None
+        self,
+        state: ConnectionState,
+        owner: BaseUser,
+        item: player.ProfileItem,
+        *,
+        um: type[SupportsEquip] | None = None,
     ):
         self.id = item.communityitemid
         """The item's id."""
         self.url = item.image_large
         """The item's url."""
         self.name = item.name
         """The item's name."""
         self.title = item.item_title
         """The item's title."""
         self.description = item.item_description
         """The item's description."""
-        self.game = StatefulGame(state, id=item.appid)
-        """The game the item is from."""
+        self.app = PartialApp(state, id=item.appid)
+        """The app the item is from."""
         self.type = ProfileItemType.try_value(item.item_type)
         """The item's type."""
         self.class_ = ProfileItemClass.try_value(item.item_class)
         """The item's class."""
         self.movie = ProfileMovie(item.movie_mp4)
         """The movie associated with the item."""
         self.equipped_flags = item.equipped_flags  # TODO might be useful for item show case?
         """The item's equipped flags."""
 
         self.owner = owner
         self._state = state
-        self._um_name = um_name
+        if um is not None:
+            assert issubclass(um, UnifiedMessage)  # until we have intersections this works with pyright
+        self._um = um
 
     def __repr__(self) -> str:
-        return f"<ProfileItem id={self.id} name={self.name!r} game={self.game!r}>"
+        return f"<ProfileItem id={self.id} name={self.name!r} app={self.app!r}>"
 
     async def equip(self) -> None:
         """Equip the profile item."""
-        if self._um_name is None:
+        if self._um is None:
             raise ValueError(f"Cannot equip {self!r}")
 
-        msg = await self._state.ws.send_um_and_wait(f"Player.Set{self._um_name}", communityitemid=self.id)
+        msg = await self._state.ws.send_um_and_wait(self._um(communityitemid=self.id))
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def item(self, *, language: Language | None = None) -> Item:
         """Resolve this to an actual item in the owner's inventory."""
-        inventory = await self.owner.inventory(self.game, language=language)
+        inventory = await self.owner.inventory(self.app, language=language)
         item = utils.get(inventory, id=self.id)
         assert item
         return item
 
 
 @dataclass
 class OwnedProfileItems:
@@ -164,66 +170,57 @@
     """The equipped avatar frame for the user."""
     animated_avatar: ProfileItem | None
     """The equipped animated avatar for the user."""
     modifier: ProfileItem | None
     """The equipped modifier for the user."""
 
 
-@dataclass
+@dataclass(repr=False, slots=True)
 class ProfileShowcaseSlot:
-    __slots__ = (
-        "_state",
-        "owner",
-        "name",
-        "content",
-        "index",
-        "game",
-        "asset",
-        "published_file_id",
-        "badge_id",
-        "border_colour",
-    )
+    """Represents a showcase slot."""
+
     _state: ConnectionState
     owner: BaseUser
     name: str | None
     """The slot's name."""
     content: str | None
     """ The slot's description."""
     index: int | None
     """The slot's index."""
-    game: StatefulGame
-    """The slot's associated game."""
+    app: PartialApp | None
+    """The slot's associated app."""
 
     asset: Asset | None
     """The :class:`Asset` the slot is associated with."""
     published_file_id: int | None
     """The ID of the :class:`PublishedFile` the slot is associated with."""
-    badge_id: UserBadge | None
+    badge_id: int | None
     """The ID of the :class:`UserBadge` the slot is associated with."""
     border_colour: int | None
     """The border colour of the slot."""
+    clan: Clan | None
+    """The Steam ID of the clan the slot is associated with."""
+
+    def __repr__(self) -> str:
+        return f"<ProfileShowcaseSlot name={self.name!r} index={self.index!r} app={self.app!r}>"
 
     async def item(self, *, language: Language | None = None) -> Item:
         """Fetches the associated :class:`.Item` from :attr:`asset`.
 
         Parameters
         ----------
         language
             The language to fetch the item in. If ``None``, the current language is used.
         """
         if self.asset is None:
             raise ValueError
+        assert self.app is not None
         key = (self.asset.class_id, self.asset.instance_id)
-        resp = await self._state.http.get_item_info(self.game.id, [key], language)
-        data: trade.Item = {
-            **resp[key],
-            **self.asset.to_dict(),
-            "missing": False,
-        }  # type: ignore  # I don't wanna type out this in full to make this type-safe
-        return Item(self._state, data, self.owner)
+        resp = await self._state.fetch_item_info(self.app.id, [key], language)
+        return Item(self._state, self.asset.to_proto(), resp[key], self.owner)
 
     async def published_file(
         self, *, revision: PublishedFileRevision = PublishedFileRevision.Default, language: Language | None = None
     ) -> PublishedFile:
         """Fetches the associated :class:`.PublishedFile` from :attr:`published_file_id`.
 
         Parameters
@@ -235,37 +232,29 @@
         """
         if self.published_file_id is None:
             raise ValueError
         (file,) = await self._state.fetch_published_files((self.published_file_id,), revision, language)
         assert file
         return file
 
-    async def badge(self) -> Badge:
+    async def badge(self) -> UserBadge:
         """Fetches the associated :class:`.Badge` from :attr:`badge_id`."""
         if self.badge_id is None:
             raise ValueError
         badges = await self.owner.badges()
-        badge = utils.get(badges.badges, id=self.badge_id)
+        badge = utils.get(
+            badges.badges, id=self.badge_id, app__id=self.app.id if self.app and self.app.id != 753 else None
+        )  # TODO manual
+
         assert badge
         return badge
 
 
-@dataclass
+@dataclass(repr=False, slots=True)
 class ProfileShowcase:
-    __slots__ = (
-        "_state",
-        "owner",
-        "type",
-        "large",
-        "active",
-        "purchase_id",
-        "level",
-        "style",
-        "slots",
-    )
     _state: ConnectionState
     owner: BaseUser
     type: ProfileItemType
     """The showcase type."""
     large: bool
     """Whether the showcase is large."""
     active: bool
@@ -275,66 +264,75 @@
     level: int
     """The level of the the showcase."""
     style: ProfileCustomisationStyle
     """The style of the showcase."""
     slots: list[ProfileShowcaseSlot]
     """The slots in this showcase."""
 
-    async def items(self, *, language: Language | None) -> list[Item]:
+    def __repr__(self) -> str:
+        return f"<ProfileShowcase type={self.type!r} active={self.active!r} level={self.level!r} style={self.style!r}>"
+
+    async def items(self, *, language: Language | None = None) -> list[Item]:
         """Fetches the associated :class:`.Item`s for the entire showcase.
 
         Parameters
         ----------
         language
             The language to fetch the items in. If ``None``, the current language is used.
         """
-        asset_map: defaultdict[int, dict[tuple[int, int], Asset]] = defaultdict(dict)
+        asset_map: defaultdict[int, dict[id.CacheKey, Asset]] = defaultdict(dict)
 
         for slot in self.slots:
             if slot.asset:
                 asset_map[slot.asset._app_id][(slot.asset.class_id, slot.asset.instance_id)] = slot.asset
 
         return [
-            Item(self._state, {**description, **assets[key].to_dict(), "missing": False}, self.owner)
+            Item(self._state, assets[key].to_proto(), description, self.owner)
             for app_id, assets in asset_map.items()
-            for key, description in (await self._state.http.get_item_info(app_id, assets, language)).items()
+            for key, description in (await self._state.fetch_item_info(app_id, assets, language)).items()
         ]
 
-    async def published_file(
+    async def published_files(
         self, *, revision: PublishedFileRevision = PublishedFileRevision.Default, language: Language | None = None
-    ) -> PublishedFile:
-        """Fetches the associated :class:`.PublishedFile` from :attr:`published_file_id`.
+    ) -> list[PublishedFile]:
+        r"""Fetches the associated :class:`.PublishedFile` for the entire showcase.
 
         Parameters
         ----------
         revision
             The revision of the file to fetch.
         language
             The language to fetch the file in. If ``None``, the current language is used.
         """
-        return await self.slots[0].published_file(revision=revision)
+        published_files = await self._state.fetch_published_files(
+            (slot.published_file_id for slot in self.slots if slot.published_file_id), revision, language
+        )
+        assert all(published_files)
+        return published_files  # type: ignore  # needs HKT to be fixed
 
-    async def badges(self) -> list[Badge]:
+    async def badges(self) -> list[UserBadge]:
         """Fetches the associated :class:`.Badge`s for the entire showcase."""
         all_badges = await self.owner.badges()
-        badges = [utils.get(all_badges.badges, id=slot.badge_id) for slot in self.slots if slot.badge_id]
+        badges = [
+            utils.get(all_badges, id=slot.badge_id, app__id=slot.app.id)
+            for slot in self.slots
+            if slot.badge_id and slot.app
+        ]
         assert all(badges)
         return badges  # type: ignore
 
 
-@dataclass
+@dataclass(slots=True)
 class ProfileTheme:
-    __slots__ = ("id", "name")
     id: str
     name: str
 
 
-@dataclass
+@dataclass(slots=True)
 class PurchasedCustomisation:  # TODO should this be merged into ProfileCustomisationSlot.purchase_id if the ids match
-    __slots__ = ("id", "type", "level")
     id: int
     type: ProfileCustomisationStyle
     level: int
 
 
 class ProfileCustomisation:
     """Represents a user's profile customisations."""
@@ -345,43 +343,46 @@
         "profile_theme",
         "purchased_customisations",
         "owner",
         "_state",
     )
 
     def __init__(self, state: ConnectionState, user: BaseUser, proto: player.GetProfileCustomizationResponse):
+        from .clan import Clan
+
         self.showcases = [
             ProfileShowcase(
                 state,
                 owner=user,
                 slots=[
                     ProfileShowcaseSlot(
                         state,
                         owner=user,
                         index=slot.slot or None,
-                        game=StatefulGame(state, id=slot.appid),
+                        app=PartialApp(state, id=slot.appid) if slot.appid else None,
                         published_file_id=slot.publishedfileid or None,
                         name=slot.title or None,
                         content=slot.notes or None,
-                        badge_id=UserBadge.try_value(slot.badgeid) if slot.badgeid else None,
+                        badge_id=slot.badgeid or None,
                         border_colour=slot.border_color or None,
                         asset=Asset(
-                            {
-                                "assetid": slot.item_assetid,  # type: ignore  # this just gets cast to an int anyway
-                                "appid": slot.appid,
-                                "contextid": slot.item_contextid,
-                                "instanceid": slot.item_instanceid,
-                                "classid": slot.item_classid,
-                                "amount": 1,
-                                "missing": False,
-                            },
+                            state,
+                            econ.Asset(
+                                assetid=slot.item_assetid,
+                                appid=slot.appid,
+                                contextid=slot.item_contextid,
+                                instanceid=slot.item_instanceid,
+                                classid=slot.item_classid,
+                                amount=1,
+                            ),
                             user,
                         )
                         if slot.item_assetid
                         else None,
+                        clan=Clan(state, slot.accountid) if slot.accountid else None,
                     )
                     for slot in customisation.slots
                 ],
                 type=ProfileItemType.try_value(customisation.customization_type),
                 large=customisation.large,
                 active=customisation.active,
                 style=ProfileCustomisationStyle.try_value(customisation.customization_style),
```

### Comparing `steamio-0.9.9/steam/protobufs/app_info.py` & `steamio-1.0.0a0/steam/protobufs/app_info.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,101 +1,101 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_clientserver_appinfo.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .emsg import EMsg
+from .msg import ProtobufMessage
+
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAppInfoUpdate(betterproto.Message):
     last_changenumber: int = betterproto.uint32_field(1)
     send_changelist: bool = betterproto.bool_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAppInfoChanges(betterproto.Message):
     current_change_number: int = betterproto.uint32_field(1)
     force_full_update: bool = betterproto.bool_field(2)
-    app_ids: List[int] = betterproto.uint32_field(3)
+    app_ids: list[int] = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAppInfoRequest(betterproto.Message):
-    apps: List["CMsgClientAppInfoRequestApp"] = betterproto.message_field(1)
+    apps: "list[CMsgClientAppInfoRequestApp]" = betterproto.message_field(1)
     supports_batches: bool = betterproto.bool_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAppInfoRequestApp(betterproto.Message):
     app_id: int = betterproto.uint32_field(1)
     section_flags: int = betterproto.uint32_field(2)
-    section_crc: List[int] = betterproto.uint32_field(3)
+    section_crc: list[int] = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAppInfoResponse(betterproto.Message):
-    apps: List["CMsgClientAppInfoResponseApp"] = betterproto.message_field(1)
-    apps_unknown: List[int] = betterproto.uint32_field(2)
+    apps: "list[CMsgClientAppInfoResponseApp]" = betterproto.message_field(1)
+    apps_unknown: list[int] = betterproto.uint32_field(2)
     apps_pending: int = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAppInfoResponseApp(betterproto.Message):
     app_id: int = betterproto.uint32_field(1)
     change_number: int = betterproto.uint32_field(2)
-    sections: List["CMsgClientAppInfoResponseAppSection"] = betterproto.message_field(3)
+    sections: "list[CMsgClientAppInfoResponseAppSection]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAppInfoResponseAppSection(betterproto.Message):
     section_id: int = betterproto.uint32_field(1)
     section_kv: bytes = betterproto.bytes_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPackageInfoRequest(betterproto.Message):
-    package_ids: List[int] = betterproto.uint32_field(1)
+    package_ids: list[int] = betterproto.uint32_field(1)
     meta_data_only: bool = betterproto.bool_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPackageInfoResponse(betterproto.Message):
-    packages: List["CMsgClientPackageInfoResponsePackage"] = betterproto.message_field(1)
-    packages_unknown: List[int] = betterproto.uint32_field(2)
+    packages: "list[CMsgClientPackageInfoResponsePackage]" = betterproto.message_field(1)
+    packages_unknown: list[int] = betterproto.uint32_field(2)
     packages_pending: int = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPackageInfoResponsePackage(betterproto.Message):
     package_id: int = betterproto.uint32_field(1)
     change_number: int = betterproto.uint32_field(2)
     sha: bytes = betterproto.bytes_field(3)
     buffer: bytes = betterproto.bytes_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPicsChangesSinceRequest(betterproto.Message):
+class CMsgClientPicsChangesSinceRequest(ProtobufMessage, msg=EMsg.ClientPICSChangesSinceRequest):
     since_change_number: int = betterproto.uint32_field(1)
     send_app_info_changes: bool = betterproto.bool_field(2)
     send_package_info_changes: bool = betterproto.bool_field(3)
     num_app_info_cached: int = betterproto.uint32_field(4)
     num_package_info_cached: int = betterproto.uint32_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPicsChangesSinceResponse(betterproto.Message):
+class CMsgClientPicsChangesSinceResponse(ProtobufMessage, msg=EMsg.ClientPICSChangesSinceResponse):
     current_change_number: int = betterproto.uint32_field(1)
     since_change_number: int = betterproto.uint32_field(2)
     force_full_update: bool = betterproto.bool_field(3)
-    package_changes: List["CMsgClientPicsChangesSinceResponsePackageChange"] = betterproto.message_field(4)
-    app_changes: List["CMsgClientPicsChangesSinceResponseAppChange"] = betterproto.message_field(5)
+    package_changes: "list[CMsgClientPicsChangesSinceResponsePackageChange]" = betterproto.message_field(4)
+    app_changes: "list[CMsgClientPicsChangesSinceResponseAppChange]" = betterproto.message_field(5)
     force_full_app_update: bool = betterproto.bool_field(6)
     force_full_package_update: bool = betterproto.bool_field(7)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPicsChangesSinceResponsePackageChange(betterproto.Message):
     packageid: int = betterproto.uint32_field(1)
@@ -106,18 +106,17 @@
 @dataclass(eq=False, repr=False)
 class CMsgClientPicsChangesSinceResponseAppChange(betterproto.Message):
     appid: int = betterproto.uint32_field(1)
     change_number: int = betterproto.uint32_field(2)
     needs_token: bool = betterproto.bool_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPicsProductInfoRequest(betterproto.Message):
-    packages: List["CMsgClientPicsProductInfoRequestPackageInfo"] = betterproto.message_field(1)
-    apps: List["CMsgClientPicsProductInfoRequestAppInfo"] = betterproto.message_field(2)
+class CMsgClientPicsProductInfoRequest(ProtobufMessage, msg=EMsg.ClientPICSProductInfoRequest):
+    packages: "list[CMsgClientPicsProductInfoRequestPackageInfo]" = betterproto.message_field(1)
+    apps: "list[CMsgClientPicsProductInfoRequestAppInfo]" = betterproto.message_field(2)
     meta_data_only: bool = betterproto.bool_field(3)
     num_prev_failed: int = betterproto.uint32_field(4)
     supports_package_tokens: int = betterproto.uint32_field(5)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPicsProductInfoRequestAppInfo(betterproto.Message):
@@ -128,20 +127,19 @@
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPicsProductInfoRequestPackageInfo(betterproto.Message):
     packageid: int = betterproto.uint32_field(1)
     access_token: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPicsProductInfoResponse(betterproto.Message):
-    apps: List["CMsgClientPicsProductInfoResponseAppInfo"] = betterproto.message_field(1)
-    unknown_appids: List[int] = betterproto.uint32_field(2)
-    packages: List["CMsgClientPicsProductInfoResponsePackageInfo"] = betterproto.message_field(3)
-    unknown_packageids: List[int] = betterproto.uint32_field(4)
+class CMsgClientPicsProductInfoResponse(ProtobufMessage, msg=EMsg.ClientPICSProductInfoResponse):
+    apps: "list[CMsgClientPicsProductInfoResponseAppInfo]" = betterproto.message_field(1)
+    unknown_appids: list[int] = betterproto.uint32_field(2)
+    packages: "list[CMsgClientPicsProductInfoResponsePackageInfo]" = betterproto.message_field(3)
+    unknown_packageids: list[int] = betterproto.uint32_field(4)
     meta_data_only: bool = betterproto.bool_field(5)
     response_pending: bool = betterproto.bool_field(6)
     http_min_size: int = betterproto.uint32_field(7)
     http_host: str = betterproto.string_field(8)
 
 
 @dataclass(eq=False, repr=False)
@@ -161,26 +159,24 @@
     change_number: int = betterproto.uint32_field(2)
     missing_token: bool = betterproto.bool_field(3)
     sha: bytes = betterproto.bytes_field(4)
     buffer: bytes = betterproto.bytes_field(5)
     size: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPicsAccessTokenRequest(betterproto.Message):
-    packageids: List[int] = betterproto.uint32_field(1)
-    appids: List[int] = betterproto.uint32_field(2)
+class CMsgClientPicsAccessTokenRequest(ProtobufMessage, msg=EMsg.ClientPICSAccessTokenRequest):
+    packageids: list[int] = betterproto.uint32_field(1)
+    appids: list[int] = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPicsAccessTokenResponse(betterproto.Message):
-    package_access_tokens: List["CMsgClientPicsAccessTokenResponsePackageToken"] = betterproto.message_field(1)
-    package_denied_tokens: List[int] = betterproto.uint32_field(2)
-    app_access_tokens: List["CMsgClientPicsAccessTokenResponseAppToken"] = betterproto.message_field(3)
-    app_denied_tokens: List[int] = betterproto.uint32_field(4)
+class CMsgClientPicsAccessTokenResponse(ProtobufMessage, msg=EMsg.ClientPICSAccessTokenResponse):
+    package_access_tokens: "list[CMsgClientPicsAccessTokenResponsePackageToken]" = betterproto.message_field(1)
+    package_denied_tokens: list[int] = betterproto.uint32_field(2)
+    app_access_tokens: "list[CMsgClientPicsAccessTokenResponseAppToken]" = betterproto.message_field(3)
+    app_denied_tokens: list[int] = betterproto.uint32_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPicsAccessTokenResponsePackageToken(betterproto.Message):
     packageid: int = betterproto.uint32_field(1)
     access_token: int = betterproto.uint64_field(2)
```

### Comparing `steamio-0.9.9/steam/protobufs/base.py` & `steamio-1.0.0a0/steam/protobufs/base.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,16 +1,18 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_base.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .emsg import EMsg
+from .msg import ProtobufMessage
+
 
 class EProtoClanEventType(betterproto.Enum):
     OtherEvent = 1
     GameEvent = 2
     PartyEvent = 3
     MeetingEvent = 4
     SpecialCauseEvent = 5
@@ -49,57 +51,26 @@
 @dataclass(eq=False, repr=False)
 class CMsgIpAddress(betterproto.Message):
     v4: int = betterproto.fixed32_field(1, group="ip")
     v6: bytes = betterproto.bytes_field(2, group="ip")
 
 
 @dataclass(eq=False, repr=False)
+@dataclass(eq=False, repr=False)
 class CMsgIpAddressBucket(betterproto.Message):
     original_ip_address: "CMsgIpAddress" = betterproto.message_field(1)
     bucket: int = betterproto.fixed64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgProtoBufHeader(betterproto.Message):
-    steam_id: int = betterproto.fixed64_field(1)
-    session_id: int = betterproto.int32_field(2)
-    routing_app_id: int = betterproto.uint32_field(3)
-    job_id_source: int = betterproto.fixed64_field(10)
-    job_id_target: int = betterproto.fixed64_field(11)
-    job_name_target: str = betterproto.string_field(12)
-    seq_num: int = betterproto.int32_field(24)
-    eresult: int = betterproto.int32_field(13)
-    error_message: str = betterproto.string_field(14)
-    auth_account_flags: int = betterproto.uint32_field(16)
-    token_source: int = betterproto.uint32_field(22)
-    admin_spoofing_user: bool = betterproto.bool_field(23)
-    transport_error: int = betterproto.int32_field(17)
-    message_id: int = betterproto.uint64_field(18)
-    publisher_group_id: int = betterproto.uint32_field(19)
-    sys_id: int = betterproto.uint32_field(20)
-    trace_tag: int = betterproto.uint64_field(21)
-    webapi_key_id: int = betterproto.uint32_field(25)
-    is_from_external_source: bool = betterproto.bool_field(26)
-    forward_to_sys_id: List[int] = betterproto.uint32_field(27)
-    cm_sys_id: int = betterproto.uint32_field(28)
-    wg_token: str = betterproto.string_field(30)
-    launcher_type: int = betterproto.uint32_field(31)
-    realm: int = betterproto.uint32_field(32)
-    ip: int = betterproto.uint32_field(15, group="ip_addr")
-    ip_v6: bytes = betterproto.bytes_field(29, group="ip_addr")
-
-
-@dataclass(eq=False, repr=False)
-class CMsgMulti(betterproto.Message):
+class CMsgMulti(ProtobufMessage, msg=EMsg.Multi):
     size_unzipped: int = betterproto.uint32_field(1)
     message_body: bytes = betterproto.bytes_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgProtobufWrapped(betterproto.Message):
+class CMsgProtobufWrapped(ProtobufMessage, msg=EMsg.ProtobufWrapped):
     message_body: bytes = betterproto.bytes_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgAuthTicket(betterproto.Message):
     estate: int = betterproto.uint32_field(1)
     eresult: int = betterproto.uint32_field(2)
@@ -154,16 +125,16 @@
     platform_windows: bool = betterproto.bool_field(2)
     platform_mac: bool = betterproto.bool_field(3)
     platform_linux: bool = betterproto.bool_field(4)
     vr_content: bool = betterproto.bool_field(5)
     adult_content_violence: bool = betterproto.bool_field(6)
     adult_content_sex: bool = betterproto.bool_field(7)
     timestamp_updated: int = betterproto.uint32_field(8)
-    tagids_curated: List[int] = betterproto.uint32_field(9)
-    tagids_filtered: List[int] = betterproto.uint32_field(10)
+    tagids_curated: list[int] = betterproto.uint32_field(9)
+    tagids_filtered: list[int] = betterproto.uint32_field(10)
     website_title: str = betterproto.string_field(11)
     website_url: str = betterproto.string_field(12)
     discussion_url: str = betterproto.string_field(13)
     show_broadcast: bool = betterproto.bool_field(14)
 
 
 @dataclass(eq=False, repr=False)
@@ -187,28 +158,28 @@
 
 
 @dataclass(eq=False, repr=False)
 class CClanMatchEventByRange(betterproto.Message):
     rtime_before: int = betterproto.uint32_field(1)
     rtime_after: int = betterproto.uint32_field(2)
     qualified: int = betterproto.uint32_field(3)
-    events: List["CClanEventUserNewsTuple"] = betterproto.message_field(4)
+    events: "list[CClanEventUserNewsTuple]" = betterproto.message_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class CCommunityClanAnnouncementInfo(betterproto.Message):
     gid: int = betterproto.uint64_field(1)
     clanid: int = betterproto.uint64_field(2)
     posterid: int = betterproto.uint64_field(3)
     headline: str = betterproto.string_field(4)
     posttime: int = betterproto.uint32_field(5)
     updatetime: int = betterproto.uint32_field(6)
     body: str = betterproto.string_field(7)
     commentcount: int = betterproto.int32_field(8)
-    tags: List[str] = betterproto.string_field(9)
+    tags: list[str] = betterproto.string_field(9)
     language: int = betterproto.int32_field(10)
     hidden: bool = betterproto.bool_field(11)
     forum_topic_id: int = betterproto.fixed64_field(12)
     event_gid: int = betterproto.fixed64_field(13)
     voteupcount: int = betterproto.int32_field(14)
     votedowncount: int = betterproto.int32_field(15)
 
@@ -238,15 +209,15 @@
     follower_count: int = betterproto.uint32_field(21)
     ignore_count: int = betterproto.uint32_field(22)
     forum_topic_id: int = betterproto.fixed64_field(23)
     rtime32_last_modified: int = betterproto.uint32_field(24)
     news_post_gid: int = betterproto.fixed64_field(25)
     rtime_mod_reviewed: int = betterproto.uint32_field(26)
     featured_app_tagid: int = betterproto.uint32_field(27)
-    referenced_appids: List[int] = betterproto.uint32_field(28)
+    referenced_appids: list[int] = betterproto.uint32_field(28)
     build_id: int = betterproto.uint32_field(29)
     build_branch: str = betterproto.string_field(30)
 
 
 @dataclass(eq=False, repr=False)
 class CBillingAddress(betterproto.Message):
     first_name: str = betterproto.string_field(1)
```

### Comparing `steamio-0.9.9/steam/protobufs/chat.py` & `steamio-1.0.0a0/steam/protobufs/chat.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_chat.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
 from .friends import CMsgClientPersonaStateFriend
+from .msg import UnifiedMessage
 
 
 class EChatRoomJoinState(betterproto.Enum):
     Default = 0
     NONE = 1
     Joined = 2
     TestInvalid = 99
@@ -75,20 +75,19 @@
 
 
 @dataclass(eq=False, repr=False)
 class RequestFriendPersonaStatesResponse(betterproto.Message):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CreateChatRoomGroupRequest(betterproto.Message):
+class CreateChatRoomGroupRequest(UnifiedMessage, um_name="ChatRoom.CreateChatRoomGroup"):
     steamid_partner: int = betterproto.fixed64_field(1)
     steamid_invited: int = betterproto.fixed64_field(2)
     name: str = betterproto.string_field(3)
-    steamid_invitees: List[int] = betterproto.fixed64_field(4)
+    steamid_invitees: list[int] = betterproto.fixed64_field(4)
     watching_broadcast_accountid: int = betterproto.uint32_field(6)
     watching_broadcast_channel_id: int = betterproto.uint64_field(7)
 
 
 @dataclass(eq=False, repr=False)
 class Role(betterproto.Message):
     role_id: int = betterproto.uint64_field(1)
@@ -126,52 +125,52 @@
     chat_name: str = betterproto.string_field(2)
     clanid: int = betterproto.uint32_field(13)
     accountid_owner: int = betterproto.uint32_field(14)
     appid: int = betterproto.uint32_field(21)
     tagline: str = betterproto.string_field(15)
     avatar_sha: bytes = betterproto.bytes_field(16)
     default_role_id: int = betterproto.uint64_field(17)
-    roles: List["Role"] = betterproto.message_field(18)
-    role_actions: List["RoleActions"] = betterproto.message_field(19)
+    roles: "list[Role]" = betterproto.message_field(18)
+    role_actions: "list[RoleActions]" = betterproto.message_field(19)
     watching_broadcast_accountid: int = betterproto.uint32_field(20)
-    party_beacons: List["PartyBeacon"] = betterproto.message_field(22)
+    party_beacons: "list[PartyBeacon]" = betterproto.message_field(22)
     watching_broadcast_channel_id: int = betterproto.uint64_field(23)
     active_minigame_id: int = betterproto.uint64_field(24)
     avatar_ugc_url: str = betterproto.string_field(25)
     disabled: bool = betterproto.bool_field(26)
 
 
 @dataclass(eq=False, repr=False)
 class Member(betterproto.Message):
     accountid: int = betterproto.uint32_field(1)
     state: "EChatRoomJoinState" = betterproto.enum_field(3)
     rank: "EChatRoomGroupRank" = betterproto.enum_field(4)
     time_kick_expire: int = betterproto.uint32_field(6)
-    role_ids: List[int] = betterproto.uint64_field(7)
+    role_ids: list[int] = betterproto.uint64_field(7)
 
 
 @dataclass(eq=False, repr=False)
 class State(betterproto.Message):
     chat_id: int = betterproto.uint64_field(1)
     chat_name: str = betterproto.string_field(2)
     voice_allowed: bool = betterproto.bool_field(3)
-    members_in_voice: List[int] = betterproto.uint32_field(4)
+    members_in_voice: list[int] = betterproto.uint32_field(4)
     time_last_message: int = betterproto.uint32_field(5)
     sort_order: int = betterproto.uint32_field(6)
     last_message: str = betterproto.string_field(7)
     accountid_last_message: int = betterproto.uint32_field(8)
 
 
 @dataclass(eq=False, repr=False)
 class GroupState(betterproto.Message):
     header_state: "GroupHeaderState" = betterproto.message_field(1)
-    members: List["Member"] = betterproto.message_field(2)
+    members: "list[Member]" = betterproto.message_field(2)
     default_chat_id: int = betterproto.uint64_field(4)
-    chat_rooms: List["State"] = betterproto.message_field(5)
-    kicked: List["Member"] = betterproto.message_field(7)
+    chat_rooms: "list[State]" = betterproto.message_field(5)
+    kicked: "list[Member]" = betterproto.message_field(7)
 
 
 @dataclass(eq=False, repr=False)
 class ChatRoomState(betterproto.Message):
     chat_id: int = betterproto.uint64_field(1)
     time_joined: int = betterproto.uint32_field(2)
     time_last_ack: int = betterproto.uint32_field(3)
@@ -182,393 +181,329 @@
     time_first_unread: int = betterproto.uint32_field(8)
 
 
 @dataclass(eq=False, repr=False)
 class ChatRoomGroupState(betterproto.Message):
     chat_group_id: int = betterproto.uint64_field(1)
     time_joined: int = betterproto.uint32_field(2)
-    user_chat_room_state: List["ChatRoomState"] = betterproto.message_field(3)
+    user_chat_room_state: "list[ChatRoomState]" = betterproto.message_field(3)
     desktop_notification_level: "EChatRoomNotificationLevel" = betterproto.enum_field(4)
     mobile_notification_level: "EChatRoomNotificationLevel" = betterproto.enum_field(5)
     time_last_group_ack: int = betterproto.uint32_field(6)
     unread_indicator_muted: bool = betterproto.bool_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class CreateChatRoomGroupResponse(betterproto.Message):
+class CreateChatRoomGroupResponse(UnifiedMessage, um_name="ChatRoom.CreateChatRoomGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     state: "GroupState" = betterproto.message_field(2)
     user_chat_state: "ChatRoomGroupState" = betterproto.message_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class SaveChatRoomGroupRequest(betterproto.Message):
+class SaveChatRoomGroupRequest(UnifiedMessage, um_name="ChatRoom.SaveChatRoomGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     name: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SaveChatRoomGroupResponse(betterproto.Message):
+class SaveChatRoomGroupResponse(UnifiedMessage, um_name="ChatRoom.SaveChatRoomGroup"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class RenameChatRoomGroupRequest(betterproto.Message):
+class RenameChatRoomGroupRequest(UnifiedMessage, um_name="ChatRoom.RenameChatRoomGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     name: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class RenameChatRoomGroupResponse(betterproto.Message):
+class RenameChatRoomGroupResponse(UnifiedMessage, um_name="ChatRoom.RenameChatRoomGroup"):
     name: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetChatRoomGroupTaglineRequest(betterproto.Message):
+class SetChatRoomGroupTaglineRequest(UnifiedMessage, um_name="ChatRoom.SetChatRoomGroupTagline"):
     chat_group_id: int = betterproto.uint64_field(1)
     tagline: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetChatRoomGroupTaglineResponse(betterproto.Message):
+class SetChatRoomGroupTaglineResponse(UnifiedMessage, um_name="ChatRoom.SetChatRoomGroupTagline"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class SetChatRoomGroupAvatarRequest(betterproto.Message):
+class SetChatRoomGroupAvatarRequest(UnifiedMessage, um_name="ChatRoom.SetChatRoomGroupAvatar"):
     chat_group_id: int = betterproto.uint64_field(1)
     avatar_sha: bytes = betterproto.bytes_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetChatRoomGroupAvatarResponse(betterproto.Message):
+class SetChatRoomGroupAvatarResponse(UnifiedMessage, um_name="ChatRoom.SetChatRoomGroupAvatar"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class SetChatRoomGroupWatchingBroadcastRequest(betterproto.Message):
+class SetChatRoomGroupWatchingBroadcastRequest(UnifiedMessage, um_name="ChatRoom.SetChatRoomGroupWatchingBroadcast"):
     chat_group_id: int = betterproto.uint64_field(1)
     watching_broadcast_accountid: int = betterproto.uint32_field(2)
     watching_broadcast_channel_id: int = betterproto.uint64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class SetChatRoomGroupWatchingBroadcastResponse(betterproto.Message):
+class SetChatRoomGroupWatchingBroadcastResponse(UnifiedMessage, um_name="ChatRoom.SetChatRoomGroupWatchingBroadcast"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class JoinMiniGameForChatRoomGroupRequest(betterproto.Message):
+class JoinMiniGameForChatRoomGroupRequest(UnifiedMessage, um_name="ChatRoom.JoinMiniGameForChatRoomGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class JoinMiniGameForChatRoomGroupResponse(betterproto.Message):
+class JoinMiniGameForChatRoomGroupResponse(UnifiedMessage, um_name="ChatRoom.JoinMiniGameForChatRoomGroup"):
     minigame_id: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class EndMiniGameForChatRoomGroupRequest(betterproto.Message):
+class EndMiniGameForChatRoomGroupRequest(UnifiedMessage, um_name="ChatRoom.EndMiniGameForChatRoomGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     minigame_id: int = betterproto.uint64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class EndMiniGameForChatRoomGroupResponse(betterproto.Message):
+class EndMiniGameForChatRoomGroupResponse(UnifiedMessage, um_name="ChatRoom.EndMiniGameForChatRoomGroup"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class MuteUserRequest(betterproto.Message):
+class MuteUserRequest(UnifiedMessage, um_name="ChatRoom.MuteUserInGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     steamid: int = betterproto.fixed64_field(2)
     expiration: int = betterproto.int32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class MuteUserResponse(betterproto.Message):
+class MuteUserResponse(UnifiedMessage, um_name="ChatRoom.MuteUserInGroup"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class KickUserRequest(betterproto.Message):
+class KickUserRequest(UnifiedMessage, um_name="ChatRoom.KickUserFromGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     steamid: int = betterproto.fixed64_field(2)
     expiration: int = betterproto.int32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class KickUserResponse(betterproto.Message):
+class KickUserResponse(UnifiedMessage, um_name="ChatRoom.KickUserFromGroup"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class SetUserBanStateRequest(betterproto.Message):
+class SetUserBanStateRequest(UnifiedMessage, um_name="ChatRoom.SetUserBanState"):
     chat_group_id: int = betterproto.uint64_field(1)
     steamid: int = betterproto.fixed64_field(2)
     ban_state: bool = betterproto.bool_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class SetUserBanStateResponse(betterproto.Message):
+class SetUserBanStateResponse(UnifiedMessage, um_name="ChatRoom.SetUserBanState"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class RevokeInviteRequest(betterproto.Message):
+class RevokeInviteRequest(UnifiedMessage, um_name="ChatRoom.RevokeInviteToGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     steamid: int = betterproto.fixed64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class RevokeInviteResponse(betterproto.Message):
+class RevokeInviteResponse(UnifiedMessage, um_name="ChatRoom.RevokeInviteToGroup"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CreateRoleRequest(betterproto.Message):
+class CreateRoleRequest(UnifiedMessage, um_name="ChatRoom.CreateRole"):
     chat_group_id: int = betterproto.uint64_field(1)
     name: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CreateRoleResponse(betterproto.Message):
+class CreateRoleResponse(UnifiedMessage, um_name="ChatRoom.CreateRole"):
     actions: "RoleActions" = betterproto.message_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetRolesRequest(betterproto.Message):
+class GetRolesRequest(UnifiedMessage, um_name="ChatRoom.GetRoles"):
     chat_group_id: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetRolesResponse(betterproto.Message):
-    roles: List["Role"] = betterproto.message_field(1)
+class GetRolesResponse(UnifiedMessage, um_name="ChatRoom.GetRoles"):
+    roles: "list[Role]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class RenameRoleRequest(betterproto.Message):
+class RenameRoleRequest(UnifiedMessage, um_name="ChatRoom.RenameRole"):
     chat_group_id: int = betterproto.uint64_field(1)
     role_id: int = betterproto.uint64_field(2)
     name: str = betterproto.string_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class RenameRoleResponse(betterproto.Message):
+class RenameRoleResponse(UnifiedMessage, um_name="ChatRoom.RenameRole"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class ReorderRoleRequest(betterproto.Message):
+class ReorderRoleRequest(UnifiedMessage, um_name="ChatRoom.ReorderRole"):
     chat_group_id: int = betterproto.uint64_field(1)
     role_id: int = betterproto.uint64_field(2)
     ordinal: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class ReorderRoleResponse(betterproto.Message):
+class ReorderRoleResponse(UnifiedMessage, um_name="ChatRoom.ReorderRole"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class DeleteRoleRequest(betterproto.Message):
+class DeleteRoleRequest(UnifiedMessage, um_name="ChatRoom.DeleteRole"):
     chat_group_id: int = betterproto.uint64_field(1)
     role_id: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class DeleteRoleResponse(betterproto.Message):
+class DeleteRoleResponse(UnifiedMessage, um_name="ChatRoom.DeleteRole"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetRoleActionsRequest(betterproto.Message):
+class GetRoleActionsRequest(UnifiedMessage, um_name="ChatRoom.GetRoleActions"):
     chat_group_id: int = betterproto.uint64_field(1)
     role_id: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetRoleActionsResponse(betterproto.Message):
-    actions: List["RoleActions"] = betterproto.message_field(1)
+class GetRoleActionsResponse(UnifiedMessage, um_name="ChatRoom.GetRoleActions"):
+    actions: "list[RoleActions]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class ReplaceRoleActionsRequest(betterproto.Message):
+class ReplaceRoleActionsRequest(UnifiedMessage, um_name="ChatRoom.ReplaceRoleActions"):
     chat_group_id: int = betterproto.uint64_field(1)
     role_id: int = betterproto.uint64_field(2)
     actions: "RoleActions" = betterproto.message_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class ReplaceRoleActionsResponse(betterproto.Message):
+class ReplaceRoleActionsResponse(UnifiedMessage, um_name="ChatRoom.ReplaceRoleActions"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class AddRoleToUserRequest(betterproto.Message):
+class AddRoleToUserRequest(UnifiedMessage, um_name="ChatRoom.AddRoleToUser"):
     chat_group_id: int = betterproto.uint64_field(1)
     role_id: int = betterproto.uint64_field(3)
     steamid: int = betterproto.fixed64_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class AddRoleToUserResponse(betterproto.Message):
+class AddRoleToUserResponse(UnifiedMessage, um_name="ChatRoom.AddRoleToUser"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetRolesForUserRequest(betterproto.Message):
+class GetRolesForUserRequest(UnifiedMessage, um_name="ChatRoom.GetRolesForUser"):
     chat_group_id: int = betterproto.uint64_field(1)
     steamid: int = betterproto.fixed64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetRolesForUserResponse(betterproto.Message):
-    role_ids: List[int] = betterproto.uint64_field(1)
+class GetRolesForUserResponse(UnifiedMessage, um_name="ChatRoom.GetRolesForUser"):
+    role_ids: list[int] = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class DeleteRoleFromUserRequest(betterproto.Message):
+class DeleteRoleFromUserRequest(UnifiedMessage, um_name="ChatRoom.DeleteRoleFromUser"):
     chat_group_id: int = betterproto.uint64_field(1)
     role_id: int = betterproto.uint64_field(3)
     steamid: int = betterproto.fixed64_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class DeleteRoleFromUserResponse(betterproto.Message):
+class DeleteRoleFromUserResponse(UnifiedMessage, um_name="ChatRoom.DeleteRoleFromUser"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class JoinChatRoomGroupRequest(betterproto.Message):
+class JoinChatRoomGroupRequest(UnifiedMessage, um_name="ChatRoom.JoinChatRoomGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     invite_code: str = betterproto.string_field(2)
     chat_id: int = betterproto.uint64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class JoinChatRoomGroupResponse(betterproto.Message):
+class JoinChatRoomGroupResponse(UnifiedMessage, um_name="ChatRoom.JoinChatRoomGroup"):
     state: "GroupState" = betterproto.message_field(1)
     user_chat_state: "ChatRoomGroupState" = betterproto.message_field(3)
     join_chat_id: int = betterproto.uint64_field(4)
     time_expire: int = betterproto.uint32_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class InviteFriendToChatRoomGroupRequest(betterproto.Message):
+class InviteFriendToChatRoomGroupRequest(UnifiedMessage, um_name="ChatRoom.InviteFriendToChatRoomGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
     steamid: int = betterproto.fixed64_field(2)
     chat_id: int = betterproto.uint64_field(3)
     skip_friendsui_check: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class InviteFriendToChatRoomGroupResponse(betterproto.Message):
+class InviteFriendToChatRoomGroupResponse(UnifiedMessage, um_name="ChatRoom.InviteFriendToChatRoomGroup"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class LeaveChatRoomGroupRequest(betterproto.Message):
+class LeaveChatRoomGroupRequest(UnifiedMessage, um_name="ChatRoom.LeaveChatRoomGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class LeaveChatRoomGroupResponse(betterproto.Message):
+class LeaveChatRoomGroupResponse(UnifiedMessage, um_name="ChatRoom.LeaveChatRoomGroup"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CreateChatRoomRequest(betterproto.Message):
+class CreateChatRoomRequest(UnifiedMessage, um_name="ChatRoom.CreateChatRoom"):
     chat_group_id: int = betterproto.uint64_field(1)
     name: str = betterproto.string_field(2)
     allow_voice: bool = betterproto.bool_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CreateChatRoomResponse(betterproto.Message):
+class CreateChatRoomResponse(UnifiedMessage, um_name="ChatRoom.CreateChatRoom"):
     chat_room: "State" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class DeleteChatRoomRequest(betterproto.Message):
+class DeleteChatRoomRequest(UnifiedMessage, um_name="ChatRoom.DeleteChatRoom"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class DeleteChatRoomResponse(betterproto.Message):
+class DeleteChatRoomResponse(UnifiedMessage, um_name="ChatRoom.DeleteChatRoom"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class RenameChatRoomRequest(betterproto.Message):
+class RenameChatRoomRequest(UnifiedMessage, um_name="ChatRoom.RenameChatRoom"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     name: str = betterproto.string_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class RenameChatRoomResponse(betterproto.Message):
+class RenameChatRoomResponse(UnifiedMessage, um_name="ChatRoom.RenameChatRoom"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class ReorderChatRoomRequest(betterproto.Message):
+class ReorderChatRoomRequest(UnifiedMessage, um_name="ChatRoom.ReorderChatRoom"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     move_after_chat_id: int = betterproto.uint64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class ReorderChatRoomResponse(betterproto.Message):
+class ReorderChatRoomResponse(UnifiedMessage, um_name="ChatRoom.ReorderChatRoom"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class SendChatMessageRequest(betterproto.Message):
+class SendChatMessageRequest(UnifiedMessage, um_name="ChatRoom.SendChatMessage"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     message: str = betterproto.string_field(3)
     echo_to_sender: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class SendChatMessageResponse(betterproto.Message):
+class SendChatMessageResponse(UnifiedMessage, um_name="ChatRoom.SendChatMessage"):
     modified_message: str = betterproto.string_field(1)
     server_timestamp: int = betterproto.uint32_field(2)
     ordinal: int = betterproto.uint32_field(3)
     message_without_bb_code: str = betterproto.string_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class JoinVoiceChatRequest(betterproto.Message):
+class JoinVoiceChatRequest(UnifiedMessage, um_name="ChatRoom.JoinVoiceChat"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class JoinVoiceChatResponse(betterproto.Message):
+class JoinVoiceChatResponse(UnifiedMessage, um_name="ChatRoom.JoinVoiceChat"):
     voice_chatid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class LeaveVoiceChatRequest(betterproto.Message):
+class LeaveVoiceChatRequest(UnifiedMessage, um_name="ChatRoom.LeaveVoiceChat"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class LeaveVoiceChatResponse(betterproto.Message):
+class LeaveVoiceChatResponse(UnifiedMessage, um_name="ChatRoom.LeaveVoiceChat"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetMessageHistoryRequest(betterproto.Message):
+class GetMessageHistoryRequest(UnifiedMessage, um_name="ChatRoom.GetMessageHistory"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     last_time: int = betterproto.uint32_field(3)
     last_ordinal: int = betterproto.uint32_field(4)
     start_time: int = betterproto.uint32_field(5)
     start_ordinal: int = betterproto.uint32_field(6)
     max_count: int = betterproto.uint32_field(7)
@@ -577,247 +512,221 @@
 @dataclass(eq=False, repr=False)
 class ServerMessage(betterproto.Message):
     message: "EChatRoomServerMessage" = betterproto.enum_field(1)
     string_param: str = betterproto.string_field(2)
     accountid_param: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetMessageHistoryResponse(betterproto.Message):
-    messages: List["GetMessageHistoryResponseChatMessage"] = betterproto.message_field(1)
+class GetMessageHistoryResponse(UnifiedMessage, um_name="ChatRoom.GetMessageHistory"):
+    messages: "list[GetMessageHistoryResponseChatMessage]" = betterproto.message_field(1)
     more_available: bool = betterproto.bool_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class GetMessageHistoryResponseChatMessage(betterproto.Message):
     sender: int = betterproto.uint32_field(1)
     server_timestamp: int = betterproto.uint32_field(2)
     message: str = betterproto.string_field(3)
     ordinal: int = betterproto.uint32_field(4)
     server_message: "ServerMessage" = betterproto.message_field(5)
     deleted: bool = betterproto.bool_field(6)
-    reactions: List["GetMessageHistoryResponseChatMessageMessageReaction"] = betterproto.message_field(7)
+    reactions: "list[GetMessageHistoryResponseChatMessageMessageReaction]" = betterproto.message_field(7)
 
 
 @dataclass(eq=False, repr=False)
 class GetMessageHistoryResponseChatMessageMessageReaction(betterproto.Message):
     reaction_type: "EChatRoomMessageReactionType" = betterproto.enum_field(1)
     reaction: str = betterproto.string_field(2)
     num_reactors: int = betterproto.uint32_field(3)
     has_user_reacted: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class GetMyChatRoomGroupsRequest(betterproto.Message):
+class GetMyChatRoomGroupsRequest(UnifiedMessage, um_name="ChatRoom.GetMyChatRoomGroups"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetChatRoomGroupSummaryResponse(betterproto.Message):
+class GetChatRoomGroupSummaryResponse(UnifiedMessage, um_name="ChatRoom.GetChatRoomGroupSummary"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_group_name: str = betterproto.string_field(2)
     active_member_count: int = betterproto.uint32_field(3)
     active_voice_member_count: int = betterproto.uint32_field(4)
     default_chat_id: int = betterproto.uint64_field(5)
-    chat_rooms: List["State"] = betterproto.message_field(6)
+    chat_rooms: "list[State]" = betterproto.message_field(6)
     clanid: int = betterproto.uint32_field(7)
     chat_group_tagline: str = betterproto.string_field(8)
     accountid_owner: int = betterproto.uint32_field(9)
-    top_members: List[int] = betterproto.uint32_field(10)
+    top_members: list[int] = betterproto.uint32_field(10)
     chat_group_avatar_sha: bytes = betterproto.bytes_field(11)
     rank: "EChatRoomGroupRank" = betterproto.enum_field(12)
     default_role_id: int = betterproto.uint64_field(13)
-    role_ids: List[int] = betterproto.uint64_field(14)
-    role_actions: List["RoleActions"] = betterproto.message_field(15)
+    role_ids: list[int] = betterproto.uint64_field(14)
+    role_actions: "list[RoleActions]" = betterproto.message_field(15)
     watching_broadcast_accountid: int = betterproto.uint32_field(16)
     appid: int = betterproto.uint32_field(17)
-    party_beacons: List["PartyBeacon"] = betterproto.message_field(18)
+    party_beacons: "list[PartyBeacon]" = betterproto.message_field(18)
     watching_broadcast_channel_id: int = betterproto.uint64_field(19)
     active_minigame_id: int = betterproto.uint64_field(20)
     avatar_ugc_url: str = betterproto.string_field(21)
     disabled: bool = betterproto.bool_field(22)
 
 
 @dataclass(eq=False, repr=False)
 class SummaryPair(betterproto.Message):
     user_chat_group_state: "ChatRoomGroupState" = betterproto.message_field(1)
     group_summary: "GetChatRoomGroupSummaryResponse" = betterproto.message_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetMyChatRoomGroupsResponse(betterproto.Message):
-    chat_room_groups: List["SummaryPair"] = betterproto.message_field(1)
+class GetMyChatRoomGroupsResponse(UnifiedMessage, um_name="ChatRoom.GetMyChatRoomGroups"):
+    chat_room_groups: "list[SummaryPair]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetChatRoomGroupStateRequest(betterproto.Message):
+class GetChatRoomGroupStateRequest(UnifiedMessage, um_name="ChatRoom.GetChatRoomGroupState"):
     chat_group_id: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetChatRoomGroupStateResponse(betterproto.Message):
+class GetChatRoomGroupStateResponse(UnifiedMessage, um_name="ChatRoom.GetChatRoomGroupState"):
     state: "GroupState" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetChatRoomGroupSummaryRequest(betterproto.Message):
+class GetChatRoomGroupSummaryRequest(UnifiedMessage, um_name="ChatRoom.GetChatRoomGroupSummary"):
     chat_group_id: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetAppChatRoomGroupForceActiveRequest(betterproto.Message):
+class SetAppChatRoomGroupForceActiveRequest(UnifiedMessage, um_name="ChatRoom.SetAppChatRoomGroupForceActive"):
     chat_group_id: int = betterproto.uint64_field(1)
     requesting_app_id: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetAppChatRoomGroupForceActiveResponse(betterproto.Message):
-    result: int = betterproto.uint32_field(1)
-    accounts_in_channel: List[int] = betterproto.uint32_field(2)
+class SetAppChatRoomGroupForceActiveResponse(UnifiedMessage, um_name="ChatRoom.SetAppChatRoomGroupForceActive"):
+    eresult: int = betterproto.uint32_field(1)
+    accounts_in_channel: list[int] = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetAppChatRoomGroupStopForceActiveNotification(betterproto.Message):
+class SetAppChatRoomGroupStopForceActiveNotification(
+    UnifiedMessage, um_name="ChatRoom.SetAppChatRoomGroupStopForceActive"
+):
     chat_group_id: int = betterproto.uint64_field(1)
     requesting_app_id: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class AckChatMessageNotification(betterproto.Message):
+class AckChatMessageNotification(UnifiedMessage, um_name="ChatRoom.AckChatMessage"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     timestamp: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CreateInviteLinkRequest(betterproto.Message):
+class CreateInviteLinkRequest(UnifiedMessage, um_name="ChatRoom.CreateInviteLink"):
     chat_group_id: int = betterproto.uint64_field(1)
     seconds_valid: int = betterproto.uint32_field(2)
     chat_id: int = betterproto.uint64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CreateInviteLinkResponse(betterproto.Message):
+class CreateInviteLinkResponse(UnifiedMessage, um_name="ChatRoom.CreateInviteLink"):
     invite_code: str = betterproto.string_field(1)
     seconds_valid: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetInviteLinkInfoRequest(betterproto.Message):
+class GetInviteLinkInfoRequest(UnifiedMessage, um_name="ChatRoom.GetInviteLinkInfo"):
     invite_code: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetInviteLinkInfoResponse(betterproto.Message):
+class GetInviteLinkInfoResponse(UnifiedMessage, um_name="ChatRoom.GetInviteLinkInfo"):
     steamid_sender: int = betterproto.fixed64_field(3)
     time_expires: int = betterproto.uint32_field(4)
     chat_id: int = betterproto.uint64_field(6)
     group_summary: "GetChatRoomGroupSummaryResponse" = betterproto.message_field(8)
     user_chat_group_state: "ChatRoomGroupState" = betterproto.message_field(9)
     time_kick_expire: int = betterproto.uint32_field(10)
     banned: bool = betterproto.bool_field(11)
 
 
-@dataclass(eq=False, repr=False)
-class GetInviteInfoRequest(betterproto.Message):
+class GetInviteInfoRequest(UnifiedMessage, um_name="ChatRoom.GetInviteInfo"):
     steamid_invitee: int = betterproto.fixed64_field(1)
     chat_group_id: int = betterproto.uint64_field(2)
     chat_id: int = betterproto.uint64_field(3)
     invite_code: str = betterproto.string_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class GetInviteInfoResponse(betterproto.Message):
+class GetInviteInfoResponse(UnifiedMessage, um_name="ChatRoom.GetInviteInfo"):
     group_summary: "GetChatRoomGroupSummaryResponse" = betterproto.message_field(1)
     time_kick_expire: int = betterproto.uint32_field(2)
     banned: bool = betterproto.bool_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetInviteLinksForGroupRequest(betterproto.Message):
+class GetInviteLinksForGroupRequest(UnifiedMessage, um_name="ChatRoom.GetInviteLinksForGroup"):
     chat_group_id: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetInviteLinksForGroupResponse(betterproto.Message):
-    invite_links: List["GetInviteLinksForGroupResponseLinkInfo"] = betterproto.message_field(1)
+class GetInviteLinksForGroupResponse(UnifiedMessage, um_name="ChatRoom.GetInviteLinksForGroup"):
+    invite_links: "list[GetInviteLinksForGroupResponseLinkInfo]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetInviteLinksForGroupResponseLinkInfo(betterproto.Message):
     invite_code: str = betterproto.string_field(1)
     steamid_creator: int = betterproto.fixed64_field(2)
     time_expires: int = betterproto.uint32_field(3)
     chat_id: int = betterproto.uint64_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class GetBanListRequest(betterproto.Message):
+class GetBanListRequest(UnifiedMessage, um_name="ChatRoom.GetBanList"):
     chat_group_id: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetBanListResponse(betterproto.Message):
-    bans: List["GetBanListResponseBanInfo"] = betterproto.message_field(1)
+class GetBanListResponse(UnifiedMessage, um_name="ChatRoom.GetBanList"):
+    bans: "list[GetBanListResponseBanInfo]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetBanListResponseBanInfo(betterproto.Message):
     accountid: int = betterproto.uint32_field(1)
     accountid_actor: int = betterproto.uint32_field(2)
     time_banned: int = betterproto.uint32_field(3)
     ban_reason: str = betterproto.string_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class GetInviteListRequest(betterproto.Message):
+class GetInviteListRequest(UnifiedMessage, um_name="ChatRoom.GetInviteList"):
     chat_group_id: int = betterproto.uint64_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GroupInvite(betterproto.Message):
     accountid: int = betterproto.uint32_field(1)
     accountid_actor: int = betterproto.uint32_field(2)
     time_invited: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetInviteListResponse(betterproto.Message):
-    invites: List["GroupInvite"] = betterproto.message_field(1)
+class GetInviteListResponse(UnifiedMessage, um_name="ChatRoom.GetInviteList"):
+    invites: "list[GroupInvite]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class DeleteInviteLinkRequest(betterproto.Message):
+class DeleteInviteLinkRequest(UnifiedMessage, um_name="ChatRoom.DeleteInviteLink"):
     chat_group_id: int = betterproto.uint64_field(1)
     invite_code: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class DeleteInviteLinkResponse(betterproto.Message):
+class DeleteInviteLinkResponse(UnifiedMessage, um_name="ChatRoom.DeleteInviteLink"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class SetSessionActiveChatRoomGroupsRequest(betterproto.Message):
-    chat_group_ids: List[int] = betterproto.uint64_field(1)
-    chat_groups_data_requested: List[int] = betterproto.uint64_field(2)
+class SetSessionActiveChatRoomGroupsRequest(UnifiedMessage, um_name="ChatRoom.SetSessionActiveChatRoomGroups"):
+    chat_group_ids: list[int] = betterproto.uint64_field(1)
+    chat_groups_data_requested: list[int] = betterproto.uint64_field(2)
     virtualize_members_threshold: int = betterproto.int32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class SetSessionActiveChatRoomGroupsResponse(betterproto.Message):
-    chat_states: List["GroupState"] = betterproto.message_field(1)
-    virtualize_members_chat_group_ids: List[int] = betterproto.uint64_field(2)
+class SetSessionActiveChatRoomGroupsResponse(UnifiedMessage, um_name="ChatRoom.SetSessionActiveChatRoomGroups"):
+    chat_states: "list[GroupState]" = betterproto.message_field(1)
+    virtualize_members_chat_group_ids: list[int] = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetUserChatGroupPreferencesRequest(betterproto.Message):
+class SetUserChatGroupPreferencesRequest(UnifiedMessage, um_name="ChatRoom.SetUserChatGroupPreferences"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_group_preferences: "SetUserChatGroupPreferencesRequestChatGroupPreferences" = betterproto.message_field(2)
-    chat_room_preferences: List["SetUserChatGroupPreferencesRequestChatRoomPreferences"] = betterproto.message_field(3)
+    chat_room_preferences: "list[SetUserChatGroupPreferencesRequestChatRoomPreferences]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class SetUserChatGroupPreferencesRequestChatGroupPreferences(betterproto.Message):
     desktop_notification_level: "EChatRoomNotificationLevel" = betterproto.enum_field(1)
     mobile_notification_level: "EChatRoomNotificationLevel" = betterproto.enum_field(2)
     unread_indicator_muted: bool = betterproto.bool_field(3)
@@ -827,194 +736,176 @@
 class SetUserChatGroupPreferencesRequestChatRoomPreferences(betterproto.Message):
     chat_id: int = betterproto.uint64_field(1)
     desktop_notification_level: "EChatRoomNotificationLevel" = betterproto.enum_field(2)
     mobile_notification_level: "EChatRoomNotificationLevel" = betterproto.enum_field(3)
     unread_indicator_muted: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class SetUserChatGroupPreferencesResponse(betterproto.Message):
+class SetUserChatGroupPreferencesResponse(UnifiedMessage, um_name="ChatRoom.SetUserChatGroupPreferences"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class DeleteChatMessagesRequest(betterproto.Message):
+class DeleteChatMessagesRequest(UnifiedMessage, um_name="ChatRoom.DeleteChatMessages"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
-    messages: List["DeleteChatMessagesRequestMessage"] = betterproto.message_field(3)
+    messages: "list[DeleteChatMessagesRequestMessage]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class DeleteChatMessagesRequestMessage(betterproto.Message):
     server_timestamp: int = betterproto.uint32_field(1)
     ordinal: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class DeleteChatMessagesResponse(betterproto.Message):
+class DeleteChatMessagesResponse(UnifiedMessage, um_name="ChatRoom.DeleteChatMessages"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class UpdateMemberListViewNotification(betterproto.Message):
+class UpdateMemberListViewNotification(UnifiedMessage, um_name="ChatRoom.UpdateMemberListView"):
     chat_group_id: int = betterproto.uint64_field(1)
     view_id: int = betterproto.uint64_field(2)
     start: int = betterproto.int32_field(3)
     end: int = betterproto.int32_field(4)
     client_changenumber: int = betterproto.int32_field(5)
     delete_view: bool = betterproto.bool_field(6)
-    persona_subscribe_accountids: List[int] = betterproto.int32_field(7)
-    persona_unsubscribe_accountids: List[int] = betterproto.int32_field(8)
+    persona_subscribe_accountids: list[int] = betterproto.int32_field(7)
+    persona_unsubscribe_accountids: list[int] = betterproto.int32_field(8)
 
 
-@dataclass(eq=False, repr=False)
-class SearchMembersRequest(betterproto.Message):
+class SearchMembersRequest(UnifiedMessage, um_name="ChatRoom.SearchMembers"):
     chat_group_id: int = betterproto.uint64_field(1)
     search_id: int = betterproto.uint64_field(2)
     search_text: str = betterproto.string_field(3)
     max_results: int = betterproto.int32_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class SearchMembersResponse(betterproto.Message):
-    matching_members: List["SearchMembersResponseMemberMatch"] = betterproto.message_field(1)
+class SearchMembersResponse(UnifiedMessage, um_name="ChatRoom.SearchMembers"):
+    matching_members: "list[SearchMembersResponseMemberMatch]" = betterproto.message_field(1)
     status_flags: int = betterproto.uint32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class SearchMembersResponseMemberMatch(betterproto.Message):
     accountid: int = betterproto.int32_field(1)
     persona: CMsgClientPersonaStateFriend = betterproto.message_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateMessageReactionRequest(betterproto.Message):
+class UpdateMessageReactionRequest(UnifiedMessage, um_name="ChatRoom.UpdateMessageReaction"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     server_timestamp: int = betterproto.uint32_field(3)
     ordinal: int = betterproto.uint32_field(4)
     reaction_type: "EChatRoomMessageReactionType" = betterproto.enum_field(5)
     reaction: str = betterproto.string_field(6)
     is_add: bool = betterproto.bool_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateMessageReactionResponse(betterproto.Message):
+class UpdateMessageReactionResponse(UnifiedMessage, um_name="ChatRoom.UpdateMessageReaction"):
     num_reactors: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetMessageReactionReactorsRequest(betterproto.Message):
+class GetMessageReactionReactorsRequest(UnifiedMessage, um_name="ChatRoom.GetMessageReactionReactors"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     server_timestamp: int = betterproto.uint32_field(3)
     ordinal: int = betterproto.uint32_field(4)
     reaction_type: "EChatRoomMessageReactionType" = betterproto.enum_field(5)
     reaction: str = betterproto.string_field(6)
     limit: int = betterproto.uint32_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class GetMessageReactionReactorsResponse(betterproto.Message):
-    reactors: List[int] = betterproto.uint32_field(1)
+class GetMessageReactionReactorsResponse(UnifiedMessage, um_name="ChatRoom.GetMessageReactionReactors"):
+    reactors: list[int] = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetClanChatRoomInfoRequest(betterproto.Message):
+class GetClanChatRoomInfoRequest(UnifiedMessage, um_name="ClanChatRooms.GetClanChatRoomInfo"):
     steamid: int = betterproto.fixed64_field(1)
     autocreate: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetClanChatRoomInfoResponse(betterproto.Message):
+class GetClanChatRoomInfoResponse(UnifiedMessage, um_name="ClanChatRooms.GetClanChatRoomInfo"):
     chat_group_summary: "GetChatRoomGroupSummaryResponse" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetClanChatRoomPrivateRequest(betterproto.Message):
+class SetClanChatRoomPrivateRequest(UnifiedMessage, um_name="ClanChatRooms.SetClanChatRoomPrivate"):
     steamid: int = betterproto.fixed64_field(1)
     chat_room_private: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetClanChatRoomPrivateResponse(betterproto.Message):
+class SetClanChatRoomPrivateResponse(UnifiedMessage, um_name="ClanChatRooms.SetClanChatRoomPrivate"):
     chat_room_private: bool = betterproto.bool_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class Mentions(betterproto.Message):
     mention_all: bool = betterproto.bool_field(1)
     mention_here: bool = betterproto.bool_field(2)
-    ids: List[int] = betterproto.uint32_field(3)
+    ids: list[int] = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class IncomingChatMessageNotification(betterproto.Message):
+class IncomingChatMessageNotification(UnifiedMessage, um_name="ChatRoomClient.NotifyIncomingChatMessage"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     steamid_sender: int = betterproto.fixed64_field(3)
     message: str = betterproto.string_field(4)
     timestamp: int = betterproto.uint32_field(5)
     mentions: "Mentions" = betterproto.message_field(6)
     ordinal: int = betterproto.uint32_field(7)
     server_message: "ServerMessage" = betterproto.message_field(8)
     message_no_bbcode: str = betterproto.string_field(9)
     chat_name: str = betterproto.string_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class ChatMessageModifiedNotification(betterproto.Message):
+class ChatMessageModifiedNotification(UnifiedMessage, um_name="ChatRoomClient.NotifyChatMessageModified"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
-    messages: List["ChatMessageModifiedNotificationChatMessage"] = betterproto.message_field(3)
+    messages: "list[ChatMessageModifiedNotificationChatMessage]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class ChatMessageModifiedNotificationChatMessage(betterproto.Message):
     server_timestamp: int = betterproto.uint32_field(1)
     ordinal: int = betterproto.uint32_field(2)
     deleted: bool = betterproto.bool_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class MemberStateChangeNotification(betterproto.Message):
+class MemberStateChangeNotification(UnifiedMessage, um_name="ChatRoomClient.NotifyMemberStateChange"):
     chat_group_id: int = betterproto.uint64_field(1)
     member: "Member" = betterproto.message_field(2)
     change: "EChatRoomMemberStateChange" = betterproto.enum_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class ChatRoomHeaderStateNotification(betterproto.Message):
+class ChatRoomHeaderStateNotification(UnifiedMessage, um_name="ChatRoomClient.NotifyChatRoomHeaderStateChange"):
     header_state: "GroupHeaderState" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class ChatRoomGroupRoomsChangeNotification(betterproto.Message):
+class ChatRoomGroupRoomsChangeNotification(UnifiedMessage, um_name="ChatRoomClient.NotifyChatRoomGroupRoomsChange"):
     chat_group_id: int = betterproto.uint64_field(1)
     default_chat_id: int = betterproto.uint64_field(2)
-    chat_rooms: List["State"] = betterproto.message_field(3)
+    chat_rooms: "list[State]" = betterproto.message_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class NotifyShouldRejoinChatRoomVoiceChatNotification(betterproto.Message):
+class NotifyShouldRejoinChatRoomVoiceChatNotification(
+    UnifiedMessage, um_name="ChatRoomClient.NotifyShouldRejoinChatRoomVoiceChat"
+):
     chat_id: int = betterproto.uint64_field(1)
     chat_group_id: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class NotifyChatGroupUserStateChangedNotification(betterproto.Message):
+class NotifyChatGroupUserStateChangedNotification(
+    UnifiedMessage, um_name="ChatRoomClient.NotifyChatGroupUserStateChanged"
+):
     chat_group_id: int = betterproto.uint64_field(1)
     user_chat_group_state: "ChatRoomGroupState" = betterproto.message_field(2)
     group_summary: "GetChatRoomGroupSummaryResponse" = betterproto.message_field(3)
     user_action: "EChatRoomMemberStateChange" = betterproto.enum_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class NotifyChatRoomDisconnectNotification(betterproto.Message):
-    chat_group_ids: List[int] = betterproto.uint64_field(1)
+class NotifyChatRoomDisconnectNotification(UnifiedMessage, um_name="ChatRoomClient.NotifyChatRoomDisconnect"):
+    chat_group_ids: list[int] = betterproto.uint64_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class MemberListView(betterproto.Message):
     start: int = betterproto.int32_field(3)
     end: int = betterproto.int32_field(4)
     total_count: int = betterproto.int32_field(5)
@@ -1025,34 +916,32 @@
 @dataclass(eq=False, repr=False)
 class MemberSummaryCounts(betterproto.Message):
     ingame: int = betterproto.int32_field(1)
     online: int = betterproto.int32_field(2)
     offline: int = betterproto.int32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class MemberListViewUpdatedNotification(betterproto.Message):
+class MemberListViewUpdatedNotification(UnifiedMessage, um_name="ChatRoomClient.NotifyMemberListViewUpdated"):
     chat_group_id: int = betterproto.uint64_field(1)
     view_id: int = betterproto.uint64_field(2)
     view: "MemberListView" = betterproto.message_field(3)
-    members: List["MemberListViewUpdatedNotificationMemberListViewEntry"] = betterproto.message_field(4)
+    members: "list[MemberListViewUpdatedNotificationMemberListViewEntry]" = betterproto.message_field(4)
     status_flags: int = betterproto.uint32_field(5)
     member_summary: "MemberSummaryCounts" = betterproto.message_field(6)
-    subscribed_personas: List[CMsgClientPersonaStateFriend] = betterproto.message_field(7)
+    subscribed_personas: list[CMsgClientPersonaStateFriend] = betterproto.message_field(7)
 
 
 @dataclass(eq=False, repr=False)
 class MemberListViewUpdatedNotificationMemberListViewEntry(betterproto.Message):
     rank: int = betterproto.int32_field(1)
     accountid: int = betterproto.uint32_field(2)
     persona: CMsgClientPersonaStateFriend = betterproto.message_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class MessageReactionNotification(betterproto.Message):
+class MessageReactionNotification(UnifiedMessage, um_name="ChatRoomClient.NotifyMessageReaction"):
     chat_group_id: int = betterproto.uint64_field(1)
     chat_id: int = betterproto.uint64_field(2)
     server_timestamp: int = betterproto.uint32_field(3)
     ordinal: int = betterproto.uint32_field(4)
     reactor: int = betterproto.fixed64_field(5)
     reaction_type: "EChatRoomMessageReactionType" = betterproto.enum_field(6)
     reaction: str = betterproto.string_field(7)
```

### Comparing `steamio-0.9.9/steam/protobufs/client_server.py` & `steamio-1.0.0a0/steam/protobufs/client_server.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,118 +1,108 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_clientserver.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
 from .base import CMsgAuthTicket, CMsgIpAddress
+from .emsg import EMsg
 from .encrypted_app_ticket import EncryptedAppTicket
+from .msg import ProtobufMessage
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientRegisterAuthTicketWithCm(betterproto.Message):
     protocol_version: int = betterproto.uint32_field(1)
     ticket: bytes = betterproto.bytes_field(3)
     client_instance_id: int = betterproto.uint64_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientTicketAuthComplete(betterproto.Message):
+class CMsgClientTicketAuthComplete(ProtobufMessage, msg=EMsg.ClientTicketAuthComplete):
     steam_id: int = betterproto.fixed64_field(1)
     game_id: int = betterproto.fixed64_field(2)
     estate: int = betterproto.uint32_field(3)
     eauth_session_response: int = betterproto.uint32_field(4)
     deprecated_ticket: bytes = betterproto.bytes_field(5)
     ticket_crc: int = betterproto.uint32_field(6)
     ticket_sequence: int = betterproto.uint32_field(7)
     owner_steam_id: int = betterproto.fixed64_field(8)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientCmList(betterproto.Message):
-    cm_addresses: List[int] = betterproto.uint32_field(1)
-    cm_ports: List[int] = betterproto.uint32_field(2)
-    cm_websocket_addresses: List[str] = betterproto.string_field(3)
+class CMsgClientCmList(ProtobufMessage, msg=EMsg.ClientCMList):
+    cm_addresses: list[int] = betterproto.uint32_field(1)
+    cm_ports: list[int] = betterproto.uint32_field(2)
+    cm_websocket_addresses: list[str] = betterproto.string_field(3)
     percent_default_to_websocket: int = betterproto.uint32_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientP2PConnectionInfo(betterproto.Message):
+class CMsgClientP2PConnectionInfo(ProtobufMessage, msg=EMsg.ClientP2PConnectionInfo):
     steam_id_dest: int = betterproto.fixed64_field(1)
     steam_id_src: int = betterproto.fixed64_field(2)
     app_id: int = betterproto.uint32_field(3)
     candidate: bytes = betterproto.bytes_field(4)
     legacy_connection_id_src: int = betterproto.fixed64_field(5)
     rendezvous: bytes = betterproto.bytes_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientP2PConnectionFailInfo(betterproto.Message):
+class CMsgClientP2PConnectionFailInfo(ProtobufMessage, msg=EMsg.ClientP2PConnectionFailInfo):
     steam_id_dest: int = betterproto.fixed64_field(1)
     steam_id_src: int = betterproto.fixed64_field(2)
     app_id: int = betterproto.uint32_field(3)
     ep2_p_session_error: int = betterproto.uint32_field(4)
     connection_id_dest: int = betterproto.fixed64_field(5)
     close_reason: int = betterproto.uint32_field(7)
     close_message: str = betterproto.string_field(8)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientNetworkingCertRequest(betterproto.Message):
+class CMsgClientNetworkingCertRequest(ProtobufMessage, msg=EMsg.ClientNetworkingCertRequest):
     key_data: bytes = betterproto.bytes_field(2)
     app_id: int = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientNetworkingCertReply(betterproto.Message):
     cert: bytes = betterproto.bytes_field(4)
     ca_key_id: int = betterproto.fixed64_field(5)
     ca_signature: bytes = betterproto.bytes_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientNetworkingMobileCertRequest(betterproto.Message):
+class CMsgClientNetworkingMobileCertRequest(ProtobufMessage, msg=EMsg.ClientNetworkingMobileCertRequest):
     app_id: int = betterproto.uint32_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientNetworkingMobileCertReply(betterproto.Message):
     encoded_cert: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetAppOwnershipTicket(betterproto.Message):
+class CMsgClientGetAppOwnershipTicket(ProtobufMessage, msg=EMsg.ClientGetAppOwnershipTicket):
     app_id: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetAppOwnershipTicketResponse(betterproto.Message):
+class CMsgClientGetAppOwnershipTicketResponse(ProtobufMessage, msg=EMsg.ClientGetAppOwnershipTicketResponse):
     eresult: int = betterproto.uint32_field(1)
     app_id: int = betterproto.uint32_field(2)
     ticket: bytes = betterproto.bytes_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientSessionToken(betterproto.Message):
+class CMsgClientSessionToken(ProtobufMessage, msg=EMsg.ClientSessionToken):
     token: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGameConnectTokens(betterproto.Message):
+class CMsgClientGameConnectTokens(ProtobufMessage, msg=EMsg.ClientGameConnectTokens):
     max_tokens_to_keep: int = betterproto.uint32_field(1)
-    tokens: List[bytes] = betterproto.bytes_field(2)
+    tokens: list[bytes] = betterproto.bytes_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGamesPlayed(betterproto.Message):
-    games_played: List["CMsgClientGamesPlayedGamePlayed"] = betterproto.message_field(1)
+class CMsgClientGamesPlayed(ProtobufMessage, msg=EMsg.ClientGamesPlayedWithDataBlob):
+    games_played: "list[CMsgClientGamesPlayedGamePlayed]" = betterproto.message_field(1)
     client_os_type: int = betterproto.uint32_field(2)
     cloud_gaming_platform: int = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientGamesPlayedGamePlayed(betterproto.Message):
     steam_id_gs: int = betterproto.uint64_field(1)
@@ -137,54 +127,48 @@
     controller_workshop_file_id: int = betterproto.uint64_field(20)
     launch_source: int = betterproto.uint32_field(21)
     vr_hmd_runtime: int = betterproto.uint32_field(22)
     game_ip_address: CMsgIpAddress = betterproto.message_field(23)
     controller_connection_type: int = betterproto.uint32_field(24)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgGsApprove(betterproto.Message):
+class CMsgGsApprove(ProtobufMessage, msg=EMsg.GSApprove):
     steam_id: int = betterproto.fixed64_field(1)
     owner_steam_id: int = betterproto.fixed64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgGsDeny(betterproto.Message):
+class CMsgGsDeny(ProtobufMessage, msg=EMsg.GSDeny):
     steam_id: int = betterproto.fixed64_field(1)
     edeny_reason: int = betterproto.int32_field(2)
     deny_string: str = betterproto.string_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgGsKick(betterproto.Message):
+class CMsgGsKick(ProtobufMessage, msg=EMsg.GSKick):
     steam_id: int = betterproto.fixed64_field(1)
     edeny_reason: int = betterproto.int32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientAuthList(betterproto.Message):
+class CMsgClientAuthList(ProtobufMessage, msg=EMsg.ClientAuthList):
     tokens_left: int = betterproto.uint32_field(1)
     last_request_seq: int = betterproto.uint32_field(2)
     last_request_seq_from_server: int = betterproto.uint32_field(3)
-    tickets: List[CMsgAuthTicket] = betterproto.message_field(4)
-    app_ids: List[int] = betterproto.uint32_field(5)
+    tickets: list[CMsgAuthTicket] = betterproto.message_field(4)
+    app_ids: list[int] = betterproto.uint32_field(5)
     message_sequence: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientAuthListAck(betterproto.Message):
-    ticket_crc: List[int] = betterproto.uint32_field(1)
-    app_ids: List[int] = betterproto.uint32_field(2)
+class CMsgClientAuthListAck(ProtobufMessage, msg=EMsg.ClientAuthListAck):
+    ticket_crc: list[int] = betterproto.uint32_field(1)
+    app_ids: list[int] = betterproto.uint32_field(2)
     message_sequence: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientLicenseList(betterproto.Message):
+class CMsgClientLicenseList(ProtobufMessage, msg=EMsg.ClientLicenseList):
     eresult: int = betterproto.int32_field(1)
-    licenses: List["CMsgClientLicenseListLicense"] = betterproto.message_field(2)
+    licenses: "list[CMsgClientLicenseListLicense]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientLicenseListLicense(betterproto.Message):
     package_id: int = betterproto.uint32_field(1)
     time_created: int = betterproto.fixed32_field(2)
     time_next_process: int = betterproto.fixed32_field(3)
@@ -201,69 +185,63 @@
     initial_time_unit: int = betterproto.uint32_field(14)
     renewal_period: int = betterproto.uint32_field(15)
     renewal_time_unit: int = betterproto.uint32_field(16)
     access_token: int = betterproto.uint64_field(17)
     master_package_id: int = betterproto.uint32_field(18)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientIsLimitedAccount(betterproto.Message):
+class CMsgClientIsLimitedAccount(ProtobufMessage, msg=EMsg.ClientIsLimitedAccount):
     bis_limited_account: bool = betterproto.bool_field(1)
     bis_community_banned: bool = betterproto.bool_field(2)
     bis_locked_account: bool = betterproto.bool_field(3)
     bis_limited_account_allowed_to_invite_friends: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestedClientStats(betterproto.Message):
-    stats_to_send: List["CMsgClientRequestedClientStatsStatsToSend"] = betterproto.message_field(1)
+class CMsgClientRequestedClientStats(ProtobufMessage, msg=EMsg.ClientRequestedClientStats):
+    stats_to_send: "list[CMsgClientRequestedClientStatsStatsToSend]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientRequestedClientStatsStatsToSend(betterproto.Message):
     client_stat: int = betterproto.uint32_field(1)
     stat_aggregate_method: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientStat2(betterproto.Message):
-    stat_detail: List["CMsgClientStat2StatDetail"] = betterproto.message_field(1)
+class CMsgClientStat2(ProtobufMessage, msg=EMsg.ClientStat2):
+    stat_detail: "list[CMsgClientStat2StatDetail]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientStat2StatDetail(betterproto.Message):
     client_stat: int = betterproto.uint32_field(1)
     ll_value: int = betterproto.int64_field(2)
     time_of_day: int = betterproto.uint32_field(3)
     cell_id: int = betterproto.uint32_field(4)
     depot_id: int = betterproto.uint32_field(5)
     app_id: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientInviteToGame(betterproto.Message):
+class CMsgClientInviteToGame(ProtobufMessage, msg=EMsg.ClientInviteToGame):
     steam_id_dest: int = betterproto.fixed64_field(1)
     steam_id_src: int = betterproto.fixed64_field(2)
     connect_string: str = betterproto.string_field(3)
     remote_play: str = betterproto.string_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientChatInvite(betterproto.Message):
+class CMsgClientChatInvite(ProtobufMessage, msg=EMsg.ClientChatInvite):
     steam_id_invited: int = betterproto.fixed64_field(1)
     steam_id_chat: int = betterproto.fixed64_field(2)
     steam_id_patron: int = betterproto.fixed64_field(3)
     chatroom_type: int = betterproto.int32_field(4)
     steam_id_friend_chat: int = betterproto.fixed64_field(5)
     chat_name: str = betterproto.string_field(6)
     game_id: int = betterproto.fixed64_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientConnectionStats(betterproto.Message):
+class CMsgClientConnectionStats(ProtobufMessage, msg=EMsg.ClientConnectionStats):
     stats_logon: "CMsgClientConnectionStatsStatsLogon" = betterproto.message_field(1)
     stats_vconn: "CMsgClientConnectionStatsStatsVConn" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientConnectionStatsStatsLogon(betterproto.Message):
     connect_attempts: int = betterproto.int32_field(1)
@@ -304,46 +282,41 @@
     failed_connect_challenges: int = betterproto.uint64_field(16)
     micro_sec_avg_latency: int = betterproto.uint32_field(17)
     micro_sec_min_latency: int = betterproto.uint32_field(18)
     micro_sec_max_latency: int = betterproto.uint32_field(19)
     mem_pool_msg_in_use: int = betterproto.uint32_field(20)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientServersAvailable(betterproto.Message):
-    server_types_available: List["CMsgClientServersAvailableServerTypesAvailable"] = betterproto.message_field(1)
+class CMsgClientServersAvailable(ProtobufMessage, msg=EMsg.ClientServersAvailable):
+    server_types_available: "list[CMsgClientServersAvailableServerTypesAvailable]" = betterproto.message_field(1)
     server_type_for_auth_services: int = betterproto.uint32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientServersAvailableServerTypesAvailable(betterproto.Message):
     server: int = betterproto.uint32_field(1)
     changed: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientReportOverlayDetourFailure(betterproto.Message):
-    failure_strings: List[str] = betterproto.string_field(1)
+class CMsgClientReportOverlayDetourFailure(ProtobufMessage, msg=EMsg.ClientReportOverlayDetourFailure):
+    failure_strings: list[str] = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestEncryptedAppTicket(betterproto.Message):
+class CMsgClientRequestEncryptedAppTicket(ProtobufMessage, msg=EMsg.ClientRequestEncryptedAppTicket):
     app_id: int = betterproto.uint32_field(1)
     userdata: bytes = betterproto.bytes_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestEncryptedAppTicketResponse(betterproto.Message):
+class CMsgClientRequestEncryptedAppTicketResponse(ProtobufMessage, msg=EMsg.ClientRequestEncryptedAppTicketResponse):
     app_id: int = betterproto.uint32_field(1)
     eresult: int = betterproto.int32_field(2)
     encrypted_app_ticket: EncryptedAppTicket = betterproto.message_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientWalletInfoUpdate(betterproto.Message):
+class CMsgClientWalletInfoUpdate(ProtobufMessage, msg=EMsg.ClientWalletInfoUpdate):
     has_wallet: bool = betterproto.bool_field(1)
     balance: int = betterproto.int32_field(2)
     currency: int = betterproto.int32_field(3)
     balance_delayed: int = betterproto.int32_field(4)
     balance64: int = betterproto.int64_field(5)
     balance64_delayed: int = betterproto.int64_field(6)
     realm: int = betterproto.int32_field(7)
@@ -360,54 +333,52 @@
     steamid_clan: int = betterproto.fixed64_field(2)
     officer_count: int = betterproto.int32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAmGetPersonaNameHistory(betterproto.Message):
     id_count: int = betterproto.int32_field(1)
-    ids: List["CMsgClientAmGetPersonaNameHistoryIdInstance"] = betterproto.message_field(2)
+    ids: "list[CMsgClientAmGetPersonaNameHistoryIdInstance]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAmGetPersonaNameHistoryIdInstance(betterproto.Message):
     steamid: int = betterproto.fixed64_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAmGetPersonaNameHistoryResponse(betterproto.Message):
-    responses: List["CMsgClientAmGetPersonaNameHistoryResponseNameTableInstance"] = betterproto.message_field(2)
+    responses: "list[CMsgClientAmGetPersonaNameHistoryResponseNameTableInstance]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAmGetPersonaNameHistoryResponseNameTableInstance(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
     steamid: int = betterproto.fixed64_field(2)
-    names: List["CMsgClientAmGetPersonaNameHistoryResponseNameTableInstanceNameInstance"] = betterproto.message_field(3)
+    names: "list[CMsgClientAmGetPersonaNameHistoryResponseNameTableInstanceNameInstance]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAmGetPersonaNameHistoryResponseNameTableInstanceNameInstance(betterproto.Message):
     name_since: int = betterproto.fixed32_field(1)
     name: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientDeregisterWithServer(betterproto.Message):
+class CMsgClientDeregisterWithServer(ProtobufMessage, msg=EMsg.ClientDeregisterWithServer):
     eservertype: int = betterproto.uint32_field(1)
     app_id: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientClanState(betterproto.Message):
+class CMsgClientClanState(ProtobufMessage, msg=EMsg.ClientClanState):
     steamid_clan: int = betterproto.fixed64_field(1)
     clan_account_flags: int = betterproto.uint32_field(3)
     name_info: "CMsgClientClanStateNameInfo" = betterproto.message_field(4)
     user_counts: "CMsgClientClanStateUserCounts" = betterproto.message_field(5)
-    events: List["CMsgClientClanStateEvent"] = betterproto.message_field(6)
-    announcements: List["CMsgClientClanStateEvent"] = betterproto.message_field(7)
+    events: "list[CMsgClientClanStateEvent]" = betterproto.message_field(6)
+    announcements: "list[CMsgClientClanStateEvent]" = betterproto.message_field(7)
     chat_room_private: bool = betterproto.bool_field(8)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientClanStateNameInfo(betterproto.Message):
     clan_name: str = betterproto.string_field(1)
     sha_avatar: bytes = betterproto.bytes_field(2)
```

### Comparing `steamio-0.9.9/steam/protobufs/client_server_2.py` & `steamio-1.0.0a0/steam/protobufs/client_server_2.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,41 +1,53 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_clientserver_2.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from ..utils import StructIO
+from .emsg import EMsg
+from .msg import Message, ProtobufMessage
 
-@dataclass(eq=False, repr=False)
-class CMsgClientUpdateUserGameInfo(betterproto.Message):
+
+# used in ext._gc.Client.buy_item
+class ClientMicroTxnAuthorize(Message, msg=EMsg.ClientMicroTxnAuthorize, init=False):
+    def __init__(self, order_id: int):
+        self.order_id = order_id
+        self.code = 1
+
+    def __bytes__(self) -> bytes:
+        with StructIO() as io:
+            io.write_u64(self.order_id)
+            io.write_i32(self.code)
+            return io.buffer
+
+
+class CMsgClientUpdateUserGameInfo(ProtobufMessage, msg=EMsg.ClientUpdateUserGameInfo):
     steamid_idgs: int = betterproto.fixed64_field(1)
     gameid: int = betterproto.fixed64_field(2)
     game_ip: int = betterproto.uint32_field(3)
     game_port: int = betterproto.uint32_field(4)
     token: bytes = betterproto.bytes_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRichPresenceUpload(betterproto.Message):
+class CMsgClientRichPresenceUpload(ProtobufMessage, msg=EMsg.ClientRichPresenceUpload):
     rich_presence_kv: bytes = betterproto.bytes_field(1)
-    steamid_broadcast: List[int] = betterproto.fixed64_field(2)
+    steamid_broadcast: list[int] = betterproto.fixed64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRichPresenceRequest(betterproto.Message):
-    steamid_request: List[int] = betterproto.fixed64_field(1)
+class CMsgClientRichPresenceRequest(ProtobufMessage, msg=EMsg.ClientRichPresenceRequest):
+    steamid_request: list[int] = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRichPresenceInfo(betterproto.Message):
-    rich_presence: List["CMsgClientRichPresenceInfoRichPresence"] = betterproto.message_field(1)
+class CMsgClientRichPresenceInfo(ProtobufMessage, msg=EMsg.ClientRichPresenceInfo):
+    rich_presence: "list[CMsgClientRichPresenceInfoRichPresence]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientRichPresenceInfoRichPresence(betterproto.Message):
     steamid_user: int = betterproto.fixed64_field(1)
     rich_presence_kv: bytes = betterproto.bytes_field(2)
 
@@ -55,114 +67,102 @@
     sha_file: bytes = betterproto.bytes_field(6)
     signatureheader: bytes = betterproto.bytes_field(7)
     filesize: int = betterproto.uint32_field(8)
     getlasterror: int = betterproto.uint32_field(9)
     evalvesignaturecheckdetail: int = betterproto.uint32_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientReadMachineAuth(betterproto.Message):
+class CMsgClientReadMachineAuth(ProtobufMessage, msg=EMsg.ClientReadMachineAuth):
     filename: str = betterproto.string_field(1)
     offset: int = betterproto.uint32_field(2)
     cubtoread: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientReadMachineAuthResponse(betterproto.Message):
+class CMsgClientReadMachineAuthResponse(ProtobufMessage, msg=EMsg.ClientReadMachineAuthResponse):
     filename: str = betterproto.string_field(1)
     eresult: int = betterproto.uint32_field(2)
     filesize: int = betterproto.uint32_field(3)
     sha_file: bytes = betterproto.bytes_field(4)
     getlasterror: int = betterproto.uint32_field(5)
     offset: int = betterproto.uint32_field(6)
     cubread: int = betterproto.uint32_field(7)
     bytes_read: bytes = betterproto.bytes_field(8)
     filename_sentry: str = betterproto.string_field(9)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientUpdateMachineAuth(betterproto.Message):
+class CMsgClientUpdateMachineAuth(ProtobufMessage, msg=EMsg.ClientUpdateMachineAuth):
     filename: str = betterproto.string_field(1)
     offset: int = betterproto.uint32_field(2)
     cubtowrite: int = betterproto.uint32_field(3)
     bytes_: bytes = betterproto.bytes_field(4)
     otp_type: int = betterproto.uint32_field(5)
     otp_identifier: str = betterproto.string_field(6)
     otp_sharedsecret: bytes = betterproto.bytes_field(7)
     otp_timedrift: int = betterproto.uint32_field(8)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientUpdateMachineAuthResponse(betterproto.Message):
+class CMsgClientUpdateMachineAuthResponse(ProtobufMessage, msg=EMsg.ClientUpdateMachineAuthResponse):
     filename: str = betterproto.string_field(1)
     eresult: int = betterproto.uint32_field(2)
     filesize: int = betterproto.uint32_field(3)
     sha_file: bytes = betterproto.bytes_field(4)
     getlasterror: int = betterproto.uint32_field(5)
     offset: int = betterproto.uint32_field(6)
     cubwrote: int = betterproto.uint32_field(7)
     otp_type: int = betterproto.int32_field(8)
     otp_value: int = betterproto.uint32_field(9)
     otp_identifier: str = betterproto.string_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestMachineAuth(betterproto.Message):
+class CMsgClientRequestMachineAuth(ProtobufMessage, msg=EMsg.ClientRequestMachineAuth):
     filename: str = betterproto.string_field(1)
     eresult_sentryfile: int = betterproto.uint32_field(2)
     filesize: int = betterproto.uint32_field(3)
     sha_sentryfile: bytes = betterproto.bytes_field(4)
     lock_account_action: int = betterproto.int32_field(6)
     otp_type: int = betterproto.uint32_field(7)
     otp_identifier: str = betterproto.string_field(8)
     otp_sharedsecret: bytes = betterproto.bytes_field(9)
     otp_value: int = betterproto.uint32_field(10)
     machine_name: str = betterproto.string_field(11)
     machine_name_userchosen: str = betterproto.string_field(12)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestMachineAuthResponse(betterproto.Message):
+class CMsgClientRequestMachineAuthResponse(ProtobufMessage, msg=EMsg.ClientRequestMachineAuthResponse):
     eresult: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRegisterKey(betterproto.Message):
+class CMsgClientRegisterKey(ProtobufMessage, msg=EMsg.ClientRegisterKey):
     key: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPurchaseResponse(betterproto.Message):
+class CMsgClientPurchaseResponse(ProtobufMessage, msg=EMsg.ClientPurchaseResponse):
     eresult: int = betterproto.int32_field(1)
     purchaseresult_details: int = betterproto.int32_field(2)
     purchase_receipt_info: bytes = betterproto.bytes_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientActivateOemLicense(betterproto.Message):
+class CMsgClientActivateOemLicense(ProtobufMessage, msg=EMsg.ClientActivateOEMLicense):
     bios_manufacturer: str = betterproto.string_field(1)
     bios_serialnumber: str = betterproto.string_field(2)
     license_file: bytes = betterproto.bytes_field(3)
     mainboard_manufacturer: str = betterproto.string_field(4)
     mainboard_product: str = betterproto.string_field(5)
     mainboard_serialnumber: str = betterproto.string_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRegisterOemMachine(betterproto.Message):
+class CMsgClientRegisterOemMachine(ProtobufMessage, msg=EMsg.ClientRegisterOEMMachine):
     oem_register_file: bytes = betterproto.bytes_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRegisterOemMachineResponse(betterproto.Message):
+class CMsgClientRegisterOemMachineResponse(ProtobufMessage, msg=EMsg.ClientRegisterOEMMachineResponse):
     eresult: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPurchaseWithMachineId(betterproto.Message):
+class CMsgClientPurchaseWithMachineId(ProtobufMessage, msg=EMsg.ClientPurchaseWithMachineID):
     package_id: int = betterproto.uint32_field(1)
     machine_info: bytes = betterproto.bytes_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgTradingInitiateTradeRequest(betterproto.Message):
     trade_request_id: int = betterproto.uint32_field(1)
@@ -189,58 +189,53 @@
 
 
 @dataclass(eq=False, repr=False)
 class CMsgTradingStartSession(betterproto.Message):
     other_steamid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetCdnAuthToken(betterproto.Message):
+class CMsgClientGetCdnAuthToken(ProtobufMessage, msg=EMsg.ClientGetCDNAuthToken):
     depot_id: int = betterproto.uint32_field(1)
     host_name: str = betterproto.string_field(2)
     app_id: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetDepotDecryptionKey(betterproto.Message):
+class CMsgClientGetDepotDecryptionKey(ProtobufMessage, msg=EMsg.ClientGetDepotDecryptionKey):
     depot_id: int = betterproto.uint32_field(1)
     app_id: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetDepotDecryptionKeyResponse(betterproto.Message):
+class CMsgClientGetDepotDecryptionKeyResponse(ProtobufMessage, msg=EMsg.ClientGetDepotDecryptionKeyResponse):
     eresult: int = betterproto.int32_field(1)
     depot_id: int = betterproto.uint32_field(2)
     depot_encryption_key: bytes = betterproto.bytes_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientCheckAppBetaPassword(betterproto.Message):
+class CMsgClientCheckAppBetaPassword(ProtobufMessage, msg=EMsg.ClientCheckAppBetaPassword):
     app_id: int = betterproto.uint32_field(1)
     betapassword: str = betterproto.string_field(2)
     language: int = betterproto.int32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientCheckAppBetaPasswordResponse(betterproto.Message):
+class CMsgClientCheckAppBetaPasswordResponse(ProtobufMessage, msg=EMsg.ClientCheckAppBetaPasswordResponse):
     eresult: int = betterproto.int32_field(1)
-    betapasswords: List["CMsgClientCheckAppBetaPasswordResponseBetaPassword"] = betterproto.message_field(4)
+    betapasswords: "list[CMsgClientCheckAppBetaPasswordResponseBetaPassword]" = betterproto.message_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientCheckAppBetaPasswordResponseBetaPassword(betterproto.Message):
     betaname: str = betterproto.string_field(1)
     betapassword: str = betterproto.string_field(2)
     betadescription: str = betterproto.string_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUpdateAppJobReport(betterproto.Message):
     app_id: int = betterproto.uint32_field(1)
-    depot_ids: List[int] = betterproto.uint32_field(2)
+    depot_ids: list[int] = betterproto.uint32_field(2)
     app_state: int = betterproto.uint32_field(3)
     job_app_error: int = betterproto.uint32_field(4)
     error_details: str = betterproto.string_field(5)
     job_duration: int = betterproto.uint32_field(6)
     files_validation_failed: int = betterproto.uint32_field(7)
     job_bytes_downloaded: int = betterproto.uint64_field(8)
     job_bytes_staged: int = betterproto.uint64_field(9)
@@ -255,36 +250,34 @@
     is_free_weekend: bool = betterproto.bool_field(18)
     total_bytes_legacy: int = betterproto.uint64_field(19)
     total_bytes_patched: int = betterproto.uint64_field(20)
     total_bytes_saved: int = betterproto.uint64_field(21)
     cell_id: int = betterproto.uint32_field(22)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientDpContentStatsReport(betterproto.Message):
+class CMsgClientDpContentStatsReport(ProtobufMessage, msg=EMsg.ClientDPContentStatsReport):
     stats_machine_id: int = betterproto.fixed64_field(1)
     country_code: str = betterproto.string_field(2)
     os_type: int = betterproto.int32_field(3)
     language: int = betterproto.int32_field(4)
     num_install_folders: int = betterproto.uint32_field(5)
     num_installed_games: int = betterproto.uint32_field(6)
     size_installed_games: int = betterproto.uint64_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetCdnAuthTokenResponse(betterproto.Message):
+class CMsgClientGetCdnAuthTokenResponse(ProtobufMessage, msg=EMsg.ClientGetCDNAuthTokenResponse):
     eresult: int = betterproto.uint32_field(1)
     token: str = betterproto.string_field(2)
     expiration_time: int = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgDownloadRateStatistics(betterproto.Message):
     cell_id: int = betterproto.uint32_field(1)
-    stats: List["CMsgDownloadRateStatisticsStatsInfo"] = betterproto.message_field(2)
+    stats: "list[CMsgDownloadRateStatisticsStatsInfo]" = betterproto.message_field(2)
     throttling_kbps: int = betterproto.uint32_field(3)
     steam_realm: int = betterproto.uint32_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgDownloadRateStatisticsStatsInfo(betterproto.Message):
     source_type: int = betterproto.uint32_field(1)
@@ -293,22 +286,20 @@
     bytes_: int = betterproto.uint64_field(4)
     host_name: str = betterproto.string_field(5)
     microseconds: int = betterproto.uint64_field(6)
     used_ipv6: bool = betterproto.bool_field(7)
     proxied: bool = betterproto.bool_field(8)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestAccountData(betterproto.Message):
+class CMsgClientRequestAccountData(ProtobufMessage, msg=EMsg.ClientRequestAccountData):
     account_or_email: str = betterproto.string_field(1)
     action: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestAccountDataResponse(betterproto.Message):
+class CMsgClientRequestAccountDataResponse(ProtobufMessage, msg=EMsg.ClientRequestAccountDataResponse):
     action: int = betterproto.uint32_field(1)
     eresult: int = betterproto.uint32_field(2)
     account_name: str = betterproto.string_field(3)
     ct_matches: int = betterproto.uint32_field(4)
     account_name_suggestion1: str = betterproto.string_field(5)
     account_name_suggestion2: str = betterproto.string_field(6)
     account_name_suggestion3: str = betterproto.string_field(7)
@@ -324,92 +315,91 @@
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUgsGetGlobalStatsResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
     timestamp: int = betterproto.fixed32_field(2)
     day_current: int = betterproto.int32_field(3)
-    days: List["CMsgClientUgsGetGlobalStatsResponseDay"] = betterproto.message_field(4)
+    days: "list[CMsgClientUgsGetGlobalStatsResponseDay]" = betterproto.message_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUgsGetGlobalStatsResponseDay(betterproto.Message):
     day_id: int = betterproto.uint32_field(1)
-    stats: List["CMsgClientUgsGetGlobalStatsResponseDayStat"] = betterproto.message_field(2)
+    stats: "list[CMsgClientUgsGetGlobalStatsResponseDayStat]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUgsGetGlobalStatsResponseDayStat(betterproto.Message):
     stat_id: int = betterproto.int32_field(1)
     data: int = betterproto.int64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRedeemGuestPass(betterproto.Message):
+class CMsgClientRedeemGuestPass(ProtobufMessage, msg=EMsg.ClientRedeemGuestPass):
     guest_pass_id: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRedeemGuestPassResponse(betterproto.Message):
+class CMsgClientRedeemGuestPassResponse(ProtobufMessage, msg=EMsg.ClientRedeemGuestPassResponse):
     eresult: int = betterproto.uint32_field(1)
     package_id: int = betterproto.uint32_field(2)
     must_own_appid: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetClanActivityCounts(betterproto.Message):
-    steamid_clans: List[int] = betterproto.uint64_field(1)
+class CMsgClientGetClanActivityCounts(ProtobufMessage, msg=EMsg.ClientGetClanActivityCounts):
+    steamid_clans: list[int] = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetClanActivityCountsResponse(betterproto.Message):
+class CMsgClientGetClanActivityCountsResponse(ProtobufMessage, msg=EMsg.ClientGetClanActivityCountsResponse):
     eresult: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientOgsReportString(betterproto.Message):
+class CMsgClientOgsReportString(ProtobufMessage, msg=EMsg.ClientOGSReportString):
     accumulated: bool = betterproto.bool_field(1)
     sessionid: int = betterproto.uint64_field(2)
     severity: int = betterproto.int32_field(3)
     formatter: str = betterproto.string_field(4)
     varargs: bytes = betterproto.bytes_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientOgsReportBug(betterproto.Message):
+class CMsgClientOgsReportBug(ProtobufMessage, msg=EMsg.ClientOGSReportBug):
     sessionid: int = betterproto.uint64_field(1)
     bugtext: str = betterproto.string_field(2)
     screenshot: bytes = betterproto.bytes_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientSentLogs(betterproto.Message):
+class CMsgClientSentLogs(ProtobufMessage, msg=EMsg.ClientSentLogs):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CMsgGcClient(betterproto.Message):
+class CMsgGcClientToGC(ProtobufMessage, msg=EMsg.ClientToGC):
     appid: int = betterproto.uint32_field(1)
     msgtype: int = betterproto.uint32_field(2)
     payload: bytes = betterproto.bytes_field(3)
     steamid: int = betterproto.fixed64_field(4)
     gcname: str = betterproto.string_field(5)
     ip: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestFreeLicense(betterproto.Message):
-    appids: List[int] = betterproto.uint32_field(2)
+class CMsgGcClientFromGC(ProtobufMessage, msg=EMsg.ClientFromGC):
+    appid: int = betterproto.uint32_field(1)
+    msgtype: int = betterproto.uint32_field(2)
+    payload: bytes = betterproto.bytes_field(3)
+    steamid: int = betterproto.fixed64_field(4)
+    gcname: str = betterproto.string_field(5)
+    ip: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestFreeLicenseResponse(betterproto.Message):
+class CMsgClientRequestFreeLicense(ProtobufMessage, msg=EMsg.ClientRequestFreeLicense):
+    appids: list[int] = betterproto.uint32_field(2)
+
+
+class CMsgClientRequestFreeLicenseResponse(ProtobufMessage, msg=EMsg.ClientRequestFreeLicenseResponse):
     eresult: int = betterproto.uint32_field(1)
-    granted_packageids: List[int] = betterproto.uint32_field(2)
-    granted_appids: List[int] = betterproto.uint32_field(3)
+    granted_packageids: list[int] = betterproto.uint32_field(2)
+    granted_appids: list[int] = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgDrmDownloadRequestWithCrashData(betterproto.Message):
     download_flags: int = betterproto.uint32_field(1)
     download_types_known: int = betterproto.uint32_field(2)
     guid_drm: bytes = betterproto.bytes_field(3)
@@ -467,146 +457,138 @@
 
 @dataclass(eq=False, repr=False)
 class CMsgClientDpSendSpecialSurveyResponseReply(betterproto.Message):
     eresult: int = betterproto.uint32_field(1)
     token: bytes = betterproto.bytes_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestForgottenPasswordEmail(betterproto.Message):
+class CMsgClientRequestForgottenPasswordEmail(ProtobufMessage, msg=EMsg.ClientRequestForgottenPasswordEmail):
     account_name: str = betterproto.string_field(1)
     password_tried: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestForgottenPasswordEmailResponse(betterproto.Message):
+class CMsgClientRequestForgottenPasswordEmailResponse(
+    ProtobufMessage, msg=EMsg.ClientRequestForgottenPasswordEmailResponse
+):
     eresult: int = betterproto.uint32_field(1)
     use_secret_question: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientItemAnnouncements(betterproto.Message):
+class CMsgClientItemAnnouncements(ProtobufMessage, msg=EMsg.ClientItemAnnouncements):
     count_new_items: int = betterproto.uint32_field(1)
-    unseen_items: List["CMsgClientItemAnnouncementsUnseenItem"] = betterproto.message_field(2)
+    unseen_items: "list[CMsgClientItemAnnouncementsUnseenItem]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientItemAnnouncementsUnseenItem(betterproto.Message):
     appid: int = betterproto.uint32_field(1)
     context_id: int = betterproto.uint64_field(2)
     asset_id: int = betterproto.uint64_field(3)
     amount: int = betterproto.uint64_field(4)
     rtime32_gained: int = betterproto.fixed32_field(5)
     source_appid: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestItemAnnouncements(betterproto.Message):
+class CMsgClientRequestItemAnnouncements(ProtobufMessage, msg=EMsg.ClientRequestItemAnnouncements):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientUserNotifications(betterproto.Message):
-    notifications: List["CMsgClientUserNotificationsNotification"] = betterproto.message_field(1)
+class CMsgClientUserNotifications(ProtobufMessage, msg=EMsg.ClientUserNotifications):
+    notifications: "list[CMsgClientUserNotificationsNotification]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUserNotificationsNotification(betterproto.Message):
     user_notification_type: int = betterproto.uint32_field(1)
     count: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientCommentNotifications(betterproto.Message):
+class CMsgClientCommentNotifications(ProtobufMessage, msg=EMsg.ClientCommentNotifications):
     count_new_comments: int = betterproto.uint32_field(1)
     count_new_comments_owner: int = betterproto.uint32_field(2)
     count_new_comments_subscriptions: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestCommentNotifications(betterproto.Message):
+class CMsgClientRequestCommentNotifications(ProtobufMessage, msg=EMsg.ClientRequestCommentNotifications):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientOfflineMessageNotification(betterproto.Message):
+class CMsgClientOfflineMessageNotification(ProtobufMessage, msg=EMsg.ClientChatOfflineMessageNotification):
     offline_messages: int = betterproto.uint32_field(1)
-    friends_with_offline_messages: List[int] = betterproto.uint32_field(2)
+    friends_with_offline_messages: list[int] = betterproto.uint32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientRequestOfflineMessageCount(betterproto.Message):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientChatGetFriendMessageHistory(betterproto.Message):
+class CMsgClientChatGetFriendMessageHistory(ProtobufMessage, msg=EMsg.ClientChatGetFriendMessageHistory):
     steamid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientChatGetFriendMessageHistoryResponse(betterproto.Message):
+class CMsgClientChatGetFriendMessageHistoryResponse(
+    ProtobufMessage, msg=EMsg.ClientChatGetFriendMessageHistoryResponse
+):
     steamid: int = betterproto.fixed64_field(1)
     success: int = betterproto.uint32_field(2)
-    messages: List["CMsgClientChatGetFriendMessageHistoryResponseFriendMessage"] = betterproto.message_field(3)
+    messages: "list[CMsgClientChatGetFriendMessageHistoryResponseFriendMessage]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientChatGetFriendMessageHistoryResponseFriendMessage(betterproto.Message):
     accountid: int = betterproto.uint32_field(1)
     timestamp: int = betterproto.uint32_field(2)
     message: str = betterproto.string_field(3)
     unread: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientChatGetFriendMessageHistoryForOfflineMessages(betterproto.Message):
+class CMsgClientChatGetFriendMessageHistoryForOfflineMessages(
+    ProtobufMessage, msg=EMsg.ClientChatGetFriendMessageHistoryForOfflineMessages
+):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientFsGetFriendsSteamLevels(betterproto.Message):
-    accountids: List[int] = betterproto.uint32_field(1)
+class CMsgClientFsGetFriendsSteamLevels(ProtobufMessage, msg=EMsg.ClientFSGetFriendsSteamLevels):
+    accountids: list[int] = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientFsGetFriendsSteamLevelsResponse(betterproto.Message):
-    friends: List["CMsgClientFsGetFriendsSteamLevelsResponseFriend"] = betterproto.message_field(1)
+class CMsgClientFsGetFriendsSteamLevelsResponse(ProtobufMessage, msg=EMsg.ClientFSGetFriendsSteamLevelsResponse):
+    friends: "list[CMsgClientFsGetFriendsSteamLevelsResponseFriend]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientFsGetFriendsSteamLevelsResponseFriend(betterproto.Message):
     accountid: int = betterproto.uint32_field(1)
     level: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientEmailAddrInfo(betterproto.Message):
+class CMsgClientEmailAddrInfo(ProtobufMessage, msg=EMsg.ClientEmailAddrInfo):
     email_address: str = betterproto.string_field(1)
     email_is_validated: bool = betterproto.bool_field(2)
     email_validation_changed: bool = betterproto.bool_field(3)
     credential_change_requires_code: bool = betterproto.bool_field(4)
     password_or_secretqa_change_requires_code: bool = betterproto.bool_field(5)
     remind_user_about_email: bool = betterproto.bool_field(6)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgCreItemVoteSummary(betterproto.Message):
-    published_file_ids: List["CMsgCreItemVoteSummaryPublishedFileId"] = betterproto.message_field(1)
+    published_file_ids: "list[CMsgCreItemVoteSummaryPublishedFileId]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgCreItemVoteSummaryPublishedFileId(betterproto.Message):
     published_file_id: int = betterproto.fixed64_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgCreItemVoteSummaryResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
-    item_vote_summaries: List["CMsgCreItemVoteSummaryResponseItemVoteSummary"] = betterproto.message_field(2)
+    item_vote_summaries: "list[CMsgCreItemVoteSummaryResponseItemVoteSummary]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgCreItemVoteSummaryResponseItemVoteSummary(betterproto.Message):
     published_file_id: int = betterproto.fixed64_field(1)
     votes_for: int = betterproto.int32_field(2)
     votes_against: int = betterproto.int32_field(3)
@@ -623,26 +605,26 @@
 @dataclass(eq=False, repr=False)
 class CMsgCreUpdateUserPublishedItemVoteResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgCreGetUserPublishedItemVoteDetails(betterproto.Message):
-    published_file_ids: List["CMsgCreGetUserPublishedItemVoteDetailsPublishedFileId"] = betterproto.message_field(1)
+    published_file_ids: "list[CMsgCreGetUserPublishedItemVoteDetailsPublishedFileId]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgCreGetUserPublishedItemVoteDetailsPublishedFileId(betterproto.Message):
     published_file_id: int = betterproto.fixed64_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgCreGetUserPublishedItemVoteDetailsResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
-    user_item_vote_details: List[
+    user_item_vote_details: list[
         "CMsgCreGetUserPublishedItemVoteDetailsResponseUserItemVoteDetail"
     ] = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgCreGetUserPublishedItemVoteDetailsResponseUserItemVoteDetail(betterproto.Message):
     published_file_id: int = betterproto.fixed64_field(1)
@@ -676,172 +658,154 @@
     start_index: int = betterproto.uint32_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgFsEnumerateFollowingListResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
     total_results: int = betterproto.int32_field(2)
-    steam_ids: List[int] = betterproto.fixed64_field(3)
+    steam_ids: list[int] = betterproto.fixed64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgDpGetNumberOfCurrentPlayers(betterproto.Message):
+class CMsgDpGetNumberOfCurrentPlayers(ProtobufMessage, msg=EMsg.DPGetPlayerCount):
     appid: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgDpGetNumberOfCurrentPlayersResponse(betterproto.Message):
+class CMsgDpGetNumberOfCurrentPlayersResponse(ProtobufMessage, msg=EMsg.DPGetPlayerCountResponse):
     eresult: int = betterproto.int32_field(1)
     player_count: int = betterproto.int32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientFriendUserStatusPublished(betterproto.Message):
+class CMsgClientFriendUserStatusPublished(ProtobufMessage, msg=EMsg.ClientFriendUserStatusPublished):
     friend_steamid: int = betterproto.fixed64_field(1)
     appid: int = betterproto.uint32_field(2)
     status_text: str = betterproto.string_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientServiceMethodLegacy(betterproto.Message):
+class CMsgClientServiceMethodLegacy(ProtobufMessage, msg=EMsg.ClientServiceMethodLegacy):
     method_name: str = betterproto.string_field(1)
     serialized_method: bytes = betterproto.bytes_field(2)
     is_notification: bool = betterproto.bool_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientServiceMethodLegacyResponse(betterproto.Message):
+class CMsgClientServiceMethodLegacyResponse(ProtobufMessage, msg=EMsg.ClientServiceMethodLegacyResponse):
     method_name: str = betterproto.string_field(1)
     serialized_method_response: bytes = betterproto.bytes_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientUiMode(betterproto.Message):
+class CMsgClientUiMode(ProtobufMessage, msg=EMsg.ClientCurrentUIMode):
     uimode: int = betterproto.uint32_field(1)
     chat_mode: int = betterproto.uint32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientVanityUrlChangedNotification(betterproto.Message):
     vanity_url: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientAuthorizeLocalDeviceRequest(betterproto.Message):
+class CMsgClientAuthorizeLocalDeviceRequest(ProtobufMessage, msg=EMsg.ClientAuthorizeLocalDeviceRequest):
     device_description: str = betterproto.string_field(1)
     owner_account_id: int = betterproto.uint32_field(2)
     local_device_token: int = betterproto.uint64_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientAuthorizeLocalDevice(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
     owner_account_id: int = betterproto.uint32_field(2)
     authed_device_token: int = betterproto.uint64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientAuthorizeLocalDeviceNotification(betterproto.Message):
+class CMsgClientAuthorizeLocalDeviceNotification(ProtobufMessage, msg=EMsg.ClientAuthorizeLocalDeviceNotification):
     eresult: int = betterproto.int32_field(1)
     owner_account_id: int = betterproto.uint32_field(2)
     local_device_token: int = betterproto.uint64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientDeauthorizeDeviceRequest(betterproto.Message):
+class CMsgClientDeauthorizeDeviceRequest(ProtobufMessage, msg=EMsg.ClientDeauthorizeDeviceRequest):
     deauthorization_account_id: int = betterproto.uint32_field(1)
     deauthorization_device_token: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientDeauthorizeDevice(betterproto.Message):
+class CMsgClientDeauthorizeDevice(ProtobufMessage, msg=EMsg.ClientDeauthorizeDevice):
     eresult: int = betterproto.int32_field(1)
     deauthorization_account_id: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientUseLocalDeviceAuthorizations(betterproto.Message):
-    authorization_account_id: List[int] = betterproto.uint32_field(1)
-    device_tokens: List["CMsgClientUseLocalDeviceAuthorizationsDeviceToken"] = betterproto.message_field(2)
+class CMsgClientUseLocalDeviceAuthorizations(ProtobufMessage, msg=EMsg.ClientUseLocalDeviceAuthorizations):
+    authorization_account_id: list[int] = betterproto.uint32_field(1)
+    device_tokens: "list[CMsgClientUseLocalDeviceAuthorizationsDeviceToken]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUseLocalDeviceAuthorizationsDeviceToken(betterproto.Message):
     owner_account_id: int = betterproto.uint32_field(1)
     token_id: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetAuthorizedDevices(betterproto.Message):
+class CMsgClientGetAuthorizedDevices(ProtobufMessage, msg=EMsg.ClientGetAuthorizedDevices):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetAuthorizedDevicesResponse(betterproto.Message):
+class CMsgClientGetAuthorizedDevicesResponse(ProtobufMessage, msg=EMsg.ClientGetAuthorizedDevicesResponse):
     eresult: int = betterproto.int32_field(1)
-    authorized_device: List["CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice"] = betterproto.message_field(2)
+    authorized_device: "list[CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice(betterproto.Message):
     auth_device_token: int = betterproto.uint64_field(1)
     device_name: str = betterproto.string_field(2)
     last_access_time: int = betterproto.uint32_field(3)
     borrower_id: int = betterproto.uint32_field(4)
     is_pending: bool = betterproto.bool_field(5)
     app_played: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientSharedLibraryLockStatus(betterproto.Message):
-    locked_library: List["CMsgClientSharedLibraryLockStatusLockedLibrary"] = betterproto.message_field(1)
+class CMsgClientSharedLibraryLockStatus(ProtobufMessage, msg=EMsg.ClientSharedLibraryLockStatus):
+    locked_library: "list[CMsgClientSharedLibraryLockStatusLockedLibrary]" = betterproto.message_field(1)
     own_library_locked_by: int = betterproto.uint32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientSharedLibraryLockStatusLockedLibrary(betterproto.Message):
     owner_id: int = betterproto.uint32_field(1)
     locked_by: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientSharedLibraryStopPlaying(betterproto.Message):
+class CMsgClientSharedLibraryStopPlaying(ProtobufMessage, msg=EMsg.ClientSharedLibraryStopPlaying):
     seconds_left: int = betterproto.int32_field(1)
-    stop_apps: List["CMsgClientSharedLibraryStopPlayingStopApp"] = betterproto.message_field(2)
+    stop_apps: "list[CMsgClientSharedLibraryStopPlayingStopApp]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientSharedLibraryStopPlayingStopApp(betterproto.Message):
     app_id: int = betterproto.uint32_field(1)
     owner_id: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientServiceCall(betterproto.Message):
+class CMsgClientServiceCall(ProtobufMessage, msg=EMsg.ClientServiceCall):
     sysid_routing: bytes = betterproto.bytes_field(1)
     call_handle: int = betterproto.uint32_field(2)
     module_crc: int = betterproto.uint32_field(3)
     module_hash: bytes = betterproto.bytes_field(4)
     function_id: int = betterproto.uint32_field(5)
     cub_output_max: int = betterproto.uint32_field(6)
     flags: int = betterproto.uint32_field(7)
     callparameter: bytes = betterproto.bytes_field(8)
     ping_only: bool = betterproto.bool_field(9)
     max_outstanding_calls: int = betterproto.uint32_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientServiceModule(betterproto.Message):
+class CMsgClientServiceModule(ProtobufMessage, msg=EMsg.ClientServiceModule):
     module_crc: int = betterproto.uint32_field(1)
     module_hash: bytes = betterproto.bytes_field(2)
     module_content: bytes = betterproto.bytes_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientServiceCallResponse(betterproto.Message):
+class CMsgClientServiceCallResponse(ProtobufMessage, msg=EMsg.ClientServiceCallResponse):
     sysid_routing: bytes = betterproto.bytes_field(1)
     call_handle: int = betterproto.uint32_field(2)
     module_crc: int = betterproto.uint32_field(3)
     module_hash: bytes = betterproto.bytes_field(4)
     ecallresult: int = betterproto.uint32_field(5)
     result_content: bytes = betterproto.bytes_field(6)
     os_version_info: bytes = betterproto.bytes_field(7)
@@ -878,38 +842,34 @@
 
 
 @dataclass(eq=False, repr=False)
 class CMsgAmUnlockHevcResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPlayingSessionState(betterproto.Message):
+class CMsgClientPlayingSessionState(ProtobufMessage, msg=EMsg.ClientPlayingSessionState):
     playing_blocked: bool = betterproto.bool_field(2)
     playing_app: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientKickPlayingSession(betterproto.Message):
+class CMsgClientKickPlayingSession(ProtobufMessage, msg=EMsg.ClientKickPlayingSession):
     only_stop_game: bool = betterproto.bool_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientVoiceCallPreAuthorize(betterproto.Message):
     caller_steamid: int = betterproto.fixed64_field(1)
     receiver_steamid: int = betterproto.fixed64_field(2)
     caller_id: int = betterproto.int32_field(3)
     hangup: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientVoiceCallPreAuthorizeResponse(betterproto.Message):
+class CMsgClientVoiceCallPreAuthorizeResponse(ProtobufMessage, msg=EMsg.ClientVoiceCallPreAuthorizeResponse):
     caller_steamid: int = betterproto.fixed64_field(1)
     receiver_steamid: int = betterproto.fixed64_field(2)
     eresult: int = betterproto.int32_field(3)
     caller_id: int = betterproto.int32_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgBadgeCraftedNotification(betterproto.Message):
+class CMsgBadgeCraftedNotification(ProtobufMessage, msg=EMsg.BadgeCraftedNotification):
     appid: int = betterproto.uint32_field(1)
     badge_level: int = betterproto.uint32_field(2)
```

### Comparing `steamio-0.9.9/steam/protobufs/content_manifest.py` & `steamio-1.0.0a0/steam/protobufs/content_manifest.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,36 +1,35 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: content_manifest.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
 
 class EContentDeltaChunkDataLocation(betterproto.Enum):
     InProtobuf = 0
     AfterProtobuf = 1
 
 
 @dataclass(eq=False, repr=False)
 class Payload(betterproto.Message):
-    mappings: List["PayloadFileMapping"] = betterproto.message_field(1)
+    mappings: "list[PayloadFileMapping]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class PayloadFileMapping(betterproto.Message):
     filename: str = betterproto.string_field(1)
     size: int = betterproto.uint64_field(2)
     flags: int = betterproto.uint32_field(3)
     sha_filename: bytes = betterproto.bytes_field(4)
     sha_content: bytes = betterproto.bytes_field(5)
-    chunks: List["PayloadFileMappingChunkData"] = betterproto.message_field(6)
+    chunks: "list[PayloadFileMappingChunkData]" = betterproto.message_field(6)
     linktarget: str = betterproto.string_field(7)
 
 
 @dataclass(eq=False, repr=False)
 class PayloadFileMappingChunkData(betterproto.Message):
     sha: bytes = betterproto.bytes_field(1)
     crc: int = betterproto.fixed32_field(2)
@@ -58,15 +57,15 @@
 
 
 @dataclass(eq=False, repr=False)
 class ContentDeltaChunks(betterproto.Message):
     depot_id: int = betterproto.uint32_field(1)
     manifest_id_source: int = betterproto.uint64_field(2)
     manifest_id_target: int = betterproto.uint64_field(3)
-    delta_chunks: List["ContentDeltaChunksDeltaChunk"] = betterproto.message_field(4)
+    delta_chunks: "list[ContentDeltaChunksDeltaChunk]" = betterproto.message_field(4)
     chunk_data_location: "EContentDeltaChunkDataLocation" = betterproto.enum_field(5)
 
 
 @dataclass(eq=False, repr=False)
 class ContentDeltaChunksDeltaChunk(betterproto.Message):
     sha_source: bytes = betterproto.bytes_field(1)
     sha_target: bytes = betterproto.bytes_field(2)
```

### Comparing `steamio-0.9.9/steam/protobufs/content_server.py` & `steamio-1.0.0a0/steam/protobufs/content_server.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_contentsystem.steamclient.proto
 # plugin: python-betterproto
 # Last updated 03/05/2022
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .msg import UnifiedMessage
 
-@dataclass(eq=False, repr=False)
-class GetServersForSteamPipeRequest(betterproto.Message):
+
+class GetServersForSteamPipeRequest(UnifiedMessage, um_name="ContentServerDirectory.GetServersForSteamPipe"):
     cell_id: int = betterproto.uint32_field(1)
     max_servers: int = betterproto.uint32_field(2)
     ip_override: str = betterproto.string_field(3)
     launcher_type: int = betterproto.int32_field(4)
     ipv6_public: str = betterproto.string_field(5)
 
 
@@ -28,55 +28,48 @@
     num_entries_in_client_list: int = betterproto.int32_field(6)
     steam_china_only: bool = betterproto.bool_field(7)
     host: str = betterproto.string_field(8)
     vhost: str = betterproto.string_field(9)
     use_as_proxy: bool = betterproto.bool_field(10)
     proxy_request_path_template: str = betterproto.string_field(11)
     https_support: str = betterproto.string_field(12)
-    allowed_app_ids: List[int] = betterproto.uint32_field(13)
+    allowed_app_ids: list[int] = betterproto.uint32_field(13)
     preferred_server: bool = betterproto.bool_field(14)
 
 
-@dataclass(eq=False, repr=False)
-class GetServersForSteamPipeResponse(betterproto.Message):
-    servers: List["ServerInfo"] = betterproto.message_field(1)
+class GetServersForSteamPipeResponse(UnifiedMessage, um_name="ContentServerDirectory.GetServersForSteamPipe"):
+    servers: "list[ServerInfo]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetDepotPatchInfoRequest(betterproto.Message):
+class GetDepotPatchInfoRequest(UnifiedMessage, um_name="ContentServerDirectory.GetDepotPatchInfo"):
     appid: int = betterproto.uint32_field(1)
     depotid: int = betterproto.uint32_field(2)
     source_manifestid: int = betterproto.uint64_field(3)
     target_manifestid: int = betterproto.uint64_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class GetDepotPatchInfoResponse(betterproto.Message):
+class GetDepotPatchInfoResponse(UnifiedMessage, um_name="ContentServerDirectory.GetDepotPatchInfo"):
     is_available: bool = betterproto.bool_field(1)
     patch_size: int = betterproto.uint64_field(2)
     patched_chunks_size: int = betterproto.uint64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetClientUpdateHostsRequest(betterproto.Message):
+class GetClientUpdateHostsRequest(UnifiedMessage, um_name="ContentServerDirectory.GetClientUpdateHosts"):
     cached_signature: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetClientUpdateHostsResponse(betterproto.Message):
+class GetClientUpdateHostsResponse(UnifiedMessage, um_name="ContentServerDirectory.GetClientUpdateHosts"):
     hosts_kv: str = betterproto.string_field(1)
     valid_until_time: int = betterproto.uint64_field(2)
     ip_country: str = betterproto.string_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetManifestRequestCodeRequest(betterproto.Message):
+class GetManifestRequestCodeRequest(UnifiedMessage, um_name="ContentServerDirectory.GetManifestRequestCode"):
     app_id: int = betterproto.uint32_field(1)
     depot_id: int = betterproto.uint32_field(2)
     manifest_id: int = betterproto.uint64_field(3)
     app_branch: str = betterproto.string_field(4)
     branch_password_hash: str = betterproto.string_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class GetManifestRequestCodeResponse(betterproto.Message):
+class GetManifestRequestCodeResponse(UnifiedMessage, um_name="ContentServerDirectory.GetManifestRequestCode"):
     manifest_request_code: int = betterproto.uint64_field(1)
```

### Comparing `steamio-0.9.9/steam/protobufs/emsg.py` & `steamio-1.0.0a0/steam/protobufs/emsg.py`

 * *Files 0% similar despite different names*

```diff
@@ -1420,14 +1420,15 @@
     ClientPICSAccessTokenResponse                            = 8906
 
     # WorkerProcess
     WorkerProcessPingRequest                                 = 9000
     WorkerProcessPingResponse                                = 9001
     WorkerProcessShutdown                                    = 9002
 
+
     # DRMWorkerProcess
     DRMWorkerProcessDRMAndSign                               = 9100
     DRMWorkerProcessDRMAndSignResponse                       = 9101
     DRMWorkerProcessSteamworksInfoRequest                    = 9102
     DRMWorkerProcessSteamworksInfoResponse                   = 9103
     DRMWorkerProcessInstallDRMDLLRequest                     = 9104
     DRMWorkerProcessInstallDRMDLLResponse                    = 9105
@@ -1506,14 +1507,16 @@
     ClientBroadcastUploadConfig                              = 9704
 
     # Client3
     ClientVoiceCallPreAuthorize                              = 9800
     ClientVoiceCallPreAuthorizeResponse                      = 9801
     ClientServerTimestampRequest                             = 9802
     ClientServerTimestampResponse                            = 9803
+    ServiceMethodCallFromClientNonAuthed                     = 9804
+    ClientHello                                              = 9805
 
     # ClientLANP2P
     ClientLANP2PRequestChunk                                 = 9900
     ClientLANP2PRequestChunkResponse                         = 9901
     ClientLANP2PMax                                          = 9999
 
     # WatchdogServer
```

### Comparing `steamio-0.9.9/steam/protobufs/encrypted_app_ticket.py` & `steamio-1.0.0a0/steam/protobufs/encrypted_app_ticket.py`

 * *Files identical despite different names*

### Comparing `steamio-0.9.9/steam/protobufs/friend_messages.py` & `steamio-1.0.0a0/steam/protobufs/friend_messages.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,100 +1,94 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_friendmessages.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .msg import UnifiedMessage
+
 
 class EMessageReactionType(betterproto.Enum):
     Invalid = 0
     Emoticon = 1
     Sticker = 2
 
 
-@dataclass(eq=False, repr=False)
-class GetRecentMessagesRequest(betterproto.Message):
+class GetRecentMessagesRequest(UnifiedMessage, um_name="FriendMessages.GetRecentMessages"):
     steamid1: int = betterproto.fixed64_field(1)
     steamid2: int = betterproto.fixed64_field(2)
     count: int = betterproto.uint32_field(3)
     most_recent_conversation: bool = betterproto.bool_field(4)
     rtime32_start_time: int = betterproto.fixed32_field(5)
     bbcode_format: bool = betterproto.bool_field(6)
     start_ordinal: int = betterproto.uint32_field(7)
     time_last: int = betterproto.uint32_field(8)
     ordinal_last: int = betterproto.uint32_field(9)
 
 
-@dataclass(eq=False, repr=False)
-class GetRecentMessagesResponse(betterproto.Message):
-    messages: List["GetRecentMessagesResponseFriendMessage"] = betterproto.message_field(1)
+class GetRecentMessagesResponse(UnifiedMessage, um_name="FriendMessages.GetRecentMessages"):
+    messages: "list[GetRecentMessagesResponseFriendMessage]" = betterproto.message_field(1)
     more_available: bool = betterproto.bool_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class GetRecentMessagesResponseFriendMessage(betterproto.Message):
     accountid: int = betterproto.uint32_field(1)
     timestamp: int = betterproto.uint32_field(2)
     message: str = betterproto.string_field(3)
     ordinal: int = betterproto.uint32_field(4)
-    reactions: List["GetRecentMessagesResponseFriendMessageMessageReaction"] = betterproto.message_field(5)
+    reactions: "list[GetRecentMessagesResponseFriendMessageMessageReaction]" = betterproto.message_field(5)
 
 
 @dataclass(eq=False, repr=False)
 class GetRecentMessagesResponseFriendMessageMessageReaction(betterproto.Message):
     reaction_type: "EMessageReactionType" = betterproto.enum_field(1)
     reaction: str = betterproto.string_field(2)
-    reactors: List[int] = betterproto.uint32_field(3)
+    reactors: list[int] = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetActiveMessageSessionsRequest(betterproto.Message):
+class GetActiveMessageSessionsRequest(UnifiedMessage, um_name="FriendMessages.GetActiveMessageSessions"):
     lastmessage_since: int = betterproto.uint32_field(1)
     only_sessions_with_messages: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetActiveMessageSessionsResponse(betterproto.Message):
-    message_sessions: List["GetActiveMessageSessionsResponseFriendMessageSession"] = betterproto.message_field(1)
+class GetActiveMessageSessionsResponse(UnifiedMessage, um_name="FriendMessages.GetActiveMessageSessions"):
+    message_sessions: "list[GetActiveMessageSessionsResponseFriendMessageSession]" = betterproto.message_field(1)
     timestamp: int = betterproto.uint32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class GetActiveMessageSessionsResponseFriendMessageSession(betterproto.Message):
     accountid_friend: int = betterproto.uint32_field(1)
     last_message: int = betterproto.uint32_field(2)
     last_view: int = betterproto.uint32_field(3)
     unread_message_count: int = betterproto.uint32_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class SendMessageRequest(betterproto.Message):
+class SendMessageRequest(UnifiedMessage, um_name="FriendMessages.SendMessage"):
     steamid: int = betterproto.fixed64_field(1)
     chat_entry_type: int = betterproto.int32_field(2)
     message: str = betterproto.string_field(3)
     contains_bbcode: bool = betterproto.bool_field(4)
     echo_to_sender: bool = betterproto.bool_field(5)
     low_priority: bool = betterproto.bool_field(6)
     client_message_id: str = betterproto.string_field(8)
 
 
-@dataclass(eq=False, repr=False)
-class SendMessageResponse(betterproto.Message):
+class SendMessageResponse(UnifiedMessage, um_name="FriendMessages.SendMessage"):
     modified_message: str = betterproto.string_field(1)
     server_timestamp: int = betterproto.uint32_field(2)
     ordinal: int = betterproto.uint32_field(3)
     message_without_bb_code: str = betterproto.string_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class AckMessageNotification(betterproto.Message):
+class AckMessageNotification(UnifiedMessage, um_name="FriendMessages.AckMessage"):
     steamid_partner: int = betterproto.fixed64_field(1)
     timestamp: int = betterproto.uint32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class IsInFriendsUiBetaRequest(betterproto.Message):
     steamid: int = betterproto.fixed64_field(1)
@@ -102,44 +96,40 @@
 
 @dataclass(eq=False, repr=False)
 class IsInFriendsUiBetaResponse(betterproto.Message):
     online_in_friendsui: bool = betterproto.bool_field(1)
     has_used_friendsui: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateMessageReactionRequest(betterproto.Message):
+class UpdateMessageReactionRequest(UnifiedMessage, um_name="FriendMessages.UpdateMessageReaction"):
     steamid: int = betterproto.fixed64_field(1)
     server_timestamp: int = betterproto.uint32_field(2)
     ordinal: int = betterproto.uint32_field(3)
     reaction_type: "EMessageReactionType" = betterproto.enum_field(4)
     reaction: str = betterproto.string_field(5)
     is_add: bool = betterproto.bool_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateMessageReactionResponse(betterproto.Message):
-    reactors: List[int] = betterproto.uint32_field(1)
+class UpdateMessageReactionResponse(UnifiedMessage, um_name="FriendMessages.UpdateMessageReaction"):
+    reactors: list[int] = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class IncomingMessageNotification(betterproto.Message):
+class IncomingMessageNotification(UnifiedMessage, um_name="FriendMessagesClient.IncomingMessage"):
     steamid_friend: int = betterproto.fixed64_field(1)
     chat_entry_type: int = betterproto.int32_field(2)
     from_limited_account: bool = betterproto.bool_field(3)
     message: str = betterproto.string_field(4)
     rtime32_server_timestamp: int = betterproto.fixed32_field(5)
     ordinal: int = betterproto.uint32_field(6)
     local_echo: bool = betterproto.bool_field(7)
     message_no_bbcode: str = betterproto.string_field(8)
     low_priority: bool = betterproto.bool_field(9)
 
 
-@dataclass(eq=False, repr=False)
-class MessageReactionNotification(betterproto.Message):
+class MessageReactionNotification(UnifiedMessage, um_name="FriendMessagesClient.MessageReaction"):
     steamid_friend: int = betterproto.fixed64_field(1)
     server_timestamp: int = betterproto.uint32_field(2)
     ordinal: int = betterproto.uint32_field(3)
     reactor: int = betterproto.fixed64_field(4)
     reaction_type: "EMessageReactionType" = betterproto.enum_field(5)
     reaction: str = betterproto.string_field(6)
     is_add: bool = betterproto.bool_field(7)
```

### Comparing `steamio-0.9.9/steam/protobufs/friends.py` & `steamio-1.0.0a0/steam/protobufs/friends.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,81 +1,95 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_clientserver_friends.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
+from typing_extensions import Self
 
+from ..utils import StructIO
+from .emsg import EMsg
+from .msg import Message, ProtobufMessage
 
-@dataclass(eq=False, repr=False)
-class CMsgClientFriendMsg(betterproto.Message):
+
+class ClientGetFriendsWhoPlayGame(Message, msg=EMsg.ClientGetFriendsWhoPlayGame):
+    app_id: int
+
+
+class ClientGetFriendsWhoPlayGameResponse(Message, msg=EMsg.ClientGetFriendsWhoPlayGameResponse):
+    eresult: int
+    app_id: int
+    friends: list[int]
+
+    def parse(self, data: bytes) -> Self:
+        with StructIO(data) as io:
+            self.eresult = io.read_u32()
+            self.app_id = io.read_u64()
+            self.friends = [io.read_u64() for _ in range(io.read_u32())]
+
+        return self
+
+
+class CMsgClientFriendMsg(ProtobufMessage, msg=EMsg.ClientFriendMsg):
     steamid: int = betterproto.fixed64_field(1)
     chat_entry_type: int = betterproto.int32_field(2)
     message: bytes = betterproto.bytes_field(3)
     rtime32_server_timestamp: int = betterproto.fixed32_field(4)
     echo_to_sender: bool = betterproto.bool_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientFriendMsgIncoming(betterproto.Message):
+class CMsgClientFriendMsgIncoming(ProtobufMessage, msg=EMsg.ClientFriendMsgIncoming):
     steamid_from: int = betterproto.fixed64_field(1)
     chat_entry_type: int = betterproto.int32_field(2)
     from_limited_account: bool = betterproto.bool_field(3)
     message: bytes = betterproto.bytes_field(4)
     rtime32_server_timestamp: int = betterproto.fixed32_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientAddFriend(betterproto.Message):
+class CMsgClientAddFriend(ProtobufMessage, msg=EMsg.ClientAddFriend):
     steamid_to_add: int = betterproto.fixed64_field(1)
     accountname_or_email_to_add: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientAddFriendResponse(betterproto.Message):
+class CMsgClientAddFriendResponse(ProtobufMessage, msg=EMsg.ClientAddFriendResponse):
     eresult: int = betterproto.int32_field(1)
     steam_id_added: int = betterproto.fixed64_field(2)
     persona_name_added: str = betterproto.string_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRemoveFriend(betterproto.Message):
+class CMsgClientRemoveFriend(ProtobufMessage, msg=EMsg.ClientRemoveFriend):
     friendid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientHideFriend(betterproto.Message):
+class CMsgClientHideFriend(ProtobufMessage, msg=EMsg.ClientHideFriend):
     friendid: int = betterproto.fixed64_field(1)
     hide: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientFriendsList(betterproto.Message):
+class CMsgClientFriendsList(ProtobufMessage, msg=EMsg.ClientFriendsList):
     bincremental: bool = betterproto.bool_field(1)
-    friends: List["CMsgClientFriendsListFriend"] = betterproto.message_field(2)
+    friends: "list[CMsgClientFriendsListFriend]" = betterproto.message_field(2)
     max_friend_count: int = betterproto.uint32_field(3)
     active_friend_count: int = betterproto.uint32_field(4)
     friends_limit_hit: bool = betterproto.bool_field(5)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientFriendsListFriend(betterproto.Message):
     ulfriendid: int = betterproto.fixed64_field(1)
     efriendrelationship: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientFriendsGroupsList(betterproto.Message):
+class CMsgClientFriendsGroupsList(ProtobufMessage, msg=EMsg.ClientFriendsGroupsList):
     bremoval: bool = betterproto.bool_field(1)
     bincremental: bool = betterproto.bool_field(2)
-    friend_groups: List["CMsgClientFriendsGroupsListFriendGroup"] = betterproto.message_field(3)
-    memberships: List["CMsgClientFriendsGroupsListFriendGroupsMembership"] = betterproto.message_field(4)
+    friend_groups: "list[CMsgClientFriendsGroupsListFriendGroup]" = betterproto.message_field(3)
+    memberships: "list[CMsgClientFriendsGroupsListFriendGroupsMembership]" = betterproto.message_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientFriendsGroupsListFriendGroup(betterproto.Message):
     n_group_id: int = betterproto.int32_field(1)
     str_group_name: str = betterproto.string_field(2)
 
@@ -86,15 +100,15 @@
     n_group_id: int = betterproto.int32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPlayerNicknameList(betterproto.Message):
     removal: bool = betterproto.bool_field(1)
     incremental: bool = betterproto.bool_field(2)
-    nicknames: List["CMsgClientPlayerNicknameListPlayerNickname"] = betterproto.message_field(3)
+    nicknames: "list[CMsgClientPlayerNicknameListPlayerNickname]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPlayerNicknameListPlayerNickname(betterproto.Message):
     steamid: int = betterproto.fixed64_field(1)
     nickname: str = betterproto.string_field(3)
 
@@ -106,22 +120,20 @@
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientSetPlayerNicknameResponse(betterproto.Message):
     eresult: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestFriendData(betterproto.Message):
+class CMsgClientRequestFriendData(ProtobufMessage, msg=EMsg.ClientRequestFriendData):
     persona_state_requested: int = betterproto.uint32_field(1)
-    friends: List[int] = betterproto.fixed64_field(2)
+    friends: list[int] = betterproto.fixed64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientChangeStatus(betterproto.Message):
+class CMsgClientChangeStatus(ProtobufMessage, msg=EMsg.ClientChangeStatus):
     persona_state: int = betterproto.uint32_field(1)
     player_name: str = betterproto.string_field(2)
     is_auto_generated_name: bool = betterproto.bool_field(3)
     high_priority: bool = betterproto.bool_field(4)
     persona_set_by_user: bool = betterproto.bool_field(5)
     persona_state_flags: int = betterproto.uint32_field(6)
     need_persona_response: bool = betterproto.bool_field(7)
@@ -130,18 +142,17 @@
 
 @dataclass(eq=False, repr=False)
 class CMsgPersonaChangeResponse(betterproto.Message):
     result: int = betterproto.uint32_field(1)
     player_name: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientPersonaState(betterproto.Message):
+class CMsgClientPersonaState(ProtobufMessage, msg=EMsg.ClientPersonaState):
     status_flags: int = betterproto.uint32_field(1)
-    friends: List["CMsgClientPersonaStateFriend"] = betterproto.message_field(2)
+    friends: "list[CMsgClientPersonaStateFriend]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPersonaStateFriend(betterproto.Message):
     friendid: int = betterproto.fixed64_field(1)
     persona_state: int = betterproto.uint32_field(2)
     game_played_app_id: int = betterproto.uint32_field(3)
@@ -159,15 +170,15 @@
     last_seen_online: int = betterproto.uint32_field(47)
     clan_rank: int = betterproto.uint32_field(50)
     game_name: str = betterproto.string_field(55)
     gameid: int = betterproto.fixed64_field(56)
     game_data_blob: bytes = betterproto.bytes_field(60)
     clan_data: "CMsgClientPersonaStateFriendClanData" = betterproto.message_field(64)
     clan_tag: str = betterproto.string_field(65)
-    rich_presence: List["CMsgClientPersonaStateFriendKv"] = betterproto.message_field(71)
+    rich_presence: "list[CMsgClientPersonaStateFriendKv]" = betterproto.message_field(71)
     broadcast_id: int = betterproto.fixed64_field(72)
     game_lobby_id: int = betterproto.fixed64_field(73)
     watching_broadcast_accountid: int = betterproto.uint32_field(74)
     watching_broadcast_appid: int = betterproto.uint32_field(75)
     watching_broadcast_viewers: int = betterproto.uint32_field(76)
     watching_broadcast_title: str = betterproto.string_field(77)
     is_community_banned: bool = betterproto.bool_field(78)
@@ -183,21 +194,19 @@
 
 @dataclass(eq=False, repr=False)
 class CMsgClientPersonaStateFriendKv(betterproto.Message):
     key: str = betterproto.string_field(1)
     value: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientFriendProfileInfo(betterproto.Message):
+class CMsgClientFriendProfileInfo(ProtobufMessage, msg=EMsg.ClientFriendProfileInfo):
     steamid_friend: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientFriendProfileInfoResponse(betterproto.Message):
+class CMsgClientFriendProfileInfoResponse(ProtobufMessage, msg=EMsg.ClientFriendProfileInfoResponse):
     eresult: int = betterproto.int32_field(1)
     steamid_friend: int = betterproto.fixed64_field(2)
     time_created: int = betterproto.uint32_field(3)
     real_name: str = betterproto.string_field(4)
     city_name: str = betterproto.string_field(5)
     state_name: str = betterproto.string_field(6)
     country_name: str = betterproto.string_field(7)
@@ -205,15 +214,15 @@
     summary: str = betterproto.string_field(9)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientCreateFriendsGroup(betterproto.Message):
     steamid: int = betterproto.fixed64_field(1)
     groupname: str = betterproto.string_field(2)
-    steamid_friends: List[int] = betterproto.fixed64_field(3)
+    steamid_friends: list[int] = betterproto.fixed64_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientCreateFriendsGroupResponse(betterproto.Message):
     eresult: int = betterproto.uint32_field(1)
     groupid: int = betterproto.int32_field(2)
 
@@ -229,16 +238,16 @@
     eresult: int = betterproto.uint32_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientManageFriendsGroup(betterproto.Message):
     groupid: int = betterproto.int32_field(1)
     groupname: str = betterproto.string_field(2)
-    steamid_friends_added: List[int] = betterproto.fixed64_field(3)
-    steamid_friends_removed: List[int] = betterproto.fixed64_field(4)
+    steamid_friends_added: list[int] = betterproto.fixed64_field(3)
+    steamid_friends_removed: list[int] = betterproto.fixed64_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientManageFriendsGroupResponse(betterproto.Message):
     eresult: int = betterproto.uint32_field(1)
 
 
@@ -260,24 +269,22 @@
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientRemoveFriendFromGroupResponse(betterproto.Message):
     eresult: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetEmoticonList(betterproto.Message):
+class CMsgClientGetEmoticonList(ProtobufMessage, msg=EMsg.ClientGetEmoticonList):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientEmoticonList(betterproto.Message):
-    emoticons: List["CMsgClientEmoticonListEmoticon"] = betterproto.message_field(1)
-    stickers: List["CMsgClientEmoticonListSticker"] = betterproto.message_field(2)
-    effects: List["CMsgClientEmoticonListEffect"] = betterproto.message_field(3)
+class CMsgClientEmoticonList(ProtobufMessage, msg=EMsg.ClientEmoticonList):
+    emoticons: "list[CMsgClientEmoticonListEmoticon]" = betterproto.message_field(1)
+    stickers: "list[CMsgClientEmoticonListSticker]" = betterproto.message_field(2)
+    effects: "list[CMsgClientEmoticonListEffect]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientEmoticonListEmoticon(betterproto.Message):
     name: str = betterproto.string_field(1)
     count: int = betterproto.int32_field(2)
     time_last_used: int = betterproto.uint32_field(3)
```

### Comparing `steamio-0.9.9/steam/protobufs/game_servers.py` & `steamio-1.0.0a0/steam/protobufs/game_servers.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,36 +1,34 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_gameservers.proto
 # plugin: python-betterproto
 # Last updated 18/05/2022
 
 from dataclasses import dataclass
-from typing import Dict, List
 
 import betterproto
 
 from .base import CMsgIpAddress
+from .msg import UnifiedMessage
 
 
 class EQueryType(betterproto.Enum):
     Invalid = 0
     Ping = 1
     Players = 2
     Rules = 3
 
 
-@dataclass(eq=False, repr=False)
-class GetServerListRequest(betterproto.Message):
+class GetServerListRequest(UnifiedMessage, um_name="GameServers.GetServerList"):
     filter: str = betterproto.string_field(1)
     limit: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetServerListResponse(betterproto.Message):
-    servers: List["GetServerListResponseServer"] = betterproto.message_field(1)
+class GetServerListResponse(UnifiedMessage, um_name="GameServers.GetServerList"):
+    servers: "list[GetServerListResponseServer]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetServerListResponseServer(betterproto.Message):
     addr: str = betterproto.string_field(1)
     gameport: int = betterproto.uint32_field(2)
     specport: int = betterproto.uint32_field(3)
@@ -47,37 +45,33 @@
     map: str = betterproto.string_field(14)
     secure: bool = betterproto.bool_field(15)
     dedicated: bool = betterproto.bool_field(16)
     os: str = betterproto.string_field(17)
     gametype: str = betterproto.string_field(18)
 
 
-@dataclass(eq=False, repr=False)
-class GetServerSteamIDsByIpRequest(betterproto.Message):
-    server_ips: List[str] = betterproto.string_field(1)
+class GetServerSteamIDsByIpRequest(UnifiedMessage, um_name="GameServers.GetServerSteamIDsByIP"):
+    server_ips: list[str] = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class IPsWithSteamIDsResponse(betterproto.Message):
-    servers: List["IPsWithSteamIDsResponseServer"] = betterproto.message_field(1)
+class IPsWithSteamIDsResponse(UnifiedMessage, um_name="GameServers.GetServerSteamIDsByIP"):
+    servers: "list[IPsWithSteamIDsResponseServer]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class IPsWithSteamIDsResponseServer(betterproto.Message):
     addr: str = betterproto.string_field(1)
     steamid: int = betterproto.fixed64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetServerIPsBySteamIdRequest(betterproto.Message):
-    server_steamids: List[int] = betterproto.fixed64_field(1)
+class GetServerIPsBySteamIdRequest(UnifiedMessage, um_name="GameServers.GetServerIPsBySteamID"):
+    server_steamids: list[int] = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class QueryRequest(betterproto.Message):
+class QueryRequest(UnifiedMessage, um_name="GameServers.QueryByFakeIP"):
     fake_ip: int = betterproto.uint32_field(1)
     fake_port: int = betterproto.uint32_field(2)
     app_id: int = betterproto.uint32_field(3)
     query_type: EQueryType = betterproto.enum_field(4)
 
 
 @dataclass(eq=False, repr=False)
@@ -110,20 +104,19 @@
     name: str = betterproto.string_field(1)
     score: int = betterproto.uint32_field(2)
     time_played: int = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class PlayersQueryData(betterproto.Message):
-    players: List[PlayersQueryDataPlayer] = betterproto.message_field(1)
+    players: list[PlayersQueryDataPlayer] = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class RulesQueryData(betterproto.Message):
-    rules: Dict[str, str] = betterproto.map_field(1, betterproto.TYPE_STRING, betterproto.TYPE_STRING)
+    rules: dict[str, str] = betterproto.map_field(1, betterproto.TYPE_STRING, betterproto.TYPE_STRING)
 
 
-@dataclass(eq=False, repr=False)
-class QueryResponse(betterproto.Message):
+class QueryResponse(UnifiedMessage, um_name="GameServers.QueryByFakeIP"):
     ping_data: PingQueryData = betterproto.message_field(1)
     players_data: PlayersQueryData = betterproto.message_field(2)
     rules_data: RulesQueryData = betterproto.message_field(3)
```

### Comparing `steamio-0.9.9/steam/protobufs/inventory.py` & `steamio-1.0.0a0/steam/protobufs/inventory.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,176 +1,156 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_inventory.steamclient.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .msg import UnifiedMessage
 
-@dataclass(eq=False, repr=False)
-class GetInventoryRequest(betterproto.Message):
+
+class GetInventoryRequest(UnifiedMessage, um_name="Inventory.GetInventory"):
     appid: int = betterproto.uint32_field(1)
     steamid: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class Response(betterproto.Message):
+class Response(UnifiedMessage, um_name="Inventory.GetInventory"):
     etag: str = betterproto.string_field(1)
-    removeditemids: List[int] = betterproto.uint64_field(2)
+    removeditemids: list[int] = betterproto.uint64_field(2)
     item_json: str = betterproto.string_field(3)
     itemdef_json: str = betterproto.string_field(4)
     ticket: bytes = betterproto.bytes_field(5)
     replayed: bool = betterproto.bool_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class ExchangeItemRequest(betterproto.Message):
+class ExchangeItemRequest(UnifiedMessage, um_name="Inventory.ExchangeItem"):
     appid: int = betterproto.uint32_field(1)
     steamid: int = betterproto.uint64_field(2)
-    materialsitemid: List[int] = betterproto.uint64_field(3)
-    materialsquantity: List[int] = betterproto.uint32_field(4)
+    materialsitemid: list[int] = betterproto.uint64_field(3)
+    materialsquantity: list[int] = betterproto.uint32_field(4)
     outputitemdefid: int = betterproto.uint64_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class GetEligiblePromoItemDefIDsRequest(betterproto.Message):
+class GetEligiblePromoItemDefIDsRequest(UnifiedMessage, um_name="Inventory.GetEligiblePromoItemDefIDs"):
     appid: int = betterproto.uint32_field(1)
     steamid: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetEligiblePromoItemDefIDsResponse(betterproto.Message):
-    itemdefids: List[int] = betterproto.uint64_field(1)
+class GetEligiblePromoItemDefIDsResponse(UnifiedMessage, um_name="Inventory.GetEligiblePromoItemDefIDs"):
+    itemdefids: list[int] = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class AddItemRequest(betterproto.Message):
+class AddItemRequest(UnifiedMessage, um_name="Inventory.AddPromoItem"):
     appid: int = betterproto.uint32_field(1)
-    itemdefid: List[int] = betterproto.uint64_field(2)
-    itempropsjson: List[str] = betterproto.string_field(3)
+    itemdefid: list[int] = betterproto.uint64_field(2)
+    itempropsjson: list[str] = betterproto.string_field(3)
     steamid: int = betterproto.uint64_field(4)
     notify: bool = betterproto.bool_field(5)
     requestid: int = betterproto.uint64_field(6)
     trade_restriction: bool = betterproto.bool_field(7)
     is_purchase: bool = betterproto.bool_field(8)
 
 
-@dataclass(eq=False, repr=False)
-class ModifyItemsRequest(betterproto.Message):
+class ModifyItemsRequest(UnifiedMessage, um_name="Inventory.SafeModifyItems"):
     appid: int = betterproto.uint32_field(1)
     steamid: int = betterproto.uint64_field(2)
-    updates: List["ModifyItemsRequestItemPropertyUpdate"] = betterproto.message_field(3)
+    updates: "list[ModifyItemsRequestItemPropertyUpdate]" = betterproto.message_field(3)
     timestamp: int = betterproto.uint32_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class ModifyItemsRequestItemPropertyUpdate(betterproto.Message):
     itemid: int = betterproto.uint64_field(1)
     remove_property: bool = betterproto.bool_field(2)
     property_name: str = betterproto.string_field(3)
     property_value_bool: bool = betterproto.bool_field(4)
     property_value_int: int = betterproto.int64_field(5)
     property_value_string: str = betterproto.string_field(6)
     property_value_float: float = betterproto.float_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class ConsumePlaytimeRequest(betterproto.Message):
+class ConsumePlaytimeRequest(UnifiedMessage, um_name="Inventory.ConsumePlaytime"):
     appid: int = betterproto.uint32_field(1)
     itemdefid: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class ConsumeItemRequest(betterproto.Message):
+class ConsumeItemRequest(UnifiedMessage, um_name="Inventory.ConsumeItem"):
     appid: int = betterproto.uint32_field(1)
     itemid: int = betterproto.uint64_field(2)
     quantity: int = betterproto.uint32_field(3)
     timestamp: str = betterproto.string_field(4)
     steamid: int = betterproto.uint64_field(5)
     requestid: int = betterproto.uint64_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class DevSetNextDropRequest(betterproto.Message):
+class DevSetNextDropRequest(UnifiedMessage, um_name="Inventory.DevSetNextDrop"):
     appid: int = betterproto.uint32_field(1)
     itemdefid: int = betterproto.uint64_field(2)
     droptime: str = betterproto.string_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class SplitItemStackRequest(betterproto.Message):
+class SplitItemStackRequest(UnifiedMessage, um_name="Inventory.SplitItemStack"):
     appid: int = betterproto.uint32_field(1)
     itemid: int = betterproto.uint64_field(2)
     quantity: int = betterproto.uint32_field(3)
     steamid: int = betterproto.uint64_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class CombineItemStacksRequest(betterproto.Message):
+class CombineItemStacksRequest(UnifiedMessage, um_name="Inventory.CombineItemStacks"):
     appid: int = betterproto.uint32_field(1)
     fromitemid: int = betterproto.uint64_field(2)
     destitemid: int = betterproto.uint64_field(3)
     quantity: int = betterproto.uint32_field(4)
     steamid: int = betterproto.fixed64_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class GetItemDefMetaRequest(betterproto.Message):
+class GetItemDefMetaRequest(UnifiedMessage, um_name="Inventory.GetItemDefMeta"):
     appid: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetItemDefMetaResponse(betterproto.Message):
+class GetItemDefMetaResponse(UnifiedMessage, um_name="Inventory.GetItemDefMeta"):
     modified: int = betterproto.uint32_field(1)
     digest: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetUserPurchaseInfoRequest(betterproto.Message):
+class GetUserPurchaseInfoRequest(UnifiedMessage, um_name="Inventory.GetUserPurchaseInfo"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetUserPurchaseInfoResponse(betterproto.Message):
+class GetUserPurchaseInfoResponse(UnifiedMessage, um_name="Inventory.GetUserPurchaseInfo"):
     ecurrency: int = betterproto.int32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class PurchaseInitRequest(betterproto.Message):
+class PurchaseInitRequest(UnifiedMessage, um_name="Inventory.PurchaseInit"):
     appid: int = betterproto.uint32_field(1)
     language: int = betterproto.int32_field(2)
-    line_items: List["PurchaseInitRequestLineItem"] = betterproto.message_field(3)
+    line_items: "list[PurchaseInitRequestLineItem]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class PurchaseInitRequestLineItem(betterproto.Message):
     itemdefid: int = betterproto.uint64_field(1)
     quantity: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class PurchaseInitResponse(betterproto.Message):
+class PurchaseInitResponse(UnifiedMessage, um_name="Inventory.PurchaseInit"):
     orderid: int = betterproto.uint64_field(1)
     transid: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class PurchaseFinalizeRequest(betterproto.Message):
+class PurchaseFinalizeRequest(UnifiedMessage, um_name="Inventory.PurchaseFinalize"):
     appid: int = betterproto.uint32_field(1)
     language: int = betterproto.int32_field(2)
     orderid: int = betterproto.uint64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class InspectItemRequest(betterproto.Message):
+class InspectItemRequest(UnifiedMessage, um_name="Inventory.InspectItem"):
     itemdefid: int = betterproto.uint64_field(1)
     itemid: int = betterproto.fixed64_field(2)
     tags: str = betterproto.string_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class ClientNewItemsNotification(betterproto.Message):
+class ClientNewItemsNotification(UnifiedMessage, um_name="InventoryClient.NotifyNewItems"):
     appid: int = betterproto.uint32_field(1)
     inventory_response: "Response" = betterproto.message_field(2)
```

### Comparing `steamio-0.9.9/steam/protobufs/leaderboards.py` & `steamio-1.0.0a0/steam/protobufs/leaderboards.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_clientserver_lbs.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .emsg import EMsg
+from .msg import ProtobufMessage
+
 
 @dataclass(eq=False, repr=False)
 class CMsgClientLbsSetScore(betterproto.Message):
     app_id: int = betterproto.uint32_field(1)
     leaderboard_id: int = betterproto.int32_field(2)
     score: int = betterproto.int32_field(3)
     details: bytes = betterproto.bytes_field(4)
@@ -35,48 +37,44 @@
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientLbsSetUgcResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientLbsFindOrCreateLb(betterproto.Message):
+class CMsgClientLbsFindOrCreateLb(ProtobufMessage, msg=EMsg.ClientLBSFindOrCreateLB):
     app_id: int = betterproto.uint32_field(1)
     leaderboard_sort_method: int = betterproto.int32_field(2)
     leaderboard_display_type: int = betterproto.int32_field(3)
     create_if_not_found: bool = betterproto.bool_field(4)
     leaderboard_name: str = betterproto.string_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientLbsFindOrCreateLbResponse(betterproto.Message):
+class CMsgClientLbsFindOrCreateLbResponse(ProtobufMessage, msg=EMsg.ClientLBSFindOrCreateLBResponse):
     eresult: int = betterproto.int32_field(1)
     leaderboard_id: int = betterproto.int32_field(2)
     leaderboard_entry_count: int = betterproto.int32_field(3)
     leaderboard_sort_method: int = betterproto.int32_field(4)
     leaderboard_display_type: int = betterproto.int32_field(5)
     leaderboard_name: str = betterproto.string_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientLbsGetLbEntries(betterproto.Message):
+class CMsgClientLbsGetLbEntries(ProtobufMessage, msg=EMsg.ClientLBSGetLBEntries):
     app_id: int = betterproto.int32_field(1)
     leaderboard_id: int = betterproto.int32_field(2)
     range_start: int = betterproto.int32_field(3)
     range_end: int = betterproto.int32_field(4)
     leaderboard_data_request: int = betterproto.int32_field(5)
-    steamids: List[int] = betterproto.fixed64_field(6)
+    steamids: list[int] = betterproto.fixed64_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientLbsGetLbEntriesResponse(betterproto.Message):
+class CMsgClientLbsGetLbEntriesResponse(ProtobufMessage, msg=EMsg.ClientLBSGetLBEntriesResponse):
     eresult: int = betterproto.int32_field(1)
     leaderboard_entry_count: int = betterproto.int32_field(2)
-    entries: List["CMsgClientLbsGetLbEntriesResponseEntry"] = betterproto.message_field(3)
+    entries: "list[CMsgClientLbsGetLbEntriesResponseEntry]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientLbsGetLbEntriesResponseEntry(betterproto.Message):
     steam_id_user: int = betterproto.fixed64_field(1)
     global_rank: int = betterproto.int32_field(2)
     score: int = betterproto.int32_field(3)
```

### Comparing `steamio-0.9.9/steam/protobufs/login.py` & `steamio-1.0.0a0/steam/protobufs/login.py`

 * *Files 13% similar despite different names*

```diff
@@ -4,43 +4,45 @@
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
 
 import betterproto
 
 from .base import CMsgIpAddress
+from .emsg import EMsg
+from .msg import ProtobufMessage
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientHeartBeat(betterproto.Message):
+class CMsgClientHeartBeat(ProtobufMessage, msg=EMsg.ClientHeartBeat):
     send_reply: bool = betterproto.bool_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientServerTimestampRequest(betterproto.Message):
+class CMsgClientServerTimestampRequest(ProtobufMessage, msg=EMsg.ClientServerTimestampRequest):
     client_request_timestamp: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientServerTimestampResponse(betterproto.Message):
+class CMsgClientServerTimestampResponse(ProtobufMessage, msg=EMsg.ClientServerTimestampResponse):
     client_request_timestamp: int = betterproto.uint64_field(1)
     server_timestamp_ms: int = betterproto.uint64_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientSecret(betterproto.Message):
     version: int = betterproto.uint32_field(1)
     appid: int = betterproto.uint32_field(2)
     deviceid: int = betterproto.uint32_field(3)
     nonce: int = betterproto.fixed64_field(4)
     hmac: bytes = betterproto.bytes_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientLogon(betterproto.Message):
+class CMsgClientHello(ProtobufMessage, msg=EMsg.ClientHello):
+    protocol_version: int = betterproto.uint32_field(1)
+
+
+class CMsgClientLogon(ProtobufMessage, msg=EMsg.ClientLogon):
     protocol_version: int = betterproto.uint32_field(1)
     deprecated_obfustucated_private_ip: int = betterproto.uint32_field(2)
     cell_id: int = betterproto.uint32_field(3)
     last_session_id: int = betterproto.uint32_field(4)
     client_package_version: int = betterproto.uint32_field(5)
     client_language: str = betterproto.string_field(6)
     client_os_type: int = betterproto.uint32_field(7)
@@ -86,21 +88,21 @@
     client_instance_id: int = betterproto.uint64_field(100)
     two_factor_code: str = betterproto.string_field(101)
     supports_rate_limit_response: bool = betterproto.bool_field(102)
     web_logon_nonce: str = betterproto.string_field(103)
     priority_reason: int = betterproto.int32_field(104)
     embedded_client_secret: "CMsgClientSecret" = betterproto.message_field(105)
     disable_partner_autogrants: bool = betterproto.bool_field(106)
+    is_steam_deck: bool = betterproto.bool_field(107)
+    access_token: str = betterproto.string_field(108)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientLogonResponse(betterproto.Message):
+class CMsgClientLogonResponse(ProtobufMessage, msg=EMsg.ClientLogOnResponse):
     eresult: int = betterproto.int32_field(1)
-    out_of_game_heartbeat_seconds: int = betterproto.int32_field(2)
-    in_game_heartbeat_seconds: int = betterproto.int32_field(3)
+    heartbeat_seconds: int = betterproto.int32_field(3)
     deprecated_public_ip: int = betterproto.uint32_field(4)
     rtime32_server_time: int = betterproto.fixed32_field(5)
     account_flags: int = betterproto.uint32_field(6)
     cell_id: int = betterproto.uint32_field(7)
     email_domain: str = betterproto.string_field(8)
     steam2_ticket: bytes = betterproto.bytes_field(9)
     eresult_extended: int = betterproto.int32_field(10)
@@ -115,66 +117,60 @@
     parental_setting_signature: bytes = betterproto.bytes_field(23)
     count_loginfailures_to_migrate: int = betterproto.int32_field(24)
     count_disconnects_to_migrate: int = betterproto.int32_field(25)
     ogs_data_report_time_window: int = betterproto.int32_field(26)
     client_instance_id: int = betterproto.uint64_field(27)
     force_client_update_check: bool = betterproto.bool_field(28)
     agreement_session_url: str = betterproto.string_field(29)
+    token_id: int = betterproto.uint64_field(30)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestWebApiAuthenticateUserNonce(betterproto.Message):
+class CMsgClientRequestWebApiAuthenticateUserNonce(ProtobufMessage, msg=EMsg.ClientRequestWebAPIAuthenticateUserNonce):
     token_type: int = betterproto.int32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientRequestWebApiAuthenticateUserNonceResponse(betterproto.Message):
+class CMsgClientRequestWebApiAuthenticateUserNonceResponse(
+    ProtobufMessage, msg=EMsg.ClientRequestWebAPIAuthenticateUserNonceResponse
+):
     eresult: int = betterproto.int32_field(1)
     webapi_authenticate_user_nonce: str = betterproto.string_field(11)
     token_type: int = betterproto.int32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientLogOff(betterproto.Message):
+class CMsgClientLogOff(ProtobufMessage, msg=EMsg.ClientLogOff):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientLoggedOff(betterproto.Message):
+class CMsgClientLoggedOff(ProtobufMessage, msg=EMsg.ClientLoggedOff):
     eresult: int = betterproto.int32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientNewLoginKey(betterproto.Message):
+class CMsgClientNewLoginKey(ProtobufMessage, msg=EMsg.ClientNewLoginKey):
     unique_id: int = betterproto.uint32_field(1)
     login_key: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientNewLoginKeyAccepted(betterproto.Message):
+class CMsgClientNewLoginKeyAccepted(ProtobufMessage, msg=EMsg.ClientNewLoginKeyAccepted):
     unique_id: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientAccountInfo(betterproto.Message):
+class CMsgClientAccountInfo(ProtobufMessage, msg=EMsg.ClientAccountInfo):
     persona_name: str = betterproto.string_field(1)
     ip_country: str = betterproto.string_field(2)
     count_authed_computers: int = betterproto.int32_field(5)
     account_flags: int = betterproto.uint32_field(7)
     facebook_id: int = betterproto.uint64_field(8)
     facebook_name: str = betterproto.string_field(9)
     steamguard_notify_newmachines: bool = betterproto.bool_field(14)
     steamguard_machine_name_user_chosen: str = betterproto.string_field(15)
     is_phone_verified: bool = betterproto.bool_field(16)
     two_factor_state: int = betterproto.uint32_field(17)
     is_phone_identifying: bool = betterproto.bool_field(18)
     is_phone_needing_reverify: bool = betterproto.bool_field(19)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientChallengeRequest(betterproto.Message):
+class CMsgClientChallengeRequest(ProtobufMessage, msg=EMsg.ClientChallengeRequest):
     steamid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientChallengeResponse(betterproto.Message):
+class CMsgClientChallengeResponse(ProtobufMessage, msg=EMsg.ClientChallengeResponse):
     challenge: int = betterproto.fixed64_field(1)
```

### Comparing `steamio-0.9.9/steam/protobufs/loyalty_rewards.py` & `steamio-1.0.0a0/steam/protobufs/loyalty_rewards.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_clientserver_login.proto
 # plugin: python-betterproto
 # Last updated 19/04/2022
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .msg import UnifiedMessage
+
 
 @dataclass(eq=False, repr=False)
 class DefinitionBadgeData(betterproto.Message):
     level: int = betterproto.int32_field(1)
     image: str = betterproto.string_field(2)
 
 
@@ -21,15 +22,15 @@
     item_title: str = betterproto.string_field(2)
     item_description: str = betterproto.string_field(3)
     item_image_small: str = betterproto.string_field(4)
     item_image_large: str = betterproto.string_field(5)
     item_movie_webm: str = betterproto.string_field(6)
     item_movie_mp4: str = betterproto.string_field(7)
     animated: bool = betterproto.bool_field(8)
-    badge_data: List[DefinitionBadgeData] = betterproto.message_field(9)
+    badge_data: list[DefinitionBadgeData] = betterproto.message_field(9)
     item_movie_webm_small: str = betterproto.string_field(10)
     item_movie_mp4_small: str = betterproto.string_field(11)
     profile_theme_id: str = betterproto.string_field(12)
 
 
 @dataclass(eq=False, repr=False)
 class Definition(betterproto.Message):
@@ -43,128 +44,113 @@
     timestamp_updated: int = betterproto.uint32_field(8)
     timestamp_available: int = betterproto.uint32_field(9)
     quantity: int = betterproto.int64_field(10)
     internal_description: str = betterproto.string_field(11)
     active: bool = betterproto.bool_field(12)
     community_item_data: CommunityItemData = betterproto.message_field(13)
     timestamp_available_end: int = betterproto.uint32_field(14)
-    bundle_defids: List[int] = betterproto.uint32_field(15)
+    bundle_defids: list[int] = betterproto.uint32_field(15)
     usable_duration: int = betterproto.uint32_field(16)
     bundle_discount: int = betterproto.uint32_field(17)
 
 
-@dataclass(eq=False, repr=False)
-class AddReactionRequest(betterproto.Message):
+class AddReactionRequest(UnifiedMessage, um_name="LoyaltyRewards.AddReaction"):
     target_type: int = betterproto.int32_field(1)
     targetid: int = betterproto.uint64_field(2)
     reactionid: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class AddReactionResponse(betterproto.Message):
+class AddReactionResponse(UnifiedMessage, um_name="LoyaltyRewards.AddReaction"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class BatchedQueryRewardItemsRequest(betterproto.Message):
-    requests: List["QueryRewardItemsRequest"] = betterproto.message_field(1)
+class BatchedQueryRewardItemsRequest(UnifiedMessage, um_name="LoyaltyRewards.BatchedQueryRewardItems"):
+    requests: "list[QueryRewardItemsRequest]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class BatchedQueryRewardItemsResponse(betterproto.Message):
-    responses: List["BatchedQueryRewardItemsResponseResponse"] = betterproto.message_field(1)
+class BatchedQueryRewardItemsResponse(UnifiedMessage, um_name="LoyaltyRewards.BatchedQueryRewardItems"):
+    responses: "list[BatchedQueryRewardItemsResponseResponse]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class BatchedQueryRewardItemsResponseResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
     response: "QueryRewardItemsResponse" = betterproto.message_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetActivePurchaseBonusesRequest(betterproto.Message):
+class GetActivePurchaseBonusesRequest(UnifiedMessage, um_name="LoyaltyRewards.GetActivePurchaseBonuses"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetActivePurchaseBonusesResponse(betterproto.Message):
-    bonuses: List["PurchaseBonus"] = betterproto.message_field(1)
+class GetActivePurchaseBonusesResponse(UnifiedMessage, um_name="LoyaltyRewards.GetActivePurchaseBonuses"):
+    bonuses: "list[PurchaseBonus]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetEligibleAppsRequest(betterproto.Message):
+class GetEligibleAppsRequest(UnifiedMessage, um_name="LoyaltyRewards.GetEligibleApps"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetEligibleAppsResponse(betterproto.Message):
-    apps: List["GetEligibleAppsResponseEligibleApp"] = betterproto.message_field(1)
+class GetEligibleAppsResponse(UnifiedMessage, um_name="LoyaltyRewards.GetEligibleApps"):
+    apps: "list[GetEligibleAppsResponseEligibleApp]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetEligibleAppsResponseEligibleApp(betterproto.Message):
     appid: int = betterproto.uint32_field(1)
     has_items_anyone_can_purchase: bool = betterproto.bool_field(2)
     event_app: bool = betterproto.bool_field(3)
     hero_carousel_image: str = betterproto.string_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class GetPointsForSpendResponse(betterproto.Message):
+class GetPointsForSpendResponse(UnifiedMessage, um_name="LoyaltyRewards.GetPointsForSpend"):
     points: int = betterproto.int64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileCustomizationsConfigResponse(betterproto.Message):
+class GetProfileCustomizationsConfigResponse(UnifiedMessage, um_name="LoyaltyRewards.GetProfileCustomizationsConfig"):
     points_cost: int = betterproto.uint32_field(1)
     upgrade_points_cost: int = betterproto.uint32_field(2)
-    purchasable_customization_types: List[int] = betterproto.int32_field(3)
-    upgradable_customization_types: List[int] = betterproto.int32_field(4)
+    purchasable_customization_types: list[int] = betterproto.int32_field(3)
+    upgradable_customization_types: list[int] = betterproto.int32_field(4)
     max_slots_per_type: int = betterproto.uint32_field(5)
     max_upgradable_level: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class GetReactionConfigRequest(betterproto.Message):
+class GetReactionConfigRequest(UnifiedMessage, um_name="LoyaltyRewards.GetReactionConfig"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetReactionConfigResponse(betterproto.Message):
-    reactions: List["GetReactionConfigResponseReactionConfig"] = betterproto.message_field(3)
+class GetReactionConfigResponse(UnifiedMessage, um_name="LoyaltyRewards.GetReactionConfig"):
+    reactions: "list[GetReactionConfigResponseReactionConfig]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class GetReactionConfigResponseReactionConfig(betterproto.Message):
     reactionid: int = betterproto.int32_field(1)
     points_cost: int = betterproto.uint32_field(2)
     points_transferred: int = betterproto.uint32_field(3)
-    valid_target_types: List[int] = betterproto.int32_field(4)
-    valid_ugc_types: List[int] = betterproto.uint32_field(5)
+    valid_target_types: list[int] = betterproto.int32_field(4)
+    valid_ugc_types: list[int] = betterproto.uint32_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class GetReactionsRequest(betterproto.Message):
+class GetReactionsRequest(UnifiedMessage, um_name="LoyaltyRewards.GetReactions"):
     target_type: int = betterproto.int32_field(1)
     targetid: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetReactionsResponse(betterproto.Message):
-    reactionids: List[int] = betterproto.uint32_field(1)
+class GetReactionsResponse(UnifiedMessage, um_name="LoyaltyRewards.GetReactions"):
+    reactionids: list[int] = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetReactionsSummaryForUserResponse(betterproto.Message):
-    total: List["GetReactionsSummaryForUserResponseBreakdown"] = betterproto.message_field(1)
-    user_reviews: List["GetReactionsSummaryForUserResponseBreakdown"] = betterproto.message_field(2)
-    ugc: List["GetReactionsSummaryForUserResponseBreakdown"] = betterproto.message_field(3)
-    profile: List["GetReactionsSummaryForUserResponseBreakdown"] = betterproto.message_field(4)
-    forum_topics: List["GetReactionsSummaryForUserResponseBreakdown"] = betterproto.message_field(5)
-    comments: List["GetReactionsSummaryForUserResponseBreakdown"] = betterproto.message_field(6)
+class GetReactionsSummaryForUserResponse(UnifiedMessage, um_name="LoyaltyRewards.GetReactionsSummaryForUser"):
+    total: "list[GetReactionsSummaryForUserResponseBreakdown]" = betterproto.message_field(1)
+    user_reviews: "list[GetReactionsSummaryForUserResponseBreakdown]" = betterproto.message_field(2)
+    ugc: "list[GetReactionsSummaryForUserResponseBreakdown]" = betterproto.message_field(3)
+    profile: "list[GetReactionsSummaryForUserResponseBreakdown]" = betterproto.message_field(4)
+    forum_topics: "list[GetReactionsSummaryForUserResponseBreakdown]" = betterproto.message_field(5)
+    comments: "list[GetReactionsSummaryForUserResponseBreakdown]" = betterproto.message_field(6)
     total_points_given: int = betterproto.int64_field(7)
     total_points_received: int = betterproto.int64_field(8)
     total_points_given: int = betterproto.int64_field(9)
     total_points_received: int = betterproto.int64_field(10)
 
 
 @dataclass(eq=False, repr=False)
@@ -172,110 +158,105 @@
     reactionid: int = betterproto.int32_field(1)
     given: int = betterproto.uint32_field(2)
     received: int = betterproto.uint32_field(3)
     points_given: int = betterproto.int64_field(4)
     points_received: int = betterproto.int64_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class GetSummaryRequest(betterproto.Message):
+class GetSummaryRequest(UnifiedMessage, um_name="LoyaltyRewards.GetSummary"):
     steamid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetSummaryResponse(betterproto.Message):
+class GetSummaryResponse(UnifiedMessage, um_name="LoyaltyRewards.GetSummary"):
     summary: "GetSummaryResponseSummary" = betterproto.message_field(1)
     timestamp_updated: int = betterproto.uint32_field(2)
     auditid_highwater: int = betterproto.uint64_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class GetSummaryResponseSummary(betterproto.Message):
     points: int = betterproto.int64_field(1)
     points_earned: int = betterproto.int64_field(2)
     points_spent: int = betterproto.int64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class QueryRewardItemsRequest(betterproto.Message):
-    appids: List[int] = betterproto.uint32_field(1)
+class QueryRewardItemsRequest(UnifiedMessage, um_name="LoyaltyRewards.QueryRewardItems"):
+    appids: list[int] = betterproto.uint32_field(1)
     time_available: int = betterproto.uint32_field(2)
-    community_item_classes: List[int] = betterproto.int32_field(3)
+    community_item_classes: list[int] = betterproto.int32_field(3)
     language: str = betterproto.string_field(4)
     count: int = betterproto.int32_field(5)
     cursor: str = betterproto.string_field(6)
     sort: int = betterproto.int32_field(7)
     sort_descending: bool = betterproto.bool_field(8)
-    reward_types: List[int] = betterproto.int32_field(9)
-    excluded_community_item_classes: List[int] = betterproto.int32_field(10)
-    definitionids: List[int] = betterproto.uint32_field(11)
-    filters: List[int] = betterproto.int32_field(12)
-    filter_match_all_category_tags: List[str] = betterproto.string_field(13)
-    filter_match_any_category_tags: List[str] = betterproto.string_field(14)
-    contains_definitionids: List[int] = betterproto.uint32_field(15)
+    reward_types: list[int] = betterproto.int32_field(9)
+    excluded_community_item_classes: list[int] = betterproto.int32_field(10)
+    definitionids: list[int] = betterproto.uint32_field(11)
+    filters: list[int] = betterproto.int32_field(12)
+    filter_match_all_category_tags: list[str] = betterproto.string_field(13)
+    filter_match_any_category_tags: list[str] = betterproto.string_field(14)
+    contains_definitionids: list[int] = betterproto.uint32_field(15)
     include_direct_purchase_disabled: bool = betterproto.bool_field(16)
-    excluded_content_descriptors: List[int] = betterproto.uint32_field(17)
-    excluded_appids: List[int] = betterproto.uint32_field(18)
+    excluded_content_descriptors: list[int] = betterproto.uint32_field(17)
+    excluded_appids: list[int] = betterproto.uint32_field(18)
 
 
-@dataclass(eq=False, repr=False)
-class QueryRewardItemsResponse(betterproto.Message):
-    definitions: List["Definition"] = betterproto.message_field(1)
+class QueryRewardItemsResponse(UnifiedMessage, um_name="LoyaltyRewards.QueryRewardItems"):
+    definitions: "list[Definition]" = betterproto.message_field(1)
     total_count: int = betterproto.int32_field(2)
     count: int = betterproto.int32_field(3)
     next_cursor: str = betterproto.string_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class RedeemPointsRequest(betterproto.Message):
+class RedeemPointsRequest(UnifiedMessage, um_name="LoyaltyRewards.RedeemPoints"):
     defid: int = betterproto.uint32_field(1)
     expected_points_cost: int = betterproto.int64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class RedeemPointsResponse(betterproto.Message):
+class RedeemPointsResponse(UnifiedMessage, um_name="LoyaltyRewards.RedeemPoints"):
     communityitemid: int = betterproto.uint64_field(1)
-    bundle_community_item_ids: List[int] = betterproto.uint64_field(2)
+    bundle_community_item_ids: list[int] = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class RedeemPointsForBadgeLevelRequest(betterproto.Message):
+class RedeemPointsForBadgeLevelRequest(UnifiedMessage, um_name="LoyaltyRewards.RedeemPointsForBadgeLevel"):
     defid: int = betterproto.uint32_field(1)
     num_levels: int = betterproto.int32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class RedeemPointsForProfileCustomizationRequest(betterproto.Message):
+class RedeemPointsForProfileCustomizationRequest(
+    UnifiedMessage, um_name="LoyaltyRewards.RedeemPointsForProfileCustomization"
+):
     customization_type: int = betterproto.int32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class RedeemPointsForProfileCustomizationResponse(betterproto.Message):
+class RedeemPointsForProfileCustomizationResponse(
+    UnifiedMessage, um_name="LoyaltyRewards.RedeemPointsForProfileCustomization"
+):
     purchaseid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class RedeemPointsForProfileCustomizationUpgradeRequest(betterproto.Message):
+class RedeemPointsForProfileCustomizationUpgradeRequest(
+    UnifiedMessage, um_name="LoyaltyRewards.RedeemPointsForProfileCustomizationUpgrade"
+):
     customization_type: int = betterproto.int32_field(1)
     new_level: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class RedeemPointsForProfileCustomizationUpgradeResponse(betterproto.Message):
+class RedeemPointsForProfileCustomizationUpgradeResponse(
+    UnifiedMessage, um_name="LoyaltyRewards.RedeemPointsForProfileCustomizationUpgrade"
+):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class RegisterForSteamDeckRewardsRequest(betterproto.Message):
+class RegisterForSteamDeckRewardsRequest(UnifiedMessage, um_name="LoyaltyRewards.RegisterForSteamDeckRewards"):
     serial_number: str = betterproto.string_field(1)
     controller_code: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class RegisterForSteamDeckRewardsResponse(betterproto.Message):
+class RegisterForSteamDeckRewardsResponse(UnifiedMessage, um_name="LoyaltyRewards.RegisterForSteamDeckRewards"):
     granted_profile_modifier: bool = betterproto.bool_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class PurchaseBonus(betterproto.Message):
     bonusid: int = betterproto.uint64_field(1)
     appid: int = betterproto.uint32_field(2)
```

### Comparing `steamio-0.9.9/steam/protobufs/parental.py` & `steamio-1.0.0a0/steam/protobufs/parental.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,150 +1,131 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_parental.steamclient.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .msg import UnifiedMessage
+
 
 @dataclass(eq=False, repr=False)
 class ParentalApp(betterproto.Message):
     appid: int = betterproto.uint32_field(1)
     is_allowed: bool = betterproto.bool_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class ParentalSettings(betterproto.Message):
     steamid: int = betterproto.fixed64_field(1)
     applist_base_id: int = betterproto.uint32_field(2)
     applist_base_description: str = betterproto.string_field(3)
-    applist_base: List["ParentalApp"] = betterproto.message_field(4)
-    applist_custom: List["ParentalApp"] = betterproto.message_field(5)
+    applist_base: "list[ParentalApp]" = betterproto.message_field(4)
+    applist_custom: "list[ParentalApp]" = betterproto.message_field(5)
     passwordhashtype: int = betterproto.uint32_field(6)
     salt: bytes = betterproto.bytes_field(7)
     passwordhash: bytes = betterproto.bytes_field(8)
     is_enabled: bool = betterproto.bool_field(9)
     enabled_features: int = betterproto.uint32_field(10)
     recovery_email: str = betterproto.string_field(11)
     is_site_license_lock: bool = betterproto.bool_field(12)
 
 
-@dataclass(eq=False, repr=False)
-class EnableParentalSettingsRequest(betterproto.Message):
+class EnableParentalSettingsRequest(UnifiedMessage, um_name="Parental.EnableParentalSettings"):
     password: str = betterproto.string_field(1)
     settings: "ParentalSettings" = betterproto.message_field(2)
     sessionid: str = betterproto.string_field(3)
     enablecode: int = betterproto.uint32_field(4)
     steamid: int = betterproto.fixed64_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class EnableParentalSettingsResponse(betterproto.Message):
+class EnableParentalSettingsResponse(UnifiedMessage, um_name="Parental.EnableParentalSettings"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class DisableParentalSettingsRequest(betterproto.Message):
+class DisableParentalSettingsRequest(UnifiedMessage, um_name="Parental.DisableParentalSettings"):
     password: str = betterproto.string_field(1)
     steamid: int = betterproto.fixed64_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class DisableParentalSettingsResponse(betterproto.Message):
+class DisableParentalSettingsResponse(UnifiedMessage, um_name="Parental.DisableParentalSettings"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetParentalSettingsRequest(betterproto.Message):
+class GetParentalSettingsRequest(UnifiedMessage, um_name="Parental.GetParentalSettings"):
     steamid: int = betterproto.fixed64_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class GetParentalSettingsResponse(betterproto.Message):
+class GetParentalSettingsResponse(UnifiedMessage, um_name="Parental.GetParentalSettings"):
     settings: "ParentalSettings" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetSignedParentalSettingsRequest(betterproto.Message):
+class GetSignedParentalSettingsRequest(UnifiedMessage, um_name="Parental.GetSignedParentalSettings"):
     priority: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetSignedParentalSettingsResponse(betterproto.Message):
+class GetSignedParentalSettingsResponse(UnifiedMessage, um_name="Parental.GetSignedParentalSettings"):
     serialized_settings: bytes = betterproto.bytes_field(1)
     signature: bytes = betterproto.bytes_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetParentalSettingsRequest(betterproto.Message):
+class SetParentalSettingsRequest(UnifiedMessage, um_name="Parental.SetParentalSettings"):
     password: str = betterproto.string_field(1)
     settings: "ParentalSettings" = betterproto.message_field(2)
     new_password: str = betterproto.string_field(3)
     sessionid: str = betterproto.string_field(4)
     steamid: int = betterproto.fixed64_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class SetParentalSettingsResponse(betterproto.Message):
+class SetParentalSettingsResponse(UnifiedMessage, um_name="Parental.SetParentalSettings"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class ValidateTokenRequest(betterproto.Message):
+class ValidateTokenRequest(UnifiedMessage, um_name="Parental.ValidateToken"):
     unlock_token: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class ValidateTokenResponse(betterproto.Message):
+class ValidateTokenResponse(UnifiedMessage, um_name="Parental.ValidateToken"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class ValidatePasswordRequest(betterproto.Message):
+class ValidatePasswordRequest(UnifiedMessage, um_name="Parental.ValidatePassword"):
     password: str = betterproto.string_field(1)
     session: str = betterproto.string_field(2)
     send_unlock_on_success: bool = betterproto.bool_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class ValidatePasswordResponse(betterproto.Message):
+class ValidatePasswordResponse(UnifiedMessage, um_name="Parental.ValidatePassword"):
     token: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class LockClientRequest(betterproto.Message):
+class LockClientRequest(UnifiedMessage, um_name="Parental.LockClient"):
     session: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class LockClientResponse(betterproto.Message):
+class LockClientResponse(UnifiedMessage, um_name="Parental.LockClient"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class RequestRecoveryCodeRequest(betterproto.Message):
+class RequestRecoveryCodeRequest(UnifiedMessage, um_name="Parental.RequestRecoveryCode"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class RequestRecoveryCodeResponse(betterproto.Message):
+class RequestRecoveryCodeResponse(UnifiedMessage, um_name="Parental.RequestRecoveryCode"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class DisableWithRecoveryCodeRequest(betterproto.Message):
+class DisableWithRecoveryCodeRequest(UnifiedMessage, um_name="Parental.DisableWithRecoveryCode"):
     recovery_code: int = betterproto.uint32_field(1)
     steamid: int = betterproto.fixed64_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class DisableWithRecoveryCodeResponse(betterproto.Message):
+class DisableWithRecoveryCodeResponse(UnifiedMessage, um_name="Parental.DisableWithRecoveryCode"):
     pass
 
 
 @dataclass(eq=False, repr=False)
 class ParentalSettingsChangeNotification(betterproto.Message):
     serialized_settings: bytes = betterproto.bytes_field(1)
     signature: bytes = betterproto.bytes_field(2)
```

### Comparing `steamio-0.9.9/steam/protobufs/player.py` & `steamio-1.0.0a0/steam/protobufs/player.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_parental.steamclient.proto
 # plugin: python-betterproto
 # Last updated 10/08/2022
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .msg import UnifiedMessage
+
 
 class EProfileCustomizationType(betterproto.Enum):
     Invalid = 0
     RareAchievementShowcase = 1
     GameCollector = 2
     ItemShowcase = 3
     TradeShowcase = 4
@@ -71,44 +72,40 @@
 class ETextFilterSetting(betterproto.Enum):
     SteamLabOptedOut = 0
     Enabled = 1
     EnabledAllowProfanity = 2
     Disabled = 3
 
 
-@dataclass(eq=False, repr=False)
-class GetMutualFriendsForIncomingInvitesRequest(betterproto.Message):
+class GetMutualFriendsForIncomingInvitesRequest(UnifiedMessage, um_name="Player.GetMutualFriendsForIncomingInvites"):
     pass
 
 
 @dataclass(eq=False, repr=False)
 class IncomingInviteMutualFriendList(betterproto.Message):
     steamid: int = betterproto.fixed64_field(1)
-    mutual_friend_account_ids: List[int] = betterproto.uint32_field(2)
+    mutual_friend_account_ids: list[int] = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetMutualFriendsForIncomingInvitesResponse(betterproto.Message):
-    incoming_invite_mutual_friends_lists: List["IncomingInviteMutualFriendList"] = betterproto.message_field(1)
+class GetMutualFriendsForIncomingInvitesResponse(UnifiedMessage, um_name="Player.GetMutualFriendsForIncomingInvites"):
+    incoming_invite_mutual_friends_lists: "list[IncomingInviteMutualFriendList]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetOwnedGamesRequest(betterproto.Message):
+class GetOwnedGamesRequest(UnifiedMessage, um_name="Player.GetOwnedGames"):
     steamid: int = betterproto.uint64_field(1)
     include_appinfo: bool = betterproto.bool_field(2)
     include_played_free_games: bool = betterproto.bool_field(3)
-    appids_filter: List[int] = betterproto.uint32_field(4)
+    appids_filter: list[int] = betterproto.uint32_field(4)
     include_free_sub: bool = betterproto.bool_field(5)
     skip_unvetted_apps: bool = betterproto.bool_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class GetOwnedGamesResponse(betterproto.Message):
+class GetOwnedGamesResponse(UnifiedMessage, um_name="Player.GetOwnedGames"):
     game_count: int = betterproto.uint32_field(1)
-    games: List["GetOwnedGamesResponseGame"] = betterproto.message_field(2)
+    games: "list[GetOwnedGamesResponseGame]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class GetOwnedGamesResponseGame(betterproto.Message):
     appid: int = betterproto.int32_field(1)
     name: str = betterproto.string_field(2)
     playtime_2_weeks: int = betterproto.int32_field(3)
@@ -119,39 +116,35 @@
     playtime_mac_forever: int = betterproto.int32_field(9)
     playtime_linux_forever: int = betterproto.int32_field(10)
     rtime_last_played: int = betterproto.uint32_field(11)
     capsule_filename: str = betterproto.string_field(12)
     sort_as: str = betterproto.string_field(13)
 
 
-@dataclass(eq=False, repr=False)
-class GetPlayNextRequest(betterproto.Message):
+class GetPlayNextRequest(UnifiedMessage, um_name="Player.GetPlayNext"):
     max_age_seconds: int = betterproto.uint32_field(1)
-    ignore_appids: List[int] = betterproto.uint32_field(2)
+    ignore_appids: list[int] = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetPlayNextResponse(betterproto.Message):
+class GetPlayNextResponse(UnifiedMessage, um_name="Player.GetPlayNext"):
     last_update_time: int = betterproto.uint32_field(1)
-    appids: List[int] = betterproto.uint32_field(2)
+    appids: list[int] = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetFriendsGameplayInfoRequest(betterproto.Message):
+class GetFriendsGameplayInfoRequest(UnifiedMessage, um_name="Player.GetFriendsGameplayInfo"):
     appid: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetFriendsGameplayInfoResponse(betterproto.Message):
+class GetFriendsGameplayInfoResponse(UnifiedMessage, um_name="Player.GetFriendsGameplayInfo"):
     your_info: "GetFriendsGameplayInfoResponseOwnGameplayInfo" = betterproto.message_field(1)
-    in_game: List["GetFriendsGameplayInfoResponseFriendsGameplayInfo"] = betterproto.message_field(2)
-    played_recently: List["GetFriendsGameplayInfoResponseFriendsGameplayInfo"] = betterproto.message_field(3)
-    played_ever: List["GetFriendsGameplayInfoResponseFriendsGameplayInfo"] = betterproto.message_field(4)
-    owns: List["GetFriendsGameplayInfoResponseFriendsGameplayInfo"] = betterproto.message_field(5)
-    in_wishlist: List["GetFriendsGameplayInfoResponseFriendsGameplayInfo"] = betterproto.message_field(6)
+    in_game: "list[GetFriendsGameplayInfoResponseFriendsGameplayInfo]" = betterproto.message_field(2)
+    played_recently: "list[GetFriendsGameplayInfoResponseFriendsGameplayInfo]" = betterproto.message_field(3)
+    played_ever: "list[GetFriendsGameplayInfoResponseFriendsGameplayInfo]" = betterproto.message_field(4)
+    owns: "list[GetFriendsGameplayInfoResponseFriendsGameplayInfo]" = betterproto.message_field(5)
+    in_wishlist: "list[GetFriendsGameplayInfoResponseFriendsGameplayInfo]" = betterproto.message_field(6)
 
 
 @dataclass(eq=False, repr=False)
 class GetFriendsGameplayInfoResponseFriendsGameplayInfo(betterproto.Message):
     steamid: int = betterproto.fixed64_field(1)
     minutes_played: int = betterproto.uint32_field(2)
     minutes_played_forever: int = betterproto.uint32_field(3)
@@ -162,30 +155,28 @@
     steamid: int = betterproto.fixed64_field(1)
     minutes_played: int = betterproto.uint32_field(2)
     minutes_played_forever: int = betterproto.uint32_field(3)
     in_wishlist: bool = betterproto.bool_field(4)
     owned: bool = betterproto.bool_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class GetFriendsAppsActivityRequest(betterproto.Message):
+class GetFriendsAppsActivityRequest(UnifiedMessage, um_name="Player.GetFriendsAppsActivity"):
     news_language: str = betterproto.string_field(1)
     request_flags: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetFriendsAppsActivityResponse(betterproto.Message):
-    trending: List["GetFriendsAppsActivityResponseAppFriendsInfo"] = betterproto.message_field(1)
-    recent_purchases: List["GetFriendsAppsActivityResponseAppFriendsInfo"] = betterproto.message_field(2)
-    unowned: List["GetFriendsAppsActivityResponseAppFriendsInfo"] = betterproto.message_field(3)
-    popular: List["GetFriendsAppsActivityResponseAppFriendsInfo"] = betterproto.message_field(4)
-    dont_forget: List["GetFriendsAppsActivityResponseAppFriendsInfo"] = betterproto.message_field(5)
-    being_discussed: List["GetFriendsAppsActivityResponseAppFriendsInfo"] = betterproto.message_field(6)
-    new_to_group: List["GetFriendsAppsActivityResponseAppFriendsInfo"] = betterproto.message_field(7)
-    returned_to_group: List["GetFriendsAppsActivityResponseAppFriendsInfo"] = betterproto.message_field(8)
+class GetFriendsAppsActivityResponse(UnifiedMessage, um_name="Player.GetFriendsAppsActivity"):
+    trending: "list[GetFriendsAppsActivityResponseAppFriendsInfo]" = betterproto.message_field(1)
+    recent_purchases: "list[GetFriendsAppsActivityResponseAppFriendsInfo]" = betterproto.message_field(2)
+    unowned: "list[GetFriendsAppsActivityResponseAppFriendsInfo]" = betterproto.message_field(3)
+    popular: "list[GetFriendsAppsActivityResponseAppFriendsInfo]" = betterproto.message_field(4)
+    dont_forget: "list[GetFriendsAppsActivityResponseAppFriendsInfo]" = betterproto.message_field(5)
+    being_discussed: "list[GetFriendsAppsActivityResponseAppFriendsInfo]" = betterproto.message_field(6)
+    new_to_group: "list[GetFriendsAppsActivityResponseAppFriendsInfo]" = betterproto.message_field(7)
+    returned_to_group: "list[GetFriendsAppsActivityResponseAppFriendsInfo]" = betterproto.message_field(8)
     active_friend_count: int = betterproto.uint32_field(9)
 
 
 @dataclass(eq=False, repr=False)
 class GetFriendsAppsActivityResponseFriendPlayTime(betterproto.Message):
     steamid: int = betterproto.fixed64_field(1)
     minutes_played_this_week: int = betterproto.uint32_field(2)
@@ -193,38 +184,35 @@
     minutes_played_forever: int = betterproto.uint32_field(4)
     event_count: int = betterproto.uint32_field(5)
 
 
 @dataclass(eq=False, repr=False)
 class GetFriendsAppsActivityResponseAppFriendsInfo(betterproto.Message):
     appid: int = betterproto.uint32_field(1)
-    friends: List["GetFriendsAppsActivityResponseFriendPlayTime"] = betterproto.message_field(2)
+    friends: "list[GetFriendsAppsActivityResponseFriendPlayTime]" = betterproto.message_field(2)
     display_order: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetGameBadgeLevelsRequest(betterproto.Message):
+class GetGameBadgeLevelsRequest(UnifiedMessage, um_name="Player.GetGameBadgeLevels"):
     appid: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetGameBadgeLevelsResponse(betterproto.Message):
+class GetGameBadgeLevelsResponse(UnifiedMessage, um_name="Player.GetGameBadgeLevels"):
     player_level: int = betterproto.uint32_field(1)
-    badges: List["GetGameBadgeLevelsResponseBadge"] = betterproto.message_field(2)
+    badges: "list[GetGameBadgeLevelsResponseBadge]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class GetGameBadgeLevelsResponseBadge(betterproto.Message):
     level: int = betterproto.int32_field(1)
     series: int = betterproto.int32_field(2)
     border_color: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileBackgroundRequest(betterproto.Message):
+class GetProfileBackgroundRequest(UnifiedMessage, um_name="Player.GetProfileBackground"):
     steamid: int = betterproto.fixed64_field(1)
     language: str = betterproto.string_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class ProfileItem(betterproto.Message):
     communityitemid: int = betterproto.uint64_field(1)
@@ -239,203 +227,173 @@
     movie_webm: str = betterproto.string_field(10)
     movie_mp4: str = betterproto.string_field(11)
     movie_webm_small: str = betterproto.string_field(13)
     movie_mp4_small: str = betterproto.string_field(14)
     equipped_flags: int = betterproto.uint32_field(12)
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileBackgroundResponse(betterproto.Message):
+class GetProfileBackgroundResponse(UnifiedMessage, um_name="Player.GetProfileBackground"):
     profile_background: "ProfileItem" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetProfileBackgroundRequest(betterproto.Message):
+class SetProfileBackgroundRequest(UnifiedMessage, um_name="Player.SetProfileBackground"):
     communityitemid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetProfileBackgroundResponse(betterproto.Message):
+class SetProfileBackgroundResponse(UnifiedMessage, um_name="Player.SetProfileBackground"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetMiniProfileBackgroundRequest(betterproto.Message):
+class GetMiniProfileBackgroundRequest(UnifiedMessage, um_name="Player.GetMiniProfileBackground"):
     steamid: int = betterproto.fixed64_field(1)
     language: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetMiniProfileBackgroundResponse(betterproto.Message):
+class GetMiniProfileBackgroundResponse(UnifiedMessage, um_name="Player.GetMiniProfileBackground"):
     profile_background: "ProfileItem" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetMiniProfileBackgroundRequest(betterproto.Message):
+class SetMiniProfileBackgroundRequest(UnifiedMessage, um_name="Player.SetMiniProfileBackground"):
     communityitemid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetMiniProfileBackgroundResponse(betterproto.Message):
+class SetMiniProfileBackgroundResponse(UnifiedMessage, um_name="Player.SetMiniProfileBackground"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetAvatarFrameRequest(betterproto.Message):
+class GetAvatarFrameRequest(UnifiedMessage, um_name="Player.GetAvatarFrame"):
     steamid: int = betterproto.fixed64_field(1)
     language: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetAvatarFrameResponse(betterproto.Message):
+class GetAvatarFrameResponse(UnifiedMessage, um_name="Player.GetAvatarFrame"):
     avatar_frame: "ProfileItem" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetAvatarFrameRequest(betterproto.Message):
+class SetAvatarFrameRequest(UnifiedMessage, um_name="Player.SetAvatarFrame"):
     communityitemid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetAvatarFrameResponse(betterproto.Message):
+class SetAvatarFrameResponse(UnifiedMessage, um_name="Player.SetAvatarFrame"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetAnimatedAvatarRequest(betterproto.Message):
+class GetAnimatedAvatarRequest(UnifiedMessage, um_name="Player.GetAnimatedAvatar"):
     steamid: int = betterproto.fixed64_field(1)
     language: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetAnimatedAvatarResponse(betterproto.Message):
+class GetAnimatedAvatarResponse(UnifiedMessage, um_name="Player.GetAnimatedAvatar"):
     avatar: "ProfileItem" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetAnimatedAvatarRequest(betterproto.Message):
+class SetAnimatedAvatarRequest(UnifiedMessage, um_name="Player.SetAnimatedAvatar"):
     communityitemid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetAnimatedAvatarResponse(betterproto.Message):
+class SetAnimatedAvatarResponse(UnifiedMessage, um_name="Player.SetAnimatedAvatar"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileItemsOwnedRequest(betterproto.Message):
+class GetProfileItemsOwnedRequest(UnifiedMessage, um_name="Player.GetProfileItemsOwned"):
     language: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileItemsOwnedResponse(betterproto.Message):
-    profile_backgrounds: List["ProfileItem"] = betterproto.message_field(1)
-    mini_profile_backgrounds: List["ProfileItem"] = betterproto.message_field(2)
-    avatar_frames: List["ProfileItem"] = betterproto.message_field(3)
-    animated_avatars: List["ProfileItem"] = betterproto.message_field(4)
-    profile_modifiers: List["ProfileItem"] = betterproto.message_field(5)
+class GetProfileItemsOwnedResponse(UnifiedMessage, um_name="Player.GetProfileItemsOwned"):
+    profile_backgrounds: "list[ProfileItem]" = betterproto.message_field(1)
+    mini_profile_backgrounds: "list[ProfileItem]" = betterproto.message_field(2)
+    avatar_frames: "list[ProfileItem]" = betterproto.message_field(3)
+    animated_avatars: "list[ProfileItem]" = betterproto.message_field(4)
+    profile_modifiers: "list[ProfileItem]" = betterproto.message_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileItemsEquippedRequest(betterproto.Message):
+class GetProfileItemsEquippedRequest(UnifiedMessage, um_name="Player.GetProfileItemsEquipped"):
     steamid: int = betterproto.fixed64_field(1)
     language: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileItemsEquippedResponse(betterproto.Message):
+class GetProfileItemsEquippedResponse(UnifiedMessage, um_name="Player.GetProfileItemsEquipped"):
     profile_background: "ProfileItem" = betterproto.message_field(1)
     mini_profile_background: "ProfileItem" = betterproto.message_field(2)
     avatar_frame: "ProfileItem" = betterproto.message_field(3)
     animated_avatar: "ProfileItem" = betterproto.message_field(4)
     profile_modifier: "ProfileItem" = betterproto.message_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class SetEquippedProfileItemFlagsRequest(betterproto.Message):
+class SetEquippedProfileItemFlagsRequest(UnifiedMessage, um_name="Player.SetEquippedProfileItemFlags"):
     communityitemid: int = betterproto.uint64_field(1)
     flags: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetEquippedProfileItemFlagsResponse(betterproto.Message):
+class SetEquippedProfileItemFlagsResponse(UnifiedMessage, um_name="Player.SetEquippedProfileItemFlags"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetEmoticonListRequest(betterproto.Message):
+class GetEmoticonListRequest(UnifiedMessage, um_name="Player.GetEmoticonList"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetEmoticonListResponse(betterproto.Message):
-    emoticons: List["GetEmoticonListResponseEmoticon"] = betterproto.message_field(1)
+class GetEmoticonListResponse(UnifiedMessage, um_name="Player.GetEmoticonList"):
+    emoticons: "list[GetEmoticonListResponseEmoticon]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetEmoticonListResponseEmoticon(betterproto.Message):
     name: str = betterproto.string_field(1)
     count: int = betterproto.int32_field(2)
     time_last_used: int = betterproto.uint32_field(3)
     use_count: int = betterproto.uint32_field(4)
     time_received: int = betterproto.uint32_field(5)
     appid: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class GetAchievementsProgressRequest(betterproto.Message):
+class GetAchievementsProgressRequest(UnifiedMessage, um_name="Player.GetAchievementsProgress"):
     steamid: int = betterproto.uint64_field(1)
     language: str = betterproto.string_field(2)
-    appids: List[int] = betterproto.uint32_field(3)
+    appids: list[int] = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetAchievementsProgressResponse(betterproto.Message):
-    achievement_progress: List["GetAchievementsProgressResponseAchievementProgress"] = betterproto.message_field(1)
+class GetAchievementsProgressResponse(UnifiedMessage, um_name="Player.GetAchievementsProgress"):
+    achievement_progress: "list[GetAchievementsProgressResponseAchievementProgress]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetAchievementsProgressResponseAchievementProgress(betterproto.Message):
     appid: int = betterproto.uint32_field(1)
     unlocked: int = betterproto.uint32_field(2)
     total: int = betterproto.uint32_field(3)
     percentage: float = betterproto.float_field(4)
     all_unlocked: bool = betterproto.bool_field(5)
     cache_time: int = betterproto.uint32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class GetFavoriteBadgeRequest(betterproto.Message):
+class GetFavoriteBadgeRequest(UnifiedMessage, um_name="Player.GetFavoriteBadge"):
     steamid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetFavoriteBadgeResponse(betterproto.Message):
+class GetFavoriteBadgeResponse(UnifiedMessage, um_name="Player.GetFavoriteBadge"):
     has_favorite_badge: bool = betterproto.bool_field(1)
     badgeid: int = betterproto.uint32_field(2)
     communityitemid: int = betterproto.uint64_field(3)
     item_type: int = betterproto.uint32_field(4)
     border_color: int = betterproto.uint32_field(5)
     appid: int = betterproto.uint32_field(6)
     level: int = betterproto.uint32_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class SetFavoriteBadgeRequest(betterproto.Message):
+class SetFavoriteBadgeRequest(UnifiedMessage, um_name="Player.SetFavoriteBadge"):
     communityitemid: int = betterproto.uint64_field(1)
     badgeid: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetFavoriteBadgeResponse(betterproto.Message):
+class SetFavoriteBadgeResponse(UnifiedMessage, um_name="Player.SetFavoriteBadge"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileCustomizationRequest(betterproto.Message):
+class GetProfileCustomizationRequest(UnifiedMessage, um_name="Player.GetProfileCustomization"):
     steamid: int = betterproto.fixed64_field(1)
     include_inactive_customizations: bool = betterproto.bool_field(2)
     include_purchased_customizations: bool = betterproto.bool_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class ProfileCustomizationSlot(betterproto.Message):
@@ -454,15 +412,15 @@
     ban_check_result: "EBanContentCheckResult" = betterproto.enum_field(13)
 
 
 @dataclass(eq=False, repr=False)
 class ProfileCustomization(betterproto.Message):
     customization_type: "EProfileCustomizationType" = betterproto.enum_field(1)
     large: bool = betterproto.bool_field(2)
-    slots: List["ProfileCustomizationSlot"] = betterproto.message_field(3)
+    slots: "list[ProfileCustomizationSlot]" = betterproto.message_field(3)
     active: bool = betterproto.bool_field(4)
     customization_style: "EProfileCustomizationStyle" = betterproto.enum_field(5)
     purchaseid: int = betterproto.uint64_field(6)
     level: int = betterproto.uint32_field(7)
 
 
 @dataclass(eq=False, repr=False)
@@ -472,61 +430,60 @@
 
 
 @dataclass(eq=False, repr=False)
 class ProfilePreferences(betterproto.Message):
     hide_profile_awards: bool = betterproto.bool_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileCustomizationResponse(betterproto.Message):
-    customizations: List["ProfileCustomization"] = betterproto.message_field(1)
+class GetProfileCustomizationResponse(UnifiedMessage, um_name="Player.GetProfileCustomization"):
+    customizations: "list[ProfileCustomization]" = betterproto.message_field(1)
     slots_available: int = betterproto.uint32_field(2)
     profile_theme: "ProfileTheme" = betterproto.message_field(3)
-    purchased_customizations: List["GetProfileCustomizationResponsePurchasedCustomization"] = betterproto.message_field(
+    purchased_customizations: "list[GetProfileCustomizationResponsePurchasedCustomization]" = betterproto.message_field(
         4
     )
     profile_preferences: "ProfilePreferences" = betterproto.message_field(5)
 
 
 @dataclass(eq=False, repr=False)
 class GetProfileCustomizationResponsePurchasedCustomization(betterproto.Message):
     purchaseid: int = betterproto.uint64_field(1)
     customization_type: "EProfileCustomizationType" = betterproto.enum_field(2)
     level: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetPurchasedProfileCustomizationsRequest(betterproto.Message):
+class GetPurchasedProfileCustomizationsRequest(UnifiedMessage, um_name="Player.GetPurchasedProfileCustomizations"):
     steamid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetPurchasedProfileCustomizationsResponse(betterproto.Message):
-    purchased_customizations: List[
+class GetPurchasedProfileCustomizationsResponse(UnifiedMessage, um_name="Player.GetPurchasedProfileCustomizations"):
+    purchased_customizations: list[
         "GetPurchasedProfileCustomizationsResponsePurchasedCustomization"
     ] = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetPurchasedProfileCustomizationsResponsePurchasedCustomization(betterproto.Message):
     purchaseid: int = betterproto.uint64_field(1)
     customization_type: "EProfileCustomizationType" = betterproto.enum_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetPurchasedAndUpgradedProfileCustomizationsRequest(betterproto.Message):
+class GetPurchasedAndUpgradedProfileCustomizationsRequest(
+    UnifiedMessage, um_name="Player.GetPurchasedAndUpgradedProfileCustomizations"
+):
     steamid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetPurchasedAndUpgradedProfileCustomizationsResponse(betterproto.Message):
-    purchased_customizations: List[
+class GetPurchasedAndUpgradedProfileCustomizationsResponse(
+    UnifiedMessage, um_name="Player.GetPurchasedAndUpgradedProfileCustomizations"
+):
+    purchased_customizations: list[
         "GetPurchasedAndUpgradedProfileCustomizationsResponsePurchasedCustomization"
     ] = betterproto.message_field(1)
-    upgraded_customizations: List[
+    upgraded_customizations: list[
         "GetPurchasedAndUpgradedProfileCustomizationsResponseUpgradedCustomization"
     ] = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class GetPurchasedAndUpgradedProfileCustomizationsResponsePurchasedCustomization(betterproto.Message):
     customization_type: "EProfileCustomizationType" = betterproto.enum_field(1)
@@ -535,88 +492,74 @@
 
 @dataclass(eq=False, repr=False)
 class GetPurchasedAndUpgradedProfileCustomizationsResponseUpgradedCustomization(betterproto.Message):
     customization_type: "EProfileCustomizationType" = betterproto.enum_field(1)
     level: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileThemesAvailableRequest(betterproto.Message):
+class GetProfileThemesAvailableRequest(UnifiedMessage, um_name="Player.GetProfileThemesAvailable"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetProfileThemesAvailableResponse(betterproto.Message):
-    profile_themes: List["ProfileTheme"] = betterproto.message_field(1)
+class GetProfileThemesAvailableResponse(UnifiedMessage, um_name="Player.GetProfileThemesAvailable"):
+    profile_themes: "list[ProfileTheme]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetProfileThemeRequest(betterproto.Message):
+class SetProfileThemeRequest(UnifiedMessage, um_name="Player.SetProfileTheme"):
     theme_id: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetProfileThemeResponse(betterproto.Message):
+class SetProfileThemeResponse(UnifiedMessage, um_name="Player.SetProfileTheme"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class SetProfilePreferencesRequest(betterproto.Message):
+class SetProfilePreferencesRequest(UnifiedMessage, um_name="Player.SetProfilePreferences"):
     profile_preferences: "ProfilePreferences" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetProfilePreferencesResponse(betterproto.Message):
+class SetProfilePreferencesResponse(UnifiedMessage, um_name="Player.SetProfilePreferences"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class PostStatusToFriendsRequest(betterproto.Message):
+class PostStatusToFriendsRequest(UnifiedMessage, um_name="Player.PostStatusToFriends"):
     appid: int = betterproto.uint32_field(1)
     status_text: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class PostStatusToFriendsResponse(betterproto.Message):
+class PostStatusToFriendsResponse(UnifiedMessage, um_name="Player.PostStatusToFriends"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetPostedStatusRequest(betterproto.Message):
+class GetPostedStatusRequest(UnifiedMessage, um_name="Player.GetPostedStatus"):
     steamid: int = betterproto.uint64_field(1)
     postid: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetPostedStatusResponse(betterproto.Message):
+class GetPostedStatusResponse(UnifiedMessage, um_name="Player.GetPostedStatus"):
     accountid: int = betterproto.uint32_field(1)
     postid: int = betterproto.uint64_field(2)
     status_text: str = betterproto.string_field(3)
     deleted: bool = betterproto.bool_field(4)
     appid: int = betterproto.uint32_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class DeletePostedStatusRequest(betterproto.Message):
+class DeletePostedStatusRequest(UnifiedMessage, um_name="Player.DeletePostedStatus"):
     postid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class DeletePostedStatusResponse(betterproto.Message):
+class DeletePostedStatusResponse(UnifiedMessage, um_name="Player.DeletePostedStatus"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetLastPlayedTimesRequest(betterproto.Message):
+class GetLastPlayedTimesRequest(UnifiedMessage, um_name="Player.ClientGetLastPlayedTimes"):
     min_last_played: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetLastPlayedTimesResponse(betterproto.Message):
-    games: List["GetLastPlayedTimesResponseGame"] = betterproto.message_field(1)
+class GetLastPlayedTimesResponse(UnifiedMessage, um_name="Player.ClientGetLastPlayedTimes"):
+    games: "list[GetLastPlayedTimesResponseGame]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetLastPlayedTimesResponseGame(betterproto.Message):
     appid: int = betterproto.int32_field(1)
     last_playtime: int = betterproto.uint32_field(2)
     playtime_2_weeks: int = betterproto.int32_field(3)
@@ -629,43 +572,38 @@
     first_mac_playtime: int = betterproto.uint32_field(10)
     first_linux_playtime: int = betterproto.uint32_field(11)
     last_windows_playtime: int = betterproto.uint32_field(12)
     last_mac_playtime: int = betterproto.uint32_field(13)
     last_linux_playtime: int = betterproto.uint32_field(14)
 
 
-@dataclass(eq=False, repr=False)
-class AcceptSsaRequest(betterproto.Message):
+class AcceptSsaRequest(UnifiedMessage, um_name="Player.AcceptSSA"):
     agreement_type: "EAgreementType" = betterproto.enum_field(1)
     time_signed_utc: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class AcceptSsaResponse(betterproto.Message):
+class AcceptSsaResponse(UnifiedMessage, um_name="Player.AcceptSSA"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetNicknameListRequest(betterproto.Message):
+class GetNicknameListRequest(UnifiedMessage, um_name="Player.GetNicknameList"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetNicknameListResponse(betterproto.Message):
-    nicknames: List["GetNicknameListResponsePlayerNickname"] = betterproto.message_field(1)
+class GetNicknameListResponse(UnifiedMessage, um_name="Player.GetNicknameList"):
+    nicknames: "list[GetNicknameListResponsePlayerNickname]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetNicknameListResponsePlayerNickname(betterproto.Message):
     accountid: int = betterproto.fixed32_field(1)
     nickname: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetPerFriendPreferencesRequest(betterproto.Message):
+class GetPerFriendPreferencesRequest(UnifiedMessage, um_name="Player.GetPerFriendPreferences"):
     pass
 
 
 @dataclass(eq=False, repr=False)
 class PerFriendPreferences(betterproto.Message):
     accountid: int = betterproto.fixed32_field(1)
     nickname: str = betterproto.string_field(2)
@@ -674,173 +612,150 @@
     notifications_showmessages: "ENotificationSetting" = betterproto.enum_field(5)
     sounds_showingame: "ENotificationSetting" = betterproto.enum_field(6)
     sounds_showonline: "ENotificationSetting" = betterproto.enum_field(7)
     sounds_showmessages: "ENotificationSetting" = betterproto.enum_field(8)
     notifications_sendmobile: "ENotificationSetting" = betterproto.enum_field(9)
 
 
-@dataclass(eq=False, repr=False)
-class GetPerFriendPreferencesResponse(betterproto.Message):
-    preferences: List["PerFriendPreferences"] = betterproto.message_field(1)
+class GetPerFriendPreferencesResponse(UnifiedMessage, um_name="Player.GetPerFriendPreferences"):
+    preferences: "list[PerFriendPreferences]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetPerFriendPreferencesRequest(betterproto.Message):
+class SetPerFriendPreferencesRequest(UnifiedMessage, um_name="Player.SetPerFriendPreferences"):
     preferences: "PerFriendPreferences" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetPerFriendPreferencesResponse(betterproto.Message):
+class SetPerFriendPreferencesResponse(UnifiedMessage, um_name="Player.SetPerFriendPreferences"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class AddFriendRequest(betterproto.Message):
+class AddFriendRequest(UnifiedMessage, um_name="Player.AddFriend"):
     steamid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class AddFriendResponse(betterproto.Message):
+class AddFriendResponse(UnifiedMessage, um_name="Player.AddFriend"):
     invite_sent: bool = betterproto.bool_field(1)
     friend_relationship: int = betterproto.uint32_field(2)
-    result: int = betterproto.int32_field(3)
+    eresult: int = betterproto.int32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class RemoveFriendRequest(betterproto.Message):
+class RemoveFriendRequest(UnifiedMessage, um_name="Player.RemoveFriend"):
     steamid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class RemoveFriendResponse(betterproto.Message):
+class RemoveFriendResponse(UnifiedMessage, um_name="Player.RemoveFriend"):
     friend_relationship: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class IgnoreFriendRequest(betterproto.Message):
+class IgnoreFriendRequest(UnifiedMessage, um_name="Player.IgnoreFriend"):
     steamid: int = betterproto.fixed64_field(1)
     unignore: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class IgnoreFriendResponse(betterproto.Message):
+class IgnoreFriendResponse(UnifiedMessage, um_name="Player.IgnoreFriend"):
     friend_relationship: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetCommunityPreferencesRequest(betterproto.Message):
+class GetCommunityPreferencesRequest(UnifiedMessage, um_name="Player.GetCommunityPreferences"):
     pass
 
 
 @dataclass(eq=False, repr=False)
 class CommunityPreferences(betterproto.Message):
     hide_adult_content_violence: bool = betterproto.bool_field(1)
     hide_adult_content_sex: bool = betterproto.bool_field(2)
     parenthesize_nicknames: bool = betterproto.bool_field(4)
     text_filter_setting: "ETextFilterSetting" = betterproto.enum_field(5)
     text_filter_ignore_friends: bool = betterproto.bool_field(6)
     text_filter_words_revision: int = betterproto.uint32_field(7)
     timestamp_updated: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetCommunityPreferencesResponse(betterproto.Message):
+class GetCommunityPreferencesResponse(UnifiedMessage, um_name="Player.GetCommunityPreferences"):
     preferences: "CommunityPreferences" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetCommunityPreferencesRequest(betterproto.Message):
+class SetCommunityPreferencesRequest(UnifiedMessage, um_name="Player.SetCommunityPreferences"):
     preferences: "CommunityPreferences" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class SetCommunityPreferencesResponse(betterproto.Message):
+class SetCommunityPreferencesResponse(UnifiedMessage, um_name="Player.SetCommunityPreferences"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetTextFilterWordsRequest(betterproto.Message):
+class GetTextFilterWordsRequest(UnifiedMessage, um_name="Player.GetTextFilterWords"):
     pass
 
 
 @dataclass(eq=False, repr=False)
 class TextFilterWords(betterproto.Message):
-    text_filter_custom_banned_words: List[str] = betterproto.string_field(1)
-    text_filter_custom_clean_words: List[str] = betterproto.string_field(2)
+    text_filter_custom_banned_words: list[str] = betterproto.string_field(1)
+    text_filter_custom_clean_words: list[str] = betterproto.string_field(2)
     text_filter_words_revision: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetTextFilterWordsResponse(betterproto.Message):
+class GetTextFilterWordsResponse(UnifiedMessage, um_name="Player.GetTextFilterWords"):
     words: "TextFilterWords" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetNewSteamAnnouncementStateRequest(betterproto.Message):
+class GetNewSteamAnnouncementStateRequest(UnifiedMessage, um_name="Player.GetNewSteamAnnouncementState"):
     language: int = betterproto.int32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetNewSteamAnnouncementStateResponse(betterproto.Message):
+class GetNewSteamAnnouncementStateResponse(UnifiedMessage, um_name="Player.GetNewSteamAnnouncementState"):
     state: int = betterproto.int32_field(1)
     announcement_headline: str = betterproto.string_field(2)
     announcement_url: str = betterproto.string_field(3)
     time_posted: int = betterproto.uint32_field(4)
     announcement_gid: int = betterproto.uint64_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateSteamAnnouncementLastReadRequest(betterproto.Message):
+class UpdateSteamAnnouncementLastReadRequest(UnifiedMessage, um_name="Player.UpdateSteamAnnouncementLastRead"):
     announcement_gid: int = betterproto.uint64_field(1)
     time_posted: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateSteamAnnouncementLastReadResponse(betterproto.Message):
+class UpdateSteamAnnouncementLastReadResponse(UnifiedMessage, um_name="Player.UpdateSteamAnnouncementLastRead"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetPrivacySettingsRequest(betterproto.Message):
+class GetPrivacySettingsRequest(UnifiedMessage, um_name="Player.GetPrivacySettings"):
     pass
 
 
 @dataclass(eq=False, repr=False)
 class CPrivacySettings(betterproto.Message):
     privacy_state: int = betterproto.int32_field(1)
     privacy_state_inventory: int = betterproto.int32_field(2)
     privacy_state_gifts: int = betterproto.int32_field(3)
     privacy_state_ownedgames: int = betterproto.int32_field(4)
     privacy_state_playtime: int = betterproto.int32_field(5)
     privacy_state_friendslist: int = betterproto.int32_field(6)
 
 
-@dataclass(eq=False, repr=False)
-class GetPrivacySettingsResponse(betterproto.Message):
+class GetPrivacySettingsResponse(UnifiedMessage, um_name="Player.GetPrivacySettings"):
     privacy_settings: "CPrivacySettings" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetDurationControlRequest(betterproto.Message):
+class GetDurationControlRequest(UnifiedMessage, um_name="Player.GetDurationControl"):
     appid: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetDurationControlResponse(betterproto.Message):
+class GetDurationControlResponse(UnifiedMessage, um_name="Player.GetDurationControl"):
     is_enabled: bool = betterproto.bool_field(1)
     seconds: int = betterproto.int32_field(2)
     seconds_today: int = betterproto.int32_field(3)
     is_steamchina_account: bool = betterproto.bool_field(4)
     is_age_verified: bool = betterproto.bool_field(5)
     seconds_allowed_today: int = betterproto.uint32_field(6)
 
 
 @dataclass(eq=False, repr=False)
 class LastPlayedTimesNotification(betterproto.Message):
-    games: List["GetLastPlayedTimesResponseGame"] = betterproto.message_field(1)
+    games: "list[GetLastPlayedTimesResponseGame]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class FriendNicknameChangedNotification(betterproto.Message):
     accountid: int = betterproto.fixed32_field(1)
     nickname: str = betterproto.string_field(2)
     is_echo_to_self: bool = betterproto.bool_field(3)
```

### Comparing `steamio-0.9.9/steam/protobufs/published_file.py` & `steamio-1.0.0a0/steam/protobufs/published_file.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_publishedfile.steamclient.proto
 # plugin: python-betterproto
 # Last updated 09/08/2022
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .msg import UnifiedMessage
 from .player import EBanContentCheckResult
 
 
 class EPublishedFileRevision(betterproto.Enum):
     Default = 0
     Latest = 1
     ApprovedSnapshot = 2
@@ -25,90 +25,79 @@
     PendingApproval = 1
     ApprovedForSale = 2
     RejectedForSale = 3
     NoLongerForSale = 4
     TentativeApproval = 5
 
 
-@dataclass(eq=False, repr=False)
-class VoteRequest(betterproto.Message):
+class VoteRequest(UnifiedMessage, um_name="PublishedFile.Vote"):
     publishedfileid: int = betterproto.uint64_field(1)
     vote_up: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class VoteResponse(betterproto.Message):
+class VoteResponse(UnifiedMessage, um_name="PublishedFile.Vote"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class SubscribeRequest(betterproto.Message):
+class SubscribeRequest(UnifiedMessage, um_name="PublishedFile.Subscribe"):
     publishedfileid: int = betterproto.uint64_field(1)
     list_type: int = betterproto.uint32_field(2)
     appid: int = betterproto.int32_field(3)
     notify_client: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class SubscribeResponse(betterproto.Message):
+class SubscribeResponse(UnifiedMessage, um_name="PublishedFile.Subscribe"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class UnsubscribeRequest(betterproto.Message):
+class UnsubscribeRequest(UnifiedMessage, um_name="PublishedFile.Unsubscribe"):
     publishedfileid: int = betterproto.uint64_field(1)
     list_type: int = betterproto.uint32_field(2)
     appid: int = betterproto.int32_field(3)
     notify_client: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class UnsubscribeResponse(betterproto.Message):
+class UnsubscribeResponse(UnifiedMessage, um_name="PublishedFile.Unsubscribe"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class CanSubscribeRequest(betterproto.Message):
+class CanSubscribeRequest(UnifiedMessage, um_name="PublishedFile.CanSubscribe"):
     publishedfileid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CanSubscribeResponse(betterproto.Message):
+class CanSubscribeResponse(UnifiedMessage, um_name="PublishedFile.CanSubscribe"):
     can_subscribe: bool = betterproto.bool_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class PublishRequest(betterproto.Message):
+class PublishRequest(UnifiedMessage, um_name="PublishedFile.Publish"):
     appid: int = betterproto.uint32_field(1)
     consumer_appid: int = betterproto.uint32_field(2)
     cloudfilename: str = betterproto.string_field(3)
     preview_cloudfilename: str = betterproto.string_field(4)
     title: str = betterproto.string_field(5)
     file_description: str = betterproto.string_field(6)
     file_type: int = betterproto.uint32_field(7)
     consumer_shortcut_name: str = betterproto.string_field(8)
     youtube_username: str = betterproto.string_field(9)
     youtube_videoid: str = betterproto.string_field(10)
     visibility: int = betterproto.uint32_field(11)
     redirect_uri: str = betterproto.string_field(12)
-    tags: List[str] = betterproto.string_field(13)
+    tags: list[str] = betterproto.string_field(13)
     collection_type: str = betterproto.string_field(14)
     game_type: str = betterproto.string_field(15)
     url: str = betterproto.string_field(16)
 
 
-@dataclass(eq=False, repr=False)
-class PublishResponse(betterproto.Message):
+class PublishResponse(UnifiedMessage, um_name="PublishedFile.Publish"):
     publishedfileid: int = betterproto.uint64_field(1)
     redirect_uri: str = betterproto.string_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetDetailsRequest(betterproto.Message):
-    publishedfileids: List[int] = betterproto.fixed64_field(1)
+class GetDetailsRequest(UnifiedMessage, um_name="PublishedFile.GetDetails"):
+    publishedfileids: list[int] = betterproto.fixed64_field(1)
     includetags: bool = betterproto.bool_field(2)
     includeadditionalpreviews: bool = betterproto.bool_field(3)
     includechildren: bool = betterproto.bool_field(4)
     includekvtags: bool = betterproto.bool_field(5)
     includevotes: bool = betterproto.bool_field(6)
     short_description: bool = betterproto.bool_field(8)
     includeforsaledata: bool = betterproto.bool_field(10)
@@ -171,30 +160,30 @@
     image_height: int = betterproto.uint32_field(44)
     image_url: str = betterproto.string_field(45)
     spoiler_tag: bool = betterproto.bool_field(46)
     shortcutid: int = betterproto.uint32_field(47)
     shortcutname: str = betterproto.string_field(48)
     num_children: int = betterproto.uint32_field(49)
     num_reports: int = betterproto.uint32_field(50)
-    previews: List["PublishedFileDetailsPreview"] = betterproto.message_field(51)
-    tags: List["PublishedFileDetailsTag"] = betterproto.message_field(52)
-    children: List["PublishedFileDetailsChild"] = betterproto.message_field(53)
-    kvtags: List["PublishedFileDetailsKvTag"] = betterproto.message_field(54)
+    previews: "list[PublishedFileDetailsPreview]" = betterproto.message_field(51)
+    tags: "list[PublishedFileDetailsTag]" = betterproto.message_field(52)
+    children: "list[PublishedFileDetailsChild]" = betterproto.message_field(53)
+    kvtags: "list[PublishedFileDetailsKvTag]" = betterproto.message_field(54)
     vote_data: "PublishedFileDetailsVoteData" = betterproto.message_field(55)
     playtime_stats: "PublishedFileDetailsPlaytimeStats" = betterproto.message_field(64)
     time_subscribed: int = betterproto.uint32_field(56)
     for_sale_data: "PublishedFileDetailsForSaleData" = betterproto.message_field(57)
     metadata: str = betterproto.string_field(58)
     language: int = betterproto.int32_field(61)
     maybe_inappropriate_sex: bool = betterproto.bool_field(65)
     maybe_inappropriate_violence: bool = betterproto.bool_field(66)
     revision_change_number: int = betterproto.uint64_field(67)
     revision: "EPublishedFileRevision" = betterproto.enum_field(68)
-    available_revisions: List["EPublishedFileRevision"] = betterproto.enum_field(69)
-    reactions: List["PublishedFileDetailsReaction"] = betterproto.message_field(70)
+    available_revisions: "list[EPublishedFileRevision]" = betterproto.enum_field(69)
+    reactions: "list[PublishedFileDetailsReaction]" = betterproto.message_field(70)
     ban_text_check_result: EBanContentCheckResult = betterproto.enum_field(71)
 
 
 @dataclass(eq=False, repr=False)
 class PublishedFileDetailsTag(betterproto.Message):
     tag: str = betterproto.string_field(1)
     adminonly: bool = betterproto.bool_field(2)
@@ -251,66 +240,62 @@
 
 @dataclass(eq=False, repr=False)
 class PublishedFileDetailsReaction(betterproto.Message):
     reactionid: int = betterproto.uint32_field(1)
     count: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetDetailsResponse(betterproto.Message):
-    publishedfiledetails: List["PublishedFileDetails"] = betterproto.message_field(1)
+class GetDetailsResponse(UnifiedMessage, um_name="PublishedFile.GetDetails"):
+    publishedfiledetails: "list[PublishedFileDetails]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetItemInfoRequest(betterproto.Message):
+class GetItemInfoRequest(UnifiedMessage, um_name="PublishedFile.GetItemInfo"):
     appid: int = betterproto.uint32_field(1)
     last_time_updated: int = betterproto.uint32_field(2)
-    workshop_items: List["GetItemInfoRequestWorkshopItem"] = betterproto.message_field(3)
+    workshop_items: "list[GetItemInfoRequestWorkshopItem]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class GetItemInfoRequestWorkshopItem(betterproto.Message):
     published_file_id: int = betterproto.fixed64_field(1)
     time_updated: int = betterproto.uint32_field(2)
     desired_revision: "EPublishedFileRevision" = betterproto.enum_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetItemInfoResponse(betterproto.Message):
+class GetItemInfoResponse(UnifiedMessage, um_name="PublishedFile.GetItemInfo"):
     update_time: int = betterproto.uint32_field(1)
-    workshop_items: List["GetItemInfoResponseWorkshopItemInfo"] = betterproto.message_field(2)
-    private_items: List[int] = betterproto.fixed64_field(3)
+    workshop_items: "list[GetItemInfoResponseWorkshopItemInfo]" = betterproto.message_field(2)
+    private_items: list[int] = betterproto.fixed64_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class GetItemInfoResponseWorkshopItemInfo(betterproto.Message):
     published_file_id: int = betterproto.fixed64_field(1)
     time_updated: int = betterproto.uint32_field(2)
     manifest_id: int = betterproto.fixed64_field(3)
     flags: int = betterproto.uint32_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class GetUserFilesRequest(betterproto.Message):
+class GetUserFilesRequest(UnifiedMessage, um_name="PublishedFile.GetUserFiles"):
     steamid: int = betterproto.fixed64_field(1)
     appid: int = betterproto.uint32_field(2)
     page: int = betterproto.uint32_field(4)
     numperpage: int = betterproto.uint32_field(5)
     type: str = betterproto.string_field(6)
     sortmethod: str = betterproto.string_field(7)
     privacy: int = betterproto.uint32_field(9)
-    requiredtags: List[str] = betterproto.string_field(10)
-    excludedtags: List[str] = betterproto.string_field(11)
-    required_kv_tags: List["GetUserFilesRequestKvTag"] = betterproto.message_field(30)
+    requiredtags: list[str] = betterproto.string_field(10)
+    excludedtags: list[str] = betterproto.string_field(11)
+    required_kv_tags: "list[GetUserFilesRequestKvTag]" = betterproto.message_field(30)
     filetype: int = betterproto.uint32_field(14)
     creator_appid: int = betterproto.uint32_field(15)
     match_cloud_filename: str = betterproto.string_field(16)
     cache_max_age_seconds: int = betterproto.uint32_field(27)
     language: int = betterproto.int32_field(29)
-    taggroups: List["GetUserFilesRequestTagGroup"] = betterproto.message_field(34)
+    taggroups: "list[GetUserFilesRequestTagGroup]" = betterproto.message_field(34)
     totalonly: bool = betterproto.bool_field(17)
     ids_only: bool = betterproto.bool_field(18)
     return_vote_data: bool = betterproto.bool_field(19)
     return_tags: bool = betterproto.bool_field(20)
     return_kv_tags: bool = betterproto.bool_field(21)
     return_previews: bool = betterproto.bool_field(22)
     return_children: bool = betterproto.bool_field(23)
@@ -329,145 +314,133 @@
 class GetUserFilesRequestKvTag(betterproto.Message):
     key: str = betterproto.string_field(1)
     value: str = betterproto.string_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class GetUserFilesRequestTagGroup(betterproto.Message):
-    tags: List[str] = betterproto.string_field(1)
+    tags: list[str] = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetUserFilesResponse(betterproto.Message):
+class GetUserFilesResponse(UnifiedMessage, um_name="PublishedFile.GetUserFiles"):
     total: int = betterproto.uint32_field(1)
     startindex: int = betterproto.uint32_field(2)
-    publishedfiledetails: List["PublishedFileDetails"] = betterproto.message_field(3)
-    apps: List["GetUserFilesResponseApp"] = betterproto.message_field(4)
+    publishedfiledetails: "list[PublishedFileDetails]" = betterproto.message_field(3)
+    apps: "list[GetUserFilesResponseApp]" = betterproto.message_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class GetUserFilesResponseApp(betterproto.Message):
     appid: int = betterproto.uint32_field(1)
     name: str = betterproto.string_field(2)
     shortcutid: int = betterproto.uint32_field(3)
     private: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class AreFilesInSubscriptionListRequest(betterproto.Message):
+class AreFilesInSubscriptionListRequest(UnifiedMessage, um_name="PublishedFile.AreFilesInSubscriptionList"):
     appid: int = betterproto.uint32_field(1)
-    publishedfileids: List[int] = betterproto.fixed64_field(2)
+    publishedfileids: list[int] = betterproto.fixed64_field(2)
     listtype: int = betterproto.uint32_field(3)
     filetype: int = betterproto.uint32_field(4)
     workshopfiletype: int = betterproto.uint32_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class AreFilesInSubscriptionListResponse(betterproto.Message):
-    files: List["AreFilesInSubscriptionListResponseInList"] = betterproto.message_field(1)
+class AreFilesInSubscriptionListResponse(UnifiedMessage, um_name="PublishedFile.AreFilesInSubscriptionList"):
+    files: "list[AreFilesInSubscriptionListResponseInList]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class AreFilesInSubscriptionListResponseInList(betterproto.Message):
     publishedfileid: int = betterproto.fixed64_field(1)
     inlist: bool = betterproto.bool_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateRequest(betterproto.Message):
+class UpdateRequest(UnifiedMessage, um_name="PublishedFile.Update"):
     appid: int = betterproto.uint32_field(1)
     publishedfileid: int = betterproto.fixed64_field(2)
     title: str = betterproto.string_field(3)
     file_description: str = betterproto.string_field(4)
     visibility: int = betterproto.uint32_field(5)
-    tags: List[str] = betterproto.string_field(6)
+    tags: list[str] = betterproto.string_field(6)
     filename: str = betterproto.string_field(7)
     preview_filename: str = betterproto.string_field(8)
     image_width: int = betterproto.uint32_field(15)
     image_height: int = betterproto.uint32_field(16)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateResponse(betterproto.Message):
+class UpdateResponse(UnifiedMessage, um_name="PublishedFile.Update"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetChangeHistoryEntryRequest(betterproto.Message):
+class GetChangeHistoryEntryRequest(UnifiedMessage, um_name="PublishedFile.GetChangeHistoryEntry"):
     publishedfileid: int = betterproto.fixed64_field(1)
     timestamp: int = betterproto.uint32_field(2)
     language: int = betterproto.int32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetChangeHistoryEntryResponse(betterproto.Message):
+class GetChangeHistoryEntryResponse(UnifiedMessage, um_name="PublishedFile.GetChangeHistoryEntry"):
     change_description: str = betterproto.string_field(1)
     language: int = betterproto.int32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetChangeHistoryRequest(betterproto.Message):
+class GetChangeHistoryRequest(UnifiedMessage, um_name="PublishedFile.GetChangeHistory"):
     publishedfileid: int = betterproto.fixed64_field(1)
     total_only: bool = betterproto.bool_field(2)
     startindex: int = betterproto.uint32_field(3)
     count: int = betterproto.uint32_field(4)
     language: int = betterproto.int32_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class GetChangeHistoryResponse(betterproto.Message):
-    changes: List["GetChangeHistoryResponseChangeLog"] = betterproto.message_field(1)
+class GetChangeHistoryResponse(UnifiedMessage, um_name="PublishedFile.GetChangeHistory"):
+    changes: "list[GetChangeHistoryResponseChangeLog]" = betterproto.message_field(1)
     total: int = betterproto.uint32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class GetChangeHistoryResponseChangeLog(betterproto.Message):
     timestamp: int = betterproto.uint32_field(1)
     change_description: str = betterproto.string_field(2)
     language: int = betterproto.int32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class RefreshVotingQueueRequest(betterproto.Message):
+class RefreshVotingQueueRequest(UnifiedMessage, um_name="PublishedFile.RefreshVotingQueue"):
     appid: int = betterproto.uint32_field(1)
     matching_file_type: int = betterproto.uint32_field(2)
-    tags: List[str] = betterproto.string_field(3)
+    tags: list[str] = betterproto.string_field(3)
     match_all_tags: bool = betterproto.bool_field(4)
-    excluded_tags: List[str] = betterproto.string_field(5)
+    excluded_tags: list[str] = betterproto.string_field(5)
     desired_queue_size: int = betterproto.uint32_field(6)
     desired_revision: "EPublishedFileRevision" = betterproto.enum_field(8)
 
 
-@dataclass(eq=False, repr=False)
-class RefreshVotingQueueResponse(betterproto.Message):
+class RefreshVotingQueueResponse(UnifiedMessage, um_name="PublishedFile.RefreshVotingQueue"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class QueryFilesRequest(betterproto.Message):
+class QueryFilesRequest(UnifiedMessage, um_name="PublishedFile.QueryFiles"):
     query_type: int = betterproto.uint32_field(1)
     page: int = betterproto.uint32_field(2)
     cursor: str = betterproto.string_field(39)
     numperpage: int = betterproto.uint32_field(3)
     creator_appid: int = betterproto.uint32_field(4)
     appid: int = betterproto.uint32_field(5)
-    requiredtags: List[str] = betterproto.string_field(6)
-    excludedtags: List[str] = betterproto.string_field(7)
+    requiredtags: list[str] = betterproto.string_field(6)
+    excludedtags: list[str] = betterproto.string_field(7)
     match_all_tags: bool = betterproto.bool_field(8)
-    required_flags: List[str] = betterproto.string_field(9)
-    omitted_flags: List[str] = betterproto.string_field(10)
+    required_flags: list[str] = betterproto.string_field(9)
+    omitted_flags: list[str] = betterproto.string_field(10)
     search_text: str = betterproto.string_field(11)
     filetype: int = betterproto.uint32_field(12)
     child_publishedfileid: int = betterproto.fixed64_field(13)
     days: int = betterproto.uint32_field(14)
     include_recent_votes_only: bool = betterproto.bool_field(15)
     cache_max_age_seconds: int = betterproto.uint32_field(31)
     language: int = betterproto.int32_field(33)
-    required_kv_tags: List["QueryFilesRequestKvTag"] = betterproto.message_field(34)
-    taggroups: List["QueryFilesRequestTagGroup"] = betterproto.message_field(42)
+    required_kv_tags: "list[QueryFilesRequestKvTag]" = betterproto.message_field(34)
+    taggroups: "list[QueryFilesRequestTagGroup]" = betterproto.message_field(42)
     totalonly: bool = betterproto.bool_field(16)
     ids_only: bool = betterproto.bool_field(35)
     return_vote_data: bool = betterproto.bool_field(17)
     return_tags: bool = betterproto.bool_field(18)
     return_kv_tags: bool = betterproto.bool_field(19)
     return_previews: bool = betterproto.bool_field(20)
     return_children: bool = betterproto.bool_field(21)
@@ -485,197 +458,175 @@
 class QueryFilesRequestKvTag(betterproto.Message):
     key: str = betterproto.string_field(1)
     value: str = betterproto.string_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class QueryFilesRequestTagGroup(betterproto.Message):
-    tags: List[str] = betterproto.string_field(1)
+    tags: list[str] = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class QueryFilesResponse(betterproto.Message):
+class QueryFilesResponse(UnifiedMessage, um_name="PublishedFile.QueryFiles"):
     total: int = betterproto.uint32_field(1)
-    publishedfiledetails: List["PublishedFileDetails"] = betterproto.message_field(2)
+    publishedfiledetails: "list[PublishedFileDetails]" = betterproto.message_field(2)
     next_cursor: str = betterproto.string_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class AddAppRelationshipRequest(betterproto.Message):
+class AddAppRelationshipRequest(UnifiedMessage, um_name="PublishedFile.AddAppRelationship"):
     publishedfileid: int = betterproto.uint64_field(1)
     appid: int = betterproto.uint32_field(2)
     relationship: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class AddAppRelationshipResponse(betterproto.Message):
+class AddAppRelationshipResponse(UnifiedMessage, um_name="PublishedFile.AddAppRelationship"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class RemoveAppRelationshipRequest(betterproto.Message):
+class RemoveAppRelationshipRequest(UnifiedMessage, um_name="PublishedFile.RemoveAppRelationship"):
     publishedfileid: int = betterproto.uint64_field(1)
     appid: int = betterproto.uint32_field(2)
     relationship: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class RemoveAppRelationshipResponse(betterproto.Message):
+class RemoveAppRelationshipResponse(UnifiedMessage, um_name="PublishedFile.RemoveAppRelationship"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetAppRelationshipsRequest(betterproto.Message):
+class GetAppRelationshipsRequest(UnifiedMessage, um_name="PublishedFile.GetAppRelationships"):
     publishedfileid: int = betterproto.uint64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetAppRelationshipsResponse(betterproto.Message):
-    app_relationships: List["GetAppRelationshipsResponseAppRelationship"] = betterproto.message_field(3)
+class GetAppRelationshipsResponse(UnifiedMessage, um_name="PublishedFile.GetAppRelationships"):
+    app_relationships: "list[GetAppRelationshipsResponseAppRelationship]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class GetAppRelationshipsResponseAppRelationship(betterproto.Message):
     appid: int = betterproto.uint32_field(1)
     relationship: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class StartPlaytimeTrackingRequest(betterproto.Message):
+class StartPlaytimeTrackingRequest(UnifiedMessage, um_name="PublishedFile.StartPlaytimeTracking"):
     appid: int = betterproto.uint32_field(1)
-    publishedfileids: List[int] = betterproto.uint64_field(2)
+    publishedfileids: list[int] = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class StartPlaytimeTrackingResponse(betterproto.Message):
+class StartPlaytimeTrackingResponse(UnifiedMessage, um_name="PublishedFile.StartPlaytimeTracking"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class StopPlaytimeTrackingRequest(betterproto.Message):
+class StopPlaytimeTrackingRequest(UnifiedMessage, um_name="PublishedFile.StopPlaytimeTracking"):
     appid: int = betterproto.uint32_field(1)
-    publishedfileids: List[int] = betterproto.uint64_field(2)
+    publishedfileids: list[int] = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class StopPlaytimeTrackingResponse(betterproto.Message):
+class StopPlaytimeTrackingResponse(UnifiedMessage, um_name="PublishedFile.StopPlaytimeTracking"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class StopPlaytimeTrackingForAllAppItemsRequest(betterproto.Message):
+class StopPlaytimeTrackingForAllAppItemsRequest(
+    UnifiedMessage, um_name="PublishedFile.StopPlaytimeTrackingForAllAppItems"
+):
     appid: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class StopPlaytimeTrackingForAllAppItemsResponse(betterproto.Message):
+class StopPlaytimeTrackingForAllAppItemsResponse(
+    UnifiedMessage, um_name="PublishedFile.StopPlaytimeTrackingForAllAppItems"
+):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class SetPlaytimeForControllerConfigsRequest(betterproto.Message):
+class SetPlaytimeForControllerConfigsRequest(UnifiedMessage, um_name="PublishedFile.SetPlaytimeForControllerConfigs"):
     appid: int = betterproto.uint32_field(1)
-    controller_config_usage: List[
+    controller_config_usage: list[
         "SetPlaytimeForControllerConfigsRequestControllerConfigUsage"
     ] = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class SetPlaytimeForControllerConfigsRequestControllerConfigUsage(betterproto.Message):
     publishedfileid: int = betterproto.uint64_field(1)
     seconds_active: float = betterproto.float_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class SetPlaytimeForControllerConfigsResponse(betterproto.Message):
+class SetPlaytimeForControllerConfigsResponse(UnifiedMessage, um_name="PublishedFile.SetPlaytimeForControllerConfigs"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class AddChildRequest(betterproto.Message):
+class AddChildRequest(UnifiedMessage, um_name="PublishedFile.AddChild"):
     publishedfileid: int = betterproto.uint64_field(1)
     child_publishedfileid: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class AddChildResponse(betterproto.Message):
+class AddChildResponse(UnifiedMessage, um_name="PublishedFile.AddChild"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class RemoveChildRequest(betterproto.Message):
+class RemoveChildRequest(UnifiedMessage, um_name="PublishedFile.RemoveChild"):
     publishedfileid: int = betterproto.uint64_field(1)
     child_publishedfileid: int = betterproto.uint64_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class RemoveChildResponse(betterproto.Message):
+class RemoveChildResponse(UnifiedMessage, um_name="PublishedFile.RemoveChild"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetUserVoteSummaryRequest(betterproto.Message):
-    publishedfileids: List[int] = betterproto.fixed64_field(1)
+class GetUserVoteSummaryRequest(UnifiedMessage, um_name="PublishedFile.GetUserVoteSummary"):
+    publishedfileids: list[int] = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetUserVoteSummaryResponse(betterproto.Message):
-    summaries: List["GetUserVoteSummaryResponseVoteSummary"] = betterproto.message_field(1)
+class GetUserVoteSummaryResponse(UnifiedMessage, um_name="PublishedFile.GetUserVoteSummary"):
+    summaries: "list[GetUserVoteSummaryResponseVoteSummary]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetUserVoteSummaryResponseVoteSummary(betterproto.Message):
     publishedfileid: int = betterproto.fixed64_field(1)
     vote_for: bool = betterproto.bool_field(2)
     vote_against: bool = betterproto.bool_field(3)
     reported: bool = betterproto.bool_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class GetItemChangesRequest(betterproto.Message):
+class GetItemChangesRequest(UnifiedMessage, um_name="PublishedFile.GetItemChanges"):
     appid: int = betterproto.uint32_field(1)
     last_time_updated: int = betterproto.uint32_field(2)
     num_items_max: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class GetItemChangesResponse(betterproto.Message):
+class GetItemChangesResponse(UnifiedMessage, um_name="PublishedFile.GetItemChanges"):
     update_time: int = betterproto.uint32_field(1)
-    workshop_items: List["GetItemChangesResponseWorkshopItemInfo"] = betterproto.message_field(2)
+    workshop_items: "list[GetItemChangesResponseWorkshopItemInfo]" = betterproto.message_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class GetItemChangesResponseWorkshopItemInfo(betterproto.Message):
     published_file_id: int = betterproto.fixed64_field(1)
     time_updated: int = betterproto.uint32_field(2)
     manifest_id: int = betterproto.fixed64_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class FileSubscribedNotification(betterproto.Message):
+class FileSubscribedNotification(UnifiedMessage, um_name="PublishedFileClient.NotifyFileSubscribed"):
     published_file_id: int = betterproto.fixed64_field(1)
     app_id: int = betterproto.uint32_field(2)
     file_hcontent: int = betterproto.fixed64_field(3)
     file_size: int = betterproto.uint32_field(4)
     rtime_subscribed: int = betterproto.uint32_field(5)
     is_depot_content: bool = betterproto.bool_field(6)
     rtime_updated: int = betterproto.uint32_field(7)
-    revisions: List["FileSubscribedNotificationRevisionData"] = betterproto.message_field(8)
+    revisions: "list[FileSubscribedNotificationRevisionData]" = betterproto.message_field(8)
 
 
 @dataclass(eq=False, repr=False)
 class FileSubscribedNotificationRevisionData(betterproto.Message):
     revision: "EPublishedFileRevision" = betterproto.enum_field(1)
     file_hcontent: int = betterproto.fixed64_field(2)
     rtime_updated: int = betterproto.uint32_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class FileUnsubscribedNotification(betterproto.Message):
+class FileUnsubscribedNotification(UnifiedMessage, um_name="PublishedFileClient.NotifyFileUnsubscribed"):
     published_file_id: int = betterproto.fixed64_field(1)
     app_id: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class FileDeletedClientNotification(betterproto.Message):
+class FileDeletedClientNotification(UnifiedMessage, um_name="PublishedFileClient.NotifyFileDeleted"):
     published_file_id: int = betterproto.fixed64_field(1)
     app_id: int = betterproto.uint32_field(2)
```

### Comparing `steamio-0.9.9/steam/protobufs/reviews.py` & `steamio-1.0.0a0/steam/protobufs/reviews.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,60 +1,55 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_twofactor.steamclient.proto
 # plugin: python-betterproto
 # Last updated 2/07/2022
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .msg import UnifiedMessage
 
-@dataclass(eq=False, repr=False)
-class GetIndividualRecommendationsRequest(betterproto.Message):
-    requests: List["GetIndividualRecommendationsRequestRecommendationRequest"] = betterproto.message_field(1)
+
+class GetIndividualRecommendationsRequest(UnifiedMessage, um_name="UserReviews.GetIndividualRecommendations"):
+    requests: "list[GetIndividualRecommendationsRequestRecommendationRequest]" = betterproto.message_field(1)
 
 
 @dataclass(eq=False, repr=False)
 class GetIndividualRecommendationsRequestRecommendationRequest(betterproto.Message):
     steamid: int = betterproto.uint64_field(1)
     appid: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class GetIndividualRecommendationsResponse(betterproto.Message):
-    recommendations: List["RecommendationDetails"] = betterproto.message_field(1)
+class GetIndividualRecommendationsResponse(UnifiedMessage, um_name="UserReviews.GetIndividualRecommendations"):
+    recommendations: "list[RecommendationDetails]" = betterproto.message_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateRequest(betterproto.Message):
+class UpdateRequest(UnifiedMessage, um_name="UserReviews.Update"):
     recommendationid: int = betterproto.uint64_field(1)
     review_text: str = betterproto.string_field(2)
     voted_up: bool = betterproto.bool_field(3)
     is_public: bool = betterproto.bool_field(4)
     language: str = betterproto.string_field(5)
     is_in_early_access: bool = betterproto.bool_field(6)
     received_compensation: bool = betterproto.bool_field(7)
     comments_disabled: bool = betterproto.bool_field(8)
 
 
-@dataclass(eq=False, repr=False)
-class UpdateResponse(betterproto.Message):
+class UpdateResponse(UnifiedMessage, um_name="UserReviews.Update"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class GetFriendsRecommendedAppRequest(betterproto.Message):
+class GetFriendsRecommendedAppRequest(UnifiedMessage, um_name="UserReviews.GetFriendsRecommendedApp"):
     appid: int = betterproto.uint32_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class GetFriendsRecommendedAppResponse(betterproto.Message):
-    accountids_recommended: List[int] = betterproto.uint32_field(1)
-    accountids_not_recommended: List[int] = betterproto.uint32_field(3)
+class GetFriendsRecommendedAppResponse(UnifiedMessage, um_name="UserReviews.GetFriendsRecommendedApp"):
+    accountids_recommended: list[int] = betterproto.uint32_field(1)
+    accountids_not_recommended: list[int] = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class RecommendationDetails(betterproto.Message):
     recommendationid: int = betterproto.uint64_field(1)
     steamid: int = betterproto.uint64_field(2)
     appid: int = betterproto.uint32_field(3)
@@ -90,15 +85,15 @@
     last_playtime: int = betterproto.int32_field(33)
     comments_disabled: bool = betterproto.bool_field(34)
     playtime_at_review: int = betterproto.int32_field(35)
     approved_for_china: bool = betterproto.bool_field(36)
     ban_check_result: int = betterproto.int32_field(37)
     refunded: bool = betterproto.bool_field(38)
     account_score_spend: int = betterproto.int32_field(39)
-    reactions: List["RecommendationLoyaltyReaction"] = betterproto.message_field(40)
+    reactions: "list[RecommendationLoyaltyReaction]" = betterproto.message_field(40)
     ipaddress: str = betterproto.string_field(41)
 
 
 @dataclass(eq=False, repr=False)
 class RecommendationLoyaltyReaction(betterproto.Message):
     reactionid: int = betterproto.uint32_field(1)
     count: int = betterproto.uint32_field(2)
```

### Comparing `steamio-0.9.9/steam/protobufs/two_factor.py` & `steamio-1.0.0a0/steam/protobufs/two_factor.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,25 +1,24 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_twofactor.steamclient.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .msg import UnifiedMessage
 
-@dataclass(eq=False, repr=False)
-class StatusRequest(betterproto.Message):
+
+class StatusRequest(UnifiedMessage, um_name="TwoFactor.QueryStatus"):
     steamid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class StatusResponse(betterproto.Message):
+class StatusResponse(UnifiedMessage, um_name="TwoFactor.QueryStatus"):
     state: int = betterproto.uint32_field(1)
     inactivation_reason: int = betterproto.uint32_field(2)
     authenticator_type: int = betterproto.uint32_field(3)
     authenticator_allowed: bool = betterproto.bool_field(4)
     steamguard_scheme: int = betterproto.uint32_field(5)
     token_gid: str = betterproto.string_field(6)
     email_validated: bool = betterproto.bool_field(7)
@@ -27,104 +26,90 @@
     time_created: int = betterproto.uint32_field(9)
     revocation_attempts_remaining: int = betterproto.uint32_field(10)
     classified_agent: str = betterproto.string_field(11)
     allow_external_authenticator: bool = betterproto.bool_field(12)
     time_transferred: int = betterproto.uint32_field(13)
 
 
-@dataclass(eq=False, repr=False)
-class AddAuthenticatorRequest(betterproto.Message):
+class AddAuthenticatorRequest(UnifiedMessage, um_name="TwoFactor.AddAuthenticator"):
     steamid: int = betterproto.fixed64_field(1)
     authenticator_time: int = betterproto.uint64_field(2)
     serial_number: int = betterproto.fixed64_field(3)
     authenticator_type: int = betterproto.uint32_field(4)
     device_identifier: str = betterproto.string_field(5)
     sms_phone_id: str = betterproto.string_field(6)
-    http_headers: List[str] = betterproto.string_field(7)
+    http_headers: list[str] = betterproto.string_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class AddAuthenticatorResponse(betterproto.Message):
+class AddAuthenticatorResponse(UnifiedMessage, um_name="TwoFactor.AddAuthenticator"):
     shared_secret: bytes = betterproto.bytes_field(1)
     serial_number: int = betterproto.fixed64_field(2)
     revocation_code: str = betterproto.string_field(3)
     uri: str = betterproto.string_field(4)
     server_time: int = betterproto.uint64_field(5)
     account_name: str = betterproto.string_field(6)
     token_gid: str = betterproto.string_field(7)
     identity_secret: bytes = betterproto.bytes_field(8)
     secret_1: bytes = betterproto.bytes_field(9)
     status: int = betterproto.int32_field(10)
 
 
-@dataclass(eq=False, repr=False)
-class SendEmailRequest(betterproto.Message):
+class SendEmailRequest(UnifiedMessage, um_name="TwoFactor.SendEmail"):
     steamid: int = betterproto.fixed64_field(1)
     email_type: int = betterproto.uint32_field(2)
     include_activation_code: bool = betterproto.bool_field(3)
 
 
-@dataclass(eq=False, repr=False)
-class SendEmailResponse(betterproto.Message):
+class SendEmailResponse(UnifiedMessage, um_name="TwoFactor.SendEmail"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class FinalizeAddAuthenticatorRequest(betterproto.Message):
+class FinalizeAddAuthenticatorRequest(UnifiedMessage, um_name="TwoFactor.FinalizeAddAuthenticator"):
     steamid: int = betterproto.fixed64_field(1)
     authenticator_code: str = betterproto.string_field(2)
     authenticator_time: int = betterproto.uint64_field(3)
     activation_code: str = betterproto.string_field(4)
-    http_headers: List[str] = betterproto.string_field(5)
+    http_headers: list[str] = betterproto.string_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class FinalizeAddAuthenticatorResponse(betterproto.Message):
+class FinalizeAddAuthenticatorResponse(UnifiedMessage, um_name="TwoFactor.FinalizeAddAuthenticator"):
     success: bool = betterproto.bool_field(1)
     want_more: bool = betterproto.bool_field(2)
     server_time: int = betterproto.uint64_field(3)
     status: int = betterproto.int32_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class RemoveAuthenticatorRequest(betterproto.Message):
+class RemoveAuthenticatorRequest(UnifiedMessage, um_name="TwoFactor.RemoveAuthenticator"):
     revocation_code: str = betterproto.string_field(2)
     revocation_reason: int = betterproto.uint32_field(5)
     steamguard_scheme: int = betterproto.uint32_field(6)
     remove_all_steamguard_cookies: bool = betterproto.bool_field(7)
 
 
-@dataclass(eq=False, repr=False)
-class RemoveAuthenticatorResponse(betterproto.Message):
+class RemoveAuthenticatorResponse(UnifiedMessage, um_name="TwoFactor.RemoveAuthenticator"):
     success: bool = betterproto.bool_field(1)
     server_time: int = betterproto.uint64_field(3)
     revocation_attempts_remaining: int = betterproto.uint32_field(5)
 
 
-@dataclass(eq=False, repr=False)
-class CreateEmergencyCodesRequest(betterproto.Message):
+class CreateEmergencyCodesRequest(UnifiedMessage, um_name="TwoFactor.CreateEmergencyCodes"):
     code: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class CreateEmergencyCodesResponse(betterproto.Message):
-    codes: List[str] = betterproto.string_field(1)
+class CreateEmergencyCodesResponse(UnifiedMessage, um_name="TwoFactor.CreateEmergencyCodes"):
+    codes: list[str] = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class DestroyEmergencyCodesRequest(betterproto.Message):
+class DestroyEmergencyCodesRequest(UnifiedMessage, um_name="TwoFactor.DestroyEmergencyCodes"):
     steamid: int = betterproto.fixed64_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class DestroyEmergencyCodesResponse(betterproto.Message):
+class DestroyEmergencyCodesResponse(UnifiedMessage, um_name="TwoFactor.DestroyEmergencyCodes"):
     pass
 
 
-@dataclass(eq=False, repr=False)
-class ValidateTokenRequest(betterproto.Message):
+class ValidateTokenRequest(UnifiedMessage, um_name="TwoFactor.ValidateToken"):
     code: str = betterproto.string_field(1)
 
 
-@dataclass(eq=False, repr=False)
-class ValidateTokenResponse(betterproto.Message):
+class ValidateTokenResponse(UnifiedMessage, um_name="TwoFactor.ValidateToken"):
     valid: bool = betterproto.bool_field(1)
```

### Comparing `steamio-0.9.9/steam/protobufs/ucm.py` & `steamio-1.0.0a0/steam/protobufs/ucm.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,34 +1,36 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_clientserver_ucm.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .emsg import EMsg
+from .msg import ProtobufMessage
+
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUcmAddScreenshot(betterproto.Message):
     appid: int = betterproto.uint32_field(1)
     filename: str = betterproto.string_field(2)
     thumbname: str = betterproto.string_field(3)
     vr_filename: str = betterproto.string_field(14)
     rtime32_created: int = betterproto.fixed32_field(4)
     width: int = betterproto.uint32_field(5)
     height: int = betterproto.uint32_field(6)
     permissions: int = betterproto.uint32_field(7)
     caption: str = betterproto.string_field(8)
     shortcut_name: str = betterproto.string_field(9)
-    tag: List["CMsgClientUcmAddScreenshotTag"] = betterproto.message_field(10)
-    tagged_steamid: List[int] = betterproto.fixed64_field(11)
+    tag: "list[CMsgClientUcmAddScreenshotTag]" = betterproto.message_field(10)
+    tagged_steamid: list[int] = betterproto.fixed64_field(11)
     spoiler_tag: bool = betterproto.bool_field(12)
-    tagged_publishedfileid: List[int] = betterproto.uint64_field(13)
+    tagged_publishedfileid: list[int] = betterproto.uint64_field(13)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUcmAddScreenshotTag(betterproto.Message):
     tag_name: str = betterproto.string_field(1)
     tag_value: str = betterproto.string_field(2)
 
@@ -53,15 +55,15 @@
 class CMsgClientUcmPublishFile(betterproto.Message):
     app_id: int = betterproto.uint32_field(1)
     file_name: str = betterproto.string_field(2)
     preview_file_name: str = betterproto.string_field(3)
     consumer_app_id: int = betterproto.uint32_field(4)
     title: str = betterproto.string_field(5)
     description: str = betterproto.string_field(6)
-    tags: List[str] = betterproto.string_field(8)
+    tags: list[str] = betterproto.string_field(8)
     workshop_file: bool = betterproto.bool_field(9)
     visibility: int = betterproto.int32_field(10)
     file_type: int = betterproto.uint32_field(11)
     url: str = betterproto.string_field(12)
     video_provider: int = betterproto.uint32_field(13)
     video_account_name: str = betterproto.string_field(14)
     video_identifier: str = betterproto.string_field(15)
@@ -79,15 +81,15 @@
 class CMsgClientUcmUpdatePublishedFile(betterproto.Message):
     app_id: int = betterproto.uint32_field(1)
     published_file_id: int = betterproto.fixed64_field(2)
     file_name: str = betterproto.string_field(3)
     preview_file_name: str = betterproto.string_field(4)
     title: str = betterproto.string_field(5)
     description: str = betterproto.string_field(6)
-    tags: List[str] = betterproto.string_field(7)
+    tags: list[str] = betterproto.string_field(7)
     visibility: int = betterproto.int32_field(8)
     update_file: bool = betterproto.bool_field(9)
     update_preview_file: bool = betterproto.bool_field(10)
     update_title: bool = betterproto.bool_field(11)
     update_description: bool = betterproto.bool_field(12)
     update_tags: bool = betterproto.bool_field(13)
     update_visibility: bool = betterproto.bool_field(14)
@@ -95,18 +97,18 @@
     update_url: bool = betterproto.bool_field(16)
     url: str = betterproto.string_field(17)
     update_content_manifest: bool = betterproto.bool_field(18)
     content_manifest: int = betterproto.fixed64_field(19)
     metadata: str = betterproto.string_field(20)
     update_metadata: bool = betterproto.bool_field(21)
     language: int = betterproto.int32_field(22)
-    removed_kvtags: List[str] = betterproto.string_field(23)
-    kvtags: List["CMsgClientUcmUpdatePublishedFileKeyValueTag"] = betterproto.message_field(24)
-    previews: List["CMsgClientUcmUpdatePublishedFileAdditionalPreview"] = betterproto.message_field(25)
-    previews_to_remove: List[int] = betterproto.int32_field(26)
+    removed_kvtags: list[str] = betterproto.string_field(23)
+    kvtags: "list[CMsgClientUcmUpdatePublishedFileKeyValueTag]" = betterproto.message_field(24)
+    previews: "list[CMsgClientUcmUpdatePublishedFileAdditionalPreview]" = betterproto.message_field(25)
+    previews_to_remove: list[int] = betterproto.int32_field(26)
     clear_in_progress: bool = betterproto.bool_field(27)
     remove_all_kvtags: bool = betterproto.bool_field(28)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUcmUpdatePublishedFileKeyValueTag(betterproto.Message):
     key: str = betterproto.string_field(1)
@@ -146,15 +148,15 @@
     start_time: int = betterproto.fixed32_field(3)
     desired_revision: int = betterproto.uint32_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUcmEnumerateUserSubscribedFilesWithUpdatesResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
-    subscribed_files: List[
+    subscribed_files: list[
         "CMsgClientUcmEnumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId"
     ] = betterproto.message_field(2)
     total_results: int = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUcmEnumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId(betterproto.Message):
@@ -185,15 +187,15 @@
     num_items_needed: int = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientWorkshopItemChangesResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
     update_time: int = betterproto.uint32_field(2)
-    workshop_items: List["CMsgClientWorkshopItemChangesResponseWorkshopItemInfo"] = betterproto.message_field(5)
+    workshop_items: "list[CMsgClientWorkshopItemChangesResponseWorkshopItemInfo]" = betterproto.message_field(5)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientWorkshopItemChangesResponseWorkshopItemInfo(betterproto.Message):
     published_file_id: int = betterproto.fixed64_field(1)
     time_updated: int = betterproto.uint32_field(2)
     manifest_id: int = betterproto.fixed64_field(3)
@@ -217,22 +219,21 @@
     start_index: int = betterproto.uint32_field(2)
     action: int = betterproto.int32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUcmEnumeratePublishedFilesByUserActionResponse(betterproto.Message):
     eresult: int = betterproto.int32_field(1)
-    published_files: List[
+    published_files: list[
         "CMsgClientUcmEnumeratePublishedFilesByUserActionResponsePublishedFileId"
     ] = betterproto.message_field(2)
     total_results: int = betterproto.uint32_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientUcmEnumeratePublishedFilesByUserActionResponsePublishedFileId(betterproto.Message):
     published_file_id: int = betterproto.fixed64_field(1)
     rtime_time_stamp: int = betterproto.fixed32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientScreenshotsChanged(betterproto.Message):
+class CMsgClientScreenshotsChanged(ProtobufMessage, msg=EMsg.ClientScreenshotsChanged):
     pass
```

### Comparing `steamio-0.9.9/steam/protobufs/user_stats.py` & `steamio-1.0.0a0/steam/protobufs/user_stats.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,99 +1,95 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # sources: steammessages_clientserver_userstats.proto
 # plugin: python-betterproto
 # Last updated 09/09/2021
 
 from dataclasses import dataclass
-from typing import List
 
 import betterproto
 
+from .emsg import EMsg
+from .msg import ProtobufMessage
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetUserStats(betterproto.Message):
+
+class CMsgClientGetUserStats(ProtobufMessage, msg=EMsg.ClientGetUserStats):
     game_id: int = betterproto.fixed64_field(1)
     crc_stats: int = betterproto.uint32_field(2)
     schema_local_version: int = betterproto.int32_field(3)
     steam_id_for_user: int = betterproto.fixed64_field(4)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientGetUserStatsResponse(betterproto.Message):
+class CMsgClientGetUserStatsResponse(ProtobufMessage, msg=EMsg.ClientGetUserStatsResponse):
     game_id: int = betterproto.fixed64_field(1)
     eresult: int = betterproto.int32_field(2)
     crc_stats: int = betterproto.uint32_field(3)
     schema: bytes = betterproto.bytes_field(4)
-    stats: List["CMsgClientGetUserStatsResponseStats"] = betterproto.message_field(5)
-    achievement_blocks: List["CMsgClientGetUserStatsResponseAchievementBlocks"] = betterproto.message_field(6)
+    stats: "list[CMsgClientGetUserStatsResponseStats]" = betterproto.message_field(5)
+    achievement_blocks: "list[CMsgClientGetUserStatsResponseAchievementBlocks]" = betterproto.message_field(6)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientGetUserStatsResponseStats(betterproto.Message):
     stat_id: int = betterproto.uint32_field(1)
     stat_value: int = betterproto.uint32_field(2)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientGetUserStatsResponseAchievementBlocks(betterproto.Message):
     achievement_id: int = betterproto.uint32_field(1)
-    unlock_time: List[int] = betterproto.fixed32_field(2)
+    unlock_time: list[int] = betterproto.fixed32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientStoreUserStatsResponse(betterproto.Message):
+class CMsgClientStoreUserStatsResponse(ProtobufMessage, msg=EMsg.ClientStoreUserStatsResponse):
     game_id: int = betterproto.fixed64_field(1)
     eresult: int = betterproto.int32_field(2)
     crc_stats: int = betterproto.uint32_field(3)
-    stats_failed_validation: List["CMsgClientStoreUserStatsResponseStatsFailedValidation"] = betterproto.message_field(
+    stats_failed_validation: "list[CMsgClientStoreUserStatsResponseStatsFailedValidation]" = betterproto.message_field(
         4
     )
     stats_out_of_date: bool = betterproto.bool_field(5)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientStoreUserStatsResponseStatsFailedValidation(betterproto.Message):
     stat_id: int = betterproto.uint32_field(1)
     reverted_stat_value: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientStoreUserStats2(betterproto.Message):
+class CMsgClientStoreUserStats2(ProtobufMessage, msg=EMsg.ClientStoreUserStats2):
     game_id: int = betterproto.fixed64_field(1)
     settor_steam_id: int = betterproto.fixed64_field(2)
     settee_steam_id: int = betterproto.fixed64_field(3)
     crc_stats: int = betterproto.uint32_field(4)
     explicit_reset: bool = betterproto.bool_field(5)
-    stats: List["CMsgClientStoreUserStats2Stats"] = betterproto.message_field(6)
+    stats: "list[CMsgClientStoreUserStats2Stats]" = betterproto.message_field(6)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientStoreUserStats2Stats(betterproto.Message):
     stat_id: int = betterproto.uint32_field(1)
     stat_value: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientStatsUpdated(betterproto.Message):
+class CMsgClientStatsUpdated(ProtobufMessage, msg=EMsg.ClientStatsUpdated):
     steam_id: int = betterproto.fixed64_field(1)
     game_id: int = betterproto.fixed64_field(2)
     crc_stats: int = betterproto.uint32_field(3)
-    updated_stats: List["CMsgClientStatsUpdatedUpdatedStats"] = betterproto.message_field(4)
+    updated_stats: "list[CMsgClientStatsUpdatedUpdatedStats]" = betterproto.message_field(4)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientStatsUpdatedUpdatedStats(betterproto.Message):
     stat_id: int = betterproto.uint32_field(1)
     stat_value: int = betterproto.uint32_field(2)
 
 
-@dataclass(eq=False, repr=False)
-class CMsgClientStoreUserStats(betterproto.Message):
+class CMsgClientStoreUserStats(ProtobufMessage, msg=EMsg.ClientStoreUserStats):
     game_id: int = betterproto.fixed64_field(1)
     explicit_reset: bool = betterproto.bool_field(2)
-    stats_to_store: List["CMsgClientStoreUserStatsStatsToStore"] = betterproto.message_field(3)
+    stats_to_store: "list[CMsgClientStoreUserStatsStatsToStore]" = betterproto.message_field(3)
 
 
 @dataclass(eq=False, repr=False)
 class CMsgClientStoreUserStatsStatsToStore(betterproto.Message):
     stat_id: int = betterproto.uint32_field(1)
     stat_value: int = betterproto.uint32_field(2)
```

### Comparing `steamio-0.9.9/steam/published_file.py` & `steamio-1.0.0a0/steam/published_file.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,26 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
-from collections.abc import AsyncGenerator
+from collections.abc import AsyncGenerator, Sequence
 from contextlib import asynccontextmanager
 from dataclasses import dataclass
 from datetime import datetime
 from io import BytesIO
-from typing import TYPE_CHECKING, Sequence
+from typing import TYPE_CHECKING
 
 from yarl import URL as URL_
 
 from .abc import Awardable, Commentable, _CommentableKwargs
+from .app import PartialApp
 from .enums import Language, PublishedFileRevision, PublishedFileType, PublishedFileVisibility
-from .game import StatefulGame
 from .models import URL, _IOMixin
 from .reaction import AwardReaction
+from .types.id import ID64
 from .utils import DateTime
 
 if TYPE_CHECKING:
     from .manifest import Manifest
     from .message import Authors
     from .protobufs.published_file import PublishedFileDetails
     from .state import ConnectionState
@@ -30,38 +31,38 @@
     "DetailsPreview",
     "PreviewInfo",
     "PublishedFileChild",
     "PublishedFileChange",
 )
 
 
-@dataclass
+@dataclass(slots=True)
 class DetailsPreview(_IOMixin):
     _state: ConnectionState
     id: int
     position: int
     url: str
     size: int
     filename: str
     type: int
 
     @property
     def ugc_id(self) -> int:
         return int(URL_(self.url).parts[2])
 
 
-@dataclass
+@dataclass(slots=True)
 class PreviewInfo(_IOMixin):
     _state: ConnectionState
     ugc_id: int
     size: int
     url: str
 
 
-@dataclass
+@dataclass(slots=True)
 class PublishedFileChild:
     _state: ConnectionState
     id: int
     position: int
     type: int
     parent: PublishedFile
 
@@ -86,31 +87,30 @@
 
     async def manifest(self) -> Manifest:
         """Fetch the manifest for this child."""
         resolved = await self.fetch()
         return await resolved.manifest()
 
 
-@dataclass
+@dataclass(slots=True)
 class PublishedFileChange:
-    __slots__ = ("description", "created_at")
     description: str
     created_at: datetime
 
 
 class PublishedFile(Commentable, Awardable):
     """Represents a published file on SteamPipe."""
 
     _AWARDABLE_TYPE = 2
     __slots__ = (
         "_state",
         "id",
         "name",
         "author",
-        "game",
+        "app",
         "created_with",
         "created_at",
         "updated_at",
         "url",
         "manifest_id",
         "revision",
         "available_revisions",
@@ -177,17 +177,17 @@
         self._state = state
         self.id = proto.publishedfileid
         """The file's id."""
         self.name = proto.title
         """The file's name."""
         self.author = author
         """The file's author."""
-        self.game = StatefulGame(state, id=proto.consumer_appid, name=proto.app_name)
-        """The file's game."""
-        self.created_with = StatefulGame(state, id=proto.creator_appid)
+        self.app = PartialApp(state, id=proto.consumer_appid, name=proto.app_name)
+        """The file's app."""
+        self.created_with = PartialApp(state, id=proto.creator_appid)
         """The file's created_with."""
         self.created_at = DateTime.from_timestamp(proto.time_created)
         """The time the file was created at."""
         self.updated_at = DateTime.from_timestamp(proto.time_updated)
         """The time the file was last updated at."""
         self.url = str(
             URL.COMMUNITY / "sharedfiles/filedetails" % {"id": self.id}
@@ -320,28 +320,28 @@
         self.maybe_inappropriate_violence = proto.maybe_inappropriate_violence
         """Whether the file may contain violent content which may be inappropriate for some."""
 
         self.reactions = [AwardReaction(state, reaction) for reaction in proto.reactions]
         """The file's reactions."""
 
     def __repr__(self) -> str:
-        attrs = ("name", "id", "author", "game", "manifest_id", "change_number")
+        attrs = ("name", "id", "author", "type", "app", "manifest_id", "change_number")
         resolved = [f"{name}={getattr(self, name)!r}" for name in attrs]
         return f"<{self.__class__.__name__} {' '.join(resolved)}>"
 
     @property
     def _commentable_kwargs(self) -> _CommentableKwargs:
         return {
             "id64": self.author.id64,
-            "thread_type": 9,
+            "forum_id": self.id,
         }
 
     async def manifest(self) -> Manifest:
         """The manifest associated with this published file."""
-        return await self._state.fetch_manifest(self.game.id, self.manifest_id, self.game.id, self.name)
+        return await self._state.fetch_manifest(self.app.id, self.manifest_id, self.app.id, self.name)
 
     @asynccontextmanager
     async def open(self) -> AsyncGenerator[BytesIO, None]:
         if self.type not in (PublishedFileType.Art, PublishedFileType.SteamVideo):
             raise NotImplementedError(f"Cannot open {self.type}")
 
         async with self._state.http._session.get(self.cdn_url) as r:
@@ -379,24 +379,24 @@
             The revision to fetch.
         language
             The language to fetch parents in. If ``None``, the current language is used.
         """
         cursor = "*"
         more = True
         parents: list[PublishedFile] = []
-        authors: set[int] = set()
+        authors = set[ID64]()
 
         while more:
             proto = await self._state.fetch_published_file_parents(self.id, revision, language, cursor)
             more = len(parents) < proto.total
 
             for file in proto.publishedfiledetails:
-                author: Authors = file.creator  # type: ignore
-                parents.append(PublishedFile(self._state, file, author))
-                authors.add(file.creator)
+                author = ID64(file.creator)
+                parents.append(PublishedFile(self._state, file, author))  # type: ignore
+                authors.add(author)
 
         for author in await self._state._maybe_users(authors):
             for parent in parents:
                 if parent.author == author.id64:
                     parent.author = author
 
         return parents
@@ -504,15 +504,15 @@
         """
         try:
             preview_filename = self.previews[0].filename  # TODO test
         except IndexError:
             preview_filename = ""
         await self._state.edit_published_file(
             self.id,
-            self.game.id,
+            self.app.id,
             name if name is not None else self.name,
             description if description is not None else self.description,
             visibility or self.visibility,
             tags if tags is not None else [t.display_name for t in self.tags],
             filename if filename is not None else self.filename,
             preview_filename if preview_filename is not None else preview_filename,
         )
```

### Comparing `steamio-0.9.9/steam/reaction.py` & `steamio-1.0.0a0/steam/reaction.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,21 +3,22 @@
 from __future__ import annotations
 
 from collections.abc import AsyncGenerator, Mapping
 from contextlib import asynccontextmanager
 from dataclasses import dataclass
 from datetime import datetime
 from io import BytesIO
-from typing import TYPE_CHECKING, cast
+from typing import TYPE_CHECKING, Final, Protocol, cast, overload
 
-from typing_extensions import Final, Protocol
 from yarl import URL
 
-from .game import StatefulGame
+from .app import PartialApp
 from .models import _IOMixin
+from .protobufs.chat import EChatRoomMessageReactionType
+from .protobufs.friend_messages import EMessageReactionType
 from .utils import DateTime
 
 if TYPE_CHECKING:
     from .message import Authors, Message
     from .protobufs.friends import (
         CMsgClientEmoticonListEffect as ClientEffectProto,
         CMsgClientEmoticonListEmoticon as ClientEmoticonProto,
@@ -39,23 +40,23 @@
 
 
 class ReactionProtocol(Protocol):
     reactionid: int
     count: int
 
 
-@dataclass
+@dataclass(slots=True)
 class _Reaction:
-    __slots__ = tuple(ReactionProtocol.__annotations__)
-    __annotations__ = ReactionProtocol.__annotations__
+    reactionid: int
+    count: int
 
 
 BASE_REACTION_URL: Final = "https://store.cloudflare.steamstatic.com/public/images/loyalty/reactions/{type}/{id}.png"
 BASE_ECONOMY_URL: Final = URL("https://community.akamai.steamstatic.com/economy")
-AWARD_ID_TO_NAME: Final = cast("Mapping[int, str]", {
+AWARD_ID_TO_NAME: Final = cast(Mapping[int, str], {
     1: "Deep Thoughts",
     2: "Heartwarming",
     3: "Hilarious",
     4: "Hot Take",
     5: "Poetry",
     6: "Extra Helpful",
     7: "Gotta Have It",
@@ -129,131 +130,220 @@
         self.award = Award(state, proto.reactionid)
         self.count = proto.count
 
     def __repr__(self) -> str:
         return f"<{self.__class__.__name__} award={self.award!r} count={self.count}>"
 
 
-@dataclass
+@dataclass(slots=True)
 class PartialMessageReaction:
     """Represents a partial reaction to a message."""
 
     _state: ConnectionState
     message: Message
     """The message the reaction applies to. """
     emoticon: Emoticon | None
     """The emoticon that was reacted with."""
     sticker: Sticker | None
     """The sticker that was reacted with."""
 
+    if TYPE_CHECKING:
+
+        @overload
+        def __init__(self, _state: ConnectionState, message: Message, emoticon: Emoticon, sticker: None) -> None:  # type: ignore
+            ...
+
+        @overload
+        def __init__(self, _state: ConnectionState, message: Message, emoticon: None, sticker: Sticker) -> None:
+            ...
+
+    def __repr__(self) -> str:
+        return (
+            f"<{self.__class__.__name__} message={self.message!r} emoticon={self.emoticon!r} sticker={self.sticker!r}>"
+        )
+
 
-@dataclass
+@dataclass(slots=True, eq=False, repr=False)
 class MessageReaction(PartialMessageReaction):
     """Represents a reaction to a message."""
 
     user: Authors
     """The user that reacted to the message."""
     created_at: datetime | None = None
     """The time the reaction was added to the message."""
     ordinal: int | None = None
     """The ordinal of the the message."""
 
+    if TYPE_CHECKING:
+
+        @overload
+        def __init__(  # type: ignore
+            self,
+            _state: ConnectionState,
+            message: Message,
+            emoticon: Emoticon,
+            sticker: None,
+            user: Authors,
+            created_at: datetime | None = None,
+            ordinal: int | None = None,
+        ) -> None:
+            ...
+
+        @overload
+        def __init__(
+            self,
+            _state: ConnectionState,
+            message: Message,
+            emoticon: None,
+            sticker: Sticker,
+            user: Authors,
+            created_at: datetime | None = None,
+            ordinal: int | None = None,
+        ) -> None:
+            ...
+
     def __eq__(self, other: object) -> bool:
         if not isinstance(other, self.__class__):
             return NotImplemented
 
         return (
             self.message == other.message
             and self.emoticon == other.emoticon
             and self.sticker == other.sticker
             and self.user == other.user
         )
 
+    def __hash__(self) -> int:
+        return hash((self.message, self.emoticon, self.sticker, self.user))
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} message={self.message!r} emoticon={self.emoticon!r} sticker={self.sticker!r} user={self.user!r}>"
+
 
 class BaseEmoticon(_IOMixin):
     __slots__ = ("_state", "name")
     url: str
 
     def __init__(self, state: ConnectionState, name: str):
         self._state = state
-        self.name = name.strip(":")  # :emoji_name:
+        self.name = name.removeprefix(":").removesuffix(":")  # :emoji_name:
 
     def __repr__(self) -> str:
         return f"<{self.__class__.__name__} name={self.name!r}>"
 
+    def __eq__(self, other: object) -> bool:
+        if not isinstance(other, BaseEmoticon):
+            return NotImplemented
+        if (isinstance(self, Emoticon) and isinstance(other, Emoticon)) or (
+            isinstance(self, Sticker) and isinstance(other, Sticker)
+        ):
+            return self.name == other.name
+
+        return NotImplemented
+
+    def __hash__(self) -> int:
+        return hash(self.name)
+
+
+EMOTICON_TYPE = EChatRoomMessageReactionType.Emoticon
+STICKER_TYPE = EChatRoomMessageReactionType.Sticker
+
+if TYPE_CHECKING:  # until actual intersection types are added this will have to do
+    assert isinstance(EMOTICON_TYPE, EMessageReactionType)
+    assert isinstance(STICKER_TYPE, EMessageReactionType)
+
 
 class Emoticon(BaseEmoticon):
     """Represents an emoticon in chat.
 
     .. container:: operations
 
+        .. describe:: x == y
+
+            Checks if two emoticons are equal.
+
         .. describe:: str(x)
 
             The string to send this emoticon in chat.
 
+        .. describe:: hash(x)
+
+            Returns the emoticon's hash.
+
+
     Attributes
     ----------
     name
         The name of this emoticon.
     """
 
     __slots__ = ()
+    _TYPE: Final = EMOTICON_TYPE
 
     def __str__(self):
         return f":{self.name}:"
 
     @property
     def url(self) -> str:
         """The URL for this emoticon."""
         return str(BASE_ECONOMY_URL / "emoticonlarge" / self.name)
 
-    async def game(self) -> StatefulGame:
-        """Fetches this emoticon's associated game.
+    async def app(self) -> PartialApp:
+        """Fetches this emoticon's associated app.
 
         Note
         ----
-        This game has its :attr:`~Game.name` set unlike :meth:`Sticker.game`.
+        This app has its :attr:`~App.name` set unlike :meth:`Sticker.app`.
         """
         data = await self._state.http.get(BASE_ECONOMY_URL / "emoticonhoverjson" / self.name)
-        return StatefulGame(self._state, id=data["appid"], name=data["app_name"])
+        return PartialApp(self._state, id=data["appid"], name=data["app_name"])
 
 
 class Sticker(BaseEmoticon):
     """Represents a sticker in chat.
 
     .. container:: operations
 
+        .. describe:: x == y
+
+            Checks if two stickers are equal.
+
         .. describe:: str(x)
 
             The way to send this sticker in chat.
 
+        .. describe:: hash(x)
+
+            Returns the stickers's hash.
+
     Note
     ----
     Unlike :class:`Emoticon` this can only be sent in a message by itself.
 
     Attributes
     ----------
     name
         The name of this sticker.
     """
 
     __slots__ = ()
+    _TYPE: Final = STICKER_TYPE
 
     def __str__(self) -> str:
         return f"/sticker {self.name}"
 
     @property
     def url(self) -> str:
         """The URL for this sticker."""
         return str(BASE_ECONOMY_URL / "sticker" / self.name)
 
-    async def game(self) -> StatefulGame:
-        """Fetches this sticker's associated game."""
+    async def app(self) -> PartialApp:
+        """Fetches this sticker's associated app."""
         data = await self._state.http.get(BASE_ECONOMY_URL / "stickerjson" / self.name)
-        return StatefulGame(self._state, id=data["appid"])
+        return PartialApp(self._state, id=data["appid"])
 
 
 class BaseClientEmoticon(BaseEmoticon):
     __slots__ = ("count", "use_count", "last_used", "received_at")
 
     def __init__(self, state: ConnectionState, proto: ClientEmoticonProto | ClientStickerProto):
         super().__init__(state, proto.name)
@@ -277,9 +367,9 @@
 
     __slots__ = ("_app_id",)
 
     def __init__(self, state: ConnectionState, proto: ClientStickerProto):
         super().__init__(state, proto)
         self._app_id = proto.appid
 
-    async def game(self) -> StatefulGame:
-        return StatefulGame(self._state, id=self._app_id)  # no point fetching
+    async def app(self) -> PartialApp:
+        return PartialApp(self._state, id=self._app_id)  # no point fetching
```

### Comparing `steamio-0.9.9/steam/review.py` & `steamio-1.0.0a0/steam/review.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,17 +5,17 @@
 from dataclasses import dataclass
 from datetime import datetime, timedelta
 from typing import TYPE_CHECKING, Any
 
 from typing_extensions import Self
 
 from .abc import Awardable, Commentable, _CommentableKwargs
+from .app import PartialApp
 from .chat import WrapsUser
 from .enums import Language, ReviewType
-from .game import StatefulGame
 from .reaction import AwardReaction
 from .user import User
 from .utils import DateTime
 
 if TYPE_CHECKING:
     from .protobufs.reviews import RecommendationDetails as ReviewProto
     from .state import ConnectionState
@@ -24,70 +24,70 @@
     "Review",
     "ReviewUser",
 )
 
 
 class ReviewUser(WrapsUser):
     __slots__ = (
-        "number_of_games_owned",
+        "number_of_apps_owned",
         "number_of_reviews",
         "playtime_forever",
         "playtime_last_two_weeks",
         "playtime_at_review",
         "last_played",
     )
 
-    number_of_games_owned: int | None
+    number_of_apps_owned: int | None
     number_of_reviews: int | None
     playtime_forever: timedelta
     playtime_last_two_weeks: timedelta
     playtime_at_review: timedelta
     last_played: datetime
 
     @classmethod
     def _from_proto(cls, state: ConnectionState, user: User, review: ReviewProto) -> Self:
         review_user = cls(state, user)
         review_user.number_of_reviews = None
-        review_user.number_of_games_owned = None
+        review_user.number_of_apps_owned = None
         review_user.playtime_forever = timedelta(seconds=review.playtime_forever)
         review_user.playtime_last_two_weeks = timedelta(seconds=review.playtime_2weeks)
         review_user.playtime_at_review = timedelta(seconds=review.playtime_at_review)
         review_user.last_played = DateTime.from_timestamp(review.last_playtime)
         return review_user
 
     @classmethod
     def _from_data(cls, state: ConnectionState, user: User, data: dict[str, Any]) -> Self:
         review_user = cls(state, user)
-        review_user.number_of_reviews = data["num_games_owned"]
-        review_user.number_of_games_owned = data["num_reviews"]
+        review_user.number_of_reviews = data["num_reviews"]
+        review_user.number_of_apps_owned = data["num_games_owned"]
         review_user.playtime_forever = timedelta(seconds=data["playtime_forever"])
         review_user.playtime_last_two_weeks = timedelta(seconds=data["playtime_last_two_weeks"])
         review_user.playtime_at_review = timedelta(seconds=data["playtime_at_review"])
         review_user.last_played = DateTime.from_timestamp(data["last_played"])
         return review_user
 
 
-class ReviewGame(StatefulGame):
+class ReviewApp(PartialApp):
     __slots__ = ("review_status",)
 
     def __init__(self, state: ConnectionState, id: int, review_status: int):
         super().__init__(state, id=id)
         self.review_status = ReviewType.try_value(review_status)
 
 
 @dataclass(repr=False, eq=False)
 class Review(Commentable, Awardable):
-    """Represents a review for a game."""
+    """Represents a review for an app."""
 
     _AWARDABLE_TYPE = 1
     __slots__ = (
         "_state",
         "id",
         "author",
-        "game",
+        "app",
         "language",
         "content",
         "created_at",
         "updated_at",
         "recommended",
         "votes_helpful",
         "votes_funny",
@@ -103,18 +103,18 @@
     )
 
     _state: ConnectionState
     id: int
     """The ID of the review."""
     author: ReviewUser
     """The author of the review."""
-    game: ReviewGame
-    """The game being reviewed."""
+    app: ReviewApp
+    """The app being reviewed."""
     recommended: bool
-    """Whether the reviewer recommends the game."""
+    """Whether the reviewer recommends the app."""
     language: Language
     """The language the review is written in."""
     content: str
     """The contents of the review."""
     created_at: datetime
     """The time the review was created at."""
     updated_at: datetime
@@ -126,47 +126,46 @@
     weighted_vote_score: float
     """The weighted score from Steam."""
     commentable: bool | None
     """Whether the author has allowed comments on the review."""
     comment_count: int
     """The amount of comments this review has."""
     steam_purchase: bool | None
-    """Whether the game was purchased through Steam."""
+    """Whether the app was purchased through Steam."""
     received_compensation: bool
     """Whether the reviewer received compensation for this review."""
     written_during_early_access: bool
-    """Whether the reviewer played the game the game during """
+    """Whether the reviewer played the app the app during early access."""
     developer_response: str | None
     """The developer's response to the review."""
     developer_responded_at: datetime | None
     """The time the developer responded to the review."""
     reactions: list[AwardReaction] | None
     """The review's reactions."""
 
     def __repr__(self) -> str:
-        return f"<{self.__class__.__name__} id={self.id} game={self.game!r} author={self.author!r}>"
+        return f"<{self.__class__.__name__} id={self.id} app={self.app!r} author={self.author!r}>"
 
     def __eq__(self, other: object) -> bool:
         return self.id == other.id if isinstance(other, self.__class__) else NotImplemented
 
     @property
     def _commentable_kwargs(self) -> _CommentableKwargs:
         return {
-            "thread_type": 8,
             "id64": self.author.id64,
-            "gidfeature": self.game.id,
+            "forum_id": self.app.id,
         }
 
     @classmethod
     def _from_proto(cls, state: ConnectionState, review: ReviewProto, user: User) -> Self:
         return cls(
             state,
             id=review.recommendationid,
             author=ReviewUser._from_proto(state, user, review),
-            game=ReviewGame(state, review.appid, review.review_quality),
+            app=ReviewApp(state, review.appid, review.review_quality),
             language=Language.from_str(review.language),
             content=review.review,
             created_at=DateTime.from_timestamp(review.time_created),
             updated_at=DateTime.from_timestamp(review.time_updated),
             recommended=review.voted_up,
             votes_funny=review.votes_funny,
             votes_helpful=review.votes_up,
@@ -182,20 +181,20 @@
                 if review.time_developer_responded
                 else None  # TODO add the rest of the developer attrs
             ),
             reactions=[AwardReaction(state, reaction) for reaction in review.reactions],
         )
 
     @classmethod
-    def _from_data(cls, state: ConnectionState, data: dict[str, Any], game: ReviewGame, user: User) -> Self:
+    def _from_data(cls, state: ConnectionState, data: dict[str, Any], app: ReviewApp, user: User) -> Self:
         return cls(
             state,
             id=data["recommendationid"],
             author=ReviewUser._from_data(state, user, data["author"]),
-            game=game,
+            app=app,
             language=Language.from_str(data["language"]),
             content=data["review"],
             created_at=DateTime.from_timestamp(data["timestamp_created"]),
             updated_at=DateTime.from_timestamp(data["timestamp_updated"]),
             recommended=data["voted_up"],
             votes_funny=data["votes_funny"],
             votes_helpful=data["votes_up"],
```

### Comparing `steamio-0.9.9/steam/role.py` & `steamio-1.0.0a0/steam/role.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
-from typing import TYPE_CHECKING, Any
+from typing import TYPE_CHECKING
 
 from typing_extensions import Self
 
 if TYPE_CHECKING:
     from .chat import Member
     from .clan import Clan
     from .group import Group
@@ -21,15 +21,15 @@
 
 class Role:
     __slots__ = ("id", "name", "ordinal", "clan", "group", "permissions", "_state")
 
     def __init__(self, state: ConnectionState, group: Clan | Group, role: chat.Role, permissions: chat.RoleActions):
         self._state = state
         self.id = int(role.role_id)
-        self.name = role.name[len("#ChatRoomRole_") :]  # str.removeprefix
+        self.name = role.name.removeprefix("#ChatRoomRole_")
         self.ordinal = role.ordinal
 
         from .clan import Clan
 
         if isinstance(group, Clan):
             self.clan = group
             self.group = None
@@ -86,24 +86,24 @@
         self.read_message_history = proto.can_view_history
         self.change_group_roles = proto.can_change_group_roles
         self.change_user_roles = proto.can_change_user_roles
         self.mention_all = proto.can_mention_all
         self.set_watching_broadcast = proto.can_set_watching_broadcast
 
     def copy(self) -> Self:
-        return self.__class__(chat.RoleActions(**self.to_dict()))
+        return self.__class__(self.to_proto())
 
     __copy__ = copy
 
-    def to_dict(self) -> dict[str, bool]:
-        return {
-            "can_kick": self.kick,
-            "can_ban": self.ban_members,
-            "can_invite": self.invite,
-            "can_change_tagline_avatar_name": self.manage_group,
-            "can_chat": self.send_messages,
-            "can_view_history": self.read_message_history,
-            "can_change_group_roles": self.change_group_roles,
-            "can_change_user_roles": self.change_user_roles,
-            "can_mention_all": self.mention_all,
-            "can_set_watching_broadcast": self.set_watching_broadcast,
-        }
+    def to_proto(self) -> chat.RoleActions:
+        return chat.RoleActions(
+            can_kick=self.kick,
+            can_ban=self.ban_members,
+            can_invite=self.invite,
+            can_change_tagline_avatar_name=self.manage_group,
+            can_chat=self.send_messages,
+            can_view_history=self.read_message_history,
+            can_change_group_roles=self.change_group_roles,
+            can_change_user_roles=self.change_user_roles,
+            can_mention_all=self.mention_all,
+            can_set_watching_broadcast=self.set_watching_broadcast,
+        )
```

### Comparing `steamio-0.9.9/steam/state.py` & `steamio-1.0.0a0/steam/state.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,146 +10,143 @@
 from collections import defaultdict, deque
 from collections.abc import Callable, Collection, Iterable, Sequence
 from copy import copy
 from datetime import datetime, timedelta
 from itertools import count
 from operator import attrgetter
 from time import time
-from typing import TYPE_CHECKING, Any, Generic, TypeVar
+from typing import TYPE_CHECKING, Any
 
 from bs4 import BeautifulSoup
 from typing_extensions import Self
 from yarl import URL as URL_
 
 from . import utils
 from ._const import HTML_PARSER, URL, VDF_BINARY_LOADS, VDF_LOADS
-from .abc import Awardable, BaseUser, Commentable, SteamID
+from .abc import Awardable, BaseUser, Commentable
 from .channel import DMChannel
 from .clan import Clan
 from .comment import Comment
 from .enums import *
 from .errors import *
 from .friend import Friend
 from .group import Group
 from .guard import *
+from .id import ID, parse_id64
 from .invite import ClanInvite, UserInvite
-from .manifest import ContentServer, GameInfo, Manifest, PackageInfo
+from .manifest import AppInfo, ContentServer, Manifest, PackageInfo
 from .message import *
 from .message import ClanMessage
 from .models import Registerable, register
 from .package import License
 from .protobufs import (
     EMsg,
-    Msg,
-    MsgProto,
+    ProtobufMessage,
+    UnifiedMessage,
     app_info,
     chat,
+    clan,
     client_server,
     client_server_2,
     comments,
     content_server,
-    do_nothing_case,
     econ,
+    encrypted_app_ticket,
     friend_messages,
     friends,
     game_servers,
     login,
     loyalty_rewards,
     player,
     published_file,
     reviews,
-    struct_messages,
+    store,
 )
 from .published_file import PublishedFile
 from .reaction import (
     Award,
     ClientEmoticon,
     ClientSticker,
     Emoticon,
     MessageReaction,
     ReactionProtocol,
     Sticker,
     _Reaction,
 )
 from .role import RolePermissions
 from .trade import TradeOffer
-from .types.id import ID32
+from .types.id import ID32, ID64, AppID, CacheKey, ChatGroupID, ChatID, Intable
 from .user import ClientUser, User
-from .utils import DateTime
+from .utils import DateTime, cached_property
 
 if TYPE_CHECKING:
     from .abc import Message
     from .client import Client
-    from .gateway import SteamWebSocket
-    from .types import game, trade, user
+    from .gateway import CMServer, SteamWebSocket
+    from .types import trade
     from .types.http import Coro
-    from .types.id import ID64, ChannelID, ChatGroupID
 
 log = logging.getLogger(__name__)
 
 
-T = TypeVar("T")
-
-
-class Queue(Generic[T]):
-    def __init__(self, attr: attrgetter[int] = attrgetter("id")) -> None:
-        self.queue: list[T] = []
-        self.attr = attr
-        self._waiting_for: dict[int, asyncio.Future[T]] = {}
-
-    async def wait_for(self, id: int) -> T:
-        for item in reversed(self.queue):  # check if it's already here
-            if self.attr(item) == id:
-                self.queue.remove(item)
-                return item
+class TradeQueue:
+    def __init__(self):
+        self.queue: list[TradeOffer] = []
+        self._waiting_for: dict[int, asyncio.Future[TradeOffer]] = {}
+
+    async def wait_for(self, id: int) -> TradeOffer:
+        for trade in reversed(self.queue):  # check if it's already here
+            if trade.id == id:
+                self.queue.remove(trade)
+                return trade
 
         self._waiting_for[id] = future = asyncio.get_running_loop().create_future()
-        item = await future
-        self.queue.remove(item)
-        return item
+        trade = await future
+        self.queue.remove(trade)
+        return trade
 
     def __len__(self) -> int:
         return len(self.queue)
 
-    def __iadd__(self, other: Iterable[T]) -> Self:
-        for item in other:
-            attr = self.attr(item)
+    def __iadd__(self, other: list[TradeOffer]) -> Self:
+        for trade in other:
             try:
-                future = self._waiting_for[attr]
+                future = self._waiting_for[trade.id]
             except KeyError:
                 pass
             else:
-                future.set_result(item)
-                del self._waiting_for[attr]
+                future.set_result(trade)
+                del self._waiting_for[trade.id]
 
         self.queue += other
         return self
 
 
 class ConnectionState(Registerable):
-    parsers: dict[EMsg, Callable]
+    parsers: dict[EMsg, Callable[..., Any]]
 
     def __init__(self, client: Client, **kwargs: Any):
         self.client = client
         self.dispatch = client.dispatch
         self.http = client.http
 
         self.handled_friends = asyncio.Event()
         self.handled_emoticons = asyncio.Event()
         self.handled_chat_groups = asyncio.Event()
         self.handled_group_members = asyncio.Event()
+        self.login_complete = asyncio.Event()
         self.handled_licenses = asyncio.Event()
-        self.max_messages: int = kwargs.pop("max_messages", 1000)
+        self.max_messages: int | None = kwargs.pop("max_messages", 1000)
 
-        game = kwargs.get("game")
-        games = kwargs.get("games")
-        games = [game.to_dict() for game in games] if games is not None else []
-        if game is not None:
-            games.append(game.to_dict())
-        self._games: list[game.GameToDict] = games
+        app = kwargs.get("app")
+        apps = kwargs.get("apps")
+        apps = [app.to_proto() for app in apps] if apps is not None else []
+        if app is not None:
+            apps.append(app.to_proto())
+        self._apps: list[client_server.CMsgClientGamesPlayedGamePlayed] = apps
         self._state: PersonaState = kwargs.get("state", PersonaState.Online)
         self._ui_mode: UIMode = kwargs.get("ui_mode", UIMode.Desktop)
         self._flags: PersonaStateFlag = kwargs.get("flags", PersonaStateFlag.NONE)
         self._force_kick: bool = kwargs.get("force_kick", False)
         self.auto_chunk_chat_groups: bool = kwargs.get("auto_chunk_chat_groups", False)
 
         self.clear()
@@ -159,47 +156,45 @@
         self._trades: dict[int, TradeOffer] = {}
 
         self._groups: dict[ChatGroupID, Group] = {}
         self._clans: dict[ID32, Clan] = {}
         self._clans_by_chat_id: dict[ChatGroupID, Clan] = {}
         self.chat_group_to_view_id: defaultdict[ChatGroupID, int] = defaultdict(count().__next__)
         self.active_chat_groups: set[ChatGroupID] = set()
-        self.chat_group_members_waiting: dict[tuple[int, int], asyncio.Future[list[User]]] = {}
 
         self._confirmations: dict[int, Confirmation] = {}
         self.confirmation_generation_locks: dict[str, tuple[asyncio.Lock, datetime]] = {}
         self._confirmations_to_ignore: list[int] = []
         self._messages: deque[Message] = deque(maxlen=self.max_messages or 0)
         self.invites: dict[ID64, UserInvite | ClanInvite] = {}
         self.emoticons: list[ClientEmoticon] = []
         self.stickers: list[ClientSticker] = []
 
         self.polling_trades = False
-        self.trade_queue = Queue[TradeOffer]()
+        self.trade_queue = TradeQueue()
         self._trades_to_watch: set[int] = set()
         self._trades_received_cache: Sequence[dict[str, Any]] = ()
         self._trades_sent_cache: Sequence[dict[str, Any]] = ()
-        self.polling_confirmations = False
-        self.confirmation_queue = Queue[Confirmation](attr=attrgetter("creator_id"))
+
+        self.cell_id = 0
+        self._connected_cm: CMServer | None = None
 
         self.licenses: dict[int, License] = {}
         self._manifest_passwords: dict[int, dict[str, str]] = {}
         self.cs_servers: list[ContentServer] = []
-        self.cs_lock = asyncio.Lock()
 
         self.handled_friends.clear()
         self.handled_emoticons.clear()
         self.handled_chat_groups.clear()
         self.handled_licenses.clear()
 
     async def __ainit__(self) -> None:
-        if self.http.api_key is not None:
-            self._device_id = generate_device_id(self.user)
+        self._device_id = generate_device_id(self.user)
 
-            await self.poll_trades()
+        await self.poll_trades()
 
     @utils.cached_property
     def ws(self) -> SteamWebSocket:
         assert self.client.ws is not None
         return self.client.ws
 
     @utils.cached_property
@@ -236,41 +231,31 @@
     @property
     def confirmations(self) -> list[Confirmation]:
         return list(self._confirmations.values())
 
     def get_user(self, id: ID32) -> User | None:
         return self._users.get(id)
 
-    async def fetch_user(self, user_id64: int) -> User | None:
-        data = await self.http.get_user(user_id64)
-        return self._store_user(data) if data else None
-        # return (await self.fetch_users([user_id64]))[0]
-
-    async def fetch_users(self, user_id64s: Iterable[int]) -> list[User | None]:
-        resp = await self.http.get_users(user_id64s)
-        """
-        msg: MsgProto[CMsgClientRequestFriendData] = MsgProto(
-            EMsg.ClientRequestFriendData,
-            persona_state_requested=863,  # 1 | 2 | 4 | 8 | 16 | 64 | 256 | 512  corresponds to EClientPersonaStateFlag
-            friends=user_id64s,
-        )
-        await self.ws.send_as_proto(msg)
-        """
-
-        return [self._store_user(data) for data in resp]
-
-    async def _maybe_user(self, id64: ID64) -> User | SteamID:
-        steam_id = SteamID(id64)
-        return self.get_user(steam_id.id) or await self.fetch_user(id64) or steam_id
+    async def fetch_user(self, user_id64: ID64) -> User | None:
+        (user,) = await self.fetch_users((user_id64,))
+        return user
+
+    async def fetch_users(self, user_id64s: Iterable[ID64]) -> list[User]:
+        friends = await self.ws.fetch_users(user_id64s)
+        return [self._store_user(user) for user in friends]
+
+    async def _maybe_user(self, id: Intable) -> User | ID:
+        steam_id = ID(id)
+        return self.get_user(steam_id.id) or await self.fetch_user(steam_id.id64) or steam_id
 
-    async def _maybe_users(self, id64s: Iterable[ID64]) -> list[User | SteamID]:
-        ret: list[User | SteamID] = []
+    async def _maybe_users(self, id64s: Iterable[ID64]) -> list[User | ID]:
+        ret: list[User | ID] = []
         to_fetch: dict[ID64, list[int]] = {}
         for idx, id64 in enumerate(id64s):
-            steam_id = SteamID(id64)
+            steam_id = ID(id64, type=Type.Individual)
             user = self.get_user(steam_id.id)
             if user is not None:
                 ret.append(user)
             else:
                 idxs = to_fetch.get(id64)
                 if idxs is None:
                     idxs = to_fetch[id64] = []
@@ -282,63 +267,69 @@
             for idxs, user in zip(to_fetch.values(), await self.fetch_users(to_fetch)):
                 if user is not None:
                     for idx in idxs:
                         ret[idx] = user
 
         return ret
 
-    def _store_user(self, data: user.User) -> User:
+    def _store_user(self, proto: friends.CMsgClientPersonaStateFriend) -> User:
         try:
-            user = self._users[int(data["steamid"]) & 0xFFFFFFFF]
+            user = self._users[proto.friendid & 0xFFFFFFFF]  # type: ignore
         except KeyError:
-            user = User(state=self, data=data)
+            user = User(state=self, proto=proto)
             self._users[user.id] = user
         else:
-            user._update(data)
+            user._update(proto)
         return user
 
     def get_friend(self, id64: ID64) -> Friend:
         return self.user._friends[id64]
 
+    def get_confirmation(self, id: int) -> Confirmation | None:
+        return self._confirmations.get(id)
+
+    async def fetch_confirmation(self, id: int) -> Confirmation | None:
+        await self._fetch_confirmations()
+        return self.get_confirmation(id)
+
     def get_group(self, id: ChatGroupID) -> Group | None:
         return self._groups.get(id)
 
     def get_clan(self, id: ID32) -> Clan | None:
         return self._clans.get(id)
 
     async def fetch_clan(self, id64: ID64, *, maybe_chunk: bool = True) -> Clan | None:
-        msg: MsgProto[chat.GetClanChatRoomInfoResponse] = await self.ws.send_um_and_wait(
-            "ClanChatRooms.GetClanChatRoomInfo", steamid=id64
+        msg: chat.GetClanChatRoomInfoResponse = await self.ws.send_um_and_wait(
+            chat.GetClanChatRoomInfoRequest(steamid=id64)
         )
         if msg.result == Result.Busy:
             raise WSNotFound(msg)
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        clan = await Clan._from_proto(self, msg.body.chat_group_summary, maybe_chunk=maybe_chunk)
+        clan = await Clan._from_proto(self, msg.chat_group_summary, maybe_chunk=maybe_chunk)
         self._clans[clan.id] = clan
         return clan
 
     def get_trade(self, id: int) -> TradeOffer | None:
         return self._trades.get(id)
 
     async def fetch_trade(self, id: int, language: Language | None) -> TradeOffer | None:
         resp = await self.http.get_trade(id, language)
-        data = resp.get("response")
-        if data:
-            trades = await self._process_trades((data["offer"],), data.get("descriptions", ()))
-            return trades[0]
+        if data := resp.get("response"):
+            (trade,) = await self._process_trades((data["offer"],), data.get("descriptions", ()))
+            return trade
 
     async def _store_trade(self, data: trade.TradeOffer) -> TradeOffer:
         try:
             trade = self._trades[int(data["tradeofferid"])]
         except KeyError:
             log.info(f'Received trade #{data["tradeofferid"]}')
             trade = TradeOffer._from_api(
-                state=self, data=data, partner=await self._maybe_user(utils.make_id64(data["accountid_other"]))
+                state=self, data=data, partner=await self._maybe_user(utils.parse_id64(data["accountid_other"]))
             )
             self._trades[trade.id] = trade
             if trade.state in (TradeOfferState.Active, TradeOfferState.ConfirmationNeed) and (
                 trade.items_to_send or trade.items_to_receive  # trade could be glitched
             ):
                 self.dispatch("trade_send" if trade.is_our_offer() else "trade_receive", trade)
                 self._trades_to_watch.add(trade.id)
@@ -352,28 +343,28 @@
                     self.dispatch(f"trade_{event_name}", trade)
                     self._trades_to_watch.discard(trade.id)
         return trade
 
     async def _process_trades(
         self, trades: Iterable[trade.TradeOffer], descriptions: Collection[trade.Description]
     ) -> list[TradeOffer]:
-        ret = []
+        ret: list[TradeOffer] = []
         for trade in trades:
-            for item in descriptions:
+            for description in descriptions:
                 for asset in trade.get("items_to_receive", ()):
-                    if item["classid"] == asset["classid"] and item["instanceid"] == asset["instanceid"]:
-                        asset.update(item)
+                    if description["classid"] == asset["classid"] and description["instanceid"] == asset["instanceid"]:
+                        asset.update(description)
                 for asset in trade.get("items_to_give", ()):
-                    if item["classid"] == asset["classid"] and item["instanceid"] == asset["instanceid"]:
-                        asset.update(item)
+                    if description["classid"] == asset["classid"] and description["instanceid"] == asset["instanceid"]:
+                        asset.update(description)
             ret.append(await self._store_trade(trade))
         return ret
 
     async def poll_trades(self) -> None:
-        if self.polling_trades or not self.http.api_key:
+        if self.polling_trades or not await self.http.get_api_key():
             return
 
         self.polling_trades = True
         try:
             await self.fill_trades()
 
             while self._trades_to_watch:  # watch trades for changes
@@ -403,184 +394,174 @@
 
     async def wait_for_trade(self, id: int) -> TradeOffer:
         self.loop.create_task(self.poll_trades())  # start re-polling trades
         return await self.trade_queue.wait_for(id=id)
 
     # confirmations
 
-    def get_confirmation(self, id: int) -> Confirmation | None:
-        return self._confirmations.get(id)
-
-    async def fetch_confirmation(self, id: int) -> Confirmation | None:
-        await self.fill_confirmations()
-        return self._confirmations.get(id)
-
-    async def fill_confirmations(self) -> None:
-        key, timestamp = await self._generate_confirmation_code("list")
-        data = await self.http.get(
-            URL.COMMUNITY / "mobileconf/getlist",
-            params={"p": self._device_id, "a": self.user.id64, "k": key, "t": timestamp, "m": "react", "tag": "list"},
-        )
-        if not data.get("success", False):
-            raise ConfirmationError(f"{data.get('message', 'Unknown error')}\n{data.get('detail') or ''}".strip())
-
-        confirmations: list[Confirmation] = []
-        for confirmation in data["conf"]:
-            confirmation_ = Confirmation(
-                self, int(confirmation["id"]), int(confirmation["nonce"]), int(confirmation["creator_id"])
-            )
-            self._confirmations[confirmation_.creator_id] = confirmation_
-            confirmations.append(confirmation_)
-        self.confirmation_queue += confirmations
-
     async def _create_confirmation_params(self, tag: str) -> dict[str, Any]:
         code, timestamp = await self._generate_confirmation_code(tag)
         return {
             "p": self._device_id,
             "a": self.user.id64,
             "k": code,
             "t": timestamp,
             "m": "android",
             "tag": tag,
         }
 
+    async def _fetch_confirmations(self) -> dict[int, Confirmation]:
+        params = await self._create_confirmation_params("conf")
+        headers = {"X-Requested-With": "com.valvesoftware.android.steam.community"}
+        resp = await self.http.get(URL.COMMUNITY / "mobileconf/conf", params=params, headers=headers)
+
+        if "incorrect Steam Guard codes." in resp:
+            raise InvalidCredentials("identity_secret is incorrect")
+
+        soup = BeautifulSoup(resp, HTML_PARSER)
+        if soup.select("#mobileconf_empty"):
+            return self._confirmations
+        for confirmation in soup.select("#mobileconf_list .mobileconf_list_entry"):
+            data_conf_id = confirmation["data-confid"]
+            key = confirmation["data-key"]
+            trade_id = int(confirmation.get("data-creator", 0))
+            confirmation_id = confirmation["id"].split("conf")[1]
+            if trade_id in self._confirmations_to_ignore:
+                continue
+            self._confirmations[trade_id] = Confirmation(self, confirmation_id, data_conf_id, key, trade_id)
+
+        return self._confirmations
+
     async def _generate_confirmation_code(self, tag: str) -> tuple[str, int]:
         # generate a confirmation code for a given tag at this instant.
         # this can wait x amount of time (<1s) for the code to be generated if codes would collide as they can only be
         # used once.
         secret = self.client.identity_secret
         if secret is None:
             raise ValueError("Cannot generate confirmation codes without passing an identity_secret")
 
         steam_time = self.steam_time
         timestamp = int(steam_time.timestamp())
         try:
             lock, last_confirmation_time = self.confirmation_generation_locks[tag]
         except KeyError:
             lock = asyncio.Lock()
-            last_confirmation_time = steam_time - timedelta(seconds=2)
+            last_confirmation_time = DateTime.now() - timedelta(seconds=2)
             self.confirmation_generation_locks[tag] = lock, last_confirmation_time
 
         await lock.acquire()
         try:
             return generate_confirmation_code(secret, tag, timestamp), timestamp
         finally:
             # wait for the next second whole before allowing generation of a new confirmation code
             next_code_valid_in = (steam_time.replace(microsecond=0) - last_confirmation_time).total_seconds()
             if next_code_valid_in < 0:
                 lock.release()
             else:
                 asyncio.get_running_loop().call_later(next_code_valid_in, lock.release)
             self.confirmation_generation_locks[tag] = lock, steam_time
 
-    async def poll_confirmations(self) -> None:
-        if self.polling_confirmations:
-            return
-
-        self.polling_confirmations = True
-        try:
-            await self.fill_confirmations()
-
-            while self.confirmation_queue.queue:
-                await asyncio.sleep(10)
-                await self.fill_confirmations()
-        finally:
-            self.polling_confirmations = False
-
-    async def wait_for_confirmation(self, id: int) -> Confirmation:
-        self.loop.create_task(self.poll_confirmations())
-        return await self.confirmation_queue.wait_for(id=id)
-
     async def fetch_and_confirm_confirmation(self, trade_id: int) -> bool:
         if self.client.identity_secret:
-            confirmation = await self.wait_for_confirmation(id=trade_id)
+            confirmation = self.get_confirmation(trade_id) or await self.fetch_confirmation(trade_id)
             if confirmation is not None:
                 await confirmation.confirm()
                 return True
 
         return False
 
     # ws stuff
 
-    @property
+    @cached_property
     def _chat_groups(self) -> utils.ChainMap[ChatGroupID, Group | Clan]:
         return utils.ChainMap(self._clans_by_chat_id, self._groups)  # type: ignore  # needs HKT
 
-    async def send_user_message(self, user_id64: int, content: str) -> UserMessage:
+    async def send_user_message(self, user_id64: ID64, content: str) -> UserMessage:
         contains_bbcode = utils.contains_bbcode(content)
-        msg: MsgProto[friend_messages.SendMessageResponse] = await self.ws.send_um_and_wait(
-            "FriendMessages.SendMessage",
-            steamid=user_id64,
-            message=content.replace("[", "\\[") if contains_bbcode else content,
-            chat_entry_type=ChatEntryType.Text,
-            contains_bbcode=contains_bbcode,
+        msg: friend_messages.SendMessageResponse = await self.ws.send_um_and_wait(
+            friend_messages.SendMessageRequest(
+                steamid=user_id64,
+                message=content.replace("[", "\\[") if contains_bbcode else content,
+                chat_entry_type=ChatEntryType.Text,
+                contains_bbcode=contains_bbcode,
+            )
         )
 
         if msg.result == Result.LimitExceeded:
             raise WSForbidden(msg)
         if msg.result != Result.OK:
             raise WSException(msg)
 
         proto = friend_messages.IncomingMessageNotification(
             chat_entry_type=ChatEntryType.Text,
             message=content,
-            rtime32_server_timestamp=msg.body.server_timestamp,
-            ordinal=msg.body.ordinal,
-            message_no_bbcode=msg.body.message_without_bb_code,
+            rtime32_server_timestamp=msg.server_timestamp,
+            ordinal=msg.ordinal,
+            message_no_bbcode=msg.message_without_bb_code,
         )
         channel = DMChannel(state=self, participant=self.get_user(user_id64 & 0xFFFFFFFF))  # type: ignore
         message = UserMessage(proto=proto, channel=channel)
         message.author = self.user
         self._messages.append(message)
         self.dispatch("message", message)
 
         return message
 
-    async def send_user_typing(self, user_id64: int) -> None:
-        await self.ws.send_um(
-            "FriendMessages.SendMessage",
-            steamid=user_id64,
-            chat_entry_type=ChatEntryType.Typing,
+    async def send_user_typing(self, user_id64: ID64) -> None:
+        msg = await self.ws.send_um_and_wait(
+            friend_messages.SendMessageRequest(
+                steamid=user_id64,
+                chat_entry_type=ChatEntryType.Typing,
+            )
         )
+        if msg.result != Result.OK:
+            raise WSException(msg)
         self.dispatch("typing", self.user, DateTime.now())
 
     async def react_to_user_message(
-        self, user_id64: int, server_timestamp: int, ordinal: int, reaction_name: str, reaction_type: int, is_add: bool
+        self,
+        user_id64: ID64,
+        server_timestamp: int,
+        ordinal: int,
+        reaction_name: str,
+        reaction_type: friend_messages.EMessageReactionType,
+        is_add: bool,
     ) -> None:
         await self.ws.send_um_and_wait(
-            "FriendMessages.UpdateMessageReaction",
-            steamid=user_id64,
-            server_timestamp=server_timestamp,
-            ordinal=ordinal,
-            reaction=reaction_name,
-            reaction_type=reaction_type,
-            is_add=is_add,
+            friend_messages.UpdateMessageReactionRequest(
+                steamid=user_id64,
+                server_timestamp=server_timestamp,
+                ordinal=ordinal,
+                reaction=reaction_name,
+                reaction_type=reaction_type,
+                is_add=is_add,
+            )
         )
 
     async def send_chat_message(
-        self, chat_group_id: ChatGroupID, chat_id: ChannelID, content: str
+        self, chat_group_id: ChatGroupID, chat_id: ChatID, content: str
     ) -> ClanMessage | GroupMessage:
-        msg: MsgProto[chat.SendChatMessageResponse] = await self.ws.send_um_and_wait(
-            "ChatRoom.SendChatMessage", chat_id=chat_id, chat_group_id=chat_group_id, message=content
+        msg: chat.SendChatMessageResponse = await self.ws.send_um_and_wait(
+            chat.SendChatMessageRequest(chat_id=chat_id, chat_group_id=chat_group_id, message=content)
         )
 
         if msg.result == Result.LimitExceeded:
             raise WSForbidden(msg)
         if msg.result == Result.InvalidParameter:
             raise WSNotFound(msg)
         if msg.result != Result.OK:
             raise WSException(msg)
 
         proto = chat.IncomingChatMessageNotification(
             chat_id=chat_id,
             chat_group_id=chat_group_id,
             steamid_sender=0,
             message=content,
-            ordinal=msg.body.ordinal,
-            message_no_bbcode=msg.body.message_without_bb_code,
+            ordinal=msg.ordinal,
+            message_no_bbcode=msg.message_without_bb_code,
             timestamp=int(time()),
         )
         group = self._chat_groups[chat_group_id]
         channel = group._channels[chat_id]
         channel._update(proto)
 
         message = (ClanMessage if isinstance(group, Clan) else GroupMessage)(
@@ -592,407 +573,431 @@
         self.dispatch("message", message)
 
         return message
 
     async def react_to_chat_message(
         self,
         chat_group_id: ChatGroupID,
-        chat_id: ChannelID,
+        chat_id: ChatID,
         server_timestamp: int,
         ordinal: int,
         reaction_name: str,
-        reaction_type: int,
+        reaction_type: chat.EChatRoomMessageReactionType,
         is_add: bool,
     ) -> None:
         msg = await self.ws.send_um_and_wait(
-            "ChatRoom.UpdateMessageReaction",
-            chat_group_id=chat_group_id,
-            chat_id=chat_id,
-            server_timestamp=server_timestamp,
-            ordinal=ordinal,
-            reaction=reaction_name,
-            reaction_type=reaction_type,
-            is_add=is_add,
+            chat.UpdateMessageReactionRequest(
+                chat_group_id=chat_group_id,
+                chat_id=chat_id,
+                server_timestamp=server_timestamp,
+                ordinal=ordinal,
+                reaction=reaction_name,
+                reaction_type=reaction_type,
+                is_add=is_add,
+            )
         )
 
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def join_chat_group(self, chat_group_id: ChatGroupID, invite_code: str | None = None) -> None:
         msg = await self.ws.send_um_and_wait(
-            "ChatRoom.JoinChatRoomGroup", chat_group_id=chat_group_id, invite_code=invite_code or ""
+            chat.JoinChatRoomGroupRequest(chat_group_id=chat_group_id, invite_code=invite_code or "")
         )
 
         if msg.result == Result.InvalidParameter:
             raise WSNotFound(msg)
         elif msg.result != Result.OK:
             raise WSException(msg)
 
     async def leave_chat_group(self, chat_group_id: ChatGroupID) -> None:
-        msg = await self.ws.send_um_and_wait("ChatRoom.LeaveChatRoomGroup", chat_group_id=chat_group_id)
+        msg = await self.ws.send_um_and_wait(chat.LeaveChatRoomGroupRequest(chat_group_id=chat_group_id))
 
         if msg.result == Result.InvalidParameter:
             raise WSNotFound(msg)
         elif msg.result != Result.OK:
             raise WSException(msg)
 
-    async def invite_user_to_chat_group(self, user_id64: int, chat_group_id: ChatGroupID) -> None:
+    async def invite_user_to_chat_group(self, user_id64: ID64, chat_group_id: ChatGroupID) -> None:
         msg = await self.ws.send_um_and_wait(
-            "ChatRoom.InviteFriendToChatRoomGroup", chat_group_id=chat_group_id, steamid=user_id64
+            chat.InviteFriendToChatRoomGroupRequest(chat_group_id=chat_group_id, steamid=user_id64)
         )
 
         if msg.result == Result.InvalidParameter:
             raise WSNotFound(msg)
         elif msg.result != Result.OK:
             raise WSException(msg)
 
-    async def request_chat_group_members(
+    async def fetch_chat_group_members(
         self,
         chat_group_id: ChatGroupID,
         view_id: int,
         client_change_number: int,
         start: int,
         stop: int,
     ) -> list[User]:
-        self.chat_group_members_waiting[(view_id, client_change_number)] = future = asyncio.Future()
-        await self.ws.send_um(
-            "ChatRoom.UpdateMemberListView",
-            chat_group_id=chat_group_id,
-            view_id=view_id,
-            start=start,
-            end=stop,
-            client_changenumber=client_change_number,
-        )
-        return await future
-
-    def handle_member_list_view_update(self, msg: MsgProto[chat.MemberListViewUpdatedNotification]):
-        self.chat_group_members_waiting[msg.body.view_id, msg.body.view.client_changenumber].set_result(
-            [self._store_user(self.patch_user_from_ws({}, member.persona)) for member in msg.body.members]
+        fut = self.ws.wait_for(
+            chat.MemberListViewUpdatedNotification,
+            check=lambda msg: (
+                isinstance(msg, chat.MemberListViewUpdatedNotification)
+                and msg.view_id == view_id
+                and msg.view.client_changenumber == client_change_number
+            ),
+        )
+        await self.ws.send_um(  # send_um_and_wait doesn't work here cause job_id is not meant to be set
+            chat.UpdateMemberListViewNotification(
+                chat_group_id=chat_group_id,
+                view_id=view_id,
+                start=start,
+                end=stop,
+                client_changenumber=client_change_number,
+            )
         )
+        msg = await fut
+        return [self._store_user(member.persona) for member in msg.members]
 
     async def edit_role_name(self, chat_group_id: ChatGroupID, role_id: int, name: str) -> None:
-        msg = await self.ws.send_um_and_wait(
-            "ChatRoom.RenameRole", chat_group_id=chat_group_id, role_id=role_id, name=name
+        msg: ProtobufMessage = await self.ws.send_um_and_wait(
+            chat.RenameRoleRequest(chat_group_id=chat_group_id, role_id=role_id, name=name)
         )
         if msg.result == Result.InvalidParameter:
             raise WSNotFound(msg)
         elif msg.result != Result.OK:
             raise WSException(msg)
 
     async def edit_role_permissions(
         self, chat_group_id: ChatGroupID, role_id: int, permissions: RolePermissions
     ) -> None:
         msg = await self.ws.send_um_and_wait(
-            "ChatRoom.ReplaceRoleActions",
-            chat_group_id=chat_group_id,
-            role_id=role_id,
-            actions=permissions.to_dict(),
+            chat.ReplaceRoleActionsRequest(
+                chat_group_id=chat_group_id,
+                role_id=role_id,
+                actions=permissions.to_proto(),
+            )
         )
         if msg.result == Result.InvalidParameter:
             raise WSNotFound(msg)
         elif msg.result != Result.OK:
             raise WSException(msg)
 
     async def delete_role(self, chat_group_id: ChatGroupID, role_id: int) -> None:
-        msg = await self.ws.send_um_and_wait("ChatRoom.DeleteRole", chat_group_id=chat_group_id, role_id=role_id)
+        msg = await self.ws.send_um_and_wait(chat.DeleteRoleRequest(chat_group_id=chat_group_id, role_id=role_id))
         if msg.result == Result.InvalidParameter:
             raise WSNotFound(msg)
         elif msg.result != Result.OK:
             raise WSException(msg)
 
     async def fetch_user_history(
         self,
         user_id64: ID64,
         start: int,
         last: int,
         start_ordinal: int = 0,
     ) -> friend_messages.GetRecentMessagesResponse:
-        msg: MsgProto[friend_messages.GetRecentMessagesResponse] = await self.ws.send_um_and_wait(
-            "FriendMessages.GetRecentMessages",
-            steamid1=self.user.id64,
-            steamid2=user_id64,
-            rtime32_start_time=start,
-            bbcode_format=False,
-            time_last=last,
-            start_ordinal=start_ordinal,
-            count=100,
+        msg: friend_messages.GetRecentMessagesResponse = await self.ws.send_um_and_wait(
+            friend_messages.GetRecentMessagesRequest(
+                steamid1=self.user.id64,
+                steamid2=user_id64,
+                rtime32_start_time=start,
+                bbcode_format=False,
+                time_last=last,
+                start_ordinal=start_ordinal,
+                count=100,
+            )
         )
 
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body
+        return msg
 
-    async def fetch_group_history(
-        self, chat_group_id: ChatGroupID, chat_id: ChannelID, start: int, last: int, last_ordinal: int
+    async def fetch_chat_group_history(
+        self, chat_group_id: ChatGroupID, chat_id: ChatID, start: int, last: int, last_ordinal: int
     ) -> chat.GetMessageHistoryResponse:
-        msg: MsgProto[chat.GetMessageHistoryResponse] = await self.ws.send_um_and_wait(
-            "ChatRoom.GetMessageHistory",
-            chat_group_id=chat_group_id,
-            chat_id=chat_id,
-            last_time=last,
-            start_time=start,
-            last_ordinal=last_ordinal,
-            max_count=100,
+        msg: chat.GetMessageHistoryResponse = await self.ws.send_um_and_wait(
+            chat.GetMessageHistoryRequest(
+                chat_group_id=chat_group_id,
+                chat_id=chat_id,
+                last_time=last,
+                start_time=start,
+                last_ordinal=last_ordinal,
+                max_count=100,
+            )
         )
 
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body
+        return msg
 
     async def fetch_message_reactors(
         self,
         chat_group_id: ChatGroupID,
-        chat_id: ChannelID,
+        chat_id: ChatID,
         server_timestamp: int,
         ordinal: int,
         reaction_name: str,
-        reaction_type: int,
+        reaction_type: chat.EChatRoomMessageReactionType,
     ) -> list[ID32]:
-        msg: MsgProto[chat.GetMessageReactionReactorsResponse] = await self.ws.send_um_and_wait(
-            "ChatRoom.GetMessageReactionReactors",
-            chat_group_id=chat_group_id,
-            chat_id=chat_id,
-            server_timestamp=server_timestamp,
-            ordinal=ordinal,
-            reaction=reaction_name,
-            reaction_type=reaction_type,
+        msg: chat.GetMessageReactionReactorsResponse = await self.ws.send_um_and_wait(
+            chat.GetMessageReactionReactorsRequest(
+                chat_group_id=chat_group_id,
+                chat_id=chat_id,
+                server_timestamp=server_timestamp,
+                ordinal=ordinal,
+                reaction=reaction_name,
+                reaction_type=reaction_type,
+            )
         )
 
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body.reactors
+        return msg.reactors
 
     async def fetch_servers(self, query: str, limit: int) -> list[game_servers.GetServerListResponseServer]:
-        msg: MsgProto[game_servers.GetServerListResponse] = await self.ws.send_um_and_wait(
-            "GameServers.GetServerList",
-            filter=query,
-            limit=limit,
+        msg: game_servers.GetServerListResponse = await self.ws.send_um_and_wait(
+            game_servers.GetServerListRequest(
+                filter=query,
+                limit=limit,
+            )
         )
 
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body.servers
+        return msg.servers
 
-    async def fetch_server_ip_from_steam_id(self, *ids: int) -> list[game_servers.IPsWithSteamIDsResponseServer]:
-        msg: MsgProto[game_servers.IPsWithSteamIDsResponse] = await self.ws.send_um_and_wait(
-            "GameServers.GetServerIPsBySteamID",
-            server_steamids=list(ids),
+    async def fetch_server_ip_from_steam_id(self, *ids: ID64) -> list[game_servers.IPsWithSteamIDsResponseServer]:
+        msg: game_servers.IPsWithSteamIDsResponse = await self.ws.send_um_and_wait(
+            game_servers.GetServerIPsBySteamIdRequest(
+                server_steamids=list(ids),
+            )
         )
 
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body.servers
+        return msg.servers
 
     async def query_server(
         self, ip: int, port: int, app_id: int, type: game_servers.EQueryType
     ) -> game_servers.QueryResponse:
-        msg: MsgProto[game_servers.QueryResponse] = await self.ws.send_um_and_wait(
-            "GameServers.QueryByFakeIP",
-            query_type=type,
-            fake_ip=ip,  # why these are "fake" I'm not really sure
-            fake_port=port,
-            app_id=app_id,
+        msg: game_servers.QueryResponse = await self.ws.send_um_and_wait(
+            game_servers.QueryRequest(
+                query_type=type,
+                fake_ip=ip,  # why these are "fake" I'm not really sure
+                fake_port=port,
+                app_id=app_id,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body
+        return msg
 
-    async def fetch_game_player_count(self, game_id: int) -> int:
-        msg: MsgProto[client_server_2.CMsgDpGetNumberOfCurrentPlayersResponse] = await self.ws.send_proto_and_wait(
-            MsgProto(EMsg.ClientGetNumberOfCurrentPlayersDP, appid=game_id)
+    async def fetch_app_player_count(self, app_id: int) -> int:
+        msg: client_server_2.CMsgDpGetNumberOfCurrentPlayersResponse = await self.ws.send_proto_and_wait(
+            client_server_2.CMsgDpGetNumberOfCurrentPlayers(appid=app_id)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body.player_count
+        return msg.player_count
 
-    async def fetch_user_games(self, user_id64: int, include_free: bool) -> list[player.GetOwnedGamesResponseGame]:
-        msg: MsgProto[player.GetOwnedGamesResponse] = await self.ws.send_um_and_wait(
-            "Player.GetOwnedGames",
-            steamid=user_id64,
-            include_appinfo=True,
-            include_played_free_games=include_free,
+    async def fetch_user_apps(self, user_id64: ID64, include_free: bool) -> list[player.GetOwnedGamesResponseGame]:
+        msg: player.GetOwnedGamesResponse = await self.ws.send_um_and_wait(
+            player.GetOwnedGamesRequest(
+                steamid=user_id64,
+                include_appinfo=True,
+                include_played_free_games=include_free,
+            )
         )
 
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body.games
+        return msg.games
 
-    async def fetch_friend_profile_info(self, user_id64: int) -> friends.CMsgClientFriendProfileInfoResponse:
-        msg: MsgProto[friends.CMsgClientFriendProfileInfoResponse] = await self.ws.send_proto_and_wait(
-            MsgProto(EMsg.ClientFriendProfileInfo, steamid_friend=user_id64)
+    async def fetch_friend_profile_info(self, user_id64: ID64) -> friends.CMsgClientFriendProfileInfoResponse:
+        msg: friends.CMsgClientFriendProfileInfoResponse = await self.ws.send_proto_and_wait(
+            friends.CMsgClientFriendProfileInfo(steamid_friend=user_id64)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body
+        return msg
 
     async def fetch_user_equipped_profile_items(
         self,
-        user_id64: int,
+        user_id64: ID64,
         language: Language | None,
     ) -> player.GetProfileItemsEquippedResponse:
-        msg: MsgProto[player.GetProfileItemsEquippedResponse] = await self.ws.send_um_and_wait(
-            "Player.GetProfileItemsEquipped",
-            steamid=user_id64,
-            language=(language or self.language).api_name,
+        msg: player.GetProfileItemsEquippedResponse = await self.ws.send_um_and_wait(
+            player.GetProfileItemsEquippedRequest(
+                steamid=user_id64,
+                language=(language or self.language).api_name,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body
+        return msg
 
     async def fetch_user_profile_customisation(
         self,
-        user_id64: int,
-        language: Language | None,
-    ):
-        msg: MsgProto[player.GetProfileCustomizationResponse] = await self.ws.send_um_and_wait(
-            "Player.GetProfileCustomization",
-            steamid=user_id64,
-            include_inactive_customizations=True,
-            include_purchased_customizations=True,
-            language=(language or self.language).api_name,
+        user_id64: ID64,
+    ) -> player.GetProfileCustomizationResponse:
+        msg: player.GetProfileCustomizationResponse = await self.ws.send_um_and_wait(
+            player.GetProfileCustomizationRequest(
+                steamid=user_id64,
+                include_inactive_customizations=True,
+                include_purchased_customizations=True,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body
+        return msg
 
     async def fetch_profile_items(self, language: Language | None) -> player.GetProfileItemsOwnedResponse:
-        msg: MsgProto[player.GetProfileItemsOwnedResponse] = await self.ws.send_um_and_wait(
-            "Player.GetProfileItemsOwned",
-            language=(language or self.language).api_name,
+        msg: player.GetProfileItemsOwnedResponse = await self.ws.send_um_and_wait(
+            player.GetProfileItemsOwnedRequest(
+                language=(language or self.language).api_name,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body
+        return msg
 
     async def fetch_user_favourite_badge(self, user_id64: ID64) -> player.GetFavoriteBadgeResponse:
-        msg: MsgProto[player.GetFavoriteBadgeResponse] = await self.ws.send_um_and_wait(
-            "Player.GetFavoriteBadge",
-            steamid=user_id64,
+        msg: player.GetFavoriteBadgeResponse = await self.ws.send_um_and_wait(
+            player.GetFavoriteBadgeRequest(
+                steamid=user_id64,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body
+        return msg
 
     async def fetch_trade_url(self, generate_new: bool) -> str:
-        msg: MsgProto[econ.GetTradeOfferAccessTokenResponse] = await self.ws.send_um_and_wait(
-            "Econ.GetTradeOfferAccessToken", generate_new_token=generate_new
+        msg: econ.GetTradeOfferAccessTokenResponse = await self.ws.send_um_and_wait(
+            econ.GetTradeOfferAccessTokenRequest(generate_new_token=generate_new)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
         return (
             f"https://steamcommunity.com/tradeoffer/new/?partner={self.user.id}"
-            f"&token={msg.body.trade_offer_access_token}"
+            f"&token={msg.trade_offer_access_token}"
         )
 
     # parsers
 
     @register(EMsg.ServiceMethod)
-    async def parse_service_method(self, msg: MsgProto[Any]) -> None:
-        name = msg.header.body.job_name_target
-        if name == "ChatRoomClient.NotifyIncomingChatMessage":
-            await self.handle_chat_message(msg)
-        elif name == "ChatRoomClient.NotifyMessageReaction":
-            await self.handle_chat_message_reaction(msg)
-        elif name == "ChatRoomClient.NotifyChatRoomHeaderStateChange":
-            await self.handle_chat_group_update(msg)
-        elif name == "ChatRoomClient.NotifyChatGroupUserStateChanged":
-            await self.handle_chat_group_user_action(msg)
-        elif name == "ChatRoomClient.NotifyMemberStateChange":
-            await self.handle_chat_member_update(msg)
-        elif name == "ChatRoomClient.NotifyChatRoomGroupRoomsChange":
-            await self.handle_chat_update(msg)
-        elif name == "FriendMessagesClient.IncomingMessage":
-            await self.handle_user_message(msg)
-        elif name == "FriendMessagesClient.MessageReaction":
-            await self.handle_user_message_reaction(msg)
-        elif name == "ChatRoomClient.NotifyMemberListViewUpdated":
-            self.handle_member_list_view_update(msg)
-        else:
-            log.debug("Got an event %r that we don't handle %r", msg.header.body.job_name_target, msg.body)
+    async def parse_um(self, msg: UnifiedMessage) -> None:
+        match msg:
+            case chat.IncomingChatMessageNotification():
+                await self.handle_chat_message(msg)
+            case chat.MessageReactionNotification():
+                await self.handle_chat_message_reaction(msg)
+            case chat.ChatRoomHeaderStateNotification():
+                await self.handle_chat_group_update(msg)
+            case chat.NotifyChatGroupUserStateChangedNotification():
+                await self.handle_chat_group_user_action(msg)
+            case chat.MemberStateChangeNotification():
+                await self.handle_chat_member_update(msg)
+            case chat.ChatRoomGroupRoomsChangeNotification():
+                await self.handle_chat_update(msg)
+            case friend_messages.IncomingMessageNotification():
+                await self.handle_user_message(msg)
+            case friend_messages.MessageReactionNotification():
+                await self.handle_user_message_reaction(msg)
+            case chat.GetMyChatRoomGroupsResponse():
+                await self.handle_get_my_chat_groups(msg)
+            case _:
+                log.debug("Got a UM %r that we don't handle %r", msg.UM_NAME, msg)
+
+    @register(EMsg.ServiceMethodResponse)
+    async def parse_service_method_response(self, msg: UnifiedMessage) -> None:
+        await self.parse_um(msg)
 
-    async def handle_user_message(self, msg: MsgProto[friend_messages.IncomingMessageNotification]) -> None:
-        partner = await self._maybe_user(msg.body.steamid_friend)  # FIXME shouldn't ever be out of cache
-        author = self.user if msg.body.local_echo else partner  # local_echo is always us
+    @register(EMsg.ServiceMethodSendToClient)
+    async def parse_service_method_send_to_client(self, msg: UnifiedMessage) -> None:
+        await self.parse_um(msg)
+
+    @register(EMsg.ServiceMethodCallFromClient)
+    async def parse_service_method_call_from_client(self, msg: UnifiedMessage) -> None:
+        await self.parse_um(msg)
+
+    async def handle_user_message(self, msg: friend_messages.IncomingMessageNotification) -> None:
+        await self.client.wait_until_ready()
+        partner = await self._maybe_user(msg.steamid_friend)  # FIXME shouldn't ever be out of cache
+        author = self.user if msg.local_echo else partner  # local_echo is always us
 
-        if msg.body.chat_entry_type == ChatEntryType.Text:
+        if msg.chat_entry_type == ChatEntryType.Text:
             channel = DMChannel(state=self, participant=partner)  # type: ignore  # remove when above fixme removed
-            message = UserMessage(proto=msg.body, channel=channel)
+            message = UserMessage(proto=msg, channel=channel)
             message.author = author
             self._messages.append(message)
             self.dispatch("message", message)
 
-        if msg.body.chat_entry_type == ChatEntryType.Typing:
-            when = DateTime.from_timestamp(msg.body.rtime32_server_timestamp)
+        if msg.chat_entry_type == ChatEntryType.Typing:
+            when = DateTime.from_timestamp(msg.rtime32_server_timestamp)
             self.dispatch("typing", author, when)
 
-    async def handle_user_message_reaction(self, msg: MsgProto[friend_messages.MessageReactionNotification]) -> None:
-        participant = await self._maybe_user(msg.body.steamid_friend)
-        reactor = self.user if msg.body.reactor == self.user.id else participant
-        ordinal = msg.body.ordinal
-        created_at = DateTime.from_timestamp(msg.body.server_timestamp)
-        authors = {participant, self.user}
+    async def handle_user_message_reaction(self, msg: friend_messages.MessageReactionNotification) -> None:
+        user = await self._maybe_user(msg.steamid_friend)
+        ordinal = msg.ordinal
+        created_at = DateTime.from_timestamp(msg.server_timestamp)
         message = utils.find(
             lambda message: (
-                message.author in authors
+                message.author in (user, self.user)
                 and message.created_at == created_at
                 and message.ordinal == ordinal
                 and message.group is None
                 and message.clan is None
             ),
             reversed(self._messages),
         )
         if message is None:
             return log.debug("Got a reaction to an unknown message %s %s", created_at, ordinal)
-        if msg.body.reaction_type == 1:
-            emoticon = Emoticon(self, msg.body.reaction)
+        if msg.reaction_type == 1:
+            emoticon = Emoticon(self, msg.reaction)
             sticker = None
-        elif msg.body.reaction_type == 2:
-            sticker = Sticker(self, msg.body.reaction)
+        elif msg.reaction_type == 2:
+            sticker = Sticker(self, msg.reaction)
             emoticon = None
         else:
-            return log.debug(
-                "Got an unknown reaction_type %s on message %s %s", msg.body.reaction_type, created_at, ordinal
-            )
+            return log.debug("Got an unknown reaction_type %s on message %s %s", msg.reaction_type, created_at, ordinal)
 
-        reaction = MessageReaction(self, message, emoticon, sticker, reactor, created_at, ordinal)
-        self.dispatch(f"reaction_{'add' if msg.body.is_add else 'remove'}", reaction)
+        reaction = MessageReaction(self, message, emoticon, sticker, user, created_at, ordinal)
+        self.dispatch(f"reaction_{'add' if msg.is_add else 'remove'}", reaction)
 
-    async def handle_chat_message(self, msg: MsgProto[chat.IncomingChatMessageNotification]) -> None:
+    async def handle_chat_message(self, msg: chat.IncomingChatMessageNotification) -> None:
         try:
-            destination = self._chat_groups[msg.body.chat_group_id]
+            destination = self._chat_groups[msg.chat_group_id]
         except KeyError:
-            return log.debug(f"Got a message for a chat we aren't in {msg.body.chat_group_id}")
+            return log.debug(f"Got a message for a chat we aren't in {msg.chat_group_id}")
 
-        channel = destination._channels[msg.body.chat_id]
-        channel._update(msg.body)
-        author = await self._maybe_user(msg.body.steamid_sender)
+        channel = destination._channels[msg.chat_id]
+        channel._update(msg)
+        author = await self._maybe_user(msg.steamid_sender)
         message = (ClanMessage if isinstance(destination, Clan) else GroupMessage)(
-            proto=msg.body,
+            proto=msg,
             channel=channel,  # type: ignore  # type checkers aren't able to figure out this is ok
             author=author,
         )
         self._messages.append(message)
         self.dispatch("message", message)
 
-    async def handle_chat_message_reaction(self, msg: MsgProto[chat.MessageReactionNotification]) -> None:
-        user = await self._maybe_user(msg.body.reactor)
-        ordinal = msg.body.ordinal
-        created_at = DateTime.from_timestamp(msg.body.server_timestamp)
-        location = (msg.body.chat_group_id, msg.body.chat_id)
+    async def handle_chat_message_reaction(self, msg: chat.MessageReactionNotification) -> None:
+        user = await self._maybe_user(msg.reactor)
+        ordinal = msg.ordinal
+        created_at = DateTime.from_timestamp(msg.server_timestamp)
+        location = (msg.chat_group_id, msg.chat_id)
         message = utils.find(
             lambda message: (
                 isinstance(message, (ClanMessage, GroupMessage))
                 and message.channel._location == location
                 and message.created_at == created_at
                 and message.ordinal == ordinal
             ),
@@ -1001,356 +1006,408 @@
         if message is None:
             return log.debug(
                 "Got a reaction to an unknown message %s %s (location %s)",
                 created_at,
                 ordinal,
                 location,
             )
-        if msg.body.reaction_type == 1:
-            emoticon = Emoticon(self, msg.body.reaction)
+        if msg.reaction_type == 1:
+            emoticon = Emoticon(self, msg.reaction)
             sticker = None
-        elif msg.body.reaction_type == 2:
-            sticker = Sticker(self, msg.body.reaction)
+        elif msg.reaction_type == 2:
+            sticker = Sticker(self, msg.reaction)
             emoticon = None
         else:
-            return log.debug("Got an unknown reaction_type %s", msg.body.reaction_type)
+            return log.debug("Got an unknown reaction_type %s", msg.reaction_type)
 
         reaction = MessageReaction(self, message, emoticon, sticker, user, created_at, ordinal)
-        self.dispatch(f"reaction_{'add' if msg.body.is_add else 'remove'}", reaction)
+        self.dispatch(f"reaction_{'add' if msg.is_add else 'remove'}", reaction)
 
-    async def handle_chat_group_update(self, msg: MsgProto[chat.ChatRoomHeaderStateNotification]) -> None:
+    async def handle_chat_group_update(self, msg: chat.ChatRoomHeaderStateNotification) -> None:
         try:
-            chat_group = self._chat_groups[msg.body.header_state.chat_group_id]
+            chat_group = self._chat_groups[msg.header_state.chat_group_id]
         except KeyError:
-            return log.debug(f"Updating a group that isn't cached {msg.body.header_state.chat_group_id}")
+            return log.debug(f"Updating a group that isn't cached {msg.header_state.chat_group_id}")
 
         before = copy(chat_group)
         before._roles = {r_id: copy(r) for r_id, r in before._roles.items()}
-        chat_group._update_header_state(msg.body.header_state)
+        chat_group._update_header_state(msg.header_state)
         self.dispatch(f"{'group' if isinstance(chat_group, Group) else 'clan'}_update", before, chat_group)
 
-    async def handle_chat_group_user_action(
-        self, msg: MsgProto[chat.NotifyChatGroupUserStateChangedNotification]
-    ) -> None:
-        if msg.body.user_action == chat.EChatRoomMemberStateChange.Joined:  # join group
-            if msg.body.group_summary.clanid:
-                clan = await Clan._from_proto(self, msg.body.group_summary)
+    async def handle_chat_group_user_action(self, msg: chat.NotifyChatGroupUserStateChangedNotification) -> None:
+        if msg.user_action == chat.EChatRoomMemberStateChange.Joined:  # join group
+            if msg.group_summary.clanid:
+                clan = await Clan._from_proto(self, msg.group_summary)
                 self._clans[clan.id] = clan
                 assert clan._id is not None
                 self._clans_by_chat_id[clan._id] = clan
                 self.dispatch("clan_join", clan)
             else:
-                group = await Group._from_proto(self, msg.body.group_summary)
+                group = await Group._from_proto(self, msg.group_summary)
                 self._groups[group.id] = group
                 self.dispatch("group_join", group)
 
-        elif msg.body.user_action == chat.EChatRoomMemberStateChange.Parted:  # leave group
-            left = self._chat_groups.pop(msg.body.chat_group_id, None)
+        elif msg.user_action == chat.EChatRoomMemberStateChange.Parted:  # leave group
+            left = self._chat_groups.pop(msg.chat_group_id, None)
             if left is None:
                 return
 
             if isinstance(left, Clan):
                 self.dispatch("clan_leave", left)
             else:
                 self.dispatch("group_leave", left)
-        # elif msg.body.user_action == chat.EChatRoomMemberStateChange.Invited:
-        #     if msg.body.group_summary.clanid:
+        # elif msg.user_action == chat.EChatRoomMemberStateChange.Invited:
+        #     if msg.group_summary.clanid:
         #         return
-        #     group = await Group._from_proto(self, msg.body.group_summary)
+        #     group = await Group._from_proto(self, msg.group_summary)
         #     self._groups[group.id] = group
         #     self.dispatch("group_invite", group)
 
-    async def handle_chat_member_update(self, msg: MsgProto[chat.MemberStateChangeNotification]) -> None:
-        if msg.body.user_action == chat.EChatRoomMemberStateChange.Joined:
-            try:
-                chat_group = self._chat_groups[msg.body.chat_group_id]
-            except KeyError:
-                return log.debug("Got a chat member update for a chat group we aren't in %d", msg.body.chat_group_id)
-            member = await chat_group._add_member(msg.body.member)
-            self.dispatch("member_join", chat_group, member)
-        elif msg.body.user_action == chat.EChatRoomMemberStateChange.Parted:
-            try:
-                chat_group = self._chat_groups[msg.body.chat_group_id]
-            except KeyError:
-                return log.debug("Got a chat member update for a chat group we aren't in %d", msg.body.chat_group_id)
-            member = chat_group._remove_member(msg.body.member)
-            if member is None:
-                return
-            self.dispatch("member_leave", chat_group, member)
-        # TODO: handle other user_actions
+    async def handle_chat_member_update(self, msg: chat.MemberStateChangeNotification) -> None:
+        try:
+            chat_group = self._chat_groups[msg.chat_group_id]
+        except KeyError:
+            return log.debug("Got a chat member update for a chat group we aren't in %d", msg.chat_group_id)
+
+        match msg.change:
+            case chat.EChatRoomMemberStateChange.Joined:
+                member = await chat_group._add_member(msg.member)
+                self.dispatch("member_join", member)
+            case chat.EChatRoomMemberStateChange.Parted:
+                member = chat_group._remove_member(msg.member)
+                if member is None:
+                    return
+                self.dispatch("member_leave", chat_group, member)
+            # TODO: handle other user_actions
 
-    async def handle_chat_update(self, msg: MsgProto[chat.ChatRoomGroupRoomsChangeNotification]):
+    async def handle_chat_update(self, msg: chat.ChatRoomGroupRoomsChangeNotification) -> None:
         try:
-            chat_group = self._chat_groups[msg.body.chat_group_id]
+            chat_group = self._chat_groups[msg.chat_group_id]
         except KeyError:
-            return log.debug("Got an update for a chat group we aren't in %d", msg.body.chat_group_id)
+            return log.debug("Got an update for a chat group we aren't in %d", msg.chat_group_id)
 
         before = copy(chat_group)
         before._channels = {c_id: copy(c) for c_id, c in before._channels.items()}
-        chat_group._update_channels(msg.body.chat_rooms)
-        self.dispatch(f"{chat_group.__class__.__name__.lower()}_update", before, chat_group)
+        chat_group._update_channels(msg.chat_rooms)
+        self.dispatch(f"{chat_group.__class__.__name__}_update", before, chat_group)
 
-    @register(EMsg.ServiceMethodResponse)
-    async def parse_service_method_response(self, msg: MsgProto[Any]) -> None:
-        name = msg.header.body.job_name_target
-        if name == "ChatRoom.GetMyChatRoomGroups":
-            msg: MsgProto[chat.GetMyChatRoomGroupsResponse] = msg
-            for chat_group in msg.body.chat_room_groups:
-                if chat_group.group_summary.clanid:  # received a clan
-                    clan = await Clan._from_proto(self, chat_group.group_summary)
-                    clan._update_channels(
-                        chat_group.user_chat_group_state.user_chat_room_state,
-                        default_channel_id=chat_group.group_summary.default_chat_id,
-                    )
-                    self._clans[clan.id] = clan
-                    assert clan._id is not None
-                    self._clans_by_chat_id[clan._id] = clan
-                else:  # else it's a group
-                    group = await Group._from_proto(self, chat_group.group_summary)
-                    group._update_channels(
-                        chat_group.user_chat_group_state.user_chat_room_state,
-                        default_channel_id=chat_group.group_summary.default_chat_id,
-                    )
-                    self._groups[group.id] = group
+    async def handle_get_my_chat_groups(self, msg: chat.GetMyChatRoomGroupsResponse) -> None:
+        for chat_group in msg.chat_room_groups:
+            if chat_group.group_summary.clanid:  # received a clan
+                clan = await Clan._from_proto(self, chat_group.group_summary)
+                clan._update_channels(
+                    chat_group.user_chat_group_state.user_chat_room_state,
+                    default_channel_id=chat_group.group_summary.default_chat_id,
+                )
+                self._clans[clan.id] = clan
+                assert clan._id is not None
+                self._clans_by_chat_id[clan._id] = clan
+            else:  # else it's a group
+                group = await Group._from_proto(self, chat_group.group_summary)
+                group._update_channels(
+                    chat_group.user_chat_group_state.user_chat_room_state,
+                    default_channel_id=chat_group.group_summary.default_chat_id,
+                )
+                self._groups[group.id] = group
 
-            self.handled_chat_groups.set()  # signal to process_group_members that we are ready
-            await self.handled_friends.wait()  # ensure friend cache is ready
-            await self.handled_emoticons.wait()  # ensure emoticon cache is ready
-            await self.handled_licenses.wait()  # ensure licenses are ready
-            await self.client._handle_ready()
-        else:
-            log.debug("Got a service method response for %r we don't handle", msg.header.body.job_name_target)
+        self.handled_chat_groups.set()
+        await self.handled_friends.wait()  # ensure friend cache is ready
+        await self.handled_emoticons.wait()  # ensure emoticon cache is ready
+        await self.handled_licenses.wait()  # ensure licenses are ready
+        await self.client._handle_ready()
 
     @register(EMsg.ClientPersonaState)
-    async def parse_persona_state_update(self, msg: MsgProto[friends.CMsgClientPersonaState]) -> None:
-        for friend in msg.body.friends:
-            data = friend.to_dict(do_nothing_case)
-            if not data:
-                continue
-            steam_id = SteamID(friend.friendid)
+    def parse_persona_state_update(self, msg: friends.CMsgClientPersonaState) -> None:
+        for friend in msg.friends:
+            steam_id = ID(friend.friendid)
             after = self.get_user(steam_id.id)
-            if after is None:  # they're private
+            if after is None:
                 continue
 
             before = copy(after)
 
-            try:
-                data = self.patch_user_from_ws(data, friend)
-            except (KeyError, TypeError):
-                invitee = await self._maybe_user(steam_id.id64)
-                invite = UserInvite(self, invitee, FriendRelationship.RequestRecipient)
-                return self.dispatch("user_invite", invite)
-
-            after._update(data)
+            after._update(friend)
             old = [getattr(before, attr, None) for attr in BaseUser.__slots__]
             new = [getattr(after, attr, None) for attr in BaseUser.__slots__]
-            if old != new:
+            if old != new and self.handled_friends.is_set():
                 self.dispatch("user_update", before, after)
 
-    def patch_user_from_ws(self, data: dict[str, Any], friend: friends.CMsgClientPersonaStateFriend) -> user.User:
-        data["personaname"] = friend.player_name
-        data["steamid"] = friend.friendid
-        data["avatarfull"] = utils._get_avatar_url(friend.avatar_hash)
-
-        if friend.last_logoff:
-            data["lastlogoff"] = friend.last_logoff
-        data["gameextrainfo"] = friend.game_name or None
-        data["personastate"] = friend.persona_state
-        data["personastateflags"] = friend.persona_state_flags
-        data["rich_presence"] = {m.key: m.value for m in friend.rich_presence}
-        return data  # type: ignore  # casting is for losers
-
     def _add_friend(self, user: User) -> Friend:
-        self.user._friends[user.id] = friend = Friend(self, user)
+        self.user._friends[user.id64] = friend = Friend(self, user)
         return friend
 
     @register(EMsg.ClientFriendsList)
-    async def process_friends(self, msg: MsgProto[friends.CMsgClientFriendsList]) -> None:
+    async def process_friends(self, msg: friends.CMsgClientFriendsList) -> None:
         elements = None
         client_user_friends: list[ID64] = []
-        is_load = not msg.body.bincremental
-        for friend in msg.body.friends:
-            relationship = FriendRelationship.try_value(friend.efriendrelationship)
-            steam_id = SteamID(friend.ulfriendid)
-
-            if relationship == FriendRelationship.Friend:
-                try:
-                    invite = self.invites.pop(steam_id.id64)
-                except KeyError:
-                    if is_load:
-                        client_user_friends.append(steam_id.id64)
-                    else:
-                        user = await self.fetch_user(steam_id.id64)
-                        assert user is not None
-                        self._add_friend(user)
-                else:
-                    if isinstance(invite, UserInvite):
-                        self.dispatch("user_invite_accept", invite)
-                        if isinstance(invite.invitee, User):
-                            friend = self._add_friend(invite.invitee)
-                            self.dispatch("friend_add", friend)
+        is_load = not msg.bincremental
+        for friend in msg.friends:
+            id = ID(friend.ulfriendid)
+            match relationship := FriendRelationship.try_value(friend.efriendrelationship):
+                case FriendRelationship.Friend:
+                    try:
+                        invite = self.invites.pop(id.id64)
+                    except KeyError:
+                        if id.type == Type.Individual:
+                            if is_load:
+                                client_user_friends.append(id.id64)
+                            else:
+                                user = await self.fetch_user(id.id64)
+                                assert user is not None
+                                self._add_friend(user)
                     else:
-                        self.dispatch("clan_invite_accept", invite)
-                        if isinstance(invite.clan, Clan):
-                            self._clans[invite.clan.id] = invite.clan
-            elif relationship in (
-                FriendRelationship.RequestInitiator,
-                FriendRelationship.RequestRecipient,
-            ):
-                if steam_id.type == Type.Individual:
-                    invitee = await self._maybe_user(steam_id.id64)
-                    invite = UserInvite(state=self, invitee=invitee, relationship=relationship)
-                    self.invites[invitee.id64] = invite
-                    self.dispatch("user_invite", invite)
-                if steam_id.type == Type.Clan:
-                    if elements is None:
-                        resp = await self.http.get(URL.COMMUNITY / "my/groups/pending", params={"ajax": "1"})
-                        soup = BeautifulSoup(resp, HTML_PARSER)
-                        elements = soup.find_all("a", class_="linkStandard")
-                    invitee_id64 = next(
-                        (
-                            utils.make_id64(elements[idx + 1]["data-miniprofile"])
-                            for idx, element in enumerate(elements)
-                            if str(steam_id.id64) in str(element)
-                        ),
-                        0,
-                    )
+                        if isinstance(invite, UserInvite):
+                            self.dispatch("user_invite_accept", invite)
+                            if isinstance(invite.invitee, User):
+                                friend = self._add_friend(invite.invitee)
+                                self.dispatch("friend_add", friend)
+                        else:
+                            self.dispatch("clan_invite_accept", invite)
+                            if isinstance(invite.clan, Clan):
+                                self._clans[invite.clan.id] = invite.clan
+
+                case FriendRelationship.RequestInitiator | FriendRelationship.RequestRecipient:
+                    match id.type:
+                        case Type.Individual:
+                            invitee = await self._maybe_user(id.id64)
+                            invite = UserInvite(state=self, invitee=invitee, relationship=relationship)
+                            self.invites[invitee.id64] = invite
+                            self.dispatch("user_invite", invite)
+
+                        case Type.Clan:
+                            if elements is None:
+                                resp = await self.http.get(URL.COMMUNITY / "my/groups/pending", params={"ajax": "1"})
+                                soup = BeautifulSoup(resp, HTML_PARSER)
+                                elements = soup.find_all("a", class_="linkStandard")
+                            invitee_id64 = next(
+                                (
+                                    utils.parse_id64(elements[idx + 1]["data-miniprofile"])
+                                    for idx, element in enumerate(elements)
+                                    if str(id.id64) in str(element)
+                                ),
+                                0,
+                            )
+
+                            invitee = await self._maybe_user(invitee_id64)
+                            try:
+                                clan = await self.fetch_clan(id.id64) or id
+                            except WSException:
+                                clan = id
+                            invite = ClanInvite(state=self, invitee=invitee, clan=clan, relationship=relationship)
+                            self.invites[clan.id64] = invite
+                            self.dispatch("clan_invite", invite)
+
+                case FriendRelationship.NONE:
+                    match id.type:
+                        case Type.Individual:
+                            try:
+                                invite = self.invites.pop(id.id64)
+                            except KeyError:
+                                friend = self.user._friends.pop(id.id64, None)
+                                if friend is None:
+                                    return log.debug("Unknown friend %s removed", id)
+                                self.dispatch("friend_remove", friend)
+                            else:
+                                self.dispatch(
+                                    f"{'user' if id.type == Type.Individual else 'clan'}_invite_decline", invite
+                                )
+
+                        case Type.Clan:
+                            try:
+                                invite = self.invites.pop(id.id64)
+                            except KeyError:
+                                clan = self._clans.pop(id.id, None)
+                                if clan is None:
+                                    return log.debug("Unknown clan %s removed", id)
+                                self.dispatch("clean_leave", clan)
+                            else:
+                                self.dispatch("clan_invite_decline", invite)
 
-                    invitee = await self._maybe_user(invitee_id64)
-                    try:
-                        clan = await self.fetch_clan(steam_id.id64) or steam_id
-                    except WSException:
-                        clan = steam_id
-                    invite = ClanInvite(state=self, invitee=invitee, clan=clan, relationship=relationship)
-                    self.invites[clan.id64] = invite
-                    self.dispatch("clan_invite", invite)
-
-            elif relationship == FriendRelationship.NONE and steam_id.type == Type.Individual:
-                try:
-                    invite = self.invites.pop(steam_id.id64)
-                except KeyError:
-                    friend = self.user._friends.pop(steam_id.id64, None)
-                    if friend is None:
-                        return log.debug("Unknown friend %s removed", steam_id)
-                    self.dispatch("user_remove", friend)  # TODO remove
-                    self.dispatch("friend_remove", friend)
-                else:
-                    self.dispatch(f"{'user'if steam_id.type == Type.Individual else 'clan'}_invite_decline", invite)
         if is_load:
-            self.user._friends = {user.id64: Friend(self, user) for user in await self._maybe_users(client_user_friends)}  # type: ignore
+            await self.login_complete.wait()
+            self.user._friends = {user.id64: Friend(self, user) for user in await self.fetch_users(client_user_friends)}
             self.handled_friends.set()
 
     async def set_chat_group_active(self, chat_group_id: ChatGroupID) -> chat.GroupState:
         self.active_chat_groups.add(chat_group_id)
-        proto: MsgProto[chat.SetSessionActiveChatRoomGroupsResponse] = await self.ws.send_um_and_wait(
-            "ChatRoom.SetSessionActiveChatRoomGroups",
-            chat_group_ids=list(self.active_chat_groups),
-            chat_groups_data_requested=[chat_group_id],
+        proto: chat.SetSessionActiveChatRoomGroupsResponse = await self.ws.send_um_and_wait(
+            chat.SetSessionActiveChatRoomGroupsRequest(
+                chat_group_ids=list(self.active_chat_groups),
+                chat_groups_data_requested=[chat_group_id],
+            )
         )
 
         try:
-            (state,) = proto.body.chat_states
+            (state,) = proto.chat_states
         except ValueError:
             raise WSForbidden(proto) from None
+        if proto.result != Result.OK:
+            raise WSException(proto)
+
         return state
 
-    async def fetch_chat_group_roles(self, chat_group_id: ChatGroupID) -> list[chat.Role]:
-        msg: MsgProto[chat.GetRolesResponse] = await self.ws.send_um_and_wait(
-            "ChatRoom.GetRoles", chat_group_id=chat_group_id
+    async def fetch_user_inventory(
+        self, user_id64: ID64, app_id: int, context_id: int, language: Language | None
+    ) -> econ.GetInventoryItemsWithDescriptionsResponse:
+        msg: econ.GetInventoryItemsWithDescriptionsResponse = await self.ws.send_um_and_wait(
+            econ.GetInventoryItemsWithDescriptionsRequest(
+                steamid=user_id64,
+                appid=app_id,
+                contextid=context_id,
+                get_descriptions=True,
+                language=(language or self.language).api_name,
+                count=5000,
+            )
         )
         if msg.result == Result.AccessDenied:
             raise WSForbidden(msg)
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body.roles
+        return msg
+
+    async def fetch_item_info(
+        self, app_id: int, items: Iterable[CacheKey], language: Language | None
+    ) -> dict[CacheKey, econ.ItemDescription]:
+        result: dict[CacheKey, econ.ItemDescription] = {}
+
+        for chunk in utils.as_chunks(items, 100):
+            msg: econ.GetAssetClassInfoResponse = await self.ws.send_um_and_wait(
+                econ.GetAssetClassInfoRequest(
+                    language=(language or self.language).api_name,
+                    appid=app_id,
+                    classes=[econ.GetAssetClassInfoRequestClass(*item_info) for item_info in chunk],
+                )
+            )
+
+            for item in msg.descriptions:
+                result[(item.classid, item.instanceid)] = item  # type: ignore
+
+        return result
+
+    async def fetch_chat_group_roles(self, chat_group_id: ChatGroupID) -> list[chat.Role]:
+        msg: chat.GetRolesResponse = await self.ws.send_um_and_wait(chat.GetRolesRequest(chat_group_id=chat_group_id))
+        if msg.result == Result.AccessDenied:
+            raise WSForbidden(msg)
+        if msg.result != Result.OK:
+            raise WSException(msg)
+        return msg.roles
+
+    async def add_user(self, user_id64: ID64) -> None:
+        msg: player.AddFriendResponse = await self.ws.send_proto_and_wait(player.AddFriendRequest(steamid=user_id64))
+        if msg.result != Result.OK:
+            raise WSException(msg)
+
+    async def remove_user(self, user_id64: ID64) -> None:
+        msg: player.RemoveFriendResponse = await self.ws.send_um_and_wait(player.RemoveFriendRequest(steamid=user_id64))
+        if msg.result != Result.OK:
+            raise WSException(msg)
+
+    async def _block_user(self, user_id64: ID64, block: bool) -> None:
+        msg: player.IgnoreFriendResponse = await self.ws.send_um_and_wait(
+            player.IgnoreFriendRequest(steamid=user_id64, unignore=block)
+        )
+        if msg.result != Result.OK:
+            raise WSException(msg)
+
+    async def block_user(self, user_id64: ID64) -> None:
+        await self._block_user(user_id64, True)
+
+    async def unblock_user(self, user_id64: ID64) -> None:
+        await self._block_user(user_id64, False)
 
     async def fetch_comment(self, owner: Commentable, id: int) -> comments.GetCommentThreadResponse.Comment:
-        msg: MsgProto[comments.GetCommentThreadResponse] = await self.ws.send_um_and_wait(
-            "Community.GetCommentThread", **owner._commentable_kwargs, id=id
+        msg: comments.GetCommentThreadResponse = await self.ws.send_um_and_wait(
+            comments.GetCommentThreadRequest(**owner._commentable_kwargs, type=owner._commentable_type, id=id)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body.comments[0]
+        return msg.comments[0]
 
     async def fetch_comments(
         self, owner: Commentable, count: int, starting_from: int, oldest_first: bool
     ) -> comments.GetCommentThreadResponse:
-        msg: MsgProto[comments.GetCommentThreadResponse] = await self.ws.send_um_and_wait(
-            "Community.GetCommentThread",
-            **owner._commentable_kwargs,
-            count=count,
-            start=starting_from,
-            oldest_first=oldest_first,
+        msg: comments.GetCommentThreadResponse = await self.ws.send_um_and_wait(
+            comments.GetCommentThreadRequest(
+                **owner._commentable_kwargs,
+                type=owner._commentable_type,
+                count=count,
+                start=starting_from,
+                oldest_first=oldest_first,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body
+        return msg
 
     async def post_comment(self, owner: Commentable, content: str, subscribe: bool) -> Comment[Commentable]:
-        msg: MsgProto[comments.PostCommentToThreadResponse] = await self.ws.send_um_and_wait(
-            "Community.PostCommentToThread",
-            **owner._commentable_kwargs,
-            content=content,
-            surpress_notifications=not subscribe,
+        msg: comments.PostCommentToThreadResponse = await self.ws.send_um_and_wait(
+            comments.PostCommentToThreadRequest(
+                **owner._commentable_kwargs,
+                type=owner._commentable_type,
+                content=content,
+                suppress_notifications=not subscribe,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
         comment = Comment(
             self,
-            id=msg.body.id,
+            id=msg.id,
             content=content,
             created_at=self.steam_time,
             author=self.user,
             owner=owner,
             reactions=[],
         )
         self.dispatch("comment", comment)
         return comment
 
     async def delete_comment(self, owner: Commentable, comment_id: int) -> None:
-        msg: MsgProto[comments.DeleteCommentFromThreadResponse] = await self.ws.send_um_and_wait(
-            "Community.DeleteCommentFromThread",
-            **owner._commentable_kwargs,
-            id=comment_id,
+        msg: comments.DeleteCommentFromThreadResponse = await self.ws.send_um_and_wait(
+            comments.DeleteCommentFromThreadRequest(
+                **owner._commentable_kwargs,
+                type=owner._commentable_type,
+                id=comment_id,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def report_comment(self, owner: Commentable, comment_id: int) -> None:
-        msg: MsgProto[comments.PostCommentToThreadResponse] = await self.ws.send_um_and_wait(
-            "Community.PostCommentToThread",  # some odd api here
-            **owner._commentable_kwargs,
-            is_report=True,
-            id=comment_id,
+        msg: comments.PostCommentToThreadResponse = await self.ws.send_um_and_wait(
+            comments.PostCommentToThreadRequest(  # some odd api here
+                **owner._commentable_kwargs,
+                type=owner._commentable_type,
+                is_report=True,
+                parent_id=comment_id,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     @register(EMsg.ClientCommentNotifications)
-    async def handle_comments(self, msg: MsgProto[client_server_2.CMsgClientCommentNotifications]) -> None:
+    async def handle_comments(self, msg: client_server_2.CMsgClientCommentNotifications) -> None:
         resp = await self.http.get(URL.COMMUNITY / "my/commentnotifications")
         soup = BeautifulSoup(resp, HTML_PARSER)
 
-        cached: dict[URL_, list[Commentable | int]] = {}
-        for attr in soup.find_all("div", class_="commentnotification_click_overlay", limit=msg.body.count_new_comments):
+        cached: dict[URL_, tuple[Commentable, int]] = {}
+        for attr in soup.find_all("div", class_="commentnotification_click_overlay", limit=msg.count_new_comments):
             url = URL_(attr.contents[1]["href"])
             url_with_no_query = url.with_query(None)
             if url_with_no_query in cached:
-                cached[url_with_no_query][1] += 1  # type: ignore
-                commentable, index = cached[url_with_no_query]  # type: ignore
-                commentable: Commentable
-                index: int
+                commentable, index = cached[url_with_no_query]
+                index += 1
             else:
-                steam_id = await SteamID.from_url(url, self.http._session)
+                steam_id = await ID.from_url(url, self.http._session)
                 if steam_id is None:
                     continue
                 if steam_id.type == Type.Individual:
-                    commentable = self.get_user(steam_id.id) or await self.fetch_user(steam_id.id64)  # type: ignore
+                    commentable = self.get_user(steam_id.id) or await self.fetch_user(steam_id.id64)
                 else:
                     clan = self.get_clan(steam_id.id) or await self.fetch_clan(steam_id.id64)
                     if clan is None:
                         continue
                     # now that we have the clan that the comment was posted in, if the url has a hash in the path we can
                     # extract the type of the comment section the comment is in.
                     if "#" not in url.path:
@@ -1363,16 +1420,15 @@
                             commentable = await clan.fetch_announcement(re.findall(r"detail/([0-9]*)", end)[0])
                         else:
                             log.debug(f"Got a comment for a type we cannot handle {path}")
                             continue
                 if commentable is None:
                     continue
                 index = 0
-                cached[url_with_no_query] = [commentable, index]
-
+            cached[url_with_no_query] = (commentable, index)
             try:
                 timestamp = int(url.query["tscn"])
             except KeyError:
                 log.debug("Got a comment without a timestamp")
                 continue
 
             after = DateTime.from_timestamp(timestamp) - timedelta(minutes=1)
@@ -1381,259 +1437,297 @@
 
             try:
                 self.dispatch("comment", comments[index])
             except IndexError:
                 pass
 
     @register(EMsg.ClientEmoticonList)
-    def handle_emoticon_list(self, msg: MsgProto[friends.CMsgClientEmoticonList]) -> None:
-        self.emoticons = [ClientEmoticon(self, emoticon) for emoticon in msg.body.emoticons]
-        self.stickers = [ClientSticker(self, sticker) for sticker in msg.body.stickers]
-        # self.effects = [ClientEffect(self, effect) for effect in msg.body.effects]  # TODO
+    def handle_emoticon_list(self, msg: friends.CMsgClientEmoticonList) -> None:
+        self.emoticons = [ClientEmoticon(self, emoticon) for emoticon in msg.emoticons]
+        self.stickers = [ClientSticker(self, sticker) for sticker in msg.stickers]
+        # self.effects = [ClientEffect(self, effect) for effect in msg.effects]  # TODO
         self.handled_emoticons.set()
 
     async def add_award(self, awardable: Awardable, award: Award) -> None:
         msg = await self.ws.send_um_and_wait(
-            "LoyaltyRewards.AddReaction",
-            target_type=awardable.__class__._AWARDABLE_TYPE,
-            targetid=awardable.id,
-            reactionid=award.id,
+            loyalty_rewards.AddReactionRequest(
+                target_type=awardable.__class__._AWARDABLE_TYPE,
+                targetid=awardable.id,
+                reactionid=award.id,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def fetch_award_reactions(self, awardable: Awardable) -> list[ReactionProtocol]:
         # this method doesn't work and when steamcommunity tries to use it, It returns an empty response so, I'm
         # assuming it's just broken for now
-        msg: MsgProto[loyalty_rewards.GetReactionsResponse] = await self.ws.send_um_and_wait(
-            "LoyaltyRewards.GetReactions",
-            target_type=awardable.__class__._AWARDABLE_TYPE,
-            targetid=awardable.id,
+        msg: loyalty_rewards.GetReactionsResponse = await self.ws.send_um_and_wait(
+            loyalty_rewards.GetReactionsRequest(
+                target_type=awardable.__class__._AWARDABLE_TYPE,
+                targetid=awardable.id,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
         # but also if this doesn't work there's no point including this method
-        return [
-            _Reaction(reactionid=id, count=count)  # type: ignore
-            for id, count in collections.Counter(msg.body.reactionids).items()
-        ]
+        return [_Reaction(reactionid=id, count=count) for id, count in collections.Counter(msg.reactionids).items()]
 
     @register(EMsg.ClientUserNotifications)
-    async def parse_notification(self, msg: MsgProto[client_server_2.CMsgClientUserNotifications]) -> None:
-        if any(b.user_notification_type == 1 for b in msg.body.notifications):
+    async def parse_notification(self, msg: client_server_2.CMsgClientUserNotifications) -> None:
+        if any(b.user_notification_type == 1 for b in msg.notifications):
             # 1 is a trade offer
             await self.poll_trades()
 
     @register(EMsg.ClientItemAnnouncements)
-    async def parse_new_items(self, msg: MsgProto[client_server_2.CMsgClientItemAnnouncements]) -> None:
-        if msg.body.count_new_items:
+    async def parse_new_items(self, msg: client_server_2.CMsgClientItemAnnouncements) -> None:
+        if msg.count_new_items:
             await self.poll_trades()
 
-    async def fetch_user_review(self, user_id64: int, app_ids: Iterable[int]) -> list[reviews.RecommendationDetails]:
-        msg: MsgProto[reviews.GetIndividualRecommendationsResponse] = await self.ws.send_um_and_wait(
-            "UserReviews.GetIndividualRecommendations",
-            requests=[{"steamid": user_id64, "appid": app_id} for app_id in app_ids],
+    async def fetch_user_post(self, user_id64: ID64, post_id: int) -> player.GetPostedStatusResponse:
+        msg: player.GetPostedStatusResponse = await self.ws.send_um_and_wait(
+            player.GetPostedStatusRequest(
+                steamid=user_id64,
+                postid=post_id,
+            )
+        )
+        if msg.result == Result.InvalidParameter:
+            raise WSNotFound(msg)
+        if msg.result != Result.OK:
+            raise WSException(msg)
+        return msg
+
+    async def create_user_post(self, content: str, app_id: AppID) -> None:
+        msg: player.PostStatusToFriendsResponse = await self.ws.send_um_and_wait(
+            player.PostStatusToFriendsRequest(appid=app_id, status_text=content)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body.recommendations
+
+    async def delete_user_post(self, post_id: int) -> None:
+        msg: player.DeletePostedStatusResponse = await self.ws.send_um_and_wait(
+            player.DeletePostedStatusRequest(
+                postid=post_id,
+            )
+        )
+        if msg.result == Result.InvalidParameter:
+            raise WSNotFound(msg)
+        if msg.result != Result.OK:
+            raise WSException(msg)
+
+    async def fetch_user_reviews(self, user_id64: ID64, app_ids: Iterable[int]) -> list[reviews.RecommendationDetails]:
+        msg: reviews.GetIndividualRecommendationsResponse = await self.ws.send_um_and_wait(
+            reviews.GetIndividualRecommendationsRequest(
+                [
+                    reviews.GetIndividualRecommendationsRequestRecommendationRequest(steamid=user_id64, appid=app_id)
+                    for app_id in app_ids
+                ]
+            )
+        )
+        if msg.result != Result.OK:
+            raise WSException(msg)
+
+        return msg.recommendations
 
     async def edit_review(
         self,
         review_id: int,
         content: str,
         public: bool,
         commentable: bool,
         language: str,
         is_in_early_access: bool,
         received_compensation: bool,
     ) -> None:
         msg = await self.ws.send_um_and_wait(
-            "UserReviews.Update",
-            recommendationid=review_id,
-            review_text=content,
-            is_public=public,
-            language=language,
-            is_in_early_access=is_in_early_access,
-            received_compensation=received_compensation,
-            comments_disabled=not commentable,
+            reviews.UpdateRequest(
+                recommendationid=review_id,
+                review_text=content,
+                is_public=public,
+                language=language,
+                is_in_early_access=is_in_early_access,
+                received_compensation=received_compensation,
+                comments_disabled=not commentable,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def fetch_friend_thoughts(self, app_id: int) -> reviews.GetFriendsRecommendedAppResponse:
-        msg: MsgProto[reviews.GetFriendsRecommendedAppResponse] = await self.ws.send_um_and_wait(
-            "UserReviews.GetFriendsRecommendedApp",
-            appid=app_id,
+        msg: reviews.GetFriendsRecommendedAppResponse = await self.ws.send_um_and_wait(
+            reviews.GetFriendsRecommendedAppRequest(appid=app_id)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body
+        return msg
 
     @register(EMsg.ClientAccountInfo)
-    def parse_account_info(self, msg: MsgProto[login.CMsgClientAccountInfo]) -> None:
-        if msg.body.persona_name != self.user.name:
+    async def parse_account_info(self, msg: login.CMsgClientAccountInfo) -> None:
+        await self.login_complete.wait()
+        if msg.persona_name != self.user.name:
             before = copy(self.user)
-            self.user.name = msg.body.persona_name or self.user.name
+            self.user.name = msg.persona_name or self.user.name
             self.dispatch("user_update", before, self.user)
 
-    async def fetch_friends_who_own(self, game_id: int) -> list[ID64]:
-        msg: Msg[struct_messages.ClientGetFriendsWhoPlayGameResponse] = await self.ws.send_proto_and_wait(
-            Msg(EMsg.ClientGetFriendsWhoPlayGame, extended=True, app_id=game_id)
+    async def fetch_friends_who_own(self, app_id: int) -> list[ID64]:
+        msg: friends.ClientGetFriendsWhoPlayGameResponse = await self.ws.send_proto_and_wait(
+            friends.ClientGetFriendsWhoPlayGame(app_id=app_id)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body.friends
+        return msg.friends  # type: ignore
 
-    async def rate_clan_announcement(self, clan_id: int, announcement_id: int, upvoted: bool) -> None:
+    async def rate_clan_announcement(self, clan_id: ID32, announcement_id: int, upvoted: bool) -> None:
         msg = await self.ws.send_um_and_wait(
-            "Community.RateClanAnnouncement",
-            announcementid=announcement_id,
-            clan_accountid=clan_id,
-            vote_up=upvoted,
+            comments.RateClanAnnouncementRequest(
+                announcementid=announcement_id,
+                clan_accountid=clan_id,
+                vote_up=upvoted,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
-    async def respond_to_clan_invite(self, clan_id64: int, accept: bool) -> None:
-        msg = await self.ws.send_um_and_wait("Clan.RespondToClanInvite", steamid=clan_id64, accept=accept)
+    async def respond_to_clan_invite(self, clan_id64: ID64, accept: bool) -> None:
+        msg: clan.RespondToClanInviteResponse = await self.ws.send_um_and_wait(
+            clan.RespondToClanInviteRequest(steamid=clan_id64, accept=accept)
+        )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     @register(EMsg.ClientClanState)
-    async def update_clan(self, msg: MsgProto[client_server.CMsgClientClanState]) -> None:
+    async def update_clan(self, msg: client_server.CMsgClientClanState) -> None:
         await self.handled_chat_groups.wait()
-        steam_id = SteamID(msg.body.steamid_clan)
+        steam_id = ID(msg.steamid_clan)
         clan = self.get_clan(steam_id.id) or await self.fetch_clan(steam_id.id64, maybe_chunk=False)
         if clan is None:
             return
 
-        for event in msg.body.events:
+        for event in msg.events:
             if event.just_posted:
                 event = await clan.fetch_event(event.gid)
                 self.dispatch("event_create", event)
-        for announcement in msg.body.announcements:
+        for announcement in msg.announcements:
             if announcement.just_posted:
                 announcement = await clan.fetch_announcement(announcement.gid)
                 self.dispatch("announcement_create", announcement)
 
-        user_counts = msg.body.user_counts
-        name_info = msg.body.name_info
+        user_counts = msg.user_counts
+        name_info = msg.name_info
 
         if user_counts or name_info:
             before = copy(clan)
         if user_counts:
             clan.member_count = user_counts.members
             clan.in_game_count = user_counts.in_game
             clan.online_count = user_counts.online
             clan.active_member_count = user_counts.chatting
         if name_info:
             clan.name = name_info.clan_name
-            clan.avatar_url = utils._get_avatar_url(name_info.sha_avatar)
+            clan._avatar_sha = name_info.sha_avatar
 
         if user_counts or name_info:
             self.dispatch("clan_update", before, clan)
 
     @register(EMsg.ClientLicenseList)
-    async def _handle_licenses(self, msg: MsgProto[client_server.CMsgClientLicenseList]) -> None:
-        users = {
+    async def handle_licenses(self, msg: client_server.CMsgClientLicenseList) -> None:
+        await self.login_complete.wait()
+        users: dict[int, User | ID] = {
             user.id: user
-            for user in await self._maybe_users(utils.make_id64(license.owner_id) for license in msg.body.licenses)
+            for user in await self._maybe_users(
+                parse_id64(license.owner_id, type=Type.Individual) for license in msg.licenses
+            )
         }
-        for license in msg.body.licenses:
+        for license in msg.licenses:
             self.licenses[license.package_id] = License(self, license, users[license.owner_id])
 
         self.handled_licenses.set()
 
     async def fetch_cs_list(self, limit: int = 20) -> list[content_server.ServerInfo]:
-        msg: MsgProto[content_server.GetServersForSteamPipeResponse] = await self.ws.send_um_and_wait(
-            "ContentServerDirectory.GetServersForSteamPipe",
-            cell_id=self.ws.cm_list.cell_id,
-            max_servers=limit,
+        msg: content_server.GetServersForSteamPipeResponse = await self.ws.send_um_and_wait(
+            content_server.GetServersForSteamPipeRequest(
+                cell_id=self.cell_id,
+                max_servers=limit,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body.servers
+        return msg.servers
 
     async def fetch_manifest(
         self,
-        game_id: int,
+        app_id: int,
         id: int,
         depot_id: int,
         name: str | None = None,
         branch: str = "public",
         password_hash: str = "",
     ) -> Manifest:
-        async with self.cs_lock:
-            if not self.cs_servers:
-                self.cs_servers = sorted(
-                    (
-                        ContentServer(
-                            self,
-                            URL_.build(
-                                scheme=f"http{'s' if server.https_support != 'none' else ''}", host=server.vhost
-                            ),
-                            server.weighted_load,
-                        )
-                        for server in await self.fetch_cs_list(limit=20)
-                        if server.type in ("CDN", "SteamCache")
-                    ),
-                    key=attrgetter("weighted_load"),
-                )
+        if not self.cs_servers:
+            self.cs_servers = sorted(
+                (
+                    ContentServer(
+                        self,
+                        URL_.build(scheme=f"http{'s' if server.https_support != 'none' else ''}", host=server.vhost),
+                        server.weighted_load,
+                    )
+                    for server in await self.fetch_cs_list(limit=20)
+                    if server.type in ("CDN", "SteamCache")
+                ),
+                key=attrgetter("weighted_load"),
+            )
 
         for server in tuple(self.cs_servers):
             try:
-                return await server.fetch_manifest(game_id, id, depot_id, name, branch, password_hash)
+                return await server.fetch_manifest(app_id, id, depot_id, name, branch, password_hash)
             except HTTPException as exc:
                 if 500 <= exc.status <= 599:
                     del self.cs_servers[0]
                 else:
                     raise
 
-        return await self.fetch_manifest(game_id, id, depot_id, name, branch, password_hash)
+        return await self.fetch_manifest(app_id, id, depot_id, name, branch, password_hash)
 
     async def fetch_manifests(
-        self, game_id: int, branch_name: str, password: str | None, limit: int | None, password_hash: str = ""
+        self, app_id: int, branch_name: str, password: str | None, limit: int | None, password_hash: str = ""
     ) -> list[Coro[Manifest]]:
-        (product_info,), _ = await self.fetch_product_info((game_id,))
+        (product_info,), _ = await self.fetch_product_info((app_id,))
 
         branch = product_info.get_branch(branch_name)
         if branch is None:
-            raise ValueError(f"No branch named {branch_name!r} for app {game_id}")
+            raise ValueError(f"No branch named {branch_name!r} for app {app_id}")
 
         try:
-            branch.password = self._manifest_passwords[game_id].get(branch_name)
+            branch.password = self._manifest_passwords[app_id].get(branch_name)
         except KeyError:
             pass
         if branch.password_required and branch.password is None:
             if not password:
                 raise ValueError(f"Branch {branch!r} requires a password")
 
-            password_msg: MsgProto[
-                client_server_2.CMsgClientCheckAppBetaPasswordResponse
-            ] = await self.ws.send_proto_and_wait(
-                MsgProto(EMsg.ClientCheckAppBetaPassword, app_id=game_id, betapassword=password)
+            password_msg: client_server_2.CMsgClientCheckAppBetaPasswordResponse = await self.ws.send_proto_and_wait(
+                client_server_2.CMsgClientCheckAppBetaPassword(app_id=app_id, betapassword=password)
             )
             if password_msg.result != Result.OK:
                 raise WSException(password_msg)
 
-            branch_password = utils.get(password_msg.body.betapasswords, betaname=branch.name)
+            branch_password = utils.get(password_msg.betapasswords, betaname=branch.name)
 
             if branch_password is None:
                 raise ValueError(f"Supplied password is not for the branch {branch!r}")
             branch.password = branch_password.betapassword
             try:
-                self._manifest_passwords[game_id][branch.name] = branch.password
+                self._manifest_passwords[app_id][branch.name] = branch.password
             except KeyError:
-                self._manifest_passwords[game_id] = {branch.name: branch.password}
+                self._manifest_passwords[app_id] = {branch.name: branch.password}
 
         return [
             self.fetch_manifest(
-                game_id,
+                app_id,
                 depot.manifest.id,
                 depot.id,
                 depot.name,
                 password_hash,
             )
             for depot in branch.depots[:limit]
         ]
@@ -1642,382 +1736,397 @@
         self,
         manifest_id: int,
         depot_id: int,
         app_id: int,
         branch: str = "",
         password_hash: str = "",
     ) -> int:
-        msg: MsgProto[content_server.GetManifestRequestCodeResponse] = await self.ws.send_um_and_wait(
-            "ContentServerDirectory.GetManifestRequestCode",
-            app_id=app_id,
-            depot_id=depot_id,
-            manifest_id=manifest_id,
-            app_branch=branch,
-            branch_password_hash=password_hash,
+        msg: content_server.GetManifestRequestCodeResponse = await self.ws.send_um_and_wait(
+            content_server.GetManifestRequestCodeRequest(
+                app_id=app_id,
+                depot_id=depot_id,
+                manifest_id=manifest_id,
+                app_branch=branch,
+                branch_password_hash=password_hash,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        code = msg.body.manifest_request_code
-        if not code:
-            raise ValueError
-        return code
+        if code := msg.manifest_request_code:
+            return code
+
+        raise ValueError
 
     async def fetch_product_info(
-        self, game_ids: Iterable[int] = (), package_ids: Iterable[int] = ()
-    ) -> tuple[list[GameInfo], list[PackageInfo]]:
-        games_to_fetch: list[dict[str, int]] = []
-        packages_to_fetch: list[dict[str, int]] = []
+        self, app_ids: Iterable[int] = (), package_ids: Iterable[int] = ()
+    ) -> tuple[list[AppInfo], list[PackageInfo]]:
+        apps_to_fetch: list[app_info.CMsgClientPicsProductInfoRequestAppInfo] = []
+        packages_to_fetch: list[app_info.CMsgClientPicsProductInfoRequestPackageInfo] = []
         app_access_tokens_to_collect: list[int] = []
         package_access_tokens_to_collect: list[int] = []
 
-        for game_id in game_ids:
+        for app_id in app_ids:
             try:
-                games_to_fetch.append({"appid": game_id, "access_token": self.licenses[game_id].access_token})
+                apps_to_fetch.append(
+                    app_info.CMsgClientPicsProductInfoRequestAppInfo(app_id, self.licenses[app_id].access_token)
+                )
             except KeyError:
-                app_access_tokens_to_collect.append(game_id)
+                app_access_tokens_to_collect.append(app_id)
 
         for package_id in package_ids:
             try:
                 packages_to_fetch.append(
-                    {"packageid": package_id, "access_token": self.licenses[package_id].access_token}
+                    app_info.CMsgClientPicsProductInfoRequestPackageInfo(
+                        package_id, self.licenses[package_id].access_token
+                    )
                 )
             except KeyError:
                 package_access_tokens_to_collect.append(package_id)
 
         if app_access_tokens_to_collect or package_access_tokens_to_collect:
             fetched_tokens = await self.fetch_manifest_access_tokens(
                 app_access_tokens_to_collect, package_access_tokens_to_collect
             )
-            games_to_fetch.extend(token.to_dict(do_nothing_case) for token in fetched_tokens.app_access_tokens)
-            packages_to_fetch.extend(token.to_dict(do_nothing_case) for token in fetched_tokens.package_access_tokens)
+            apps_to_fetch.extend(
+                app_info.CMsgClientPicsProductInfoRequestAppInfo(token.appid, token.access_token)
+                for token in fetched_tokens.app_access_tokens
+            )
+            packages_to_fetch.extend(
+                app_info.CMsgClientPicsProductInfoRequestPackageInfo(token.packageid, token.access_token)
+                for token in fetched_tokens.package_access_tokens
+            )
 
-        to_send = MsgProto[app_info.CMsgClientPicsProductInfoRequest](
-            EMsg.ClientPICSProductInfoRequest,
-            apps=games_to_fetch,
+        to_send = app_info.CMsgClientPicsProductInfoRequest(
+            apps=apps_to_fetch,
             packages=packages_to_fetch,
             supports_package_tokens=True,
         )
-        to_send.header.body.job_id_source = job_id = self.ws.next_job_id
+        to_send.header.job_id_source = job_id = self.ws.next_job_id
 
         await self.ws.send_proto(to_send)
 
         response_pending = True
-        games: list[GameInfo] = []
+        apps: list[AppInfo] = []
         packages: list[PackageInfo] = []
 
-        check: Callable[[MsgProto[app_info.CMsgClientPicsProductInfoResponse]], bool] = (
-            lambda msg: msg.header.body.job_id_target == job_id
-        )
         while response_pending:
-            msg = await self.ws.wait_for(EMsg.ClientPICSProductInfoResponse, check)
+            msg = await self.ws.wait_for(
+                app_info.CMsgClientPicsProductInfoResponse, check=lambda msg: msg.header.job_id_target == job_id
+            )
 
-            games.extend(
-                GameInfo(
+            apps.extend(
+                AppInfo(
                     self,
                     VDF_LOADS(  # type: ignore  # can be removed if AnyOf ever happens
                         app.buffer[:-1].decode("UTF-8", "replace")
                     )["appinfo"],
                     app,
                 )
-                for app in msg.body.apps
+                for app in msg.apps
             )
 
             packages.extend(
                 PackageInfo(
                     self,
                     VDF_BINARY_LOADS(package.buffer[4:])[  # type: ignore  # can be removed if AnyOf ever happens
                         str(package.packageid)
                     ],
                     package,
                 )
-                for package in msg.body.packages
+                for package in msg.packages
             )
 
-            response_pending = msg.body.response_pending
+            response_pending = msg.response_pending
 
-        return games, packages
+        return apps, packages
 
-    async def fetch_depot_key(self, game_id: int, depot_id: int) -> bytes:
-        msg: MsgProto[client_server_2.CMsgClientGetDepotDecryptionKeyResponse] = await self.ws.send_proto_and_wait(
-            MsgProto(EMsg.ClientGetDepotDecryptionKey, app_id=game_id, depot_id=depot_id)
+    async def fetch_depot_key(self, app_id: int, depot_id: int) -> bytes:
+        msg: client_server_2.CMsgClientGetDepotDecryptionKeyResponse = await self.ws.send_proto_and_wait(
+            client_server_2.CMsgClientGetDepotDecryptionKey(app_id=app_id, depot_id=depot_id)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body.depot_encryption_key
+        return msg.depot_encryption_key
 
     async def fetch_manifest_access_tokens(
         self,
-        game_ids: list[int] | None = None,
+        app_ids: list[int] | None = None,
         package_ids: list[int] | None = None,
     ) -> app_info.CMsgClientPicsAccessTokenResponse:
 
-        game_ids = [] if game_ids is None else game_ids
+        app_ids = [] if app_ids is None else app_ids
         package_ids = [] if package_ids is None else package_ids
 
-        msg: MsgProto[app_info.CMsgClientPicsAccessTokenResponse] = await self.ws.send_proto_and_wait(
-            MsgProto(EMsg.ClientPICSAccessTokenRequest, appids=game_ids, packageids=package_ids),
+        msg: app_info.CMsgClientPicsAccessTokenResponse = await self.ws.send_proto_and_wait(
+            app_info.CMsgClientPicsAccessTokenRequest(appids=app_ids, packageids=package_ids)
         )
         if msg.result not in (
             Result.OK,
             Result.Invalid,
         ):  # invalid is for the case where access tokens are not required
             raise WSException(msg)
-        return msg.body
+        return msg
 
     async def fetch_changes_since(
         self, change_number: int, app: bool, package: bool
     ) -> app_info.CMsgClientPicsChangesSinceResponse:
-        msg: MsgProto[app_info.CMsgClientPicsChangesSinceResponse] = await self.ws.send_proto_and_wait(
-            MsgProto(
-                EMsg.ClientPICSChangesSinceRequest,
+        msg: app_info.CMsgClientPicsChangesSinceResponse = await self.ws.send_proto_and_wait(
+            app_info.CMsgClientPicsChangesSinceRequest(
                 since_change_number=change_number,
                 send_app_info_changes=app,
                 send_package_info_changes=package,
             )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body
+        return msg
 
     async def fetch_published_files(
         self,
         published_file_ids: Iterable[int],
         revision: PublishedFileRevision,
         language: Language | None,
     ) -> list[PublishedFile | None]:
-        msg: MsgProto[published_file.GetDetailsResponse] = await self.ws.send_um_and_wait(
-            "PublishedFile.GetDetails",
-            publishedfileids=list(published_file_ids),
-            language=(language or self.language).value,
-            includetags=True,
-            includeadditionalpreviews=True,
-            includechildren=True,
-            includekvtags=True,
-            includevotes=True,
-            includeforsaledata=True,
-            includemetadata=True,
-            strip_description_bbcode=True,
-            includereactions=True,
-            return_playtime_stats=True,
-            desired_revision=revision,
+        msg: published_file.GetDetailsResponse = await self.ws.send_um_and_wait(
+            published_file.GetDetailsRequest(
+                publishedfileids=list(published_file_ids),
+                language=(language or self.language).value,
+                includetags=True,
+                includeadditionalpreviews=True,
+                includechildren=True,
+                includekvtags=True,
+                includevotes=True,
+                includeforsaledata=True,
+                includemetadata=True,
+                strip_description_bbcode=True,
+                includereactions=True,
+                return_playtime_stats=True,
+                desired_revision=revision,
+            )
         )
 
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        protos = msg.body.publishedfiledetails
-        authors = await self._maybe_users(proto.creator for proto in protos)
+        protos = msg.publishedfiledetails
+        authors = await self._maybe_users(ID64(proto.creator) for proto in protos)
         return [
             PublishedFile(self, proto, author) if proto.result == Result.OK else None
             for proto, author in zip(protos, authors)
         ]
 
     async def fetch_user_published_files(
         self,
-        user_id64: int,
+        user_id64: ID64,
         app_id: int,
         page: int,
         file_type: PublishedFileType,
         revision: PublishedFileRevision,
         language: Language | None,
     ) -> published_file.GetUserFilesResponse:
-        msg: MsgProto[published_file.GetUserFilesResponse] = await self.ws.send_um_and_wait(
-            "PublishedFile.GetUserFiles",
-            steamid=user_id64,
-            appid=app_id,
-            numperpage=30,
-            page=page,
-            filetype=file_type.value,
-            language=(language or self.language).value,
-            return_vote_data=True,
-            return_tags=True,
-            return_kv_tags=True,
-            return_previews=True,
-            return_children=True,
-            return_for_sale_data=True,
-            return_metadata=True,
-            return_playtime_stats=True,
-            strip_description_bbcode=True,
-            return_reactions=True,
-            desired_revision=revision,
-            return_apps=True,
+        msg: published_file.GetUserFilesResponse = await self.ws.send_um_and_wait(
+            published_file.GetUserFilesRequest(
+                steamid=user_id64,
+                appid=app_id,
+                numperpage=30,
+                page=page,
+                filetype=file_type.value,
+                language=(language or self.language).value,
+                return_vote_data=True,
+                return_tags=True,
+                return_kv_tags=True,
+                return_previews=True,
+                return_children=True,
+                return_for_sale_data=True,
+                return_metadata=True,
+                return_playtime_stats=True,
+                strip_description_bbcode=True,
+                return_reactions=True,
+                desired_revision=revision,  # type: ignore
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body
+        return msg
 
-    async def fetch_game_published_files(
+    async def fetch_app_published_files(
         self,
-        game_id: int,
-        after: datetime,
-        before: datetime,
+        app_id: int,
         file_type: PublishedFileQueryFileType,
         revision: PublishedFileRevision,
         language: Language | None,
         limit: int | None,
         cursor: str = "*",
     ) -> published_file.QueryFilesResponse:
-        msg: MsgProto[published_file.QueryFilesResponse] = await self.ws.send_um_and_wait(
-            "PublishedFile.QueryFiles",
-            numperpage=min(limit or 100, 100),
-            appid=game_id,
-            filetype=file_type,
-            cursor=cursor,
-            language=(language or self.language).value,
-            date_range_created={"timestamp_start": after.timestamp(), "timestamp_end": before.timestamp()},
-            return_vote_data=True,
-            return_tags=True,
-            return_kv_tags=True,
-            return_previews=True,
-            return_children=True,
-            return_for_sale_data=True,
-            return_metadata=True,
-            return_playtime_stats=True,
-            return_details=True,
-            return_reactions=True,
-            desired_revision=revision,
+        msg: published_file.QueryFilesResponse = await self.ws.send_um_and_wait(
+            published_file.QueryFilesRequest(
+                numperpage=min(limit or 100, 100),
+                appid=app_id,
+                filetype=file_type,
+                cursor=cursor,
+                language=(language or self.language).value,
+                return_vote_data=True,
+                return_tags=True,
+                return_kv_tags=True,
+                return_previews=True,
+                return_children=True,
+                return_for_sale_data=True,
+                return_metadata=True,
+                return_playtime_stats=True,
+                return_details=True,
+                return_reactions=True,
+                desired_revision=revision,  # type: ignore
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body
+        return msg
 
     async def fetch_published_file_parents(
         self,
         published_file_id: int,
         revision: PublishedFileRevision,
         language: Language | None,
         cursor: str = "*",
     ) -> published_file.QueryFilesResponse:
-        msg: MsgProto[published_file.QueryFilesResponse] = await self.ws.send_um_and_wait(
-            "PublishedFile.QueryFiles",
-            numperpage=100,
-            child_publishedfileid=published_file_id,
-            cursor=cursor,
-            language=(language or self.language).value,
-            return_vote_data=True,
-            return_tags=True,
-            return_kv_tags=True,
-            return_previews=True,
-            return_children=True,
-            return_for_sale_data=True,
-            return_metadata=True,
-            return_playtime_stats=True,
-            return_details=True,
-            return_reactions=True,
-            desired_revision=revision,
+        msg: published_file.QueryFilesResponse = await self.ws.send_um_and_wait(
+            published_file.QueryFilesRequest(
+                numperpage=100,
+                child_publishedfileid=published_file_id,
+                cursor=cursor,
+                language=(language or self.language).value,
+                return_vote_data=True,
+                return_tags=True,
+                return_kv_tags=True,
+                return_previews=True,
+                return_children=True,
+                return_for_sale_data=True,
+                return_metadata=True,
+                return_playtime_stats=True,
+                return_details=True,
+                return_reactions=True,
+                desired_revision=revision,  # type: ignore
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body
+        return msg
 
     async def fetch_published_file_history(
         self, published_file_id: int, language: Language | None
     ) -> list[published_file.GetChangeHistoryResponseChangeLog]:
-        msg: MsgProto[published_file.GetChangeHistoryResponse] = await self.ws.send_um_and_wait(
-            "PublishedFile.GetChangeHistory",
-            publishedfileid=published_file_id,
-            language=(language or self.language).value,
+        msg: published_file.GetChangeHistoryResponse = await self.ws.send_um_and_wait(
+            published_file.GetChangeHistoryRequest(
+                publishedfileid=published_file_id,
+                language=(language or self.language).value,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body.changes
+        return msg.changes
 
     async def fetch_published_file_history_entry(
         self, published_file_id: int, dt: datetime, language: Language | None
     ) -> published_file.GetChangeHistoryEntryResponse:
-        msg: MsgProto[published_file.GetChangeHistoryEntryResponse] = await self.ws.send_um_and_wait(
-            "PublishedFile.GetChangeHistoryEntry",
-            publishedfileid=published_file_id,
-            timestamp=dt.timestamp(),
-            language=(language or self.language).value,
+        msg: published_file.GetChangeHistoryEntryResponse = await self.ws.send_um_and_wait(
+            published_file.GetChangeHistoryEntryRequest(
+                publishedfileid=published_file_id,
+                timestamp=int(dt.timestamp()),
+                language=(language or self.language).value,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        return msg.body
+        return msg
 
     async def subscribe_to_published_file(self, published_file_id: int) -> None:
         msg = await self.ws.send_um_and_wait(
-            "PublishedFile.Subscribe", publishedfileid=published_file_id, notifyclient=True
+            published_file.SubscribeRequest(publishedfileid=published_file_id, notifyclient=True)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def unsubscribe_from_published_file(self, published_file_id: int) -> None:
         msg = await self.ws.send_um_and_wait(
-            "PublishedFile.Unsubscribe", publishedfileid=published_file_id, notifyclient=True
+            published_file.UnsubscribeRequest(publishedfileid=published_file_id, notifyclient=True)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def is_subscribed_to_published_file(self, published_file_id: int) -> bool:
-        msg: MsgProto[published_file.CanSubscribeResponse] = await self.ws.send_um_and_wait(
-            "PublishedFile.CanSubscribe", publishedfileid=published_file_id
+        msg: published_file.CanSubscribeResponse = await self.ws.send_um_and_wait(
+            published_file.CanSubscribeRequest(publishedfileid=published_file_id)
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
-        return msg.body.can_subscribe
+        return msg.can_subscribe
 
     async def add_published_file_child(self, published_file_id: int, child_published_file_id: int) -> None:
         msg = await self.ws.send_um_and_wait(
-            "PublishedFile.AddChild", publishedfileid=published_file_id, child_publishedfileid=child_published_file_id
+            published_file.AddChildRequest(
+                publishedfileid=published_file_id, child_publishedfileid=child_published_file_id
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def remove_published_file_child(self, published_file_id: int, child_published_file_id: int) -> None:
         msg = await self.ws.send_um_and_wait(
-            "PublishedFile.RemoveChild",
-            publishedfileid=published_file_id,
-            child_publishedfileid=child_published_file_id,
+            published_file.RemoveChildRequest(
+                publishedfileid=published_file_id,
+                child_publishedfileid=child_published_file_id,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def upvote_published_file(self, published_file_id: int, vote_up: bool) -> None:
         msg = await self.ws.send_um_and_wait(
-            "PublishedFile.Vote",
-            publishedfileid=published_file_id,
-            vote_up=vote_up,
+            published_file.VoteRequest(
+                publishedfileid=published_file_id,
+                vote_up=vote_up,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def edit_published_file(
         self,
         published_file_id: int,
-        game_id: int,
+        app_id: int,
         name: str,
         content: str,
         visibility: int,
         tags: Sequence[str],
         filename: str,
         preview_filename: str,
     ):
         msg = await self.ws.send_um_and_wait(
-            "PublishedFile.Update",
-            appid=game_id,
-            publishedfileid=published_file_id,
-            title=name,
-            file_description=content,
-            visibility=visibility,
-            tags=tags,
-            filename=filename,
-            preview_filename=preview_filename,
+            published_file.UpdateRequest(
+                appid=app_id,
+                publishedfileid=published_file_id,
+                title=name,
+                file_description=content,
+                visibility=visibility,
+                tags=tags,
+                filename=filename,
+                preview_filename=preview_filename,
+            )
         )
         if msg.result != Result.OK:
             raise WSException(msg)
 
     async def request_free_license(self, *app_ids: int) -> tuple[list[int], list[License]]:
         old_licenses = self.licenses.copy()
         self.handled_licenses.clear()
-        msg: MsgProto[client_server_2.CMsgClientRequestFreeLicenseResponse] = await self.ws.send_proto_and_wait(
-            MsgProto(EMsg.ClientRequestFreeLicense, appids=list(app_ids)),
+        msg: client_server_2.CMsgClientRequestFreeLicenseResponse = await self.ws.send_proto_and_wait(
+            client_server_2.CMsgClientRequestFreeLicense(appids=list(app_ids)),
         )
         if msg.result != Result.OK:
             raise WSException(msg)
-        if any(app_id not in msg.body.granted_appids for app_id in app_ids):
+        if any(app_id not in msg.granted_appids for app_id in app_ids):
             raise WSNotFound(msg)
-        if not msg.body.granted_packageids:
+        if not msg.granted_packageids:
             raise ValueError("No licenses granted")
         await self.handled_licenses.wait()
-        return msg.body.granted_appids, [l for l in self.licenses.values() if l.id not in old_licenses]
+        return msg.granted_appids, [l for l in self.licenses.values() if l.id not in old_licenses]
```

### Comparing `steamio-0.9.9/steam/trade.py` & `steamio-1.0.0a0/steam/trade.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,27 +5,30 @@
 import asyncio
 import dis
 import sys
 import types
 import warnings
 from collections.abc import Iterator, Sequence
 from datetime import datetime, timedelta
-from typing import TYPE_CHECKING, Any, Generic, NamedTuple, TypeVar, overload
+from typing import TYPE_CHECKING, Any, Generic, NamedTuple, TypeAlias, TypeVar, overload
 
-from typing_extensions import Self, TypeAlias
+from typing_extensions import Self
 
 from . import utils
 from ._const import URL
-from .enums import Language, Result, TradeOfferState
-from .errors import ClientException, ConfirmationError, HTTPException
-from .game import Game, StatefulGame
+from .app import App, PartialApp
+from .enums import Language, TradeOfferState
+from .errors import ClientException, ConfirmationError
+from .id import ID
+from .protobufs import econ
+from .types.id import AppID, AssetID, ClassID, ContextID, InstanceID
 from .utils import DateTime
 
 if TYPE_CHECKING:
-    from .abc import BaseUser, SteamID
+    from .abc import BaseUser
     from .state import ConnectionState
     from .types import trade
     from .user import User
 
 
 __all__ = (
     "Asset",
@@ -72,30 +75,30 @@
     __slots__ = (
         "id",
         "amount",
         "class_id",
         "instance_id",
         # "post_rollback_id",
         "owner",
-        "_game_cs",
+        "_app_cs",
         "_app_id",
         "_context_id",
         "_state",
     )
-    REPR_ATTRS = ("id", "class_id", "instance_id", "amount", "owner", "game")  # "post_rollback_id"
+    REPR_ATTRS = ("id", "class_id", "instance_id", "amount", "owner", "app")  # "post_rollback_id"
 
-    def __init__(self, state: ConnectionState, data: trade.Asset, owner: BaseUser):
-        self.id = int(data["assetid"])
-        self.amount = int(data["amount"])
-        self.instance_id = int(data["instanceid"])
-        self.class_id = int(data["classid"])
+    def __init__(self, state: ConnectionState, asset: econ.Asset, owner: BaseUser):
+        self.id = AssetID(asset.assetid)
+        self.amount = asset.amount
+        self.instance_id = InstanceID(asset.instanceid)
+        self.class_id = ClassID(asset.classid)
         # self.post_rollback_id = int(data["rollback_new_assetid"]) if "rollback_new_assetid" in data else None
         self.owner = owner
-        self._app_id = int(data["appid"])
-        self._context_id = int(data["contextid"])
+        self._app_id = AppID(asset.appid)
+        self._context_id = ContextID(asset.contextid)
         self._state = state
 
     def __repr__(self) -> str:
         cls = self.__class__
         resolved = [f"{attr}={getattr(self, attr, None)!r}" for attr in cls.REPR_ATTRS]
         return f"<{cls.__name__} {' '.join(resolved)}>"
 
@@ -113,46 +116,41 @@
         return {
             "assetid": str(self.id),
             "amount": self.amount,
             "appid": str(self._app_id),
             "contextid": str(self._context_id),
         }
 
+    def to_proto(self) -> econ.Asset:
+        return econ.Asset(
+            assetid=self.id,
+            amount=self.amount,
+            instanceid=self.instance_id,
+            classid=self.class_id,
+            appid=self._app_id,
+            contextid=self._context_id,
+        )
+
     @utils.cached_slot_property
-    def game(self) -> StatefulGame:
-        """The game the item is from."""
-        return StatefulGame(self._state, id=self._app_id, context_id=self._context_id)
+    def app(self) -> PartialApp:
+        """The app the item is from."""
+        return PartialApp(self._state, id=self._app_id, context_id=self._context_id)
 
     @property
     def url(self) -> str:
         """The URL for the asset in the owner's inventory.
 
         e.g. https://steamcommunity.com/profiles/76561198248053954/inventory/#440_2_8526584188
         """
         return f"{URL.COMMUNITY}/profiles/{self.owner.id64}/inventory#{self._app_id}_{self._context_id}_{self.id}"
 
-    @property
-    def asset_id(self) -> int:
-        """The assetid of the item.
-
-        .. deprecated:: 0.9.0:: Use :attr:`id` instead.
-        """
-        warnings.warn("asset_id is deprecated, use id instead", DeprecationWarning)
-        return self.id
-
 
 class Item(Asset):
     """Represents an item in a User's inventory.
 
-    .. container:: operations
-
-        .. describe:: x == y
-
-            Checks if two items are equal.
-
     Attributes
     -------------
     name
         The market_name of the item.
     display_name
         The displayed name of the item. This could be different to :attr:`Item.name` if the item is user re-nameable.
     colour
@@ -187,64 +185,48 @@
         "owner_actions",
         "market_actions",
         "_is_tradable",
         "_is_marketable",
     )
     REPR_ATTRS = ("name", *Asset.REPR_ATTRS)
 
-    def __init__(self, state: ConnectionState, data: trade.Item, owner: BaseUser):
-        super().__init__(state, data, owner)
-        self._from_data(data)
-
-    def _from_data(self, data: trade.Item) -> None:
-        self.name = data.get("market_name")
-        self.display_name = data.get("name")
-        self.colour = int(data["name_color"], 16) if "name_color" in data else None
-        self.descriptions = data.get("descriptions")
-        self.owner_descriptions = data.get("owner_descriptions", [])
-        self.type = data.get("type")
-        self.tags = data.get("tags")
+    def __init__(self, state: ConnectionState, asset: econ.Asset, description: econ.ItemDescription, owner: BaseUser):
+        super().__init__(state, asset, owner)
+
+        self.name = description.market_name
+        self.display_name = description.name or self.name
+        self.colour = int(description.name_color, 16) if description.name_color else None
+        self.descriptions = description.descriptions
+        self.owner_descriptions = description.owner_descriptions
+        self.type = description.type
+        self.tags = description.tags
         self.icon_url = (
-            f"https://steamcommunity-a.akamaihd.net/economy/image/{data['icon_url_large']}"
-            if "icon_url_large" in data
-            else f"https://steamcommunity-a.akamaihd.net/economy/image/{data['icon_url']}"
-            if "icon_url" in data
+            f"https://steamcommunity-a.akamaihd.net/economy/image/{description.icon_url_large}"
+            if description.icon_url_large
+            else f"https://steamcommunity-a.akamaihd.net/economy/image/{description.icon_url}"
+            if description.icon_url
             else None
         )
-        self.fraud_warnings = data.get("fraudwarnings", [])
-        self.actions = data.get("actions", [])
-        self.owner_actions = data.get("owner_actions")
-        self.market_actions = data.get("market_actions")
-        self._is_tradable = bool(data.get("tradable", False))
-        self._is_marketable = bool(data.get("marketable", False))
+        self.fraud_warnings = description.fraudwarnings
+        self.actions = description.actions
+        self.owner_actions = description.owner_actions
+        self.market_actions = description.market_actions
+        self._is_tradable = description.tradable
+        self._is_marketable = description.marketable
 
     def is_tradable(self) -> bool:
         """Whether the item is tradable."""
         return self._is_tradable
 
     def is_marketable(self) -> bool:
         """Whether the item is marketable."""
         return self._is_marketable
 
 
-kwargs: dict[str, Any]
-if sys.version_info >= (3, 9, 2):  # GenericAlias wasn't subclass-able in 3.9.0
-    GenericAlias = types.GenericAlias
-    kwargs = {}
-else:
-    GenericAlias = type(
-        types.new_class(
-            "",
-            (Generic[TypeVar("T")],),  # type: ignore
-        )[int]
-    )
-    kwargs = {"_root": True}
-
-
-class InventoryGenericAlias(GenericAlias, **kwargs):
+class InventoryGenericAlias(types.GenericAlias):
     __alias_name__: str
     __args__: tuple[type[ItemT_co]]  # type: ignore
 
     def __repr__(self) -> str:
         return f"{self.__origin__.__module__}.{object.__getattribute__(self, '__alias_name__')}"
 
     def __call__(self, *args: Any, **kwargs: Any) -> object:
@@ -267,34 +249,39 @@
         return (BaseInventory,)
 
 
 class BaseInventory(Generic[ItemT_co]):
     """Base for all inventories."""
 
     __slots__ = (
-        "game",
+        "app",
         "items",
         "owner",
         "_language",
         "_state",
         "__orig_class__",  # undocumented typing internals more shim to make extensions work
     )
     __orig_class__: InventoryGenericAlias
 
     def __init__(
-        self, state: ConnectionState, data: trade.Inventory, owner: BaseUser, game: Game, language: Language | None
+        self,
+        state: ConnectionState,
+        data: econ.GetInventoryItemsWithDescriptionsResponse,
+        owner: BaseUser,
+        app: App,
+        language: Language | None,
     ):
         self._state = state
         self.owner = owner
-        self.game = StatefulGame(state, id=game.id, name=game.name, context_id=game.context_id)
+        self.app = PartialApp(state, id=app.id, name=app.name)
         self._language = language
         self._update(data)
 
     def __repr__(self) -> str:
-        attrs = ("owner", "game")
+        attrs = ("owner", "app")
         resolved = [f"{attr}={getattr(self, attr)!r}" for attr in attrs]
         return f"<{self.__orig_class__} {' '.join(resolved)}>"
 
     def __len__(self) -> int:
         return len(self.items)
 
     def __iter__(self) -> Iterator[ItemT_co]:
@@ -327,107 +314,65 @@
                     return_next = True
             else:
                 return generic_alias
 
             object.__setattr__(generic_alias, "__alias_name__", instruction.argval)
             return generic_alias
 
-    def _update(self, data: trade.Inventory) -> None:
-        items = []
+    def _update(self, data: econ.GetInventoryItemsWithDescriptionsResponse) -> None:
+        items: list[ItemT_co] = []
         (ItemClass,) = self.__orig_class__.__args__
-        for asset in data.get("assets", ()):
-            for item in data["descriptions"]:
-                if item["instanceid"] == asset["instanceid"] and item["classid"] == asset["classid"]:
-                    item.update(asset)  # type: ignore  # maybe this will work if types.IntersectionType happens
-                    items.append(ItemClass(self._state, data=item, owner=self.owner))  # type: ignore
+        for asset in data.assets:
+            for description in data.descriptions:
+                if description.instanceid == asset.instanceid and description.classid == asset.classid:
+                    items.append(ItemClass(self._state, asset=asset, description=description, owner=self.owner))
                     break
             else:
-                items.append(Asset(self._state, data=asset, owner=self.owner))
+                items.append(Asset(self._state, asset=asset, owner=self.owner))  # type: ignore  # should never happen anyway
         self.items: Sequence[ItemT_co] = items
 
     async def update(self) -> None:
         """Re-fetches the inventory and updates it inplace."""
-        if self.owner == self._state.user:
-            data = await self._state.http.get_client_user_inventory(self.game.id, self.game.context_id, self._language)
-        else:
-            data = await self._state.http.get_user_inventory(
-                self.owner.id64, self.game.id, self.game.context_id, self._language
-            )
+        # if self.owner == self._state.user:
+        #     data = await self._state.fetch_client_user_inventory(self.app.id, self.app.context_id, self._language)
+        # else:
+        data = await self._state.fetch_user_inventory(self.owner.id64, self.app.id, self.app.context_id, self._language)
         self._update(data)
 
-    def filter_items(self, *names: str, limit: int | None = None) -> list[ItemT_co]:
-        """A helper function that filters items by name from the inventory.
-
-        .. deprecated:: 0.9
-
-            Use a list comprehension instead of this.
-
-        Parameters
-        ------------
-        names
-            The names of the items to filter for.
-        limit
-            The maximum amount of items to return. Checks from the front of the items.
-
-        Raises
-        -------
-        :exc:`ValueError`
-            You passed a limit and multiple item names.
-
-        Returns
-        ---------
-        The matching items.
-        """
-        if len(names) > 1 and limit:
-            raise ValueError("Cannot pass a limit with multiple items")
-        items = [item for item in self if item.name in names]
-        return items if limit is None else items[:limit]
-
-    def get_item(self, name: str) -> ItemT_co | None:
-        """A helper function that gets an item or ``None`` if no matching item is found by name from the inventory.
-
-        .. deprecated:: 0.9
-
-            Use :func:`steam.utils.get` instead of this.
-
-        Parameters
-        ----------
-        name
-            The item to get from the inventory.
-        """
-        item = self.filter_items(name, limit=1)
-        return item[0] if item else None
-
 
 Inventory: TypeAlias = BaseInventory[Item]  # necessitated by TypeVar not currently supporting defaults
 """Represents a User's inventory.
 
 .. container:: operations
 
     .. describe:: len(x)
 
         Returns how many items are in the inventory.
 
     .. describe:: iter(x)
 
         Iterates over the inventory's items.
 
+    .. describe:: x[i]
+
+        Returns the item at the given index.
+
     .. describe:: y in x
 
         Determines if an item is in the inventory based off of its :attr:`Asset.id`.
 
 
 Attributes
 ----------
 items
     A list of the inventory's items.
 owner
     The owner of the inventory.
-game
-    The game the inventory the game belongs to.
+app
+    The app the inventory the app belongs to.
 """
 
 
 class TradeOfferReceipt(NamedTuple):
     sent: list[MovedItem]
     received: list[MovedItem]
 
@@ -447,25 +392,24 @@
         "new_id",
         "new_context_id",
     )
     REPR_ATTRS = (*Item.REPR_ATTRS, "new_id", "new_context_id")
     new_id: int
     new_context_id: int
 
-    def _from_data(self, data: trade.TradeOfferReceiptItem):
-        super()._from_data(data)
+    def __init__(self, state: ConnectionState, data: trade.TradeOfferReceiptItem, owner: BaseUser):
+        super().__init__(
+            state,
+            asset=econ.Asset().from_dict(data),  # type: ignore  # TODO waiting on https://github.com/danielgtaylor/python-betterproto/issues/432
+            description=econ.ItemDescription().from_dict(data),  # type: ignore
+            owner=owner,
+        )
         self.new_id = int(data["new_assetid"])
         self.new_context_id = int(data["new_contextid"])
 
-    @property
-    def new_asset_id(self) -> int:
-        """The new asset ID of the item in the partner's inventory."""
-        warnings.warn("new_asset_id is deprecated, use new_id instead", DeprecationWarning)
-        return self.new_id
-
 
 class TradeOffer:
     """Represents a trade offer from/to send to a User.
     This can also be used in :meth:`steam.User.send`.
 
     Parameters
     ----------
@@ -481,15 +425,15 @@
         The trade token used to send trades to users who aren't on the ClientUser's friend's list.
     message
          The offer message to send with the trade.
 
     Attributes
     ----------
     partner
-        The trade offer partner. This should only ever be a :class:`~steam.SteamID` if the partner's profile is private.
+        The trade offer partner. This should only ever be a :class:`steam.ID` if the partner's profile is private.
     items_to_send
         A list of items to send to the partner.
     items_to_receive
         A list of items to receive from the partner.
     state
         The offer state of the trade for the possible types see :class:`~steam.TradeOfferState`.
     message
@@ -525,15 +469,15 @@
         "items_to_receive",
         "_has_been_sent",
         "_state",
         "_is_our_offer",
     )
 
     id: int
-    partner: User | SteamID
+    partner: User | ID
 
     @overload
     def __init__(
         self,
         *,
         token: str | None = ...,
         message: str | None = ...,
@@ -571,34 +515,27 @@
         self.created_at: datetime | None = None
         self.escrow: timedelta | None = None
         self.state = TradeOfferState.Invalid
         self._id: int | None = None
         self._has_been_sent = False
 
     @classmethod
-    def _from_api(cls, state: ConnectionState, data: trade.TradeOffer, partner: User | SteamID | None = None) -> Self:
+    def _from_api(cls, state: ConnectionState, data: trade.TradeOffer, partner: User | ID | None = None) -> Self:
         trade = cls()
         trade._has_been_sent = True
         trade._state = state
-        if partner is None:
-            from .abc import SteamID
-
-            trade.partner = SteamID(data["accountid_other"])
-        else:
-            trade.partner = partner
+        trade.partner = ID(data["accountid_other"]) if partner is None else partner
         trade._update(data)
         return trade
 
     @classmethod
     def _from_history(cls, state: ConnectionState, data: trade.TradeOfferHistoryTrade) -> Self:
         received: list[trade.TradeOfferReceiptItem] = data.get("assets_received", [])  # type: ignore
         sent: list[trade.TradeOfferReceiptItem] = data.get("assets_given", [])  # type: ignore
-        from .abc import SteamID
-
-        partner = SteamID(data["steamid_other"])
+        partner = ID(data["steamid_other"])
         trade = cls(
             items_to_receive=[MovedItem(state, item, partner) for item in received],
             items_to_send=[MovedItem(state, item, state.user) for item in sent],
         )
         trade._state = state
         trade._id = int(data["tradeid"])
         trade.partner = partner
@@ -632,18 +569,30 @@
         created_at = data.get("time_created")
         self.expires = DateTime.from_timestamp(expires) if expires else None
         self.escrow = DateTime.from_timestamp(escrow) - DateTime.now() if escrow else None
         self.updated_at = DateTime.from_timestamp(updated_at) if updated_at else None
         self.created_at = DateTime.from_timestamp(created_at) if created_at else None
         self.state = TradeOfferState.try_value(data.get("trade_offer_state", 1))
         self.items_to_send = [
-            Item(self._state, data=item, owner=self.partner) for item in data.get("items_to_give", [])
+            Item(
+                self._state,
+                asset=econ.Asset().from_dict(item),
+                description=econ.ItemDescription().from_dict(item),
+                owner=self.partner,
+            )
+            for item in data.get("items_to_give", ())
         ]
         self.items_to_receive = [
-            Item(self._state, data=item, owner=self.partner) for item in data.get("items_to_receive", [])
+            Item(
+                self._state,
+                asset=econ.Asset().from_dict(item),
+                description=econ.ItemDescription().from_dict(item),
+                owner=self.partner,
+            )
+            for item in data.get("items_to_receive", ())
         ]
         self._is_our_offer = data.get("is_our_offer", False)
 
     def __eq__(self, other: Any) -> bool:
         if not isinstance(other, TradeOffer):
             return NotImplemented
         if self._has_been_sent and other._has_been_sent:
```

### Comparing `steamio-0.9.9/steam/types/game.py` & `steamio-1.0.0a0/steam/types/app.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,32 +3,20 @@
 from __future__ import annotations
 
 from typing import Any
 
 from typing_extensions import Literal, TypedDict
 
 
-class GetOwnedGames(TypedDict):
-    games: list[GetOwnedGamesGame]
-
-
-class GetOwnedGamesGame(TypedDict):
-    name: str
-    appid: str
-    playtime_forever: int
-    img_icon_url: str
-    has_community_visible_stats: bool
-
-
-class GameToDict(TypedDict, total=False):
+class AppToDict(TypedDict, total=False):
     game_id: str
     game_extra_info: str
 
 
-class WishlistGame(TypedDict):
+class WishlistApp(TypedDict):
     name: str
     capsule: str
     review_score: int
     review_desc: str
     reviews_total: str
     reviews_percent: int
     release_date: int
@@ -66,24 +54,24 @@
     option_text: str
     option_description: str
     can_get_free_license: str
     is_free_license: bool
     price_in_cents_with_discount: int
 
 
-class FetchedGamePriceOverview(TypedDict):
+class FetchedAppPriceOverview(TypedDict):
     currency: str
     initial: int
     final: int
     discount_percent: int
     initial_formatted: str
     final_formatted: str
 
 
-class FetchedGame(TypedDict):
+class FetchedApp(TypedDict):
     # https://wiki.teamfortress.com/wiki/User:RJackson/StorefrontAPI#Result_data_3
     type: Literal["game", "dlc", "demo", "advertising", "mod", "video"]
     name: str
     steam_appid: int
     required_age: int
     is_free: bool
     controller_support: Literal["partial", "full"]
@@ -96,15 +84,15 @@
     pc_requirements: list[dict[str, str]]
     mac_requirements: list[dict[str, str]]
     linux_requirements: list[dict[str, str]]
     legal_notice: str
     developers: list[str]
     publishers: list[str]
     demos: list[dict[str, Any]]
-    price_overview: FetchedGamePriceOverview
+    price_overview: FetchedAppPriceOverview
     packages: list[int]
     package_groups: list[PackageGroups]
     platforms: dict[str, bool]
     metacritic: list[dict[str, str]]
     categories: list[dict[str, str]]
     release_date: dict[str, str]
     background: str
```

### Comparing `steamio-0.9.9/steam/types/manifest.py` & `steamio-1.0.0a0/steam/types/manifest.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 
 from multidict import MultiDict
 from typing_extensions import Literal, NotRequired, Required
 
 from .vdf import TypedVDFDict, VDFDict, VDFInt, VDFList
 
 
-class GameInfo(TypedVDFDict):
+class AppInfo(TypedVDFDict):
     appid: str
     common: Common
     extended: NotRequired[Extended]
     config: VDFDict
     depots: Depot | VDFDict
     ufs: MultiDict[VDFInt]
     sysreqs: MultiDict[MultiDict[Any]]
```

### Comparing `steamio-0.9.9/steam/types/package.py` & `steamio-1.0.0a0/steam/types/package.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,9 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
-
 from typing_extensions import TypedDict
 
 
 class FetchedPackageApp(TypedDict):
     id: int
     name: str
```

### Comparing `steamio-0.9.9/steam/types/trade.py` & `steamio-1.0.0a0/steam/types/trade.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020 James H-B. See LICENSE"""
 
 from typing_extensions import NotRequired, Required, TypedDict
 
 
+# str | int keys are cast to int in Asset.__init__
 class AssetToDict(TypedDict):
-    assetid: str
+    assetid: str | int
     amount: int
-    appid: str
-    contextid: str
+    appid: str | int
+    contextid: str | int
 
 
 class Asset(AssetToDict):
-    instanceid: str
-    classid: str
+    instanceid: str | int
+    classid: str | int
     missing: bool
     # rollback_new_assetid: NotRequired[str]
 
 
 class ItemDescriptionLine(TypedDict):
     type: str
     value: str
@@ -35,20 +36,20 @@
     internal_name: str
     localized_category_name: str
     localized_tag_name: str
     color: str
 
 
 class Description(TypedDict, total=False):
-    instanceid: Required[str]
-    classid: Required[str]
+    instanceid: Required[str | int]
+    classid: Required[str | int]
     market_name: str
     currency: int
     name: str
-    market_hash_name: str
+    market_hash_name: Required[str]
     name_color: str
     background_color: str  # hex code
     type: str
     descriptions: list[ItemDescriptionLine]
     owner_descriptions: list[ItemDescriptionLine]
     actions: list[ItemAction]
     owner_actions: list[ItemAction]
@@ -62,24 +63,14 @@
     fraudwarnings: list[str]
 
 
 class Item(Asset, Description):
     """We combine Assets with their matching Description to form items."""
 
 
-class Inventory(TypedDict):
-    assets: list[Asset]
-    descriptions: list[Description]
-    total_inventory_count: int
-    last_assetid: str
-    more_items: bool
-    success: int  # Result
-    rwgrsn: int  # p. much always -2
-
-
 class TradeOffer(TypedDict):
     tradeofferid: str
     tradeid: str  # only used for receipts (it's not the useful one)
     accountid_other: int
     message: str
     trade_offer_state: int  # TradeOfferState
     expiration_time: int  # unix timestamps
```

### Comparing `steamio-0.9.9/steam/types/user.py` & `steamio-1.0.0a0/steam/types/user.py`

 * *Files identical despite different names*

### Comparing `steamio-0.9.9/steam/types/vdf.py` & `steamio-1.0.0a0/steam/types/vdf.py`

 * *Files identical despite different names*

### Comparing `steamio-0.9.9/steam/user.py` & `steamio-1.0.0a0/steam/user.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,95 +1,90 @@
 """Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE"""
 
 from __future__ import annotations
 
 import asyncio
 import sys
-from collections.abc import Coroutine
+import weakref
+from collections.abc import Coroutine, Sequence
 from datetime import timedelta
+from ipaddress import IPv4Address
 from operator import attrgetter
 from typing import TYPE_CHECKING, Any
 
 from . import utils
 from ._const import URL
 from .abc import BaseUser, Messageable
-from .enums import CommunityVisibilityState, Language, PersonaState, PersonaStateFlag, Result, TradeOfferState, Type
+from .app import PartialApp
+from .enums import Language, PersonaState, PersonaStateFlag, Result, TradeOfferState, Type
 from .errors import ClientException, ConfirmationError, HTTPException
-from .game import Game, StatefulGame
+from .id import ID
 from .profile import ClientUserProfile, OwnedProfileItems, ProfileInfo, ProfileItem
-from .trade import Inventory, TradeOffer
+from .protobufs import player
+from .trade import TradeOffer
+from .types.id import ID64, AppID, Intable
 from .utils import DateTime
 
 if TYPE_CHECKING:
+    from .app import App
     from .friend import Friend
     from .image import Image
     from .message import UserMessage
+    from .protobufs.friends import CMsgClientPersonaStateFriend as UserProto
     from .state import ConnectionState
-    from .types import user
-    from .types.id import ID64
+    from .trade import Inventory
 
 __all__ = (
     "User",
     "ClientUser",
+    "AnonymousClientUser",
 )
 
 
 class _BaseUser(BaseUser):
-    __slots__ = ()
+    __slots__ = (
+        "name",
+        "app",
+        "state",
+        "flags",
+        "trade_url",
+        "last_seen_online",
+        "last_logoff",
+        "last_logon",
+        "rich_presence",
+        "game_server_ip",
+        "game_server_port",
+        "_state",
+        "_avatar_sha",
+    )
 
-    def __init__(self, state: ConnectionState, data: user.User):
-        super().__init__(data["steamid"])
+    def __init__(self, state: ConnectionState, proto: UserProto):
+        super().__init__(proto.friendid)
         self._state = state
-        self.real_name = None
-        self.community_url = None
-        self.avatar_url = None
-        self.primary_clan = None
-        self.country = None
-        self.created_at = None
-        self.last_logoff = None
-        self.last_logon = None
-        self.last_seen_online = None
-        self.game = None
-        self.state = None
-        self.flags = None
-        self.privacy_state = None
-        self.comment_permissions = None
-        self.profile_state = None
-        self.rich_presence = None
-        self._update(data)
-
-    def _update(self, data: user.User) -> None:
-        self.name = data["personaname"]
-        self.real_name = data.get("realname") or self.real_name
-        self.community_url = data.get("profileurl") or super().community_url
-        self.avatar_url = data.get("avatarfull") or self.avatar_url
-        self.trade_url = URL.COMMUNITY / "tradeoffer/new/" % {"partner": str(self.id)}
-        from .clan import Clan  # circular import
+        self._update(proto)
 
-        self.primary_clan = (
-            Clan(self._state, data["primaryclanid"]) if "primaryclanid" in data else self.primary_clan  # type: ignore
-        )
-        self.country = data.get("loccountrycode") or self.country
-        self.created_at = DateTime.from_timestamp(data["timecreated"]) if "timecreated" in data else self.created_at
-        self.last_logoff = DateTime.from_timestamp(data["lastlogoff"]) if "lastlogoff" in data else self.last_logoff
-        self.last_logon = DateTime.from_timestamp(data["last_logon"]) if "last_logon" in data else self.last_logon
-        self.last_seen_online = (
-            DateTime.from_timestamp(data["last_seen_online"]) if "last_seen_online" in data else self.last_seen_online
-        )
-        self.rich_presence = data["rich_presence"] if "rich_presence" in data else self.rich_presence
-        self.game = (
-            StatefulGame(self._state, name=data["gameextrainfo"], id=data["gameid"]) if "gameid" in data else self.game
+    def _update(self, proto: UserProto) -> None:
+        self.name = proto.player_name
+        self._avatar_sha = proto.avatar_hash
+        self.trade_url = URL.COMMUNITY / f"tradeoffer/new/?partner={self.id}"
+
+        self.game_server_ip = IPv4Address(proto.game_server_ip) if proto.game_server_ip else None
+        self.game_server_port = proto.game_server_port or None
+
+        self.last_logoff = DateTime.from_timestamp(proto.last_logoff)
+        self.last_logon = DateTime.from_timestamp(proto.last_logon)
+        self.last_seen_online = DateTime.from_timestamp(proto.last_seen_online)
+        self.rich_presence = {message.key: message.value for message in proto.rich_presence}
+        self.app = (
+            PartialApp(self._state, name=proto.game_name, id=proto.game_played_app_id)
+            if proto.game_played_app_id
+            else None
         )
-        self.state = PersonaState.try_value(data.get("personastate", 0)) or self.state
-        self.flags = PersonaStateFlag.try_value(data.get("personastateflags", 0)) or self.flags
-        self.privacy_state = CommunityVisibilityState.try_value(data.get("communityvisibilitystate", 0))
-        self.comment_permissions = CommunityVisibilityState.try_value(
-            data.get("commentpermission", 0)
-        )  # FIXME CommentPrivacyState
-        self.profile_state = CommunityVisibilityState.try_value(data.get("profilestate", 0))
+        self.state = PersonaState.try_value(proto.persona_state) or self.state
+        self.flags = PersonaStateFlag.try_value(proto.persona_state_flags) or self.flags
 
 
 class User(_BaseUser, Messageable["UserMessage"]):
     """Represents a Steam user's account.
 
     .. container:: operations
 
@@ -103,16 +98,16 @@
 
     Attributes
     ----------
     name
         The user's username.
     state
         The current persona state of the account (e.g. LookingToTrade).
-    game
-        The Game instance attached to the user. Is ``None`` if the user isn't in a game or one that is recognised by the
+    app
+        The app the user is playing. Is ``None`` if the user isn't in a app or one that is recognised by the
         api.
     avatar_url
         The avatar url of the user. Uses the large (184x184 px) image url.
     real_name
         The user's real name defined by them. Could be ``None``.
     primary_clan
         The user's primary clan.
@@ -131,32 +126,32 @@
         The persona state flags of the account.
     """
 
     __slots__ = ()
 
     async def add(self) -> None:
         """Sends a friend invite to the user to your friends list."""
-        await self._state.http.add_user(self.id64)
+        await self._state.add_user(self.id64)
 
     async def remove(self) -> None:
         """Remove the user from your friends list."""
-        await self._state.http.remove_user(self.id64)
+        await self._state.remove_user(self.id64)
         self._state.user._friends.pop(self.id64, None)
 
     async def cancel_invite(self) -> None:
         """Cancels an invitation sent to the user. This effectively does the same thing as :meth:`remove`."""
-        await self._state.http.remove_user(self.id64)
+        await self._state.remove_user(self.id64)
 
     async def block(self) -> None:
         """Blocks the user."""
-        await self._state.http.block_user(self.id64)
+        await self._state.block_user(self.id64)
 
     async def unblock(self) -> None:
         """Unblocks the user."""
-        await self._state.http.unblock_user(self.id64)
+        await self._state.unblock_user(self.id64)
 
     async def escrow(self, token: str | None = None) -> timedelta | None:
         """Check how long any received items would take to arrive. ``None`` if the user has no escrow or has a
         private inventory.
 
         Parameters
         ----------
@@ -236,19 +231,18 @@
             trade._has_been_sent = True
             needs_confirmation = resp.get("needs_mobile_confirmation", False)
             trade._update_from_send(self._state, resp, self, active=not needs_confirmation)
             if needs_confirmation:
                 for tries in range(5):
                     try:
                         await trade.confirm()
-                        break
                     except ConfirmationError:
+                        break
+                    except ClientException:
                         await asyncio.sleep(tries * 2)
-                else:
-                    raise ConfirmationError("Failed to confirm trade offer")
                 trade.state = TradeOfferState.Active
 
             # make sure the trade is updated before this function returns
             self._state._trades[trade.id] = trade
             self._state._trades_to_watch.add(trade.id)
             await self._state.wait_for_trade(trade.id)
             self._state.dispatch("trade_send", trade)
@@ -273,62 +267,56 @@
 
             Returns the user's name.
 
     Attributes
     ----------
     name
         The user's username.
-    friends
-        A list of the :class:`ClientUser`'s friends.
     state
         The current persona state of the account (e.g. LookingToTrade).
-    game
-        The Game instance attached to the user. Is ``None`` if the user isn't in a game or one that is recognised by
-        the api.
-    avatar_url
-        The avatar url of the user. Uses the large (184x184 px) image url.
-    real_name
-        The user's real name defined by them. Could be ``None``.
-    primary_clan
-        The user's primary clan. Could be ``None``
-    created_at
-        The time at which the user's account was created. Could be ``None``.
+    app
+        The app the user is currently playing. Is ``None`` if the user isn't in an app or one that is recognised by the
+        api.
     last_logon
         The last time the user logged into steam. This is only ``None`` if user hasn't been updated from the websocket.
     last_logoff
         The last time the user logged off from steam. Could be ``None`` (e.g. if they are currently online).
     last_seen_online
         The last time the user could be seen online. This is only ``None`` if user hasn't been updated from the
         websocket.
-    country
-        The country code of the account. Could be ``None``.
     flags
         The persona state flags of the account.
     """
 
     # TODO more stuff to add https://github.com/DoctorMcKay/node-steamcommunity/blob/master/components/profile.js
 
-    __slots__ = ("_friends",)
+    __slots__ = ("_friends", "_inventory_locks")
 
-    def __init__(self, state: ConnectionState, data: user.User):
-        super().__init__(state, data)
+    def __init__(self, state: ConnectionState, proto: UserProto):
+        super().__init__(state, proto)
         self._friends: dict[ID64, Friend] = {}
+        self._inventory_locks = weakref.WeakValueDictionary[AppID, asyncio.Lock]()
 
-    async def friends(self) -> list[Friend]:
-        """Returns a list of the user's friends."""
+    async def friends(self) -> Sequence[Friend]:
+        """A list of the user's friends."""
         return list(self._friends.values())
 
-    def get_friend(self, id: utils.Intable) -> Friend | None:
+    def get_friend(self, id: Intable) -> Friend | None:
         """Get a friend from the client user's friends list."""
-        id64 = utils.make_id64(id, type=Type.Individual)
+        id64 = utils.parse_id64(id, type=Type.Individual)
         return self._friends.get(id64)
 
-    async def inventory(self, game: Game, *, language: Language | None = None) -> Inventory:
-        resp = await self._state.http.get_client_user_inventory(game.id, game.context_id, language)
-        return Inventory(state=self._state, data=resp, owner=self, game=game, language=language)
+    async def inventory(self, app: App, *, language: Language | None = None) -> Inventory:
+        try:
+            lock = self._inventory_locks[app.id]
+        except KeyError:
+            lock = self._inventory_locks[app.id] = asyncio.Lock()
+
+        async with lock:  # requires a per-app lock to avoid Result.DuplicateRequest
+            return await super().inventory(app, language=language)
 
     async def setup_profile(self) -> None:
         """Set up your profile if possible."""
         params = {"welcomed": 1}
         await self._state.http.get(URL.COMMUNITY / "my/edit", params=params)
 
     async def clear_nicks(self) -> None:
@@ -342,38 +330,38 @@
         ----------
         language
             The language to fetch the profile items in. If ``None`` the current language is used
         """
         items = await self._state.fetch_profile_items(language)
         return OwnedProfileItems(
             backgrounds=[
-                ProfileItem(self._state, self, background, um_name="ProfileBackground")
+                ProfileItem(self._state, self, background, um=player.SetProfileBackgroundRequest)
                 for background in items.profile_backgrounds
             ],
             mini_profile_backgrounds=[
-                ProfileItem(self._state, self, mini_profile_background, um_name="MiniProfileBackground")
+                ProfileItem(self._state, self, mini_profile_background, um=player.SetMiniProfileBackgroundRequest)
                 for mini_profile_background in items.mini_profile_backgrounds
             ],
             avatar_frames=[
-                ProfileItem(self._state, self, avatar_frame, um_name="AvatarFrame")
+                ProfileItem(self._state, self, avatar_frame, um=player.SetAvatarFrameRequest)
                 for avatar_frame in items.avatar_frames
             ],
             animated_avatars=[
-                ProfileItem(self._state, self, animated_avatar, um_name="AnimatedAvatar")
+                ProfileItem(self._state, self, animated_avatar, um=player.SetAnimatedAvatarRequest)
                 for animated_avatar in items.animated_avatars
             ],
             modifiers=[ProfileItem(self._state, self, modifier) for modifier in items.profile_modifiers],
         )
 
     async def profile(self, *, language: Language | None = None) -> ClientUserProfile:
         return ClientUserProfile(
             *await asyncio.gather(
                 self.equipped_profile_items(language=language),
                 self.profile_info(),
-                self.profile_customisation_info(language=language),
+                self.profile_customisation_info(),
                 self.profile_items(language=language),
             )
         )
 
     async def profile_info(self) -> ProfileInfo:
         """The friend's profile info."""
         info = await self._state.fetch_friend_profile_info(self.id64)
@@ -449,20 +437,32 @@
     ----
     This class does not forward ClientUsers attribute's so things like Clan().me.clear_nicks() will fail.
     """
 
     __slots__ = ("_user",)
 
     def __init__(self, state: ConnectionState, user: User):
-        super().__init__(user.id64, type=Type.Individual)  # type: ignore
+        ID.__init__(self, user.id64, type=Type.Individual)
         self._user = user
 
     def __init_subclass__(cls) -> None:
         super().__init_subclass__()
 
         for name, function in set(User.__dict__.items()) - set(object.__dict__.items()):
-            setattr(cls, name, function)
-        for name in (*User.__slots__, *BaseUser.__slots__):
+            if not name.startswith("__"):
+                setattr(cls, name, function)
+        for name in _BaseUser.__slots__:
             setattr(cls, name, property(attrgetter(f"_user.{name}")))  # TODO time this with a compiled property
             # probably wont be different than the above
 
         User.register(cls)
+
+
+class AnonymousClientUser(ID):
+    __slots__ = ("_state",)
+
+    def __init__(self, state: ConnectionState, id64: int):
+        super().__init__(id64, type=Type.AnonUser)
+        self._state = state
+
+    def __repr__(self) -> str:
+        return f"<AnonymousClientUser id={self.id} universe={self.universe!r}, instance={self.instance!r}>"
```

### Comparing `steamio-0.9.9/steam/utils.py` & `steamio-1.0.0a0/steam/utils.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,367 +1,72 @@
 """
 Licensed under The MIT License (MIT) - Copyright (c) 2020-present James H-B. See LICENSE
 
 Contains large portions of:
-https://github.com/ValvePython/steam/blob/master/steam/steamid.py
 https://github.com/Rapptz/discord.py/blob/master/discord/utils.py
-The appropriate licenses are in LICENSE
+The appropriate license is in LICENSE
 """
 
 from __future__ import annotations
 
 import abc
 import asyncio
+import base64
 import collections
-import contextvars
 import functools
 import html
-import json
 import re
 import struct
-import sys
-from collections.abc import Awaitable, Callable, Coroutine, Generator, Iterable, Mapping
+from collections.abc import (
+    AsyncGenerator,
+    AsyncIterable,
+    Awaitable,
+    Callable,
+    Coroutine,
+    Generator,
+    Iterable,
+    Mapping,
+    Sized,
+)
+from dataclasses import dataclass
 from datetime import datetime, timezone
 from inspect import getmembers, isawaitable
 from io import BytesIO
 from itertools import zip_longest
 from operator import attrgetter
 from types import MemberDescriptorType
-from typing import TYPE_CHECKING, Any, Generic, SupportsInt, TypeVar, cast, overload
+from typing import TYPE_CHECKING, Any, Final, Generic, Literal, ParamSpec, TypeAlias, TypedDict, TypeVar, cast, overload
 
-import aiohttp
 from cryptography.exceptions import InvalidSignature
 from cryptography.hazmat.primitives import hashes
 from cryptography.hazmat.primitives.asymmetric import padding, rsa
 from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
-from typing_extensions import Final, Literal, ParamSpec, Self, TypeAlias
+from typing_extensions import Self
 
-from .enums import InstanceFlag, Type, TypeChar, Universe, _is_descriptor, classproperty as classproperty
-from .errors import InvalidSteamID
+from ._const import JSON_LOADS, MISSING, URL
+from .enums import _is_descriptor, classproperty as classproperty
+from .id import (
+    _URL_START,
+    ID,
+    id64_from_url as id64_from_url,
+    parse_id2 as parse_id2,
+    parse_id3 as parse_id3,
+    parse_id64 as parse_id64,
+    parse_invite_code as parse_invite_code,
+)
 
 if TYPE_CHECKING:
-    from typing import SupportsIndex  # doesn't exist in 3.7
-
-    from .types.http import StrOrURL
-    from .types.id import ID32, ID64
+    from .types.http import Coro, StrOrURL
 
 
 _T = TypeVar("_T")
 _P = ParamSpec("_P")
-_PROTOBUF_MASK = 0x80000000
-
-
-def is_proto(emsg: int) -> bool:
-    return emsg & _PROTOBUF_MASK  # type: ignore  # this is boolean like for a bit of extra speed
-
-
-def set_proto_bit(emsg: int) -> int:
-    return emsg | _PROTOBUF_MASK
-
-
-def clear_proto_bit(emsg: int) -> int:
-    return emsg & ~_PROTOBUF_MASK
-
-
-Intable: TypeAlias = "SupportsInt | SupportsIndex | str | bytes"  # anything int(x) wouldn't normally fail on
-TypeType: TypeAlias = """
-Type | Literal[
-    'Invalid', 'Individual', 'Multiseat', 'GameServer', 'AnonGameServer', 'Pending', 'ContentServer', 'Clan',
-    'Chat', 'ConsoleUser', 'AnonUser', 'Max', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
-]
-"""
-UniverseType: TypeAlias = """
-    Universe | Literal['Invalid', 'Public', 'Beta', 'Internal', 'Dev', 'Max', 0, 1, 2, 3, 4, 5, 6]
-"""
-InstanceType: TypeAlias = "InstanceFlag | str | int"
-
-
-def make_id64(
-    id: Intable = 0,
-    type: TypeType | None = None,
-    universe: UniverseType | None = None,
-    instance: InstanceType | None = None,
-) -> ID64:
-    """Convert various representations of Steam IDs to its Steam 64-bit ID.
-
-    Parameters
-    ----------
-    id
-        The ID to convert.
-    type
-        The type of the ID. Can be the name, the integer value of the type or the recommended way is to use
-        :class:`steam.Type`\\.
-    universe
-        The universe of the ID. Can be the name, the integer value of the universe or the recommended way is to use
-        :class:`steam.Universe`\\.
-    instance
-        The instance of the ID.
-
-    Examples
-    --------
-    .. code-block:: python3
-
-        make_id64()  # invalid
-        make_id64(12345)
-        make_id64("12345")  # account ids
-        make_id64(12345, type=steam.Type.Clan)  # makes the clan id into a clan id64
-        make_id64(103582791429521412)
-        make_id64("103582791429521412")  # id64s
-        make_id64("STEAM_1:0:2")  # id2
-        make_id64("[g:1:4]")  # id3
-
-    Raises
-    ------
-    :exc:`.InvalidSteamID`
-        The created 64-bit Steam ID would be invalid.
-
-    Returns
-    -------
-    The 64 bit Steam ID.
-    """
-    # format of a 64-bit steam ID:
-    # 0b0000000100010000000000000000000100010001001001110100110011000010
-    #   
-    #                                               
-    #   universe   type                              
-    #   (8 bits)    (4 bits)   instance (20 bits)     
-    #                                                    account id
-    #                                                     (32 bits)
-    if not any((id, type, universe, instance)):
-        return 0
-
-    try:
-        id = int(id)
-    except ValueError:
-        # textual input e.g. [g:1:4]
-        try:
-            id, type, universe, instance = id2_to_tuple(id) or id3_to_tuple(id)
-        except TypeError:
-            raise InvalidSteamID(id, "it cannot be parsed") from None
-    else:
-        # numeric input
-        # 32 bit account id
-        if 0 <= id < 2**32:
-            type = type or Type.Individual
-            universe = universe or Universe.Public
-        # 64 bit
-        elif id < 2**64:
-            value = id
-            id = id & 0xFFFFFFFF
-            instance = (value >> 32) & 0xFFFFF
-            type = (value >> 52) & 0xF
-            universe = (value >> 56) & 0xFF
-        else:
-            raise InvalidSteamID(id, "it is too large" if id > 2**64 else "it is too small")
-
-        try:
-            type = Type(type) if isinstance(type, int) else Type[type]
-        except (KeyError, ValueError):
-            raise InvalidSteamID(id, f"{type!r} is not a valid Type") from None
-        try:
-            universe = Universe(universe) if isinstance(universe, int) else Universe[universe]
-        except (KeyError, ValueError):
-            raise InvalidSteamID(id, f"{universe!r} is not a valid Universe") from None
-
-    if instance is None:
-        instance = 1 if type in (Type.Individual, Type.GameServer) else 0
-
-    return universe << 56 | type << 52 | instance << 32 | id
-
-
-ID2_REGEX = re.compile(r"STEAM_(?P<universe>\d+):(?P<remainder>[0-1]):(?P<id>\d{1,10})")
-
-
-def id2_to_tuple(value: str) -> tuple[ID32, Literal[Type.Individual], Universe, Literal[InstanceFlag.Desktop]] | None:
-    """Convert an ID2 into its component parts.
-
-    Parameters
-    ----------
-    value
-        The ID2 e.g. ``STEAM_1:0:1234``.
-
-    Note
-    ----
-    The universe will be always set to ``1``. See :attr:`SteamID.id2_zero`.
-
-    Returns
-    -------
-    A tuple of 32 bit ID, type, universe and instance or ``None``
-
-    e.g. (100000, Type.Individual, Universe.Public, InstanceFlag.Desktop).
-    """
-    search = ID2_REGEX.search(value)
-
-    if search is None:
-        return None
-
-    id = (int(search["id"]) << 1) | int(search["remainder"])
-    universe = int(search["universe"])
-
-    # games before orange box used to incorrectly display universe as 0, we support that
-    if universe == 0:
-        universe = 1
-
-    return id, Type.Individual, Universe(universe), InstanceFlag.Desktop
-
-
-ID3_REGEX = re.compile(
-    rf"\[(?P<type>[i{''.join(TypeChar._member_map_)}]):"
-    r"(?P<universe>[0-4]):"
-    r"(?P<id>[0-9]{1,10})"
-    r"(:(?P<instance>\d+))?]",
-)
-
-
-def id3_to_tuple(value: str) -> tuple[ID32, Type, Universe, InstanceFlag] | None:
-    """Convert a Steam ID3 into its component parts.
-
-    Parameters
-    ----------
-    value
-        The ID3 e.g. ``[U:1:1234]``.
-
-    Returns
-    -------
-    A tuple of 32 bit ID, type, universe and instance or ``None``
-
-    e.g. (100000, Type.Individual, Universe.Public, InstanceFlag.Desktop)
-    """
-    search = ID3_REGEX.search(value)
-    if search is None:
-        return None
-
-    id = int(search["id"])
-    universe = Universe(int(search["universe"]))
-    type_char = search["type"].replace("i", "I")
-    type = Type(TypeChar[type_char])
-    instance_ = search["instance"]
-
-    if type_char in "gT" or instance_ is None:
-        instance = InstanceFlag.All
-    else:
-        instance = InstanceFlag.try_value(int(instance_))
-    if type_char == "L":
-        instance |= InstanceFlag.ChatLobby
-    if type_char == "c":
-        instance |= InstanceFlag.ChatClan
-    if type_char in (Type.Individual, Type.GameServer):
-        instance = InstanceFlag.Desktop
-
-    return id, type, universe, instance
-
-
-_INVITE_HEX = "0123456789abcdef"
-_INVITE_CUSTOM = "bcdfghjkmnpqrtvw"
-_INVITE_VALID = f"{_INVITE_HEX}{_INVITE_CUSTOM}"
-_INVITE_MAPPING = dict(zip(_INVITE_HEX, _INVITE_CUSTOM))
-_INVITE_INVERSE_MAPPING = dict(zip(_INVITE_CUSTOM, _INVITE_HEX))
-INVITE_REGEX = re.compile(rf"(https?://s\.team/p/(?P<code_1>[\-{_INVITE_VALID}]+))|(?P<code_2>[\-{_INVITE_VALID}]+)")
-
-
-def invite_code_to_tuple(
-    code: str,
-) -> tuple[ID32, Literal[Type.Individual], Literal[Universe.Public], Literal[InstanceFlag.Desktop]] | None:
-    """Convert an invitation code into its component parts.
-
-    Parameters
-    ----------
-    code
-        The invite code e.g. ``cv-dgb``
-
-    Returns
-    -------
-    A tuple of 32 bit ID, type, universe and instance or ``None``
-
-    e.g. (100000, Type.Individual, Universe.Public, InstanceFlag.Desktop).
-    """
-    search = INVITE_REGEX.search(code)
-
-    if not search:
-        return None
-
-    code = (search["code_1"] or search["code_2"]).replace("-", "")
-
-    id = int(re.sub(f"[{_INVITE_CUSTOM}]", lambda m: _INVITE_INVERSE_MAPPING[m.group()], code), 16)
-
-    if 0 < id < 2**32:
-        return id, Type.Individual, Universe.Public, InstanceFlag.Desktop
-
-
-URL_REGEX = re.compile(
-    r"(?P<clean_url>https?(www\.)?://steamcommunity\.com/(?P<type>profiles|id|gid|groups|app|games)/(?P<value>.+))"
-)
-USER_ID64_FROM_URL_REGEX = re.compile(r"g_rgProfileData\s*=\s*(?P<json>{.*?});\s*")
-CLAN_ID64_FROM_URL_REGEX = re.compile(r"OpenGroupChat\(\s*'(?P<steamid>\d+)'\s*\)")
-
-
-async def id64_from_url(url: StrOrURL, session: aiohttp.ClientSession | None = None) -> ID64 | None:
-    """Takes a Steam Community url and returns 64-bit Steam ID or ``None``.
-
-    Notes
-    -----
-    - Each call makes a http request to https://steamcommunity.com.
-
-    - Example URLs:
-
-        https://steamcommunity.com/gid/[g:1:4]
-
-        https://steamcommunity.com/gid/103582791429521412
-
-        https://steamcommunity.com/groups/Valve
-
-        https://steamcommunity.com/profiles/[U:1:12]
-
-        https://steamcommunity.com/profiles/76561197960265740
-
-        https://steamcommunity.com/id/johnc
 
-        https://steamcommunity.com/app/570
 
-    Parameters
-    ----------
-    url
-        The Steam community url.
-    session
-        The session to make the request with. If ``None`` is passed a new one is generated.
-
-    Returns
-    -------
-    The found 64-bit ID or ``None`` if ``https://steamcommunity.com`` is down or no matching account is found.
-    """
-
-    search = URL_REGEX.search(str(url))
-
-    if search is None:
-        return None
-
-    gave_session = session is not None
-    session = session or aiohttp.ClientSession()
-
-    try:
-        if search["type"] in ("id", "profiles"):
-            # user profile
-            r = await session.get(search["clean_url"])
-            text = await r.text()
-            data_match = USER_ID64_FROM_URL_REGEX.search(text)
-            data = json.loads(data_match["json"])  # type: ignore  # handled by try+except
-        else:
-            # clan profile
-            r = await session.get(search["clean_url"])
-            text = await r.text()
-            data = CLAN_ID64_FROM_URL_REGEX.search(text)
-        return int(data["steamid"])  # type: ignore  # handled by try+except
-    except (TypeError, AttributeError):
-        return None
-    finally:
-        if not gave_session:
-            await session.close()
-
-
-def unpad(s: bytes) -> bytes:
+def unpad(s: bytes, /) -> bytes:
     return s[: -s[-1]]
 
 
 def symmetric_decrypt(text: bytes, key: bytes) -> bytes:
     cipher = Cipher(algorithms.AES(key), modes.ECB())
     decryptor = cipher.decryptor()
     iv = decryptor.update(text[:16])
@@ -371,70 +76,83 @@
     decryptor = cipher.decryptor()
     return unpad(decryptor.update(text[16:]))
 
 
 STEAM_PUBLIC_KEY: Final = rsa.RSAPublicNumbers(
     17,
     int(
-        "1572435756163492767473017547683098671778311221560259237468446760604065883521072242173339019599191749864"
-        "5577395742561473053175122897795413393419038630648254894306773660858554891146738442477393264257606729213"
-        "7056263003121836768211312089498275802694267916711103128551999842076575732754013467986241640244933837449"
+        (
+            "1572435756163492767473017547683098671778311221560259237468446760604065883521072242173339019599191749864"
+            "5577395742561473053175122897795413393419038630648254894306773660858554891146738442477393264257606729213"
+            "7056263003121836768211312089498275802694267916711103128551999842076575732754013467986241640244933837449"
+        )
     ),
 )
 
 
 def verify_signature(data: bytes, signature: bytes) -> bool:
     try:
         STEAM_PUBLIC_KEY.public_key().verify(signature, data, padding.PKCS1v15(), hashes.SHA1())
     except InvalidSignature:
         return False
     else:
         return True
 
 
-def parse_trade_url(url: StrOrURL) -> re.Match[str] | None:
+@dataclass(slots=True)
+class TradeURLInfo:
+    id: ID
+    token: str | None = None
+
+    @property
+    def url(self) -> str:
+        """The full trade URL."""
+        url = URL.COMMUNITY / "tradeoffer/new" % {"partner": self.id.id}
+        return str(url % {"token": self.token}) if self.token else str(url)
+
+    def __str__(self) -> str:
+        return self.url
+
+
+def parse_trade_url(url: StrOrURL) -> TradeURLInfo | None:
     """Parses a trade URL for useful information.
 
     Parameters
     -----------
     url
         The trade URL to search.
 
     Returns
     -------
-    A :class:`re.Match` object with ``token`` and ``user_id`` :meth:`re.Match.group` objects or ``None``.
-    """
-    return re.search(
-        r"(?:https?://)?(?:www\.)?steamcommunity\.com/tradeoffer/new/?\?partner=(?P<user_id>[0-9]{,10})"
-        r"&token=(?P<token>[\w-]{7,})",
-        html.unescape(str(url)),
-    )
+    TradeURLInfo is a :func:`~dataclasses.dataclass` defined as:
 
+    .. source:: TradeURLInfo
+    """
+    if (
+        match := re.match(
+            (
+                rf"{_URL_START}steamcommunity\.com/tradeoffer/new/?\?partner=(?P<user_id>\d{{,10}})"
+                r"(?:&token=(?P<token>[\w-]{7,}))?"
+            ),
+            html.unescape(str(url)),
+        )
+    ) is None:
+        return None
 
-# some backports
-# TODO make a custom cancellable Executor
-if sys.version_info >= (3, 9):
-    from asyncio import to_thread
-else:
-
-    async def to_thread(callable: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -> _T:
-        loop = asyncio.get_running_loop()
-        ctx = contextvars.copy_context()
-        partial = functools.partial(ctx.run, callable, *args, **kwargs)
-        return await loop.run_in_executor(None, partial)
+    return TradeURLInfo(ID(match["user_id"]), match["token"] or None)
 
 
 _SelfT = TypeVar("_SelfT")
 _T_co = TypeVar("_T_co", covariant=True)
 
 
 class cached_property(Generic[_SelfT, _T_co]):
     __slots__ = ("function", "__doc__")
 
-    def __init__(self, function: Callable[[_SelfT], _T_co]):
+    def __init__(self, function: Callable[[_SelfT], _T_co], /):
         self.function = function
         self.__doc__: str | None = getattr(function, "__doc__", None)
 
     @overload
     def __get__(self, instance: None, _) -> Self:
         ...
 
@@ -448,38 +166,63 @@
 
         value = self.function(instance)
         setattr(instance, self.function.__name__, value)
 
         return value
 
 
-class cached_slot_property(cached_property[_SelfT, _T_co]):
+@overload
+def cached_slot_property(function: Callable[[_SelfT], _T_co], /) -> CachedSlotProperty[_SelfT, _T_co]:
+    ...
+
+
+@overload
+def cached_slot_property(name: str, /) -> Callable[[Callable[[_SelfT], _T_co]], CachedSlotProperty[_SelfT, _T_co]]:
+    ...
+
+
+def cached_slot_property(function_or_name: Any, /) -> Any:
+    if isinstance(function_or_name, str):
+
+        def wrapper(function: Callable[[_SelfT], _T_co]) -> CachedSlotProperty[_SelfT, _T_co]:
+            return CachedSlotProperty(function, function_or_name)
+
+        return wrapper
+    return CachedSlotProperty(function_or_name, f"_{function_or_name.__name__}_cs")
+
+
+class CachedSlotProperty(cached_property[_SelfT, _T_co]):
+    __slots__ = ("name", "__doc__")
+
+    def __init__(self, function: Callable[[_SelfT], _T_co], name: str):
+        super().__init__(function)
+        self.name = name
+
     @overload
     def __get__(self, instance: None, _) -> Self:
         ...
 
     @overload
     def __get__(self, instance: _SelfT, _) -> _T_co:
         ...
 
     def __get__(self, instance: _SelfT | None, _) -> _T_co | Self:
         if instance is None:
             return self
 
-        slot_name = f"_{self.function.__name__}_cs"
         try:
-            return getattr(instance, slot_name)
+            return getattr(instance, self.name)
         except AttributeError:
             value = self.function(instance)
-            setattr(instance, slot_name, value)
+            setattr(instance, self.name, value)
             return value
 
 
 def ainput(prompt: str = "") -> Coroutine[None, None, str]:
-    return to_thread(input, prompt)
+    return asyncio.to_thread(input, prompt)
 
 
 def contains_bbcode(string: str) -> bool:
     bbcodes = {
         "me",
         "code",
         "pre",
@@ -498,32 +241,14 @@
         "roomeffect",
         "img",
         "url",
     }
     return any(string.startswith(f"/{bbcode}") for bbcode in bbcodes)
 
 
-def _get_avatar_url(sha: bytes) -> str:
-    hexed = sha.hex()
-    hash = hexed if hexed != "\x00" * 20 else "fef49e7fa7e1997310d705b2a6158ff8dc1cdfeb"
-    return f"https://avatars.cloudflare.steamstatic.com/{hash}_full.jpg"
-
-
-def chunk(iterable: Iterable[_T], size: int) -> Generator[list[_T], None, None]:
-    chunk: list[_T] = []
-
-    for element in iterable:
-        if len(chunk) == size:
-            yield chunk
-            chunk = []
-        chunk.append(element)
-
-    yield chunk
-
-
 def _int_chunks(len: int, size: int) -> Generator[tuple[int, int], None, None]:
     idxs = range(0, len, size)
     second = iter(idxs)
     next(second)
     yield from zip_longest(idxs, second, fillvalue=len)
 
 
@@ -580,15 +305,15 @@
     def from_timestamp(timestamp: float) -> datetime:
         return datetime.fromtimestamp(timestamp, timezone.utc)
 
     @staticmethod
     def strptime(input: str, format: str) -> datetime:
         return datetime.strptime(input, format).replace(tzinfo=timezone.utc)
 
-    @staticmethod
+    @staticmethod  # TODO actually make this reliable for languages other than english
     def parse_steam_date(input: str, *, full_month: bool = True) -> datetime | None:
         if ", " not in input:
             input += f"{input}, {DateTime.now().year}"  # assume current year
 
         british = input.split()[0].isdigit()  # starts with a number
         format = f"%d %{'B' if full_month else 'b'}, %Y" if british else f"%{'B' if full_month else 'b'} %d, %Y"
         try:
@@ -608,15 +333,15 @@
         await self.__ainit__()
         return self
 
     def __await__(self) -> Generator[Any, None, Self]:
         return self.__await_inner__().__await__()
 
 
-PACK_FORMATS: Final = cast("Mapping[str, str]", {
+PACK_FORMATS: Final = cast(Mapping[str, str], {
     "i8": "b",
     "u8": "B",
     "i16": "h",
     "u16": "H",
     "i32": "i",
     "u32": "I",
     "i64": "q",
@@ -629,24 +354,28 @@
 
 
 class StructIOMeta(type):
     def __new__(mcs, name: str, bases: tuple[type, ...], namespace: dict[str, Any]) -> StructIOMeta:
         for method_name, format in PACK_FORMATS.items():
             exec(f"def write_{method_name}(self, item): self.write_struct('<{format}', item)", {}, namespace)
             exec(
-                f"def read_{method_name}(self):"
-                f"return self.read_struct('<{format}', {struct.calcsize(f'<{format}')})[0]",
+                (
+                    f"def read_{method_name}(self):"
+                    f"return self.read_struct('<{format}', {struct.calcsize(f'<{format}')})[0]"
+                ),
                 {},
                 namespace,
             )
 
         return super().__new__(mcs, name, bases, namespace)
 
 
-class StructIO(BytesIO, metaclass=StructIOMeta):
+class StructIO(
+    BytesIO, metaclass=type if TYPE_CHECKING else StructIOMeta
+):  # type[BytesIO] is a subclass of ABCMeta at type time
     __slots__ = ()
 
     def __repr__(self) -> str:
         return f"{self.__class__.__name__}(buffer={self.buffer!r}, position={self.position})"
 
     @property
     def buffer(self) -> bytes:
@@ -664,22 +393,22 @@
         buffer = self.read(position or struct.calcsize(format))
         return struct.unpack(format, buffer)
 
     def write_struct(self, format: str, *to_write: Any) -> None:
         self.write(struct.pack(format, *to_write))
 
     def read_cstring(self, terminator: bytes = b"\x00") -> bytes:
-        starting_position = self.position
-        data = self.read()
-        null_index = data.find(terminator)
-        if null_index == -1:
-            raise RuntimeError("Reached end of buffer")
-        result = data[:null_index]  # bytes without the terminator
-        self.seek(starting_position + null_index + len(terminator))  # advance offset past terminator
-        return result
+        data = self.getbuffer()[self.position :]
+        for i, chars in enumerate(as_chunks(data, len(terminator))):
+            if bytes(chars) == terminator:
+                result = bytes(data[: i * len(terminator)])
+                self.position += len(result) + len(terminator)
+                return result
+
+        raise RuntimeError("Reached end of buffer")
 
     if TYPE_CHECKING:
         # added by the metaclass
         # fmt: off
         def read_i8(self) -> int: ...
         def write_i8(self, item: int) -> None: ...
         def read_u8(self) -> int: ...
@@ -705,18 +434,17 @@
         def read_ulong(self) -> int: ...
         def write_ulong(self, item: int) -> None: ...
         # fmt: on
 
 
 _KT = TypeVar("_KT")
 _VT = TypeVar("_VT")
-MISSING: Final[Any] = object()
 
 
-class ChainMap(collections.ChainMap[_KT, _VT] if TYPE_CHECKING else collections.ChainMap):
+class ChainMap(collections.ChainMap[_KT, _VT]):
     # this is different to the standard library's ChainMap because it is always O(n),
     # keys should be unique between maps
     def __delitem__(self, key: _KT) -> None:
         for map in self.maps:
             try:
                 del map[key]
                 return
@@ -743,18 +471,115 @@
         raise KeyError(key)
 
     def clear(self) -> None:
         for map in self.maps:
             map.clear()
 
 
-# TODO consider in V1 making these allow async iterables after async iterator rework?
+class JWTToken(TypedDict):
+    iss: Literal["steam"]
+    sub: str  # SteamID
+    aud: list[str]
+    exp: int
+    nbf: int
+    iat: int
+    jti: str
+    oat: int
+    per: int
+    ip_subject: str
+    ip_confirmer: str
+
+
+def decode_jwt(token: str) -> JWTToken:
+    try:
+        _, jwt, _ = token.split(".")
+    except TypeError:
+        raise ValueError("Invalid JWT") from None
+
+    # python doesn't like the lack of padding on the end of the JWT so we need to add it back
+    return JSON_LOADS(base64.b64decode(f"{jwt}==", altchars=b"-_"))
+
+
 # everything below here is directly from discord.py's utils
 # https://github.com/Rapptz/discord.py/blob/master/discord/utils.py
-def find(predicate: Callable[[_T], bool], iterable: Iterable[_T]) -> _T | None:
+_Iter: TypeAlias = Iterable[_T] | AsyncIterable[_T]
+
+
+def _chunk(
+    iterator: Iterable[_T], max_size: int, len: Callable[[Sized], int] = len, /
+) -> Generator[list[_T], None, None]:
+    ret: list[_T] = []
+    for item in iterator:
+        ret.append(item)
+        if len(ret) == max_size:
+            yield ret
+            ret = []
+    if ret:
+        yield ret
+
+
+async def _achunk(
+    iterator: AsyncIterable[_T], max_size: int, len: Callable[[Sized], int] = len, /
+) -> AsyncGenerator[list[_T], None]:
+    ret: list[_T] = []
+    async for item in iterator:
+        ret.append(item)
+        if len(ret) == max_size:
+            yield ret
+            ret = []
+    if ret:
+        yield ret
+
+
+@overload
+def as_chunks(iterator: AsyncIterable[_T], /, max_size: int) -> AsyncGenerator[list[_T], None]:
+    ...
+
+
+@overload
+def as_chunks(iterator: Iterable[_T], /, max_size: int) -> Generator[list[_T], None, None]:
+    ...
+
+
+def as_chunks(iterator: _Iter[_T], /, max_size: int) -> _Iter[list[_T]]:
+    """A helper function that collects an iterator into chunks of a given size.
+
+    Parameters
+    ----------
+    iterator: Union[:class:`collections.abc.Iterable`, :class:`collections.abc.AsyncIterable`]
+        The iterator to chunk, can be sync or async.
+    max_size: :class:`int`
+        The maximum chunk size.
+
+
+    Warning
+    -------
+        The last chunk collected may not be as large as ``max_size``.
+
+    Returns
+    --------
+    A new iterator which yields chunks of a given size.
+    """
+    if max_size <= 0:
+        raise ValueError("max_size must be greater than 0")
+
+    return _achunk(iterator, max_size) if hasattr(iterator, "__aiter__") else _chunk(iterator, max_size)  # type: ignore
+
+
+@overload
+def find(predicate: Callable[[_T], bool], iterable: AsyncIterable[_T], /) -> Coro[_T | None]:
+    ...
+
+
+@overload
+def find(predicate: Callable[[_T], bool], iterable: Iterable[_T], /) -> _T | None:
+    ...
+
+
+def find(predicate: Callable[[_T], bool], iterable: _Iter[_T], /) -> _T | Coro[_T | None] | None:
     """A helper to return the first element found in the sequence.
 
     Examples
     --------
     .. code-block:: python3
 
         first_active_offer = steam.utils.find(
@@ -772,21 +597,67 @@
 
     Returns
     -------
     The first element from the ``iterable`` for which the ``predicate`` returns ``True`` or if no matching element was
     found returns ``None``.
     """
 
-    for element in iterable:
-        if predicate(element):
-            return element
-    return None
+    if hasattr(iterable, "__aiter__"):  # isinstance(iterable, collections.abc.AsyncIterable) is too slow
+        return anext((element async for element in iterable if predicate(element)), None)  # type: ignore
+    else:
+        return next((element for element in iterable if predicate(element)), None)  # type: ignore
+
+
+def _get(
+    iterable: Iterable[_T],
+    all: Callable[[Iterable[bool]], bool] = all,
+    attrgetter: type[attrgetter[_T]] = attrgetter,
+    /,
+    **attrs: Any,
+) -> _T | None:
+    # Special case the single element call
+    if len(attrs) == 1:
+        k, v = attrs.popitem()
+        pred = attrgetter(k.replace("__", "."))
+        return next((elem for elem in iterable if pred(elem) == v), None)
+
+    converted = [(attrgetter(attr.replace("__", ".")), value) for attr, value in attrs.items()]
+
+    return next((elem for elem in iterable if all(pred(elem) == value for pred, value in converted)), None)
+
+
+def _aget(
+    iterable: AsyncIterable[_T],
+    all: Callable[[Iterable[bool]], bool] = all,
+    attrgetter: type[attrgetter[_T]] = attrgetter,
+    /,
+    **attrs: Any,
+) -> Coro[_T | None]:
+    # Special case the single element call
+    if len(attrs) == 1:
+        k, v = attrs.popitem()
+        pred = attrgetter(k.replace("__", "."))
+        return anext((elem async for elem in iterable if pred(elem) == v), None)
+
+    converted = [(attrgetter(attr.replace("__", ".")), value) for attr, value in attrs.items()]
+
+    return anext((elem async for elem in iterable if all(pred(elem) == value for pred, value in converted)), None)
+
 
+@overload
+def get(iterable: AsyncIterable[_T], /, **attrs: Any) -> Coro[_T | None]:
+    ...
 
-def get(iterable: Iterable[_T], **attrs: Any) -> _T | None:
+
+@overload
+def get(iterable: Iterable[_T], /, **attrs: Any) -> _T | None:
+    ...
+
+
+def get(iterable: _Iter[_T], /, **attrs: Any) -> _T | Coro[_T | None] | None:
     """A helper that returns the first element in the iterable that meets all the traits passed in ``attrs``. This
     is an alternative for :func:`find`.
 
     Examples
     --------
     .. code-block:: python3
 
@@ -802,38 +673,21 @@
         Keyword arguments that denote attributes to match.
 
     Returns
     -------
     The first element from the ``iterable`` which matches all the traits passed in ``attrs`` or ``None`` if no matching
     element was found.
     """
-
-    # global -> local
-    _all = all
-    attrget = attrgetter
-
-    # Special case the single element call
-    if len(attrs) == 1:
-        k, v = attrs.popitem()
-        pred = attrget(k.replace("__", "."))
-        for elem in iterable:
-            if pred(elem) == v:
-                return elem
-        return None
-
-    converted = [(attrget(attr.replace("__", ".")), value) for attr, value in attrs.items()]
-
-    for elem in iterable:
-        if _all(pred(elem) == value for pred, value in converted):
-            return elem
-    return None
+    return (
+        _aget(iterable, **attrs)  # type: ignore
+        if hasattr(iterable, "__aiter__")  # isinstance(iterable, collections.abc.AsyncIterable) is too slow
+        else _get(iterable, **attrs)  # type: ignore
+    )
 
 
 async def maybe_coroutine(
     func: Callable[_P, _T | Awaitable[_T]],
     *args: _P.args,
     **kwargs: _P.kwargs,
 ) -> _T:
     value = func(*args, **kwargs)
-    if isawaitable(value):
-        return await value
-    return value  # type: ignore
+    return await value if isawaitable(value) else value  # type: ignore
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `steamio-0.9.9/PKG-INFO` & `steamio-1.0.0a0/PKG-INFO`

 * *Files 5% similar despite different names*

```diff
@@ -1,36 +1,34 @@
 Metadata-Version: 2.1
 Name: steamio
-Version: 0.9.9
+Version: 1.0.0a0
 Summary: A Python wrapper for the Steam API
 License: MIT
 Keywords: steam.py,steam,steamio,steam-api
 Author: Gobot1234
-Requires-Python: >=3.7,<4.0
+Author-email: gobot1234yt@gmail.com
+Requires-Python: >=3.10,<4.0
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Framework :: AsyncIO
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Natural Language :: English
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: Software Development :: Libraries
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Classifier: Typing :: Typed
-Requires-Dist: aiohttp (>=3.7,<3.9)
+Requires-Dist: aiohttp (>=3.8,<4.0)
 Requires-Dist: beautifulsoup4 (>=4.10,<5.0)
 Requires-Dist: betterproto (==2.0.0b4)
-Requires-Dist: cryptography (>=37.0,<38.0)
-Requires-Dist: tomli (>=2,<3) ; python_version < "3.11"
-Requires-Dist: typing-extensions (==4.2.0)
+Requires-Dist: cryptography (>=38.0,<39.0)
+Requires-Dist: tomli (>=2,<3); python_version < "3.11"
+Requires-Dist: typing-extensions (==4.4.0)
 Requires-Dist: vdf (>=3.4,<4.0)
 Project-URL: Bug Tracker, https://github.com/Gobot1234/steam.py/issues
 Project-URL: Code, https://github.com/Gobot1234/steam.py
 Project-URL: Documentation, https://steam-py.github.io/docs/latest
 Description-Content-Type: text/markdown
 
 # steam.py
```

