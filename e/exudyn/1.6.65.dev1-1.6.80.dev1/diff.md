# Comparing `tmp/exudyn-1.6.65.dev1-cp39-cp39-win_amd64.whl.zip` & `tmp/exudyn-1.6.80.dev1-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,38 +1,38 @@
-Zip file size: 2206186 bytes, number of entries: 36
+Zip file size: 2192575 bytes, number of entries: 36
 -rw-rw-rw-  2.0 fat   212931 b- defN 23-Apr-21 06:54 exudyn/FEM.py
 -rw-rw-rw-  2.0 fat    42942 b- defN 23-Jan-12 07:22 exudyn/GUI.py
--rw-rw-rw-  2.0 fat     6474 b- defN 23-Jan-12 22:51 exudyn/__init__.py
+-rw-rw-rw-  2.0 fat     6613 b- defN 23-Apr-26 08:04 exudyn/__init__.py
 -rw-rw-rw-  2.0 fat    16183 b- defN 23-Feb-13 16:15 exudyn/advancedUtilities.py
 -rw-rw-rw-  2.0 fat    15264 b- defN 23-Mar-20 11:48 exudyn/artificialIntelligence.py
 -rw-rw-rw-  2.0 fat    11393 b- defN 23-Feb-16 08:35 exudyn/basicUtilities.py
 -rw-rw-rw-  2.0 fat    35948 b- defN 23-Feb-13 08:08 exudyn/beams.py
--rw-rw-rw-  2.0 fat     7288 b- defN 23-Mar-06 07:23 exudyn/demos.py
--rw-rw-rw-  2.0 fat  5756416 b- defN 23-Apr-21 07:12 exudyn/exudynCPP.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     7366 b- defN 23-Apr-26 07:58 exudyn/demos.py
+-rw-rw-rw-  2.0 fat  5729280 b- defN 23-Apr-28 06:37 exudyn/exudynCPP.cp39-win_amd64.pyd
 -rw-rw-rw-  2.0 fat    85436 b- defN 23-Mar-27 06:21 exudyn/graphicsDataUtilities.py
 -rw-rw-rw-  2.0 fat    53048 b- defN 23-Feb-16 08:35 exudyn/interactive.py
--rw-rw-rw-  2.0 fat   158659 b- defN 23-Apr-21 07:00 exudyn/itemInterface.py
+-rw-rw-rw-  2.0 fat   158659 b- defN 23-Apr-28 06:29 exudyn/itemInterface.py
 -rw-rw-rw-  2.0 fat    32746 b- defN 23-Mar-14 16:29 exudyn/kinematicTree.py
--rw-rw-rw-  2.0 fat    21846 b- defN 23-Mar-27 18:51 exudyn/lieGroupBasics.py
+-rw-rw-rw-  2.0 fat    22928 b- defN 23-Apr-26 16:13 exudyn/lieGroupBasics.py
 -rw-rw-rw-  2.0 fat    13557 b- defN 22-Jul-11 07:16 exudyn/lieGroupIntegration.py
 -rw-rw-rw-  2.0 fat     3165 b- defN 23-Jan-09 06:59 exudyn/machines.py
 -rw-rw-rw-  2.0 fat     6169 b- defN 23-Feb-20 07:14 exudyn/physics.py
 -rw-rw-rw-  2.0 fat    50407 b- defN 23-Feb-16 08:35 exudyn/plot.py
 -rw-rw-rw-  2.0 fat    71531 b- defN 23-Apr-06 12:54 exudyn/processing.py
 -rw-rw-rw-  2.0 fat    14646 b- defN 23-Jan-09 06:59 exudyn/resultsMonitor.py
 -rw-rw-rw-  2.0 fat    66182 b- defN 23-Apr-21 06:54 exudyn/rigidBodyUtilities.py
 -rw-rw-rw-  2.0 fat    15158 b- defN 23-Apr-15 13:44 exudyn/signalProcessing.py
--rw-rw-rw-  2.0 fat    27593 b- defN 23-Feb-16 08:35 exudyn/solver.py
+-rw-rw-rw-  2.0 fat    35482 b- defN 23-Apr-28 06:28 exudyn/solver.py
 -rw-rw-rw-  2.0 fat    66527 b- defN 23-Apr-15 13:44 exudyn/utilities.py
 -rw-rw-rw-  2.0 fat      898 b- defN 21-Dec-03 09:28 exudyn/robotics/__init__.py
 -rw-rw-rw-  2.0 fat    24507 b- defN 23-Apr-06 06:16 exudyn/robotics/future.py
 -rw-rw-rw-  2.0 fat      527 b- defN 21-Dec-03 09:28 exudyn/robotics/mobile.py
 -rw-rw-rw-  2.0 fat    32539 b- defN 23-Mar-29 09:16 exudyn/robotics/models.py
 -rw-rw-rw-  2.0 fat    26097 b- defN 22-Mar-01 19:40 exudyn/robotics/motion.py
--rw-rw-rw-  2.0 fat    97871 b- defN 23-Mar-29 16:14 exudyn/robotics/roboticsCore.py
+-rw-rw-rw-  2.0 fat    97970 b- defN 23-Apr-26 17:15 exudyn/robotics/roboticsCore.py
 -rw-rw-rw-  2.0 fat    15166 b- defN 23-Apr-06 06:16 exudyn/robotics/special.py
 -rw-rw-rw-  2.0 fat     5171 b- defN 23-Apr-15 13:43 exudyn/robotics/utilities.py
--rw-rw-rw-  2.0 fat     1653 b- defN 23-Apr-21 07:12 exudyn-1.6.65.dev1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-21 07:12 exudyn-1.6.65.dev1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-Apr-21 07:12 exudyn-1.6.65.dev1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2906 b- defN 23-Apr-21 07:12 exudyn-1.6.65.dev1.dist-info/RECORD
-36 files, 6998951 bytes uncompressed, 2201658 bytes compressed:  68.6%
+-rw-rw-rw-  2.0 fat     1653 b- defN 23-Apr-28 06:37 exudyn-1.6.80.dev1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-28 06:37 exudyn-1.6.80.dev1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-Apr-28 06:37 exudyn-1.6.80.dev1.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2906 b- defN 23-Apr-28 06:37 exudyn-1.6.80.dev1.dist-info/RECORD
+36 files, 6981102 bytes uncompressed, 2188047 bytes compressed:  68.7%
```

## zipnote {}

```diff
@@ -90,20 +90,20 @@
 
 Filename: exudyn/robotics/special.py
 Comment: 
 
 Filename: exudyn/robotics/utilities.py
 Comment: 
 
-Filename: exudyn-1.6.65.dev1.dist-info/METADATA
+Filename: exudyn-1.6.80.dev1.dist-info/METADATA
 Comment: 
 
-Filename: exudyn-1.6.65.dev1.dist-info/WHEEL
+Filename: exudyn-1.6.80.dev1.dist-info/WHEEL
 Comment: 
 
-Filename: exudyn-1.6.65.dev1.dist-info/top_level.txt
+Filename: exudyn-1.6.80.dev1.dist-info/top_level.txt
 Comment: 
 
-Filename: exudyn-1.6.65.dev1.dist-info/RECORD
+Filename: exudyn-1.6.80.dev1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## exudyn/__init__.py

```diff
@@ -86,24 +86,24 @@
     try:
         from exudynCPP import *
     except:
         raise ImportError('Import of exudyn C++ module failed; check 32/64 bits versions, restart your iPython console or try to uninstall and install exudyn')
 
 #import very useful solver functionality into exudyn module (==> available as exu.SolveStatic, etc.)
 try:
-    from .solver import SolveStatic, SolveDynamic, ComputeODE2Eigenvalues
+    from .solver import SolveStatic, SolveDynamic, SolverSuccess, ComputeLinearizedSystem, ComputeSystemDegreeOfFreedom, ComputeODE2Eigenvalues
 except:
     #for run inside Visual Studio (exudynCPP lies in Release or Debug folders):
-    from solver import SolveStatic, SolveDynamic, ComputeODE2Eigenvalues
+    from solver import SolveStatic, SolveDynamic, SolverSuccess, ComputeLinearizedSystem, ComputeSystemDegreeOfFreedom, ComputeODE2Eigenvalues
 
 try:
     from .demos import Demo1, Demo2
 except:
     #for run inside Visual Studio (exudynCPP lies in Release or Debug folders):
-    from solver import Demo1, Demo2
+    from demos import Demo1, Demo2
 
 __version__ = GetVersionString() #add __version__ to exudyn module ...
 
 
 #add a functionality to check the current version
 def RequireVersion(requiredVersionString):
     """
```

## exudyn/demos.py

```diff
@@ -21,16 +21,17 @@
     print('look under main/pythonDev/Examples')
     print('and main/pythonDev/TestModels')
     print('************************************\n')
     
 
 #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 #**function: very simple demo to show that exudyn is correctly installed; does not require graphics; similar to Examples/myFirstExample.py
-def Demo1():
-    print('start demo1: verify that exudyn is running')
+def Demo1(showAll = True):
+    if showAll:
+        print('start demo1: verify that exudyn is running')
     import exudyn as exu               #EXUDYN package including C++ core part
     import exudyn.itemInterface as eii #conversion of data to exudyn dictionaries
     
     SC = exu.SystemContainer()         #container of systems
     mbs = SC.AddSystem()               #add a new system to work with
     
     nMP = mbs.AddNode(eii.NodePoint2D(referenceCoordinates=[0,0]))
@@ -40,33 +41,35 @@
     
     mbs.Assemble()                     #assemble system and solve
     simulationSettings = exu.SimulationSettings()
     simulationSettings.timeIntegration.verboseMode=1 #provide some output
     simulationSettings.solutionSettings.coordinatesSolutionFileName = 'solution/demo1.txt'
 
     exu.SolveDynamic(mbs, simulationSettings)
-    print('results can be found in local directory: solution/demo1.txt')
-
-    DemoInfo()
+    if showAll:
+        print('results can be found in local directory: solution/demo1.txt')
+    
+        DemoInfo()
     
     return [mbs, SC]
 
 #%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 #**function: advanced demo, showing that graphics is available; similar to Examples/rigid3Dexample.py
-def Demo2():
+def Demo2(showAll = True):
     import exudyn as exu
     import exudyn.itemInterface as eii #conversion of data to exudyn dictionaries
     from exudyn.utilities import GraphicsDataCheckerBoard, eulerParameters0, GraphicsDataSphere, \
                                  GraphicsDataOrthoCubePoint, AngularVelocity2EulerParameters_t, \
                                      color4dodgerblue, color4darkgrey
     
     SC = exu.SystemContainer()
     mbs = SC.AddSystem()
     
-    print('EXUDYN version='+exu.GetVersionString())
+    if showAll:
+        print('EXUDYN version='+exu.GetVersionString())
     
     #%%+++++++++++++++++++++++++++++++++++
     #background
     color = [0.1,0.1,0.8,1]
     zz = 2  #max size
     s = 0.1 #size of cube
     sx = 3*s #x-size
@@ -124,31 +127,33 @@
 
     SC.visualizationSettings.openGL.multiSampling = 4
     SC.visualizationSettings.openGL.lineWidth = 2
     
     SC.visualizationSettings.openGL.shadow = 0.3
     SC.visualizationSettings.openGL.light0position = [4,4,10,0]
     
-    exu.StartRenderer()
-    # exu.SolveDynamic(mbs, simulationSettings) #start simulation to show solution information in window !
-    mbs.WaitForUserToContinue()
+    if showAll:
+        exu.StartRenderer()
+        mbs.WaitForUserToContinue()
     
     simulationSettings.timeIntegration.numberOfSteps = 1*fact
     simulationSettings.timeIntegration.endTime = 0.001*fact*0.5*4
     exu.SolveDynamic(mbs, simulationSettings)
     
-    SC.WaitForRenderEngineStopFlag()
-    exu.StopRenderer() #safely close rendering window!
+    if showAll:
+        SC.WaitForRenderEngineStopFlag()
+        exu.StopRenderer() #safely close rendering window!
 
-    input("Press Enter to start SolutionViewer...")
-
-    from exudyn.interactive import SolutionViewer
-    SolutionViewer(mbs)
+    if showAll:
+        input("Press Enter to start SolutionViewer...")
+    
+        from exudyn.interactive import SolutionViewer
+        SolutionViewer(mbs)
 
-    DemoInfo()
+        DemoInfo()
 
     return [mbs, SC]
 
 
 #%%++++++++++++++++++++++++
 #testing of demos
 if __name__ == '__main__':
```

## exudyn/lieGroupBasics.py

```diff
@@ -227,56 +227,84 @@
     log[0:3,3] = x
     return log
     
 
 #**function: compute the tangent operator corresponding to ExpSE3, see \cite{Bruels2011}
 #**input: 6D incremental motion vector as np.array
 #**output: 6x6 matrix as np.array
+#**author: Stefan Holzinger
+#**notes: improved accuracy for very small angles as well as angles phi 
 def TExpSE3(x):
     U     = x[0:3]
     Omega = x[3:6]
     USkew     = Skew(U)
     OmegaSkew = Skew(Omega)
     phi = norm(Omega)
-    phiOverTwo = phi/2
-    if phi == 0.:
-        TUOmegaPlus = -0.5*USkew 
-    else:
-        a = (2*sin(phiOverTwo)*cos(phiOverTwo))/phi
-        b = 4*(sin(phiOverTwo)**2)/(phi**2)
-        c1 = 0.5*(1-b)*USkew
-        c2 = ((1-a)/(phi**2))*(np.dot(USkew,OmegaSkew) + np.dot(OmegaSkew,USkew))
-        c3 = -((a-b)/(phi**2))*np.dot(np.dot(Omega,U), OmegaSkew)
-        c4 = (1/(phi**2))*(0.5*b - (3/(phi**2))*(1-a))*np.dot(Omega,U)*np.dot(OmegaSkew,OmegaSkew)
-        TUOmegaPlus = c1 + c2 + c3 + c4 - 0.5*USkew
+   # phiOverTwo = 0.5*phi
+    
+    # coefficient f2, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-2:
+        f2 = (np.cos(phi) - 1) / phi**2
+    else:
+        f2 = -0.5 + (1/24)*phi**2 - (1/720)*phi**4
+
+    # coefficient f3, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-4:
+        f3 = (phi - np.sin(phi)) / phi**3
+    else:
+        f3 = 1/6 - (1/24)*phi**2 - (1/720)*phi**4     
+
+    # coefficient f4, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-1:
+        f4 = (2 - 2*np.cos(phi) - phi*np.sin(phi)) / phi**4
+    else:
+        f4 = 1/12 - (1/180)*phi**2 + (1/6720)*phi**4 - (1/453600)*phi**6
+        
+    # coefficient f5, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-1:
+        f5 = ( phi*(2 + np.cos(phi)) - 3*np.sin(phi)) / phi**5
+    else:
+        f5 = 1/60 - (1/1260)*phi**2 + (1/60480)*phi**4 - (1/4989600)*phi**6     
+    
+    TUOmegaPlus = f2*USkew + f3*( USkew @ OmegaSkew + OmegaSkew @ USkew ) + f4*np.dot(Omega,U)*OmegaSkew - f5*np.dot(Omega,U)*OmegaSkew**2
+    
     TexpSO3 = TExpSO3(Omega)
     T = np.block([[TexpSO3,         TUOmegaPlus],
                   [np.zeros((3,3)), TexpSO3]])
     return T
 
 
+
 #**function: compute the inverse of tangent operator TExpSE3, see \cite{Sonneville2014}
 #**input: 6D incremental motion vector as np.array
 #**output: 6x6 matrix as np.array
 #**author: Stefan Holzinger
+#**notes: improved accuracy for very small angles as well as angles phi 
 def TExpSE3Inv(x):
     U     = x[0:3]
     Omega = x[3:6]
+    USkew     = Skew(U)
+    OmegaSkew = Skew(Omega)
     phi = norm(Omega)
-    if phi == 0.0:
-        Tuwm = 0.5*Skew(U)
+    phiOverTwo = 0.5*phi
+    
+    # coefficient f6, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 1e-2:
+        f6 = (2 - Cot(phiOverTwo)) / (2*phi**2)
+    else:
+        f6 = 1/12 + (1/720)*phi**2 + (1/30240)*phi**4
+    
+    # coefficient f8, see Phd thesis Stefan Hante, Table. 1, page 121
+    if phi >= 2e-1:
+        f8 = (phi*np.sin(phi) + 4*np.cos(phi) + phi**2 - 4) / (4*np.sin(phiOverTwo)**2 * phi**4)
     else:
-        alpha = Sinc(phi)
-        beta = 2*(1 - cos(phi))/phi**2 
-        USkew     = Skew(U)
-        OmegaSkew = Skew(Omega)
-        c1 = 0.5*USkew
-        c2 = ((beta-alpha)/(beta*phi**2))*(np.matmul(USkew,OmegaSkew) + np.matmul(OmegaSkew,USkew))
-        c3 = ((1 + alpha - 2*beta)/(beta*phi**4))*(np.dot(Omega,U))*np.matmul(OmegaSkew,OmegaSkew)
-        Tuwm = c1 + c2 + c3
+        f8 = 1/360 + (1/7560)*phi**2 + (1/201600)*phi**4 + (1/5987520)*phi**6 + (691/130767436800)*phi**8
+    
+    # Matrix C2, see Phd thesis Stefan Hante, Sect.A.3, page 117
+    Tuwm = 0.5*USkew + f6*( USkew @ OmegaSkew + OmegaSkew @ USkew ) + f8*np.dot(Omega,U)*OmegaSkew**2
     TexpSO3Inv = TExpSO3Inv(Omega) #NOTE: overrides the function TexpSO3Inv
     Tinv = np.block([[TexpSO3Inv,      Tuwm],
                      [np.zeros((3,3)), TexpSO3Inv]])
     return Tinv
     
 
 #**function: compute the matrix exponential map on the Lie group R3xSO(3), see \cite{Bruels2011}
```

## exudyn/solver.py

```diff
@@ -9,20 +9,21 @@
 # Notes:    Solver functions are included directly in exudyn and can be used with exu.SolveStatic(...)
 #
 # Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
 #
 #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 #import is necessary, otherwise the solvers cannot be called
+import numpy as np
 import exudyn
 
 solverCheckMemoryAllocations = True
 solverCheckMemoryAllocationsThreshold = 100000 #treshold for warning on too many news during solving
 
-#**function: helper function for unique error and helper messages
+#**function: (internal) helper function for unique error and helper messages
 def SolverErrorMessage(solver, mbs, isStatic=False, 
                        showCausingObjects=True, showCausingNodes=True, showHints=True):
     s = ''
     s += '\n******************************\n'
     if isStatic:
         s += 'STATIC SOLVER FAILED:\n'
     else:        
@@ -285,14 +286,52 @@
         mbs.systemData.SetSystemState(systemStateList=currentState, 
                                         configuration = exudyn.ConfigurationType.Initial)
         mbs.systemData.SetODE2Coordinates_tt(coordinates = mbs.systemData.GetODE2Coordinates_tt(), 
                                                 configuration = exudyn.ConfigurationType.Initial)
 
     return success
 
+#**function: return success (True/False) and error message of solver after SolveSteps(...), SolveSystem(...), SolveDynamic(...) or SolveStatic(...) have been called. May also be set if other higher level functions called e.g. SolveSystem(...)
+#**input: 
+#  solverStructure: solver structure, as stored in mbs.sys or as created e.g. by exudyn.MainSolverExplicit()
+#**output: [success, errorString], returns success=True or False and in case of no success, information is provided in errorString
+#**example:
+#  #assume MainSystem mbs, exu library and simulationSettings:
+#  try:
+#      exu.SolveDynamic(mbs, simulationSettings)
+#  except:
+#      [success, msg] = exu.SolverSuccess(mbs.sys['dynamicSolver'])
+#      print('success=',success)
+#      print('error message=',msg)
+#
+#  #alternative:
+#  solver=exu.MainSolverImplicitSecondOrder()
+#  ...
+#  [success, msg] = exu.SolverSuccess(solver)
+def SolverSuccess(solverStructure):
+    return [solverStructure.output.finishedSuccessfully, solverStructure.GetErrorString()]
+
+#internal function: uniquely turn off all output and file writing - this would potentially erase user's output files ...
+def DeactivateWritingOfSolvers(simulationSettings):
+    store = {}
+    store['verboseModeOld'] = simulationSettings.staticSolver.verboseMode
+    simulationSettings.staticSolver.verboseMode = 0
+    store['writeSolutionToFileOld'] = simulationSettings.solutionSettings.writeSolutionToFile
+    simulationSettings.solutionSettings.writeSolutionToFile = False
+    store['sensorsStoreAndWriteFilesOld'] = simulationSettings.solutionSettings.sensorsStoreAndWriteFiles
+    simulationSettings.solutionSettings.sensorsStoreAndWriteFiles = False
+    return store
+
+#internal function for special solver functions; uniquely restores some settings
+def RestoreSimulationSettings(simulationSettings, store):
+    simulationSettings.staticSolver.verboseMode = store['verboseModeOld']
+    simulationSettings.solutionSettings.writeSolutionToFile = store['writeSolutionToFileOld']
+    simulationSettings.solutionSettings.sensorsStoreAndWriteFiles = store['sensorsStoreAndWriteFilesOld']
+    
+
 #**function: compute linearized system of equations for ODE2 part of mbs, not considering the effects of algebraic constraints
 #**input:    
 #   mbs: the MainSystem containing the assembled system
 #   simulationSettings: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
 #   useSparseSolver: if False (only for small systems), all eigenvalues are computed in dense mode (slow for large systems!); if True, only the numberOfEigenvalues are computed (numberOfEigenvalues must be set!); Currently, the matrices are exported only in DENSE MODE from mbs! NOTE that the sparsesolver accuracy is much less than the dense solver
 #**output: [M, K, D]; list containing numpy mass matrix M, stiffness matrix K and damping matrix D
 #**example:
@@ -300,15 +339,17 @@
 #  #then execute the following commands in the console (or add it to the file):
 #  [M, K, D] = exu.ComputeLinearizedSystem(mbs)
 #  print("M=", M)
 #  print("K=", K)
 def ComputeLinearizedSystem(mbs, 
                             simulationSettings = exudyn.SimulationSettings(),
                             useSparseSolver = False):
-    #import numpy as np
+    #do not overide sensor files or solution files ...
+    store = DeactivateWritingOfSolvers(simulationSettings)
+
     #use static solver, as it does not include factors from time integration (and no velocity derivatives) in the jacobian
     staticSolver = exudyn.MainSolverStatic()
 
     #initialize solver with initial values
     staticSolver.InitializeSolver(mbs, simulationSettings)
 
     staticSolver.ComputeMassMatrix(mbs)
@@ -326,17 +367,107 @@
                                         scalarFactor_ODE2_t=-1, 
                                         scalarFactor_ODE1=0)    #reset jacobian
     jacobian_t = staticSolver.GetSystemJacobian() #read out stored jacobian
     
     
     D = jacobian_t[0:nODE2,0:nODE2] #obtain ODE2_t part from jacobian == damping matrix
 
+    staticSolver.FinalizeSolver(mbs, simulationSettings) #close files, etc.
+    RestoreSimulationSettings(simulationSettings, store)
+
     return [M, K, D]
 
+#**function: compute system DOF numerically, considering Gr{\"u}bler-Kutzbach formula as well as redundant constraints; uses numpy matrix rank or singular value decomposition of scipy (useSVD=True)
+#**input:
+#  mbs: MainSystem for which DOF shall be computed
+#  simulationSettings: used e.g. for settings regarding numerical differentiation; default settings may be used in most cases
+#  threshold: threshold factor for singular values which estimate the redundant constraints
+#  useSVD: use singular value decomposition directly, also showing SVD values if verbose=True
+#  verbose: if True, it will show the singular values and one may decide if the threshold shall be adapted
+#**output: returns list of [dof, nRedundant, nODE2, nODE1, nAE, nPureAE], where: dof = the degree of freedom computed numerically, nRedundant=the number of redundant constraints, nODE2=number of ODE2 coordinates, nODE1=number of ODE1 coordinates, nAE=total number of constraints, nPureAE=number of constraints on algebraic variables (e.g., lambda=0) that are not coupled to ODE2 coordinates
+#**notes: this approach may not always work! Currently only works with dense matrices, thus it will be slow for larger systems
+def ComputeSystemDegreeOfFreedom(mbs, 
+                simulationSettings = exudyn.SimulationSettings(),
+                threshold = 1e-12, verbose=False, useSVD=False):
+    #use static solver, as it does not include factors from time integration (and no velocity derivatives) in the jacobian
+    
+    store = DeactivateWritingOfSolvers(simulationSettings)
+
+    staticSolver = exudyn.MainSolverStatic()
+    #initialize solver with initial values
+    staticSolver.InitializeSolver(mbs, simulationSettings)
+
+    nODE2 = staticSolver.GetODE2size()
+    nODE1 = staticSolver.GetODE1size()
+    if nODE1 != 0:
+        print('WARNING: ComputeSystemDegreeOfFreedom(...) not suitable in case of ODE1 coordinates; ODE1 coordinates will not count as additional DOF!')
+    nODE12 = nODE2+nODE1
+    nAE = staticSolver.GetAEsize()
+
+    #reset jacobian    
+    staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=-1,
+                                        scalarFactor_ODE2_t=0, 
+                                        scalarFactor_ODE1=0)    #compute ODE2 part of jacobian ==> stored internally in solver
+    staticSolver.ComputeJacobianAE(mbs, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., scalarFactor_ODE1=1., velocityLevel=False)
+    jacobian = staticSolver.GetSystemJacobian()#.round(20) #read out stored jacobian
+
+    Code2 = jacobian[0:nODE2, nODE12:]    #C_q: constraint jacobian
+    Cae = jacobian[nODE12:,nODE12:]       #C_lambda
+    Call =  jacobian[:, nODE12:]
+    
+    staticSolver.FinalizeSolver(mbs, simulationSettings) #close files, etc.
+    #restore old settings:
+    RestoreSimulationSettings(simulationSettings, store)
+    
+    if verbose == 2:
+        print('Code2=\n', Code2, sep='')
+        print('Cae  =\n', Cae, sep='')
+
+    if useSVD:
+        try:
+            from scipy.linalg import svdvals#, svd
+        except:
+            raise ValueError('ComputeSystemDegreeOfFreedom: missing scipy package; install with: pip install scipy')
+
+    
+    nRedundant = 0
+    nPureAE = 0
+    if nAE != 0:
+
+        if useSVD:
+            #s = svd(Call, compute_uv=False, full_matrices=False)#, lapack_driver='gesvd')
+            s = svdvals(Call)
+    
+            if verbose:
+                print('singular values ODE2+AE=',s)
+    
+            sAE = svdvals(Cae)
+            #sAE = svd(Cae, compute_uv=False, full_matrices=False)#, lapack_driver='gesvd')
+    
+            if verbose:
+                print('singular values AE=',sAE)
+            
+            nRedundant = (abs(s) <= threshold).sum() #counts True=1, False=0
+            #these are constraints on AE coordinates, which do not count as constraints!
+            nPureAE = (abs(sAE) > threshold).sum() #counts True=1, False=0
+        else:
+            nRedundant = nAE - np.linalg.matrix_rank(Call)
+            nPureAE = np.linalg.matrix_rank(Cae)
+
+    dof = nODE2-(nAE-nPureAE)+nRedundant
+    if verbose:
+        print('ODE2 coordinates          =',nODE2)
+        print('total constraints         =',nAE)
+        print('redundant constraints     =',nRedundant)
+        print('pure algebraic constraints=',nPureAE)
+        print('degree of freedom         =',dof)
 
+    return [dof, nRedundant, nODE2, nODE1, nAE, nPureAE]
+
+    
 #**function: compute eigenvalues for unconstrained ODE2 part of mbs, not considering the effects of algebraic constraints; the computation is done for the initial values of the mbs, independently of previous computations. If you would like to use the current state for the eigenvalue computation, you need to copy the current state to the initial state (using GetSystemState,SetSystemState, see \refSection{sec:mbs:systemData}); note that mass and stiffness matrix are computed in dense mode so far, while eigenvalues are computed according to useSparseSolver.
 #**input:    
 #   mbs: the MainSystem containing the assembled system
 #   simulationSettings: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
 #   useSparseSolver: if False (only for small systems), all eigenvalues are computed in dense mode (slow for large systems!); if True, only the numberOfEigenvalues are computed (numberOfEigenvalues must be set!); Currently, the matrices are exported only in DENSE MODE from mbs! NOTE that the sparsesolver accuracy is much less than the dense solver
 #   numberOfEigenvalues: number of eigenvalues and eivenvectors to be computed; if numberOfEigenvalues==0, all eigenvalues will be computed (may be impossible for larger problems!)
 #   constrainedCoordinates: if this list is non-empty, the integer indices represent constrained coordinates of the system, which are fixed during eigenvalue/vector computation; according rows/columns of mass and stiffness matrices are erased
@@ -349,15 +480,17 @@
 #  [values, vectors] = exu.ComputeODE2Eigenvalues(mbs)
 #  print("eigenvalues=", values)
 #  #==>values contains the eigenvalues of the ODE2 part of the system in the current configuration
 def ComputeODE2Eigenvalues(mbs, 
                            simulationSettings = exudyn.SimulationSettings(),
                            useSparseSolver = False, numberOfEigenvalues = 0, constrainedCoordinates=[],
                            convert2Frequencies = False, useAbsoluteValues = True):
-    import numpy as np
+
+    store = DeactivateWritingOfSolvers(simulationSettings)
+
     #use static solver, as it does not include factors from time integration (and no velocity derivatives) in the jacobian
     staticSolver = exudyn.MainSolverStatic()
 
     #initialize solver with initial values
     staticSolver.InitializeSolver(mbs, simulationSettings)
 
     staticSolver.ComputeMassMatrix(mbs)
@@ -366,43 +499,49 @@
     staticSolver.ComputeJacobianODE2RHS(mbs,scalarFactor_ODE2=-1,
                                         scalarFactor_ODE2_t=0, 
                                         scalarFactor_ODE1=0)    #compute ODE2 part of jacobian ==> stored internally in solver
     #staticSolver.ComputeJacobianAE(mbs)         #compute algebraic part of jacobian (not needed here...)
     jacobian = staticSolver.GetSystemJacobian() #read out stored jacobian
 
     nODE2 = staticSolver.GetODE2size()
+    staticSolver.FinalizeSolver(mbs, simulationSettings) #close files, etc.
+    RestoreSimulationSettings(simulationSettings, store)
 
     #obtain ODE2 part from jacobian == stiffness matrix
     K = jacobian[0:nODE2,0:nODE2]
 
     remappingIndices = np.arange(nODE2) #maps new coordinates to original (full) ones
     if constrainedCoordinates != []:
         M = np.delete(np.delete(M, constrainedCoordinates, 0), constrainedCoordinates, 1)
         K = np.delete(np.delete(K, constrainedCoordinates, 0), constrainedCoordinates, 1)
         remappingIndices = np.delete(remappingIndices, constrainedCoordinates)
 
-    if not useSparseSolver:
+    try:
         from scipy.linalg import eigh  #eigh for symmetric matrices, positive definite; eig for standard eigen value problems
+        from scipy.sparse.linalg import eigsh #eigh for symmetric matrices, positive definite
+        from scipy.sparse import csr_matrix
+    except:
+        raise ValueError('ComputeODE2Eigenvalues: missing scipy package; install with: pip install scipy')
+
+
+    if not useSparseSolver:
         [eigenValuesUnsorted, eigenVectors] = eigh(K, M) #this gives omega^2 ... squared eigen frequencies (rad/s)
         if useAbsoluteValues:
             sortIndices = np.argsort(abs(eigenValuesUnsorted)) #get resorting index
             eigenValues = np.sort(a=abs(eigenValuesUnsorted)) #eigh returns unsorted eigenvalues...
         else:
             sortIndices = np.argsort(eigenValuesUnsorted) #get resorting index
             eigenValues = np.sort(a=eigenValuesUnsorted) #eigh returns unsorted eigenvalues...
         if numberOfEigenvalues > 0:
             eigenValues = eigenValues[0:numberOfEigenvalues]
             eigenVectors = eigenVectors[:,sortIndices[0:numberOfEigenvalues]] #eigenvectors are given in columns!
     else:
         if numberOfEigenvalues == 0: #compute all eigenvalues
             numberOfEigenvalues = nODE2
 
-        from scipy.sparse.linalg import eigsh #eigh for symmetric matrices, positive definite
-        from scipy.sparse import csr_matrix
-
         Kcsr = csr_matrix(K)
         Mcsr = csr_matrix(M)
 
         #use "LM" (largest magnitude), but shift-inverted mode with sigma=0, to find the zero-eigenvalues:
         #see https://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html
         [eigenValues, eigenVectors] = eigsh(A=Kcsr, k=numberOfEigenvalues, M=Mcsr, 
                                    which='LM', sigma=0, mode='normal') 
@@ -429,17 +568,30 @@
     else:
         return [eigenValues, eigenVectors]
     
 #**function: helper function for solvers to check e.g. if high number of memory allocations happened during simulation
 #            This can happen, if large amount of sensors are attached and output is written in every time step
 #**input: stat=exudyn.InfoStat() from previous step, numberOfEvaluations is a counter which is proportional to number of RHS evaluations in method
 def CheckSolverInfoStatistics(solverName, infoStat, numberOfEvaluations):
-    import numpy as np
-
     stat = np.array(exudyn.InfoStat(False)) - np.array(infoStat)
 
     newCnt = max(stat[0],stat[2],stat[4]) #array, vector, matrix new counts
 
     if newCnt > solverCheckMemoryAllocationsThreshold and newCnt >= numberOfEvaluations:
         exudyn.Print("WARNING: "+solverName+" detected large amount ("+str(newCnt)+") of memory allocations, which seem to occur in every time step; solver may be slow")
 
     #print("newcnt=", newCnt)
+
+if __name__ == '__main__':
+    import exudyn.demos as demos
+    [mbs, SC] = demos.Demo1(False)
+    [dof, nRedundant, nODE2, nODE1, nAE, nPureAE] = exudyn.ComputeSystemDegreeOfFreedom(mbs, verbose=True)
+    print('Demo1 dof=',dof) #2 DOF (2D mass point freely moving)
+
+    #takes some seconds to compute:
+    [mbs, SC] = demos.Demo2(False)
+    [dof, nRedundant, nODE2, nODE1, nAE, nPureAE] = exudyn.ComputeSystemDegreeOfFreedom(mbs)
+    print('Demo2 dof=',dof) #12*3=36 (12 bodies with 12 spherical joints)
+
+    [dof, nRedundant, nODE2, nODE1, nAE, nPureAE] = exudyn.ComputeSystemDegreeOfFreedom(mbs, verbose=True, useSVD=True)
+    print('Demo2 dof SVD=',dof) #12*3=36 (12 bodies with 12 spherical joints)
+
```

## exudyn/robotics/roboticsCore.py

```diff
@@ -1158,15 +1158,18 @@
         self.simulationSettings.staticSolver.verboseMode = 0
         self.simulationSettings.displayGlobalTimers = 0
         #self.simulationSettings.staticSolver.stabilizerODE2term = 1e-1
         self.staticSolver = exudyn.MainSolverStatic()
         # sparse solver settings are faster for redundant mbs
         self.mbsIK.Assemble()   
         self.sysStateList = self.mbsIK.systemData.GetSystemState()
-        return
+
+    def __def__(self):
+        self.staticSolver.FinalizeSolver(self.mbsIK, self.simulationSettings)
+        
     # debugging helper function 
     def createVector(p0, p01): 
         x = [p0[0], p0[0] + p01[0]]
         y = [p0[1], p0[1] + p01[1]]
         z = [p0[2], p0[2] + p01[2]]
         return x, y, z
```

## Comparing `exudyn-1.6.65.dev1.dist-info/METADATA` & `exudyn-1.6.80.dev1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: exudyn
-Version: 1.6.65.dev1
+Version: 1.6.80.dev1
 Summary: EXUDYN flexible multibody dynamics simulation in C++ and Python
 Home-page: https://github.com/jgerstmayr/EXUDYN
 Author: Johannes Gerstmayr
 Author-email: reply.exudyn@gmail.com
 License: BSD
 Platform: any
 Classifier: Development Status :: 4 - Beta
```

## Comparing `exudyn-1.6.65.dev1.dist-info/RECORD` & `exudyn-1.6.80.dev1.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,36 +1,36 @@
 exudyn/FEM.py,sha256=Rpxz0qtl6Dq03__5AWgjyiL6VFu5Lf3xImCoHVVtxks,212931
 exudyn/GUI.py,sha256=oBceXvJB9TTjyNMPieZnf9ICe6xunAVhcg2A06S72rI,42942
-exudyn/__init__.py,sha256=Vjdo4IwlQvcFeApZVT1eCyl81vH97RZxvjRjfQfZZds,6474
+exudyn/__init__.py,sha256=_l33nGTFzjQgRuVa188raFljHFLkBCVc8BBePAE-36A,6613
 exudyn/advancedUtilities.py,sha256=L6rPWNGiXodPKGftQLkBOtn8ZwD1dVb1WZQDqGCyLfY,16183
 exudyn/artificialIntelligence.py,sha256=s1TbljwSBtSNWk45m5__Nb3SZ2qC5yNH3_PgcftlSSs,15264
 exudyn/basicUtilities.py,sha256=zG5iN5W3IEc3fH1koAJ84nnKZyHcKWK1UbHTrL1_zcU,11393
 exudyn/beams.py,sha256=6onNzmq1ZP2Bn8-tCHzaetuOV9NtIW7WoVcXNRJuTLw,35948
-exudyn/demos.py,sha256=3sAMnfaAAHPk1i3TSmNLWkMCQ0J7v9h7olQsw5qP_uw,7288
-exudyn/exudynCPP.cp39-win_amd64.pyd,sha256=bOPLx0umkiJfWeFVXtDfV9kU0VBHK5DIQJXaFn7mDII,5756416
+exudyn/demos.py,sha256=cSQFKwceoxNzrFUazvaKq0kL12ibRgWxuW5VlFAGJ5c,7366
+exudyn/exudynCPP.cp39-win_amd64.pyd,sha256=WA5AB-sPmqhMldrjmc8JgZ8toq6gkxZG0pOAo58nq9w,5729280
 exudyn/graphicsDataUtilities.py,sha256=pgxtbOP_Gt7_JMibYpBZquGfvv9i6xScsIt8Fq_5lio,85436
 exudyn/interactive.py,sha256=A-bFzHVV4ScLfoZvfwUuf_7GDXZ7OI6DB8JtO3LQMME,53048
 exudyn/itemInterface.py,sha256=6JU3CwKuvdhbw6kyEF0WpJ2xooFU5palJBD-0z9sUBI,158659
 exudyn/kinematicTree.py,sha256=ltAKaZeW_7KZTdhq2Zh4SxpZw2mMf-OQIniNdi5iVqw,32746
-exudyn/lieGroupBasics.py,sha256=XpkhHFRrHgkwtNoEvtPXN-52Mpu4AbJzH8u-sQpGk2s,21846
+exudyn/lieGroupBasics.py,sha256=NE_LiYxXM2_torQ01hpiukQnjfHmdsqjdGJbVUZt7Ts,22928
 exudyn/lieGroupIntegration.py,sha256=svUYTow5b2JRWQ7EOZsSk8pkItqzGDyyKz0RZFU9Byg,13557
 exudyn/machines.py,sha256=YJ-Wepm3bXgPZuyVSc5_TB414IaUF9bZcSrp41sy5gc,3165
 exudyn/physics.py,sha256=uQp30quLIxQiraHpaqLX-RJi4xc964FqDk8df8czNhU,6169
 exudyn/plot.py,sha256=TkNGmmx75_QHql4eSb7XXnUVG1tVoYhKIMRkWM-H84w,50407
 exudyn/processing.py,sha256=Oq_9fNK4l5dqtp6Nar5X4lfDgQhJlKCTWvTA_EV5LnE,71531
 exudyn/resultsMonitor.py,sha256=i1wZdH7M279jN9z1U0FFZAzVlr9gX1VO7d_vfcSmrTg,14646
 exudyn/rigidBodyUtilities.py,sha256=QyeTVLvkAl_dLqte_AePujtfl0GtteSqbCK5fSwPoj8,66182
 exudyn/signalProcessing.py,sha256=3QZAnQT9BMLts5hVlJMKhkvbA4SDB9KJ1sK-IqAhYLI,15158
-exudyn/solver.py,sha256=ZoU8FPU9B1TKnyX1RnXHzOqkjECCKAzHQkCtCrH7Om0,27593
+exudyn/solver.py,sha256=iA6e1stYg-_sdL01c5XMhJIYCxekz6MENGr3TsG7A4U,35482
 exudyn/utilities.py,sha256=1fRIDk8x8h9J6kQ-xjw5lOqyTxHyexx2bsu25NWzDuI,66527
 exudyn/robotics/__init__.py,sha256=Pzu7pcW4qLUaw3nY2sPTkav4N2PrDgNFmB_1gzeNwLs,898
 exudyn/robotics/future.py,sha256=T9Tc_5zzo_LrFI2QZZBK2fBmxjVOKtR3IdUyH2El0mo,24507
 exudyn/robotics/mobile.py,sha256=npw-Qr4cXeNLKjvmkVf0JJFActlimPa1mlC-6s7SSGQ,527
 exudyn/robotics/models.py,sha256=23uffRQWvGSAnH5Vx9BUcRTMj9fkMRSkxDI1Wrkb97E,32539
 exudyn/robotics/motion.py,sha256=ccBje_jiBoulEPp7cxekOmR9BnaIxH_-LoTkMTUNQls,26097
-exudyn/robotics/roboticsCore.py,sha256=zbk3VJ5SMUs015UpvGY7X_XM7N-8z29XLAJQBN6eQE0,97871
+exudyn/robotics/roboticsCore.py,sha256=vrDqa-YN1y8jxrQHWqcOzr8dUBawJmLTD9fy9O4mS48,97970
 exudyn/robotics/special.py,sha256=FSGl9VeXLDfgFNHhGh0Wm8pCbRgTVffWq2b2O4042hc,15166
 exudyn/robotics/utilities.py,sha256=7Kp_Ce-b2O3RvQGHtDw50uN3iFew19p_9RLGzsOODa8,5171
-exudyn-1.6.65.dev1.dist-info/METADATA,sha256=jGWGG2SxzLTv3zE5QEhunl3YvO-GxzFQLdrpNVD4YTA,1653
-exudyn-1.6.65.dev1.dist-info/WHEEL,sha256=fVcVlLzi8CGi_Ul8vjMdn8gER25dn5GBg9E6k9z41-Y,100
-exudyn-1.6.65.dev1.dist-info/top_level.txt,sha256=w4EYVbsh-zIfLBaDyrwYdU7hMcmaIS3OhFvBmSgkFO4,7
-exudyn-1.6.65.dev1.dist-info/RECORD,,
+exudyn-1.6.80.dev1.dist-info/METADATA,sha256=OwDEhPOBTtAKIDyA2VFkWdvQx6j4AdbeDY_c2Ov5bJI,1653
+exudyn-1.6.80.dev1.dist-info/WHEEL,sha256=fVcVlLzi8CGi_Ul8vjMdn8gER25dn5GBg9E6k9z41-Y,100
+exudyn-1.6.80.dev1.dist-info/top_level.txt,sha256=w4EYVbsh-zIfLBaDyrwYdU7hMcmaIS3OhFvBmSgkFO4,7
+exudyn-1.6.80.dev1.dist-info/RECORD,,
```

