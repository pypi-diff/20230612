# Comparing `tmp/tablite-2023.6.dev2-py3-none-any.whl.zip` & `tmp/tablite-2023.6.dev3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,33 +1,33 @@
-Zip file size: 79200 bytes, number of entries: 31
--rw-r--r--  2.0 unx      244 b- defN 23-Jun-09 09:49 tablite/__init__.py
--rw-r--r--  2.0 unx    56819 b- defN 23-Jun-09 09:49 tablite/base.py
--rw-r--r--  2.0 unx     2323 b- defN 23-Jun-09 09:49 tablite/config.py
--rw-r--r--  2.0 unx    28136 b- defN 23-Jun-09 09:49 tablite/core.py
--rw-r--r--  2.0 unx     4504 b- defN 23-Jun-09 09:49 tablite/datasets.py
--rw-r--r--  2.0 unx    26976 b- defN 23-Jun-09 09:49 tablite/datatypes.py
--rw-r--r--  2.0 unx     2872 b- defN 23-Jun-09 09:49 tablite/diff.py
--rw-r--r--  2.0 unx     7759 b- defN 23-Jun-09 09:49 tablite/export_utils.py
--rw-r--r--  2.0 unx    10112 b- defN 23-Jun-09 09:49 tablite/file_reader_utils.py
--rw-r--r--  2.0 unx     4889 b- defN 23-Jun-09 09:49 tablite/groupby_utils.py
--rw-r--r--  2.0 unx     5621 b- defN 23-Jun-09 09:49 tablite/groupbys.py
--rw-r--r--  2.0 unx    22204 b- defN 23-Jun-09 09:49 tablite/import_utils.py
--rw-r--r--  2.0 unx     7589 b- defN 23-Jun-09 09:49 tablite/imputation.py
--rw-r--r--  2.0 unx    12181 b- defN 23-Jun-09 09:49 tablite/joins.py
--rw-r--r--  2.0 unx     6737 b- defN 23-Jun-09 09:49 tablite/lookup.py
--rw-r--r--  2.0 unx     3199 b- defN 23-Jun-09 09:49 tablite/mp_utils.py
--rw-r--r--  2.0 unx     8863 b- defN 23-Jun-09 09:49 tablite/pivots.py
--rw-r--r--  2.0 unx     9171 b- defN 23-Jun-09 09:49 tablite/redux.py
--rw-r--r--  2.0 unx     6098 b- defN 23-Jun-09 09:49 tablite/sort_utils.py
--rw-r--r--  2.0 unx     5299 b- defN 23-Jun-09 09:49 tablite/sortation.py
--rw-r--r--  2.0 unx     1125 b- defN 23-Jun-09 09:49 tablite/tools.py
--rw-r--r--  2.0 unx    11195 b- defN 23-Jun-09 09:49 tablite/utils.py
--rw-r--r--  2.0 unx      139 b- defN 23-Jun-09 09:49 tablite/version.py
--rw-r--r--  2.0 unx     1069 b- defN 23-Jun-09 09:49 tablite-2023.6.dev2.data/data/LICENSE
--rw-r--r--  2.0 unx     6960 b- defN 23-Jun-09 09:49 tablite-2023.6.dev2.data/data/README.md
--rw-r--r--  2.0 unx      246 b- defN 23-Jun-09 09:49 tablite-2023.6.dev2.data/data/requirements.txt
--rw-r--r--  2.0 unx     1069 b- defN 23-Jun-09 09:49 tablite-2023.6.dev2.dist-info/LICENSE
--rw-r--r--  2.0 unx     8677 b- defN 23-Jun-09 09:49 tablite-2023.6.dev2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-09 09:49 tablite-2023.6.dev2.dist-info/WHEEL
--rw-r--r--  2.0 unx        8 b- defN 23-Jun-09 09:49 tablite-2023.6.dev2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2457 b- defN 23-Jun-09 09:49 tablite-2023.6.dev2.dist-info/RECORD
-31 files, 264633 bytes uncompressed, 75332 bytes compressed:  71.5%
+Zip file size: 79968 bytes, number of entries: 31
+-rw-r--r--  2.0 unx      244 b- defN 23-Jun-12 12:07 tablite/__init__.py
+-rw-r--r--  2.0 unx    57878 b- defN 23-Jun-12 12:07 tablite/base.py
+-rw-r--r--  2.0 unx     2319 b- defN 23-Jun-12 12:07 tablite/config.py
+-rw-r--r--  2.0 unx    28564 b- defN 23-Jun-12 12:07 tablite/core.py
+-rw-r--r--  2.0 unx     4504 b- defN 23-Jun-12 12:07 tablite/datasets.py
+-rw-r--r--  2.0 unx    27391 b- defN 23-Jun-12 12:07 tablite/datatypes.py
+-rw-r--r--  2.0 unx     2872 b- defN 23-Jun-12 12:07 tablite/diff.py
+-rw-r--r--  2.0 unx     7759 b- defN 23-Jun-12 12:07 tablite/export_utils.py
+-rw-r--r--  2.0 unx    10112 b- defN 23-Jun-12 12:07 tablite/file_reader_utils.py
+-rw-r--r--  2.0 unx     4889 b- defN 23-Jun-12 12:07 tablite/groupby_utils.py
+-rw-r--r--  2.0 unx     5621 b- defN 23-Jun-12 12:07 tablite/groupbys.py
+-rw-r--r--  2.0 unx    22204 b- defN 23-Jun-12 12:07 tablite/import_utils.py
+-rw-r--r--  2.0 unx     7589 b- defN 23-Jun-12 12:07 tablite/imputation.py
+-rw-r--r--  2.0 unx    12181 b- defN 23-Jun-12 12:07 tablite/joins.py
+-rw-r--r--  2.0 unx     6737 b- defN 23-Jun-12 12:07 tablite/lookup.py
+-rw-r--r--  2.0 unx     3199 b- defN 23-Jun-12 12:07 tablite/mp_utils.py
+-rw-r--r--  2.0 unx     8863 b- defN 23-Jun-12 12:07 tablite/pivots.py
+-rw-r--r--  2.0 unx     9171 b- defN 23-Jun-12 12:07 tablite/redux.py
+-rw-r--r--  2.0 unx     6884 b- defN 23-Jun-12 12:07 tablite/sort_utils.py
+-rw-r--r--  2.0 unx     5404 b- defN 23-Jun-12 12:07 tablite/sortation.py
+-rw-r--r--  2.0 unx     1125 b- defN 23-Jun-12 12:07 tablite/tools.py
+-rw-r--r--  2.0 unx    11195 b- defN 23-Jun-12 12:07 tablite/utils.py
+-rw-r--r--  2.0 unx      139 b- defN 23-Jun-12 12:07 tablite/version.py
+-rw-r--r--  2.0 unx     1069 b- defN 23-Jun-12 12:07 tablite-2023.6.dev3.data/data/LICENSE
+-rw-r--r--  2.0 unx     6960 b- defN 23-Jun-12 12:07 tablite-2023.6.dev3.data/data/README.md
+-rw-r--r--  2.0 unx      246 b- defN 23-Jun-12 12:07 tablite-2023.6.dev3.data/data/requirements.txt
+-rw-r--r--  2.0 unx     1069 b- defN 23-Jun-12 12:07 tablite-2023.6.dev3.dist-info/LICENSE
+-rw-r--r--  2.0 unx     8677 b- defN 23-Jun-12 12:07 tablite-2023.6.dev3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-12 12:07 tablite-2023.6.dev3.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 23-Jun-12 12:07 tablite-2023.6.dev3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2457 b- defN 23-Jun-12 12:07 tablite-2023.6.dev3.dist-info/RECORD
+31 files, 267422 bytes uncompressed, 76100 bytes compressed:  71.5%
```

## zipnote {}

```diff
@@ -63,32 +63,32 @@
 
 Filename: tablite/utils.py
 Comment: 
 
 Filename: tablite/version.py
 Comment: 
 
-Filename: tablite-2023.6.dev2.data/data/LICENSE
+Filename: tablite-2023.6.dev3.data/data/LICENSE
 Comment: 
 
-Filename: tablite-2023.6.dev2.data/data/README.md
+Filename: tablite-2023.6.dev3.data/data/README.md
 Comment: 
 
-Filename: tablite-2023.6.dev2.data/data/requirements.txt
+Filename: tablite-2023.6.dev3.data/data/requirements.txt
 Comment: 
 
-Filename: tablite-2023.6.dev2.dist-info/LICENSE
+Filename: tablite-2023.6.dev3.dist-info/LICENSE
 Comment: 
 
-Filename: tablite-2023.6.dev2.dist-info/METADATA
+Filename: tablite-2023.6.dev3.dist-info/METADATA
 Comment: 
 
-Filename: tablite-2023.6.dev2.dist-info/WHEEL
+Filename: tablite-2023.6.dev3.dist-info/WHEEL
 Comment: 
 
-Filename: tablite-2023.6.dev2.dist-info/top_level.txt
+Filename: tablite-2023.6.dev3.dist-info/top_level.txt
 Comment: 
 
-Filename: tablite-2023.6.dev2.dist-info/RECORD
+Filename: tablite-2023.6.dev3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## tablite/base.py

```diff
@@ -4,19 +4,20 @@
 import yaml
 import atexit
 import shutil
 import logging
 import warnings
 import zipfile
 import numpy as np
+from tqdm import tqdm as _tqdm
 from pathlib import Path
 from itertools import count, chain, product, repeat
 from collections import defaultdict
 
-from tablite.datatypes import DataTypes, np_type_unify, numpy_to_python, list_to_np_array, pytype
+from tablite.datatypes import DataTypes, np_type_unify, numpy_to_python, list_to_np_array, pytype, multitype_set
 from tablite.utils import (
     type_check,
     intercept,
     dict_to_rows,
     unique_name,
     summary_statistics,
 )
@@ -767,36 +768,44 @@
         ['a','b','c']
         """
         arrays = []
         for page in set(self.pages):
             try:  # when it works, numpy is fast...
                 arrays.append(np.unique(page.get()))
             except TypeError:  # ...but np.unique cannot handle Nones.
-                arrays.append(list(set(page.get())))
+                arrays.append(multitype_set(page.get()))
         union = np_type_unify(arrays)
         try:
             return np.unique(union)
         except TypeError:
-            return np.array(list(set(union)))
+            return multitype_set(union)
 
     def histogram(self):
         """
         returns 2 arrays: unique elements and count of each element
 
         example:
         >>> c = Column(data=['a','b','a','c','b'])
         >>> c.histogram()
         {'a':2,'b':2,'c':1}
         """
         d = defaultdict(int)
         for page in self.pages:
-            uarray, carray = np.unique(page.get(), return_counts=True)
+            try:
+                uarray, carray = np.unique(page.get(), return_counts=True)
+            except TypeError:
+                uarray = page.get()
+                carray = repeat(1, len(uarray))
+
             for i, c in zip(uarray, carray):
-                d[numpy_to_python(i)] += numpy_to_python(c)
-        return dict(d)
+                v = numpy_to_python(i)
+                d[(type(v), v)] += numpy_to_python(c)
+        u = [v for _, v in d.keys()]
+        c = list(d.values())
+        return u, c  # unique, counts
 
     def statistics(self):
         """
         returns dict with:
         - min (int/float, length of str, date)
         - max (int/float, length of str, date)
         - mean (int/float, length of str, date)
@@ -804,36 +813,59 @@
         - stdev (int/float, length of str, date)
         - mode (int/float, length of str, date)
         - distinct (int/float, length of str, date)
         - iqr (int/float, length of str, date)
         - sum (int/float, length of str, date)
         - histogram (see .histogram)
         """
-        htg = self.histogram()
-        values, counts = list(htg.keys()), list(htg.values())
+        values, counts = self.histogram()
         return summary_statistics(values, counts)
 
     def count(self, item):
+        """counts appearances of item in column.
+
+        Note:
+
+        in python:
+        >>> L = [1, True]
+        >>> L.count(True)
+        2
+
+        in tablite:
+        >>> t = Table({'L': [1,True]})
+        >>> t['L'].count(True)
+        1
+
+        Args:
+            item (Any): target item
+
+        Returns:
+            int: number of occurrences of item.
+        """
         result = 0
         for page in self.pages:
-            result += np.nonzero(page.get() == item)[0].shape[0]
-            # what happens here ---^ below:
-            # arr = page.get()
-            # >>> arr
-            # array([1,2,3,4,3], int64)
-            # >>> (arr == 3)
-            # array([False, False,  True, False,  True])
-            # >>> np.nonzero(arr==3)
-            # (array([2,4], dtype=int64), )  <-- tuple!
-            # >>> np.nonzero(page.get() == item)[0]
-            # array([2,4])
-            # >>> np.nonzero(page.get() == item)[0].shape
-            # (2, )
-            # >>> np.nonzero(page.get() == item)[0].shape[0]
-            # 2
+            data = page.get()
+            if data.dtype != "O":
+                result += np.nonzero(page.get() == item)[0].shape[0]
+                # what happens here ---^ below:
+                # arr = page.get()
+                # >>> arr
+                # array([1,2,3,4,3], int64)
+                # >>> (arr == 3)
+                # array([False, False,  True, False,  True])
+                # >>> np.nonzero(arr==3)
+                # (array([2,4], dtype=int64), )  <-- tuple!
+                # >>> np.nonzero(page.get() == item)[0]
+                # array([2,4])
+                # >>> np.nonzero(page.get() == item)[0].shape
+                # (2, )
+                # >>> np.nonzero(page.get() == item)[0].shape[0]
+                # 2
+            else:
+                result += sum(1 for i in data if type(i) == type(item) and i == item)
         return result
 
 
 class Table(object):
     _pid_dir = None  # typically Path(Config.workdir) / f"pid-{os.getpid()}"
     _ids = count()
 
@@ -984,18 +1016,18 @@
 
         elif len(integers) == 1:  # return a single tuple.
             row_no = integers[0]
             slc = slice(row_no, row_no + 1)
             return tuple(self.columns[name][slc].tolist()[0] for name in column_names)
 
         elif not slices:  # e.g. new table with N whole columns.
-            t = self.__class__()
-            for name in column_names:
-                t.columns[name] = self.columns[name]  # link pointers, but make no copies.
-            return t
+            return self.__class__(columns={
+                name: self.columns[name]
+                for name in column_names
+            })
 
         else:  # e.g. new table from selection of columns and slices.
             t = self.__class__()
             for name in column_names:
                 column = self.columns[name]
 
                 new_column = Column(t.path)  # create new Column.
@@ -1129,15 +1161,15 @@
                     log.debug(f"adding Page {page.path}")
 
             _fields = len(self) * len(self.columns)
             _avg = _fields // _page_counter
             log.debug(f"Wrote {_fields} on {_page_counter} pages in {_file_counter} files: {_avg} fields/page")
 
     @classmethod
-    def load(cls, path):  # USER FUNCTION.
+    def load(cls, path, tqdm=_tqdm):  # USER FUNCTION.
         """loads a table from .tpz file.
         See also Table.save for details on the file format.
 
         Args:
             path (Path): source file
 
         Returns:
@@ -1145,21 +1177,26 @@
         """
         type_check(path, Path)
         log.debug(f"loading {path}")
         with zipfile.ZipFile(path, "r") as f:
             yml = f.read("table.yml")
             metadata = yaml.safe_load(yml)
             t = cls()
-            for name, d in metadata["columns"].items():
-                column = Column(t.path)
-                for page in d["pages"]:
-                    bytestream = io.BytesIO(f.read(page))
-                    data = np.load(bytestream, allow_pickle=True, fix_imports=False)
-                    column.extend(data)
-                t.columns[name] = column
+
+            page_count = sum([len(c["pages"]) for c in metadata["columns"].values()])
+
+            with tqdm(total=page_count, desc=f"importing '{path.name}' file") as pbar:
+                for name, d in metadata["columns"].items():
+                    column = Column(t.path)
+                    for page in d["pages"]:
+                        bytestream = io.BytesIO(f.read(page))
+                        data = np.load(bytestream, allow_pickle=True, fix_imports=False)
+                        column.extend(data)
+                        pbar.update(1)
+                    t.columns[name] = column
         return t
 
     def copy(self):
         cls = type(self)
         t = cls()
         for name, column in self.columns.items():
             new = Column(t.path)
```

## tablite/config.py

```diff
@@ -31,15 +31,15 @@
     """
 
     workdir = pathlib.Path(os.environ.get("TABLITE_TMPDIR", f"{tempfile.gettempdir()}/tablite-tmp"))
     workdir.mkdir(parents=True, exist_ok=True)
 
     PAGE_SIZE = 1_000_000  # sets the page size limit.
     ENCODING = "UTF-8"  # sets the page encoding when using bytes
-    
+
     DISK_LIMIT = int(10e9)  # 10e9 (10Gb) on 100 Gb disk means raise at
     # 90 Gb disk usage.
     # if DISK_LIMIT <= 0, the check is turned off.
 
     SINGLE_PROCESSING_LIMIT = 1_000_000
     # when the number of fields (rows x columns)
     # exceed this value, multiprocessing is used.
```

## tablite/core.py

```diff
@@ -174,15 +174,15 @@
                       guess_datatypes, text_qualifier, strip_leading_and_tailing_whitespace,
                       delimiter, text_escape_openings, text_escape_closures)
             # fmt:on
 
         elif reader == import_utils.from_html:
             config = (path,)
         elif reader == import_utils.from_hdf5:
-            config = (path, )
+            config = (path,)
 
         elif reader == import_utils.excel_reader:
             # config = path, first_row_has_headers, sheet, columns, start, limit
             config = (
                 str(path),
                 first_row_has_headers,
                 sheet,
@@ -387,34 +387,48 @@
         if no args, all columns are used.
         """
         if not args:
             args = self.columns
         index = [min(v) for v in self.index(*args).values()]
         return self.reindex(index)
 
-    def sort(self, sort_mode="excel", **kwargs):
+    def sort(self, mapping, sort_mode="excel"):
         """Perform multi-pass sorting with precedence given order of column names.
-        sort_mode: str: "alphanumeric", "unix", or, "excel"
-        kwargs:
-            keys: columns,
-            values: 'reverse' as boolean.
-
-        examples:
-        Table.sort(**{'A':False}) means sort by 'A' in ascending order.
-        Table.sort(**{'A':True, 'B':False}) means sort 'A' in descending order, then (2nd priority)
+
+        Args:
+            mapping (dict): keys as columns,
+                            values as boolean for 'reverse'
+            sort_mode: str: "alphanumeric", "unix", or, "excel"
+
+        Returns:
+            None: Table.sort is sorted inplace
+
+        Examples:
+        Table.sort(mappinp={A':False}) means sort by 'A' in ascending order.
+        Table.sort(mapping={'A':True, 'B':False}) means sort 'A' in descending order, then (2nd priority)
         sort B in ascending order.
         """
-        return sortation.sort(self, sort_mode, **kwargs)
+        new = sortation.sort(self, mapping, sort_mode)
+        self.columns = new.columns
+
+    def sorted(self, mapping, sort_mode="excel"):
+        """See sort.
+        Sorted returns a new table in contrast to "sort", which is in-place.
+
+        Returns:
+            Table.
+        """
+        return sortation.sort(self, mapping, sort_mode)
 
-    def is_sorted(self, **kwargs):
+    def is_sorted(self, mapping, sort_mode="excel"):
         """Performs multi-pass sorting check with precedence given order of column names.
         **kwargs: optional: sort criteria. See Table.sort()
         :return bool
         """
-        return sortation.is_sorted(self, **kwargs)
+        return sortation.is_sorted(self, mapping, sort_mode)
 
     def any(self, **kwargs):
         """
         returns Table for rows where ANY kwargs match
         :param kwargs: dictionary with headers and values / boolean callable
         """
         return redux.filter_any(self, **kwargs)
```

## tablite/datatypes.py

```diff
@@ -732,15 +732,15 @@
     def __iter__(self):
         return iter(self.items_list)
 
 
 def list_to_np_array(iterable):
     """helper to make correct np array from python types.
     Example of problem where numpy turns mixed types into strings.
-    >>> np.array([4,'5'])
+    >>> np.array([4, '5'])
     np.ndarray(['4', '5'])
     """
     dtypes = set()
     for v in iterable:
         dtypes.add(type(v))
         if len(dtypes) > 1:  # no need to continue after we know it'll be dtype=object
             break
@@ -756,7 +756,26 @@
     if len(dtypes) == 1:
         dtype, _ = dtypes.popitem()
     else:
         for ix, arr in enumerate(arrays):
             arrays[ix] = np.array(arr, dtype=object)
         dtype = object
     return np.concatenate(arrays, dtype=dtype)
+
+
+def multitype_set(arr):
+    """prevents loss of True, False when calling sets.
+
+    python looses values when called returning a set:
+    >>> {1, True, 0, False}
+    {0,1}
+
+    Args:
+        arr (Iterable): iterable of mixed types.
+
+    Returns:
+        np.array: with unique values.
+    """
+    L = [(type(v), v) for v in arr]
+    L = list(set(L))
+    L = [v for _, v in L]
+    return np.array(L, dtype=object)
```

## tablite/sort_utils.py

```diff
@@ -1,10 +1,11 @@
 from datetime import datetime, date, time, timedelta
 from pyuca import Collator
 
+
 uca_collator = Collator()
 
 # EXCEL
 _excel_typecodes = {  # declares sortation rank: 0 < 1, etc.
     time: 0,
     int: 0,
     float: 0,
@@ -58,15 +59,15 @@
     time: _excel_time,
     date: _excel_date,
     datetime: _excel_datetime,
     timedelta: _excel_timedelta,
     bool: _excel_bool,
     float: _excel_float,
     int: _excel_int,
-    type(None): _excel_none,
+    type(None): _excel_none
     # str is handled by pyUCA.
 }
 
 # UNIX
 _unix_typecodes = {
     type(None): 0,
     bool: 1,
@@ -156,27 +157,38 @@
     |   6  | timedelta | as float using date (int) + time (decimal) |
     |   7  | str       | using unicode                              |
     +------+-----------+--------------------------------------------+
 
     τ = 2 * π
 
     """
-    L = []
-    text = [i for i in values if isinstance(i, str)]
+    text, non_text = [], []
+
+    # L = []
+    # text = [i for i in values if isinstance(i, str)]
+    # text.sort(key=uca_collator.sort_key, reverse=reverse)
+    # text_code = _unix_typecodes[str]
+    # L = [(text_code, ix, v) for ix, v in enumerate(text)]
+
+    for value in values:
+        if isinstance(value, str):
+            text.append(value)
+        else:
+            t = type(value)
+            TC = _unix_typecodes[t]
+            tf = _unix_value_function[t]
+            VC = tf(value)
+            non_text.append((TC, VC, value))
+    non_text.sort(reverse=reverse)
+
     text.sort(key=uca_collator.sort_key, reverse=reverse)
     text_code = _unix_typecodes[str]
-    L = [(text_code, ix, v) for ix, v in enumerate(text)]
+    text = [(text_code, ix, v) for ix, v in enumerate(text)]
 
-    for value in (i for i in values if not isinstance(i, str)):
-        t = type(value)
-        TC = _unix_typecodes[t]
-        tf = _unix_value_function[t]
-        VC = tf(value)
-        L.append((TC, VC, value))
-    L.sort(reverse=reverse)
+    L = non_text + text
     d = {value: ix for ix, (_, _, value) in enumerate(L)}
     return d
 
 
 def excel_sort(values, reverse=False):
     """
     Excel sortation sorts by the following order:
@@ -192,28 +204,46 @@
     |   2  | str       | using unicode                              |
     |   3  | bool      | 0 as False, 1 as True                      |
     |   4  | None      | floating point infinite.                   |
     +------+-----------+--------------------------------------------+
 
     * Excel doesn't have timedelta.
     """
-    L = []
-    text = [i for i in values if isinstance(i, str)]
 
-    text.sort(key=uca_collator.sort_key, reverse=reverse)
-    L = [(2, ix, v) for ix, v in enumerate(text)]
+    def tup(TC, value):
+        return (TC, _excel_value_function[t](value), value)
 
-    for value in (i for i in values if not isinstance(i, str)):
+    text, numeric, booles, nones = [], [], [], []
+    for value in values:
         t = type(value)
         TC = _excel_typecodes[t]
-        tf = _excel_value_function[t]
-        VC = tf(value)
-        L.append((TC, VC, value))
 
-    L.sort(reverse=reverse)
+        if TC == 0:
+            numeric.append(tup(TC, value))
+        elif TC == 1:
+            text.append(value)  # text is processed later.
+        elif TC == 2:
+            booles.append(tup(TC, value))
+        elif TC == 3:
+            booles.append(tup(TC, value))
+        else:
+            raise TypeError(f"no typecode for {value}")
+
+    if text:
+        text.sort(key=uca_collator.sort_key, reverse=reverse)
+        text = [(2, ix, v) for ix, v in enumerate(text)]
+
+    numeric.sort(reverse=reverse)
+    booles.sort(reverse=reverse)
+    nones.sort(reverse=reverse)
+
+    if reverse:
+        L = nones + booles + text + numeric
+    else:
+        L = numeric + text + booles + nones
     d = {value: ix for ix, (_, _, value) in enumerate(L)}
     return d
 
 
 modes = {"alphanumeric": text_sort, "unix": unix_sort, "excel": excel_sort}
```

## tablite/sortation.py

```diff
@@ -1,60 +1,62 @@
 import os
 import numpy as np
 import psutil
 from mplite import Task, TaskManager
 from tablite.mp_utils import share_mem, reindex_task, select_processing_method
+from tablite.datatypes import multitype_set, numpy_to_python
 from tablite.sort_utils import modes as sort_modes
 from tablite.sort_utils import rank as sort_rank
 from tablite.base import Table, Column, Page
 from tablite.utils import sub_cls_check, type_check
 
 from tqdm import tqdm as _tqdm
 
 
-def sort_index(T, sort_mode="excel", tqdm=_tqdm, pbar=None, **kwargs):
+def sort_index(T, mapping, sort_mode="excel", tqdm=_tqdm, pbar=None):
     """
     helper for methods `sort` and `is_sorted`
 
     param: sort_mode: str: "alphanumeric", "unix", or, "excel" (default)
     param: **kwargs: sort criteria. See Table.sort()
     """
 
     sub_cls_check(T, Table)
 
-    if not isinstance(kwargs, dict):
-        raise ValueError("Expected keyword arguments, did you forget the ** in front of your dict?")
-    if not kwargs:
-        kwargs = {c: False for c in T.columns}
+    if not isinstance(mapping, dict) or not mapping:
+        raise TypeError("Expected mapping (dict)?")
 
-    for k, v in kwargs.items():
+    for k, v in mapping.items():
         if k not in T.columns:
             raise ValueError(f"no column {k}")
         if not isinstance(v, bool):
             raise ValueError(f"{k} was mapped to {v} - a non-boolean")
 
     if sort_mode not in sort_modes:
         raise ValueError(f"{sort_mode} not in list of sort_modes: {list(sort_modes)}")
 
     rank = {i: tuple() for i in range(len(T))}  # create index and empty tuple for sortation.
 
-    _pbar = tqdm(total=len(kwargs.items()), desc="creating sort index") if pbar is None else pbar
+    _pbar = tqdm(total=len(mapping.items()), desc="creating sort index") if pbar is None else pbar
 
-    for key, reverse in kwargs.items():
+    for key, reverse in mapping.items():
         col = T[key][:]
-        col = col.tolist() if isinstance(col, np.ndarray) else col
-        ranks = sort_rank(values=set(col), reverse=reverse, mode=sort_mode)
+        ranks = sort_rank(values=[numpy_to_python(v) for v in multitype_set(col)], reverse=reverse, mode=sort_mode)
         assert isinstance(ranks, dict)
         for ix, v in enumerate(col):
-            rank[ix] += (ranks[v],)  # add tuple
+            rank[ix] += (ranks[v],)  # add tuple for each sortation level.
 
         _pbar.update(1)
 
+    del col
+    del ranks
+
     new_order = [(r, i) for i, r in rank.items()]  # tuples are listed and sort...
-    rank.clear()  # free memory.
+    del rank  # free memory.
+
     new_order.sort()
     sorted_index = [i for _, i in new_order]  # new index is extracted.
     new_order.clear()
     return np.array(sorted_index, dtype=np.int64)
 
 
 def reindex(T, index):
@@ -85,15 +87,16 @@
     m = select_processing_method(fields, _sp_reindex, _mp_reindex)
     return m(T, index)
 
 
 def _sp_reindex(T, index):
     t = type(T)()
     for name in T.columns:
-        t[name] = np.take(T[name][:], index)
+        data = T[name][:]
+        t[name] = np.take(data, index)
     return t
 
 
 def _mp_reindex(T, index):
     assert isinstance(index, np.ndarray)
     return _sp_reindex(T, index)
 
@@ -132,34 +135,39 @@
         for dst in new[name]:
             data = np.load(dst, allow_pickle=True, fix_imports=False)
             t[name].extend(data)
             os.remove(dst)
     return t
 
 
-def sort(T, sort_mode="excel", **kwargs):
+def sort(T, mapping, sort_mode="excel"):
     """Perform multi-pass sorting with precedence given order of column names.
     sort_mode: str: "alphanumeric", "unix", or, "excel"
     kwargs:
         keys: columns,
         values: 'reverse' as boolean.
 
     examples:
     Table.sort('A'=False) means sort by 'A' in ascending order.
     Table.sort('A'=True, 'B'=False) means sort 'A' in descending order, then (2nd priority)
     sort B in ascending order.
     """
     sub_cls_check(T, Table)
 
-    index = sort_index(T, sort_mode=sort_mode, **kwargs)
+    index = sort_index(T, mapping, sort_mode=sort_mode)
     m = select_processing_method(len(T) * len(T.columns), _sp_reindex, _mp_reindex)
     return m(T, index)
 
 
-def is_sorted(T, **kwargs):
+def is_sorted(T, mapping, sort_mode="excel"):
     """Performs multi-pass sorting check with precedence given order of column names.
-    **kwargs: optional: sort criteria. See Table.sort()
-    :return bool
+
+    Args:
+        mapping: sort criteria. See Table.sort()
+        sort_mode = sort mode. See Table.sort()
+
+    Returns:
+        bool
     """
-    index = sort_index(T, **kwargs)
+    index = sort_index(T, mapping, sort_mode=sort_mode)
     match = np.arange(len(T))
     return np.all(index == match)
```

## tablite/version.py

```diff
@@ -1,3 +1,3 @@
-major, minor, patch = 2023, 6, "dev2"
+major, minor, patch = 2023, 6, "dev3"
 __version_info__ = (major, minor, patch)
 __version__ = ".".join(str(i) for i in __version_info__)
```

## Comparing `tablite-2023.6.dev2.data/data/LICENSE` & `tablite-2023.6.dev3.data/data/LICENSE`

 * *Files identical despite different names*

## Comparing `tablite-2023.6.dev2.data/data/README.md` & `tablite-2023.6.dev3.data/data/README.md`

 * *Files identical despite different names*

## Comparing `tablite-2023.6.dev2.dist-info/LICENSE` & `tablite-2023.6.dev3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `tablite-2023.6.dev2.dist-info/METADATA` & `tablite-2023.6.dev3.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: tablite
-Version: 2023.6.dev2
+Version: 2023.6.dev3
 Summary: multiprocessing enabled out-of-memory data analysis library for tabular data.
 Home-page: https://github.com/root-11/tablite
 Author: https://github.com/root-11
 License: MIT
 Keywords: all,any,average,column,columns,count,csv,data imputation,date range,dict,excel,filter,first,from,from_pandas,groupby,guess,imputation,in-memory,index,indexing,inner join,is sorted,json,last,left join,list,list on disk,log,max,median,min,mode,numpy,ods,out-of-memory,outer join,pandas,pivot,pivot table,product,read csv,remove duplicates,replace,replace missing values,rows,show,sort,standard deviation,stored list,sum,table,tables,tablite,to,to_pandas,tools,transpose,txt,unique,use disk,xlsx,xround,zip
 Platform: any
 Classifier: Development Status :: 5 - Production/Stable
```

## Comparing `tablite-2023.6.dev2.dist-info/RECORD` & `tablite-2023.6.dev3.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,31 +1,31 @@
 tablite/__init__.py,sha256=SH-lADLJJHz9XwBebXZMYNBsBneAGwSCXY5rJhYgrYg,244
-tablite/base.py,sha256=IidDF2YGNWETD_m0gmC6j7s78tnIk5nXoEYkVa6uY78,56819
-tablite/config.py,sha256=Cf0U96l2hd3dQS3a28VxE3BxLrZUc_HsHOhi6z4mDE4,2323
-tablite/core.py,sha256=_jKOCMcAEq1l2h-oeRNrGXlMOSDyDKSyD49V9uFsxm0,28136
+tablite/base.py,sha256=7ZdE2Tl9TzarRn2MbGftgbsgJe9yhdFwTmfTZIOLs7s,57878
+tablite/config.py,sha256=IWwf7uue50vgydkj1s62twnJDmcWGDFm31t45YqUZww,2319
+tablite/core.py,sha256=wE4EKGF-vZNoOox0ur0OqCatXgY4KMFnMnw8MqCYLDo,28564
 tablite/datasets.py,sha256=WCCXy6nbLFokBGt3S9nd3IdYfeEqvvmHS90ZZVguV84,4504
-tablite/datatypes.py,sha256=X16D1b1Un9aXUoS8HH5-drHfo538258EYU2zKzGg6VQ,26976
+tablite/datatypes.py,sha256=KZSHcxFZNoPBIxBwR2bveW6obTPO-yM7e2BHHQtrynY,27391
 tablite/diff.py,sha256=NuxQGJLtXEat4utd1gyRDZBucV33nsMZeP9T02Mmofc,2872
 tablite/export_utils.py,sha256=cP_daDl-qXYqfVt2JVeFcNWYxMxTWiaA9IliYGRZ870,7759
 tablite/file_reader_utils.py,sha256=3a0XGUrmfM84BueFrP-wbTfL8_xpXmHp3RvknsYUf8k,10112
 tablite/groupby_utils.py,sha256=-GhV2q_4gFd7c1QKz0Oz6aiW5YLSMXXlIa_iNsJasBw,4889
 tablite/groupbys.py,sha256=ifu_EWHle0PkYiuPnNy11fRJmU4vQcBvZFfVW9b9_BY,5621
 tablite/import_utils.py,sha256=zGzrialo7V9ivJs7ebpec3eA7MALqpLeYBXSZJkGWjI,22204
 tablite/imputation.py,sha256=cBQ3k6_5LOFWyPC0-cum7IwIGk32PKcHb8kJ-WBK7a0,7589
 tablite/joins.py,sha256=fD19iAX2Czu0mlheEd8oCrg7UryncbDMWX2git-eRO8,12181
 tablite/lookup.py,sha256=rRgwhWSDc1wTBHzoc7iRSWR0Ma0d7lWxfVHRoKE5dGU,6737
 tablite/mp_utils.py,sha256=hY1X3PodD4jEMJ04AahrnLbQztJrXEntDm_ftPFeYuw,3199
 tablite/pivots.py,sha256=Yg5-ZAHTNlndESK2k3NwNJ1YkbxYLlX9KS64hys8pcE,8863
 tablite/redux.py,sha256=yh_i7my5aBQRP95Lkt5El8lDLTV0y2aRvtcHoRfXHpQ,9171
-tablite/sort_utils.py,sha256=Wgl2X4NT59fc32y2mMOZQZlD7m41-vkgNVqR7q-Arqc,6098
-tablite/sortation.py,sha256=MAMTctJutH48GZryGe9iM1kqD9ZuDZxReK2PMOJWN04,5299
+tablite/sort_utils.py,sha256=KevYkZlRq3nsSRDElG_chUm-t7dya2KOOzh0p-he0_4,6884
+tablite/sortation.py,sha256=IGNsWgmNl6BWP9-0TiNMgDoJGuGztNtbAQ2iaEeCdeY,5404
 tablite/tools.py,sha256=hEpqij7_2yc8yptUetk9Qjq1b7NxGoMamcCWOX3X010,1125
 tablite/utils.py,sha256=GXSuj7UfJzKa9a0t3FW5TnYacnvPD2_g1P-hDFP0ZWQ,11195
-tablite/version.py,sha256=bWk5fOpcjMVDxHWXDS4mu_AOpAAMx9WNRRVDOfHuS8Y,139
-tablite-2023.6.dev2.data/data/LICENSE,sha256=DzHDlst_HKcG2siTMmSx3QBYn1DfYj8Thz7d189Hd_M,1069
-tablite-2023.6.dev2.data/data/README.md,sha256=TlGniuVuNAT76KFExrlEPDOiUDnrRb6Qa7aahNmxZ3Y,6960
-tablite-2023.6.dev2.data/data/requirements.txt,sha256=AGNyHRtmn33IBZb4LVH8kqvOsoQCbzZTM1F9-VBUxVI,246
-tablite-2023.6.dev2.dist-info/LICENSE,sha256=DzHDlst_HKcG2siTMmSx3QBYn1DfYj8Thz7d189Hd_M,1069
-tablite-2023.6.dev2.dist-info/METADATA,sha256=3R4eCDP0voGUHiJM6o3C09fGdEwL53Q9W_AH_8xGj6o,8677
-tablite-2023.6.dev2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-tablite-2023.6.dev2.dist-info/top_level.txt,sha256=wLPhlgUC10JlueE5ZhtCVSrs2VnvMQgNlhdCNsxPXPg,8
-tablite-2023.6.dev2.dist-info/RECORD,,
+tablite/version.py,sha256=rWvfYTCpGISP_cjcU7bvCWl0a6KO7HiZasfqXDU7vv0,139
+tablite-2023.6.dev3.data/data/LICENSE,sha256=DzHDlst_HKcG2siTMmSx3QBYn1DfYj8Thz7d189Hd_M,1069
+tablite-2023.6.dev3.data/data/README.md,sha256=TlGniuVuNAT76KFExrlEPDOiUDnrRb6Qa7aahNmxZ3Y,6960
+tablite-2023.6.dev3.data/data/requirements.txt,sha256=AGNyHRtmn33IBZb4LVH8kqvOsoQCbzZTM1F9-VBUxVI,246
+tablite-2023.6.dev3.dist-info/LICENSE,sha256=DzHDlst_HKcG2siTMmSx3QBYn1DfYj8Thz7d189Hd_M,1069
+tablite-2023.6.dev3.dist-info/METADATA,sha256=u6Sg3iZxFj31kyCFyrQRsnhpNZkLWME3E-uQ4Z51Glw,8677
+tablite-2023.6.dev3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+tablite-2023.6.dev3.dist-info/top_level.txt,sha256=wLPhlgUC10JlueE5ZhtCVSrs2VnvMQgNlhdCNsxPXPg,8
+tablite-2023.6.dev3.dist-info/RECORD,,
```

