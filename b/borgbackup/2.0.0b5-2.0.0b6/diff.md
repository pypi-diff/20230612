# Comparing `tmp/borgbackup-2.0.0b5.tar.gz` & `tmp/borgbackup-2.0.0b6.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "borgbackup-2.0.0b5.tar", last modified: Sun Feb 26 23:58:35 2023, max compression
+gzip compressed data, was "borgbackup-2.0.0b6.tar", last modified: Mon Jun 12 08:18:26 2023, max compression
```

## Comparing `borgbackup-2.0.0b5.tar` & `borgbackup-2.0.0b6.tar`

### file list

```diff
@@ -1,435 +1,435 @@
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.401342 borgbackup-2.0.0b5/
--rw-r--r--   0 tw         (501) staff       (20)      481 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/.coveragerc
--rw-r--r--   0 tw         (501) staff       (20)       71 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/.git-blame-ignore-revs
--rw-r--r--   0 tw         (501) staff       (20)      663 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/.readthedocs.yaml
--rw-r--r--   0 tw         (501) staff       (20)     1179 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/AUTHORS
--rw-r--r--   0 tw         (501) staff       (20)    19214 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/CHANGES.rst
--rw-r--r--   0 tw         (501) staff       (20)     1551 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/LICENSE
--rw-r--r--   0 tw         (501) staff       (20)      487 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/MANIFEST.in
--rw-r--r--   0 tw         (501) staff       (20)     7652 2023-02-26 23:58:35.401424 borgbackup-2.0.0b5/PKG-INFO
--rw-r--r--   0 tw         (501) staff       (20)     7999 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/README.rst
--rw-r--r--   0 tw         (501) staff       (20)     2107 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/README_WINDOWS.rst
--rw-r--r--   0 tw         (501) staff       (20)      392 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/SECURITY.md
--rw-r--r--   0 tw         (501) staff       (20)     2539 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/conftest.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.327845 borgbackup-2.0.0b5/docs/
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.328028 borgbackup-2.0.0b5/docs/3rd_party/
--rw-r--r--   0 tw         (501) staff       (20)      215 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/3rd_party/README
--rw-r--r--   0 tw         (501) staff       (20)     4582 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/Makefile
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.329372 borgbackup-2.0.0b5/docs/_static/
--rw-r--r--   0 tw         (501) staff       (20)      198 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/_static/Makefile
--rw-r--r--   0 tw         (501) staff       (20)    38926 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/_static/favicon.ico
--rw-r--r--   0 tw         (501) staff       (20)     1316 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/_static/logo.pdf
--rw-r--r--   0 tw         (501) staff       (20)     1789 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/_static/logo.png
--rw-r--r--   0 tw         (501) staff       (20)     1790 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/_static/logo.svg
--rw-r--r--   0 tw         (501) staff       (20)      111 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/_static/logo_font.txt
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.329660 borgbackup-2.0.0b5/docs/_templates/
--rw-r--r--   0 tw         (501) staff       (20)      633 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/_templates/globaltoc.html
--rw-r--r--   0 tw         (501) staff       (20)      160 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/_templates/logo-text.html
--rw-r--r--   0 tw         (501) staff       (20)      139 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/authors.rst
--rw-r--r--   0 tw         (501) staff       (20)      401 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/book.rst
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.318810 borgbackup-2.0.0b5/docs/borg_theme/
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.329819 borgbackup-2.0.0b5/docs/borg_theme/css/
--rw-r--r--   0 tw         (501) staff       (20)     4001 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/borg_theme/css/borg.css
--rw-r--r--   0 tw         (501) staff       (20)    19214 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/changes.rst
--rw-r--r--   0 tw         (501) staff       (20)    33202 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/changes_0.x.rst
--rw-r--r--   0 tw         (501) staff       (20)   178112 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/changes_1.x.rst
--rw-r--r--   0 tw         (501) staff       (20)     8360 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/conf.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.330642 borgbackup-2.0.0b5/docs/deployment/
--rw-r--r--   0 tw         (501) staff       (20)     8569 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/deployment/automated-local.rst
--rw-r--r--   0 tw         (501) staff       (20)     7716 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/deployment/central-backup-server.rst
--rw-r--r--   0 tw         (501) staff       (20)     3456 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/deployment/hosting-repositories.rst
--rw-r--r--   0 tw         (501) staff       (20)     5943 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/deployment/image-backup.rst
--rw-r--r--   0 tw         (501) staff       (20)    17536 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/deployment/pull-backup.rst
--rw-r--r--   0 tw         (501) staff       (20)      329 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/deployment.rst
--rw-r--r--   0 tw         (501) staff       (20)    13007 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/development.rst
--rw-r--r--   0 tw         (501) staff       (20)    53780 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/faq.rst
--rw-r--r--   0 tw         (501) staff       (20)     1680 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/global.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      367 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/index.rst
--rw-r--r--   0 tw         (501) staff       (20)    16500 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/installation.rst
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.333964 borgbackup-2.0.0b5/docs/internals/
--rw-r--r--   0 tw         (501) staff       (20)    28928 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/compaction.odg
--rw-r--r--   0 tw         (501) staff       (20)   331649 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/compaction.png
--rw-r--r--   0 tw         (501) staff       (20)    53263 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/data-structures.rst
--rw-r--r--   0 tw         (501) staff       (20)    27294 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/encryption-aead.odg
--rw-r--r--   0 tw         (501) staff       (20)   149428 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/encryption-aead.png
--rw-r--r--   0 tw         (501) staff       (20)    27978 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/frontends.rst
--rw-r--r--   0 tw         (501) staff       (20)    29733 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/object-graph.odg
--rw-r--r--   0 tw         (501) staff       (20)   389349 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/object-graph.png
--rw-r--r--   0 tw         (501) staff       (20)    18787 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/security.rst
--rw-r--r--   0 tw         (501) staff       (20)    15645 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/structure.odg
--rw-r--r--   0 tw         (501) staff       (20)   154741 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals/structure.png
--rw-r--r--   0 tw         (501) staff       (20)     1668 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/internals.rst
--rw-r--r--   0 tw         (501) staff       (20)      232 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/introduction.rst
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.340677 borgbackup-2.0.0b5/docs/man/
--rw-r--r--   0 tw         (501) staff       (20)     1459 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-benchmark-cpu.1
--rw-r--r--   0 tw         (501) staff       (20)     3456 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-benchmark-crud.1
--rw-r--r--   0 tw         (501) staff       (20)     1123 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-benchmark.1
--rw-r--r--   0 tw         (501) staff       (20)     1278 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-break-lock.1
--rw-r--r--   0 tw         (501) staff       (20)     1563 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-change-passphrase.1
--rw-r--r--   0 tw         (501) staff       (20)     6979 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-check.1
--rw-r--r--   0 tw         (501) staff       (20)     2620 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-common.1
--rw-r--r--   0 tw         (501) staff       (20)     2183 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-compact.1
--rw-r--r--   0 tw         (501) staff       (20)     4281 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-compression.1
--rw-r--r--   0 tw         (501) staff       (20)     2673 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-config.1
--rw-r--r--   0 tw         (501) staff       (20)    18754 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-create.1
--rw-r--r--   0 tw         (501) staff       (20)     4001 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-delete.1
--rw-r--r--   0 tw         (501) staff       (20)     3561 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-diff.1
--rw-r--r--   0 tw         (501) staff       (20)     3710 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-export-tar.1
--rw-r--r--   0 tw         (501) staff       (20)     4097 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-extract.1
--rw-r--r--   0 tw         (501) staff       (20)     5589 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-import-tar.1
--rw-r--r--   0 tw         (501) staff       (20)     3250 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-info.1
--rw-r--r--   0 tw         (501) staff       (20)     2779 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-key-change-algorithm.1
--rw-r--r--   0 tw         (501) staff       (20)     1679 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-key-change-location.1
--rw-r--r--   0 tw         (501) staff       (20)     2925 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-key-change-passphrase.1
--rw-r--r--   0 tw         (501) staff       (20)     3119 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-key-export.1
--rw-r--r--   0 tw         (501) staff       (20)     2186 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-key-import.1
--rw-r--r--   0 tw         (501) staff       (20)     1955 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-key-migrate-to-repokey.1
--rw-r--r--   0 tw         (501) staff       (20)     1239 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-key.1
--rw-r--r--   0 tw         (501) staff       (20)     6160 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-list.1
--rw-r--r--   0 tw         (501) staff       (20)     1966 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-match-archives.1
--rw-r--r--   0 tw         (501) staff       (20)     5996 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-mount.1
--rw-r--r--   0 tw         (501) staff       (20)    12261 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-patterns.1
--rw-r--r--   0 tw         (501) staff       (20)     3009 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-placeholders.1
--rw-r--r--   0 tw         (501) staff       (20)     7686 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-prune.1
--rw-r--r--   0 tw         (501) staff       (20)     3049 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-rcompress.1
--rw-r--r--   0 tw         (501) staff       (20)     8043 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-rcreate.1
--rw-r--r--   0 tw         (501) staff       (20)     2386 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-rdelete.1
--rw-r--r--   0 tw         (501) staff       (20)     8524 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-recreate.1
--rw-r--r--   0 tw         (501) staff       (20)     1583 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-rename.1
--rw-r--r--   0 tw         (501) staff       (20)     2143 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-rinfo.1
--rw-r--r--   0 tw         (501) staff       (20)     4530 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-rlist.1
--rw-r--r--   0 tw         (501) staff       (20)     7001 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-serve.1
--rw-r--r--   0 tw         (501) staff       (20)     5341 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-transfer.1
--rw-r--r--   0 tw         (501) staff       (20)     3117 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-umount.1
--rw-r--r--   0 tw         (501) staff       (20)     3787 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-upgrade.1
--rw-r--r--   0 tw         (501) staff       (20)     1922 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg-with-lock.1
--rw-r--r--   0 tw         (501) staff       (20)    30194 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borg.1
--rw-r--r--   0 tw         (501) staff       (20)     3110 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man/borgfs.1
--rw-r--r--   0 tw         (501) staff       (20)     1735 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/man_intro.rst
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.342835 borgbackup-2.0.0b5/docs/misc/
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.344419 borgbackup-2.0.0b5/docs/misc/asciinema/
--rw-r--r--   0 tw         (501) staff       (20)      181 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/asciinema/README
--rw-r--r--   0 tw         (501) staff       (20)     3215 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/asciinema/Vagrantfile
--rw-r--r--   0 tw         (501) staff       (20)   179888 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/asciinema/advanced.json
--rw-r--r--   0 tw         (501) staff       (20)     3191 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/asciinema/advanced.tcl
--rw-r--r--   0 tw         (501) staff       (20)    73853 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/asciinema/basic.json
--rw-r--r--   0 tw         (501) staff       (20)     3210 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/asciinema/basic.tcl
--rw-r--r--   0 tw         (501) staff       (20)    24238 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/asciinema/install.json
--rw-r--r--   0 tw         (501) staff       (20)     1307 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/asciinema/install.tcl
--rw-r--r--   0 tw         (501) staff       (20)     3007 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/asciinema/sample-wallpapers.txt
--rw-r--r--   0 tw         (501) staff       (20)     3580 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/benchmark-crud.txt
--rw-r--r--   0 tw         (501) staff       (20)    20165 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/borg-data-flow.odg
--rw-r--r--   0 tw         (501) staff       (20)   196191 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/borg-data-flow.png
--rw-r--r--   0 tw         (501) staff       (20)     4399 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/create_chunker-params.txt
--rw-r--r--   0 tw         (501) staff       (20)     1825 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/internals-picture.txt
--rw-r--r--   0 tw         (501) staff       (20)      305 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/logging.conf
--rw-r--r--   0 tw         (501) staff       (20)     4235 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/misc/prune-example.txt
--rw-r--r--   0 tw         (501) staff       (20)    21253 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/quickstart.rst
--rw-r--r--   0 tw         (501) staff       (20)     2659 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/quickstart_example.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     2055 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/support.rst
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.353451 borgbackup-2.0.0b5/docs/usage/
--rw-r--r--   0 tw         (501) staff       (20)       72 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/benchmark.rst
--rw-r--r--   0 tw         (501) staff       (20)     1183 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/benchmark_cpu.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     3812 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/benchmark_crud.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)       38 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/borgfs.rst
--rw-r--r--   0 tw         (501) staff       (20)    16125 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/borgfs.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1004 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/break-lock.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1740 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/change-passphrase.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)       27 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/check.rst
--rw-r--r--   0 tw         (501) staff       (20)    14395 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/check.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1593 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/common-options.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      120 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/compact.rst
--rw-r--r--   0 tw         (501) staff       (20)     2815 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/compact.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      446 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/config.rst
--rw-r--r--   0 tw         (501) staff       (20)     3877 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/config.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     3549 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/create.rst
--rw-r--r--   0 tw         (501) staff       (20)    43806 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/create.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1730 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/debug.rst
--rw-r--r--   0 tw         (501) staff       (20)      496 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/delete.rst
--rw-r--r--   0 tw         (501) staff       (20)    12092 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/delete.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      639 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/diff.rst
--rw-r--r--   0 tw         (501) staff       (20)     7835 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/diff.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)    10323 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/export-tar.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      681 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/extract.rst
--rw-r--r--   0 tw         (501) staff       (20)    11354 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/extract.rst.inc
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.354907 borgbackup-2.0.0b5/docs/usage/general/
--rw-r--r--   0 tw         (501) staff       (20)      297 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/date-time.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)    10396 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/environment.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     3078 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/file-metadata.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1478 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/file-systems.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1666 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/logging.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      621 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/positional-arguments.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      614 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/repository-locations.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1007 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/repository-urls.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     4621 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/resources.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      634 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/return-codes.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      499 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general/units.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     2249 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/general.rst
--rw-r--r--   0 tw         (501) staff       (20)       65 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/help.rst
--rw-r--r--   0 tw         (501) staff       (20)    17495 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/help.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)    14437 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/import-tar.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      636 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/info.rst
--rw-r--r--   0 tw         (501) staff       (20)     8303 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/info.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1513 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/key.rst
--rw-r--r--   0 tw         (501) staff       (20)     2945 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/key_change-location.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1299 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/key_change-passphrase.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     4672 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/key_export.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     3265 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/key_import.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1677 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/list.rst
--rw-r--r--   0 tw         (501) staff       (20)    11534 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/list.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)       64 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/lock.rst
--rw-r--r--   0 tw         (501) staff       (20)     1659 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/mount.rst
--rw-r--r--   0 tw         (501) staff       (20)    17462 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/mount.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)    14258 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/notes.rst
--rw-r--r--   0 tw         (501) staff       (20)     1583 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/prune.rst
--rw-r--r--   0 tw         (501) staff       (20)    16006 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/prune.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      250 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rcompress.rst
--rw-r--r--   0 tw         (501) staff       (20)     4892 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rcompress.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      914 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rcreate.rst
--rw-r--r--   0 tw         (501) staff       (20)    13440 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rcreate.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      489 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rdelete.rst
--rw-r--r--   0 tw         (501) staff       (20)     4497 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rdelete.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      994 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/recreate.rst
--rw-r--r--   0 tw         (501) staff       (20)    46476 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/recreate.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      289 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rename.rst
--rw-r--r--   0 tw         (501) staff       (20)     1887 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rename.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      553 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rinfo.rst
--rw-r--r--   0 tw         (501) staff       (20)     1918 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rinfo.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      340 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rlist.rst
--rw-r--r--   0 tw         (501) staff       (20)    13662 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/rlist.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     4289 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/serve.rst
--rw-r--r--   0 tw         (501) staff       (20)    10154 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/serve.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1647 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/tar.rst
--rw-r--r--   0 tw         (501) staff       (20)     1621 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/transfer.rst
--rw-r--r--   0 tw         (501) staff       (20)    10214 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/transfer.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1873 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/umount.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      523 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/usage_general.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     2327 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage/with-lock.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)     1637 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage.rst
--rw-r--r--   0 tw         (501) staff       (20)      539 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/docs/usage_general.rst.inc
--rw-r--r--   0 tw         (501) staff       (20)      544 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/pyproject.toml
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.355552 borgbackup-2.0.0b5/requirements.d/
--rw-r--r--   0 tw         (501) staff       (20)      118 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/requirements.d/coala.txt
--rw-r--r--   0 tw         (501) staff       (20)       18 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/requirements.d/codestyle.txt
--rw-r--r--   0 tw         (501) staff       (20)      207 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/requirements.d/development.lock.txt
--rw-r--r--   0 tw         (501) staff       (20)      141 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/requirements.d/development.txt
--rw-r--r--   0 tw         (501) staff       (20)       27 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/requirements.d/docs.txt
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.356686 borgbackup-2.0.0b5/scripts/
--rw-r--r--   0 tw         (501) staff       (20)     2254 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/borg.exe.spec
--rwxr-xr-x   0 tw         (501) staff       (20)      480 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/errorlist.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.356950 borgbackup-2.0.0b5/scripts/fuzz-cache-sync/
--rw-r--r--   0 tw         (501) staff       (20)      361 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/fuzz-cache-sync/HOWTO
--rw-r--r--   0 tw         (501) staff       (20)      705 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/fuzz-cache-sync/main.c
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.357083 borgbackup-2.0.0b5/scripts/fuzz-cache-sync/testcase_dir/
--rw-r--r--   0 tw         (501) staff       (20)      147 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/fuzz-cache-sync/testcase_dir/test_simple
--rwxr-xr-x   0 tw         (501) staff       (20)     1611 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/glibc_check.py
--rw-r--r--   0 tw         (501) staff       (20)     2881 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/hash_sizes.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.357220 borgbackup-2.0.0b5/scripts/make-testdata/
--rwxr-xr-x   0 tw         (501) staff       (20)     1608 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/make-testdata/test_transfer_upgrade.sh
--rw-r--r--   0 tw         (501) staff       (20)      119 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/msys2-build
--rw-r--r--   0 tw         (501) staff       (20)      453 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/msys2-install-deps
--rwxr-xr-x   0 tw         (501) staff       (20)      315 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/sdist-sign
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.319795 borgbackup-2.0.0b5/scripts/shell_completions/
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.357360 borgbackup-2.0.0b5/scripts/shell_completions/bash/
--rw-r--r--   0 tw         (501) staff       (20)    10481 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/shell_completions/bash/borg
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.357506 borgbackup-2.0.0b5/scripts/shell_completions/fish/
--rw-r--r--   0 tw         (501) staff       (20)    33656 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/shell_completions/fish/borg.fish
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.357694 borgbackup-2.0.0b5/scripts/shell_completions/zsh/
--rw-r--r--   0 tw         (501) staff       (20)    56985 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/shell_completions/zsh/_borg
--rwxr-xr-x   0 tw         (501) staff       (20)      338 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/sign-binaries
--rwxr-xr-x   0 tw         (501) staff       (20)      260 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/scripts/upload-pypi
--rw-r--r--   0 tw         (501) staff       (20)     5271 2023-02-26 23:58:35.401917 borgbackup-2.0.0b5/setup.cfg
--rw-r--r--   0 tw         (501) staff       (20)     9029 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/setup.py
--rw-r--r--   0 tw         (501) staff       (20)    22084 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/setup_docs.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.320480 borgbackup-2.0.0b5/src/
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.373694 borgbackup-2.0.0b5/src/borg/
--rw-r--r--   0 tw         (501) staff       (20)      699 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/__init__.py
--rw-r--r--   0 tw         (501) staff       (20)      705 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/__main__.py
--rw-r--r--   0 tw         (501) staff       (20)    12045 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/_chunker.c
--rw-r--r--   0 tw         (501) staff       (20)     1039 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/_endian.h
--rw-r--r--   0 tw         (501) staff       (20)    29154 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/_hashindex.c
--rw-r--r--   0 tw         (501) staff       (20)     1486 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/_item.c
--rw-r--r--   0 tw         (501) staff       (20)       34 2023-02-26 23:58:35.000000 borgbackup-2.0.0b5/src/borg/_version.py
--rw-r--r--   0 tw         (501) staff       (20)   110599 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archive.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.378289 borgbackup-2.0.0b5/src/borg/archiver/
--rw-r--r--   0 tw         (501) staff       (20)    31396 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/__init__.py
--rw-r--r--   0 tw         (501) staff       (20)    20709 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/_common.py
--rw-r--r--   0 tw         (501) staff       (20)    13717 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/benchmark_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     9300 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/check_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     2481 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/compact_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     8076 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/config_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    44135 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/create_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    24341 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/debug_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     7250 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/delete_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     4762 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/diff_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     7849 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/extract_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    21866 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/help_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     3348 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/info_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    13054 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/key_cmds.py
--rw-r--r--   0 tw         (501) staff       (20)     4373 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/list_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     4669 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/lock_cmds.py
--rw-r--r--   0 tw         (501) staff       (20)     7958 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/mount_cmds.py
--rw-r--r--   0 tw         (501) staff       (20)    13696 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/prune_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    10889 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/rcompress_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    10976 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/rcreate_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     5587 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/rdelete_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    10115 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/recreate_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     1592 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/rename_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     3623 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/rinfo_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     4066 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/rlist_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     3386 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/serve_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    23625 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/tar_cmds.py
--rw-r--r--   0 tw         (501) staff       (20)    10573 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/archiver/transfer_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    54563 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/cache.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.379257 borgbackup-2.0.0b5/src/borg/cache_sync/
--rw-r--r--   0 tw         (501) staff       (20)     3472 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/cache_sync/cache_sync.c
--rw-r--r--   0 tw         (501) staff       (20)     6465 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/cache_sync/sysdep.h
--rw-r--r--   0 tw         (501) staff       (20)    11163 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/cache_sync/unpack.h
--rw-r--r--   0 tw         (501) staff       (20)     2359 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/cache_sync/unpack_define.h
--rw-r--r--   0 tw         (501) staff       (20)    12353 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/cache_sync/unpack_template.h
--rw-r--r--   0 tw         (501) staff       (20)   216626 2023-02-26 23:54:33.000000 borgbackup-2.0.0b5/src/borg/checksums.c
--rw-r--r--   0 tw         (501) staff       (20)      295 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/checksums.pyi
--rw-r--r--   0 tw         (501) staff       (20)     2729 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/checksums.pyx
--rw-r--r--   0 tw         (501) staff       (20)   661006 2023-02-26 23:54:33.000000 borgbackup-2.0.0b5/src/borg/chunker.c
--rw-r--r--   0 tw         (501) staff       (20)     1159 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/chunker.pyi
--rw-r--r--   0 tw         (501) staff       (20)    14029 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/chunker.pyx
--rw-r--r--   0 tw         (501) staff       (20)  1082376 2023-02-26 23:54:33.000000 borgbackup-2.0.0b5/src/borg/compress.c
--rw-r--r--   0 tw         (501) staff       (20)     1969 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/compress.pyi
--rw-r--r--   0 tw         (501) staff       (20)    27126 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/compress.pyx
--rw-r--r--   0 tw         (501) staff       (20)     7026 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/constants.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.381687 borgbackup-2.0.0b5/src/borg/crypto/
--rw-r--r--   0 tw         (501) staff       (20)        0 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/crypto/__init__.py
--rw-r--r--   0 tw         (501) staff       (20)     8430 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/crypto/file_integrity.py
--rw-r--r--   0 tw         (501) staff       (20)    39320 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/crypto/key.py
--rw-r--r--   0 tw         (501) staff       (20)     8321 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/crypto/keymanager.py
--rw-r--r--   0 tw         (501) staff       (20)   908661 2023-02-26 23:54:33.000000 borgbackup-2.0.0b5/src/borg/crypto/low_level.c
--rw-r--r--   0 tw         (501) staff       (20)    30190 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/crypto/low_level.pyx
--rw-r--r--   0 tw         (501) staff       (20)     4420 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/crypto/nonces.py
--rw-r--r--   0 tw         (501) staff       (20)    31396 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/fuse.py
--rw-r--r--   0 tw         (501) staff       (20)      866 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/fuse_impl.py
--rw-r--r--   0 tw         (501) staff       (20)   678311 2023-02-26 23:54:34.000000 borgbackup-2.0.0b5/src/borg/hashindex.c
--rw-r--r--   0 tw         (501) staff       (20)     3104 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/hashindex.pyi
--rw-r--r--   0 tw         (501) staff       (20)    22418 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/hashindex.pyx
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.384140 borgbackup-2.0.0b5/src/borg/helpers/
--rw-r--r--   0 tw         (501) staff       (20)     3789 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/__init__.py
--rw-r--r--   0 tw         (501) staff       (20)     1212 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/checks.py
--rw-r--r--   0 tw         (501) staff       (20)     4268 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/datastruct.py
--rw-r--r--   0 tw         (501) staff       (20)      962 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/errors.py
--rw-r--r--   0 tw         (501) staff       (20)    20011 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/fs.py
--rw-r--r--   0 tw         (501) staff       (20)     1743 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/lrucache.py
--rw-r--r--   0 tw         (501) staff       (20)     6104 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/misc.py
--rw-r--r--   0 tw         (501) staff       (20)     7573 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/msgpack.py
--rw-r--r--   0 tw         (501) staff       (20)     7010 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/nanorst.py
--rw-r--r--   0 tw         (501) staff       (20)    40336 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/parseformat.py
--rw-r--r--   0 tw         (501) staff       (20)     5042 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/passphrase.py
--rw-r--r--   0 tw         (501) staff       (20)    14370 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/process.py
--rw-r--r--   0 tw         (501) staff       (20)     6828 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/progress.py
--rw-r--r--   0 tw         (501) staff       (20)     2325 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/shellpattern.py
--rw-r--r--   0 tw         (501) staff       (20)     6157 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/time.py
--rw-r--r--   0 tw         (501) staff       (20)     4671 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/helpers/yes_no.py
--rw-r--r--   0 tw         (501) staff       (20)  1254057 2023-02-26 23:54:34.000000 borgbackup-2.0.0b5/src/borg/item.c
--rw-r--r--   0 tw         (501) staff       (20)     9113 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/item.pyi
--rw-r--r--   0 tw         (501) staff       (20)    30026 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/item.pyx
--rw-r--r--   0 tw         (501) staff       (20)    16494 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/locking.py
--rw-r--r--   0 tw         (501) staff       (20)     8908 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/logger.py
--rw-r--r--   0 tw         (501) staff       (20)    13488 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/manifest.py
--rw-r--r--   0 tw         (501) staff       (20)    66029 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/paperkey.html
--rw-r--r--   0 tw         (501) staff       (20)    14408 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/patterns.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.391105 borgbackup-2.0.0b5/src/borg/platform/
--rw-r--r--   0 tw         (501) staff       (20)     2593 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platform/__init__.py
--rw-r--r--   0 tw         (501) staff       (20)    10626 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platform/base.py
--rw-r--r--   0 tw         (501) staff       (20)   378851 2023-02-26 23:54:32.000000 borgbackup-2.0.0b5/src/borg/platform/darwin.c
--rw-r--r--   0 tw         (501) staff       (20)     5483 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platform/darwin.pyx
--rw-r--r--   0 tw         (501) staff       (20)   371451 2023-02-26 23:54:32.000000 borgbackup-2.0.0b5/src/borg/platform/freebsd.c
--rw-r--r--   0 tw         (501) staff       (20)     6991 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platform/freebsd.pyx
--rw-r--r--   0 tw         (501) staff       (20)   640864 2023-02-26 23:54:33.000000 borgbackup-2.0.0b5/src/borg/platform/linux.c
--rw-r--r--   0 tw         (501) staff       (20)    12980 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platform/linux.pyx
--rw-r--r--   0 tw         (501) staff       (20)   268458 2023-02-26 23:54:33.000000 borgbackup-2.0.0b5/src/borg/platform/posix.c
--rw-r--r--   0 tw         (501) staff       (20)     3667 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platform/posix.pyx
--rw-r--r--   0 tw         (501) staff       (20)   107136 2023-02-26 23:54:33.000000 borgbackup-2.0.0b5/src/borg/platform/syncfilerange.c
--rw-r--r--   0 tw         (501) staff       (20)      587 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platform/syncfilerange.pyx
--rw-r--r--   0 tw         (501) staff       (20)   207825 2023-02-26 23:54:33.000000 borgbackup-2.0.0b5/src/borg/platform/windows.c
--rw-r--r--   0 tw         (501) staff       (20)     1519 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platform/windows.pyx
--rw-r--r--   0 tw         (501) staff       (20)     2894 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platform/xattr.py
--rw-r--r--   0 tw         (501) staff       (20)      359 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/platformflags.py
--rw-r--r--   0 tw         (501) staff       (20)    58282 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/remote.py
--rw-r--r--   0 tw         (501) staff       (20)     6311 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/repoobj.py
--rw-r--r--   0 tw         (501) staff       (20)    89875 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/repository.py
--rw-r--r--   0 tw         (501) staff       (20)     3671 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/selftest.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.395954 borgbackup-2.0.0b5/src/borg/testsuite/
--rw-r--r--   0 tw         (501) staff       (20)    14343 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/__init__.py
--rw-r--r--   0 tw         (501) staff       (20)    13302 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archive.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.400469 borgbackup-2.0.0b5/src/borg/testsuite/archiver/
--rw-r--r--   0 tw         (501) staff       (20)    17141 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/__init__.py
--rw-r--r--   0 tw         (501) staff       (20)     7188 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/argparsing.py
--rw-r--r--   0 tw         (501) staff       (20)      436 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/benchmark_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     7126 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/bypass_lock_option.py
--rw-r--r--   0 tw         (501) staff       (20)    14509 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/check_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    21501 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/checks.py
--rw-r--r--   0 tw         (501) staff       (20)     2603 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/config_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     4677 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/corruption.py
--rw-r--r--   0 tw         (501) staff       (20)    42296 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/create_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     5936 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/debug_cmds.py
--rw-r--r--   0 tw         (501) staff       (20)     4893 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/delete_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    13474 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/diff_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     3475 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/disk_full.py
--rw-r--r--   0 tw         (501) staff       (20)    32585 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/extract_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     1966 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/help_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     2443 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/info_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    13434 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/key_cmds.py
--rw-r--r--   0 tw         (501) staff       (20)     4145 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/list_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     1137 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/lock_cmds.py
--rw-r--r--   0 tw         (501) staff       (20)    18759 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/mount_cmds.py
--rw-r--r--   0 tw         (501) staff       (20)     1077 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/patterns.py
--rw-r--r--   0 tw         (501) staff       (20)    11939 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/prune_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     4344 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/rcompress_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     3390 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/rcreate_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     1392 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/rdelete_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)    15761 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/recreate_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     1980 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/rename_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     7499 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/repo12.tar.gz
--rw-r--r--   0 tw         (501) staff       (20)      844 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/return_codes.py
--rw-r--r--   0 tw         (501) staff       (20)     2799 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/rinfo_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     5298 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/rlist_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     7406 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/tar_cmds.py
--rw-r--r--   0 tw         (501) staff       (20)    15794 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/archiver/transfer_cmd.py
--rw-r--r--   0 tw         (501) staff       (20)     3702 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/benchmark.py
--rw-r--r--   0 tw         (501) staff       (20)     8590 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/cache.py
--rw-r--r--   0 tw         (501) staff       (20)      897 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/checksums.py
--rw-r--r--   0 tw         (501) staff       (20)     6466 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/chunker.py
--rw-r--r--   0 tw         (501) staff       (20)     5239 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/chunker_pytest.py
--rw-r--r--   0 tw         (501) staff       (20)     1552 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/chunker_slow.py
--rw-r--r--   0 tw         (501) staff       (20)     9971 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/compress.py
--rw-r--r--   0 tw         (501) staff       (20)    15593 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/crypto.py
--rw-r--r--   0 tw         (501) staff       (20)     1606 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/efficient_collection_queue.py
--rw-r--r--   0 tw         (501) staff       (20)     6239 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/file_integrity.py
--rw-r--r--   0 tw         (501) staff       (20)    23138 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/hashindex.py
--rw-r--r--   0 tw         (501) staff       (20)     2510 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/hashindex_pytest.py
--rw-r--r--   0 tw         (501) staff       (20)    50653 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/helpers.py
--rw-r--r--   0 tw         (501) staff       (20)     5041 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/item.py
--rw-r--r--   0 tw         (501) staff       (20)    16317 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/key.py
--rw-r--r--   0 tw         (501) staff       (20)    14267 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/locking.py
--rw-r--r--   0 tw         (501) staff       (20)     1576 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/logger.py
--rw-r--r--   0 tw         (501) staff       (20)     1437 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/lrucache.py
--rw-r--r--   0 tw         (501) staff       (20)     1002 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/nanorst.py
--rw-r--r--   0 tw         (501) staff       (20)     7191 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/nonces.py
--rw-r--r--   0 tw         (501) staff       (20)    20361 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/patterns.py
--rw-r--r--   0 tw         (501) staff       (20)     9007 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/platform.py
--rw-r--r--   0 tw         (501) staff       (20)     8277 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/remote.py
--rw-r--r--   0 tw         (501) staff       (20)     3698 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/repoobj.py
--rw-r--r--   0 tw         (501) staff       (20)    52619 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/repository.py
--rw-r--r--   0 tw         (501) staff       (20)     3485 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/shellpattern.py
--rw-r--r--   0 tw         (501) staff       (20)     1937 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/version.py
--rw-r--r--   0 tw         (501) staff       (20)     3319 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/testsuite/xattr.py
--rw-r--r--   0 tw         (501) staff       (20)     6789 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/upgrade.py
--rw-r--r--   0 tw         (501) staff       (20)     1819 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/version.py
--rw-r--r--   0 tw         (501) staff       (20)     5652 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/src/borg/xattr.py
-drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-02-26 23:58:35.401245 borgbackup-2.0.0b5/src/borgbackup.egg-info/
--rw-r--r--   0 tw         (501) staff       (20)     7652 2023-02-26 23:58:35.000000 borgbackup-2.0.0b5/src/borgbackup.egg-info/PKG-INFO
--rw-r--r--   0 tw         (501) staff       (20)    11274 2023-02-26 23:58:35.000000 borgbackup-2.0.0b5/src/borgbackup.egg-info/SOURCES.txt
--rw-r--r--   0 tw         (501) staff       (20)        1 2023-02-26 23:58:35.000000 borgbackup-2.0.0b5/src/borgbackup.egg-info/dependency_links.txt
--rw-r--r--   0 tw         (501) staff       (20)       72 2023-02-26 23:58:35.000000 borgbackup-2.0.0b5/src/borgbackup.egg-info/entry_points.txt
--rw-r--r--   0 tw         (501) staff       (20)        1 2023-02-26 23:58:35.000000 borgbackup-2.0.0b5/src/borgbackup.egg-info/not-zip-safe
--rw-r--r--   0 tw         (501) staff       (20)      132 2023-02-26 23:58:35.000000 borgbackup-2.0.0b5/src/borgbackup.egg-info/requires.txt
--rw-r--r--   0 tw         (501) staff       (20)        5 2023-02-26 23:58:35.000000 borgbackup-2.0.0b5/src/borgbackup.egg-info/top_level.txt
--rw-r--r--   0 tw         (501) staff       (20)      864 2023-02-26 23:53:12.000000 borgbackup-2.0.0b5/tox.ini
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.912566 borgbackup-2.0.0b6/
+-rw-r--r--   0 tw         (501) staff       (20)      481 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/.coveragerc
+-rw-r--r--   0 tw         (501) staff       (20)       71 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/.git-blame-ignore-revs
+-rw-r--r--   0 tw         (501) staff       (20)      221 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/.pre-commit-config.yaml
+-rw-r--r--   0 tw         (501) staff       (20)      663 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/.readthedocs.yaml
+-rw-r--r--   0 tw         (501) staff       (20)     1179 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/AUTHORS
+-rw-r--r--   0 tw         (501) staff       (20)    24039 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/CHANGES.rst
+-rw-r--r--   0 tw         (501) staff       (20)     1551 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/LICENSE
+-rw-r--r--   0 tw         (501) staff       (20)      487 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/MANIFEST.in
+-rw-r--r--   0 tw         (501) staff       (20)     7652 2023-06-12 08:18:26.912669 borgbackup-2.0.0b6/PKG-INFO
+-rw-r--r--   0 tw         (501) staff       (20)     7999 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/README.rst
+-rw-r--r--   0 tw         (501) staff       (20)      425 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/SECURITY.md
+-rw-r--r--   0 tw         (501) staff       (20)     2539 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/conftest.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.840243 borgbackup-2.0.0b6/docs/
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.840471 borgbackup-2.0.0b6/docs/3rd_party/
+-rw-r--r--   0 tw         (501) staff       (20)      215 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/3rd_party/README
+-rw-r--r--   0 tw         (501) staff       (20)     4582 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/Makefile
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.841637 borgbackup-2.0.0b6/docs/_static/
+-rw-r--r--   0 tw         (501) staff       (20)      198 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/_static/Makefile
+-rw-r--r--   0 tw         (501) staff       (20)    38926 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/_static/favicon.ico
+-rw-r--r--   0 tw         (501) staff       (20)     1316 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/_static/logo.pdf
+-rw-r--r--   0 tw         (501) staff       (20)     1789 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/_static/logo.png
+-rw-r--r--   0 tw         (501) staff       (20)     1790 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/_static/logo.svg
+-rw-r--r--   0 tw         (501) staff       (20)      111 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/_static/logo_font.txt
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.841887 borgbackup-2.0.0b6/docs/_templates/
+-rw-r--r--   0 tw         (501) staff       (20)      633 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/_templates/globaltoc.html
+-rw-r--r--   0 tw         (501) staff       (20)      160 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/_templates/logo-text.html
+-rw-r--r--   0 tw         (501) staff       (20)      139 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/authors.rst
+-rw-r--r--   0 tw         (501) staff       (20)      401 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/book.rst
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.832372 borgbackup-2.0.0b6/docs/borg_theme/
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.842011 borgbackup-2.0.0b6/docs/borg_theme/css/
+-rw-r--r--   0 tw         (501) staff       (20)     4001 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/borg_theme/css/borg.css
+-rw-r--r--   0 tw         (501) staff       (20)    24039 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/changes.rst
+-rw-r--r--   0 tw         (501) staff       (20)    33202 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/changes_0.x.rst
+-rw-r--r--   0 tw         (501) staff       (20)   178112 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/changes_1.x.rst
+-rw-r--r--   0 tw         (501) staff       (20)     8360 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/conf.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.842646 borgbackup-2.0.0b6/docs/deployment/
+-rw-r--r--   0 tw         (501) staff       (20)     8569 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/deployment/automated-local.rst
+-rw-r--r--   0 tw         (501) staff       (20)     7743 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/deployment/central-backup-server.rst
+-rw-r--r--   0 tw         (501) staff       (20)     3456 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/deployment/hosting-repositories.rst
+-rw-r--r--   0 tw         (501) staff       (20)     5943 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/deployment/image-backup.rst
+-rw-r--r--   0 tw         (501) staff       (20)    20888 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/deployment/pull-backup.rst
+-rw-r--r--   0 tw         (501) staff       (20)      329 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/deployment.rst
+-rw-r--r--   0 tw         (501) staff       (20)    13287 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/development.rst
+-rw-r--r--   0 tw         (501) staff       (20)    54267 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/faq.rst
+-rw-r--r--   0 tw         (501) staff       (20)     1680 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/global.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      367 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/index.rst
+-rw-r--r--   0 tw         (501) staff       (20)    17531 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/installation.rst
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.846005 borgbackup-2.0.0b6/docs/internals/
+-rw-r--r--   0 tw         (501) staff       (20)    28928 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/compaction.odg
+-rw-r--r--   0 tw         (501) staff       (20)   331649 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/compaction.png
+-rw-r--r--   0 tw         (501) staff       (20)    53263 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/data-structures.rst
+-rw-r--r--   0 tw         (501) staff       (20)    27294 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/encryption-aead.odg
+-rw-r--r--   0 tw         (501) staff       (20)   149428 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/encryption-aead.png
+-rw-r--r--   0 tw         (501) staff       (20)    27978 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/frontends.rst
+-rw-r--r--   0 tw         (501) staff       (20)    29733 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/object-graph.odg
+-rw-r--r--   0 tw         (501) staff       (20)   389349 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/object-graph.png
+-rw-r--r--   0 tw         (501) staff       (20)    18787 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/security.rst
+-rw-r--r--   0 tw         (501) staff       (20)    15645 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/structure.odg
+-rw-r--r--   0 tw         (501) staff       (20)   154741 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals/structure.png
+-rw-r--r--   0 tw         (501) staff       (20)     1668 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/internals.rst
+-rw-r--r--   0 tw         (501) staff       (20)      232 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/introduction.rst
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.853012 borgbackup-2.0.0b6/docs/man/
+-rw-r--r--   0 tw         (501) staff       (20)     1459 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-benchmark-cpu.1
+-rw-r--r--   0 tw         (501) staff       (20)     3456 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-benchmark-crud.1
+-rw-r--r--   0 tw         (501) staff       (20)     1123 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-benchmark.1
+-rw-r--r--   0 tw         (501) staff       (20)     1278 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-break-lock.1
+-rw-r--r--   0 tw         (501) staff       (20)     1563 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-change-passphrase.1
+-rw-r--r--   0 tw         (501) staff       (20)     6979 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-check.1
+-rw-r--r--   0 tw         (501) staff       (20)     2738 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-common.1
+-rw-r--r--   0 tw         (501) staff       (20)     2183 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-compact.1
+-rw-r--r--   0 tw         (501) staff       (20)     4800 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-compression.1
+-rw-r--r--   0 tw         (501) staff       (20)     2673 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-config.1
+-rw-r--r--   0 tw         (501) staff       (20)    18747 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-create.1
+-rw-r--r--   0 tw         (501) staff       (20)     3933 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-delete.1
+-rw-r--r--   0 tw         (501) staff       (20)     4911 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-diff.1
+-rw-r--r--   0 tw         (501) staff       (20)     3716 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-export-tar.1
+-rw-r--r--   0 tw         (501) staff       (20)     4185 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-extract.1
+-rw-r--r--   0 tw         (501) staff       (20)     5894 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-import-tar.1
+-rw-r--r--   0 tw         (501) staff       (20)     3250 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-info.1
+-rw-r--r--   0 tw         (501) staff       (20)     2779 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-key-change-algorithm.1
+-rw-r--r--   0 tw         (501) staff       (20)     1679 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-key-change-location.1
+-rw-r--r--   0 tw         (501) staff       (20)     2925 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-key-change-passphrase.1
+-rw-r--r--   0 tw         (501) staff       (20)     3119 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-key-export.1
+-rw-r--r--   0 tw         (501) staff       (20)     2186 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-key-import.1
+-rw-r--r--   0 tw         (501) staff       (20)     1955 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-key-migrate-to-repokey.1
+-rw-r--r--   0 tw         (501) staff       (20)     1239 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-key.1
+-rw-r--r--   0 tw         (501) staff       (20)     6651 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-list.1
+-rw-r--r--   0 tw         (501) staff       (20)     1966 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-match-archives.1
+-rw-r--r--   0 tw         (501) staff       (20)     6016 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-mount.1
+-rw-r--r--   0 tw         (501) staff       (20)    12712 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-patterns.1
+-rw-r--r--   0 tw         (501) staff       (20)     3009 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-placeholders.1
+-rw-r--r--   0 tw         (501) staff       (20)     8239 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-prune.1
+-rw-r--r--   0 tw         (501) staff       (20)     3049 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-rcompress.1
+-rw-r--r--   0 tw         (501) staff       (20)     8043 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-rcreate.1
+-rw-r--r--   0 tw         (501) staff       (20)     2386 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-rdelete.1
+-rw-r--r--   0 tw         (501) staff       (20)     8530 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-recreate.1
+-rw-r--r--   0 tw         (501) staff       (20)     1583 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-rename.1
+-rw-r--r--   0 tw         (501) staff       (20)     2143 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-rinfo.1
+-rw-r--r--   0 tw         (501) staff       (20)     4766 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-rlist.1
+-rw-r--r--   0 tw         (501) staff       (20)     7489 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-serve.1
+-rw-r--r--   0 tw         (501) staff       (20)     6719 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-transfer.1
+-rw-r--r--   0 tw         (501) staff       (20)     3121 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-umount.1
+-rw-r--r--   0 tw         (501) staff       (20)     3787 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-upgrade.1
+-rw-r--r--   0 tw         (501) staff       (20)     1922 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg-with-lock.1
+-rw-r--r--   0 tw         (501) staff       (20)    31741 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borg.1
+-rw-r--r--   0 tw         (501) staff       (20)     3116 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man/borgfs.1
+-rw-r--r--   0 tw         (501) staff       (20)     1735 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/man_intro.rst
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.854471 borgbackup-2.0.0b6/docs/misc/
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.856062 borgbackup-2.0.0b6/docs/misc/asciinema/
+-rw-r--r--   0 tw         (501) staff       (20)      181 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/asciinema/README
+-rw-r--r--   0 tw         (501) staff       (20)     3215 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/asciinema/Vagrantfile
+-rw-r--r--   0 tw         (501) staff       (20)   179888 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/asciinema/advanced.json
+-rw-r--r--   0 tw         (501) staff       (20)     3191 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/asciinema/advanced.tcl
+-rw-r--r--   0 tw         (501) staff       (20)    73853 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/asciinema/basic.json
+-rw-r--r--   0 tw         (501) staff       (20)     3210 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/asciinema/basic.tcl
+-rw-r--r--   0 tw         (501) staff       (20)    24238 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/asciinema/install.json
+-rw-r--r--   0 tw         (501) staff       (20)     1307 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/asciinema/install.tcl
+-rw-r--r--   0 tw         (501) staff       (20)     3007 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/asciinema/sample-wallpapers.txt
+-rw-r--r--   0 tw         (501) staff       (20)     3580 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/benchmark-crud.txt
+-rw-r--r--   0 tw         (501) staff       (20)    20165 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/borg-data-flow.odg
+-rw-r--r--   0 tw         (501) staff       (20)   196191 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/borg-data-flow.png
+-rw-r--r--   0 tw         (501) staff       (20)     4399 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/create_chunker-params.txt
+-rw-r--r--   0 tw         (501) staff       (20)     1825 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/internals-picture.txt
+-rw-r--r--   0 tw         (501) staff       (20)      305 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/logging.conf
+-rw-r--r--   0 tw         (501) staff       (20)     4235 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/misc/prune-example.txt
+-rw-r--r--   0 tw         (501) staff       (20)    21253 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/quickstart.rst
+-rw-r--r--   0 tw         (501) staff       (20)     2654 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/quickstart_example.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     2055 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/support.rst
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.865426 borgbackup-2.0.0b6/docs/usage/
+-rw-r--r--   0 tw         (501) staff       (20)       72 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/benchmark.rst
+-rw-r--r--   0 tw         (501) staff       (20)     1183 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/benchmark_cpu.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     3812 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/benchmark_crud.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)       38 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/borgfs.rst
+-rw-r--r--   0 tw         (501) staff       (20)    16125 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/borgfs.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1004 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/break-lock.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1740 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/change-passphrase.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)       27 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/check.rst
+-rw-r--r--   0 tw         (501) staff       (20)    14395 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/check.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1710 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/common-options.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      120 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/compact.rst
+-rw-r--r--   0 tw         (501) staff       (20)     2815 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/compact.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      446 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/config.rst
+-rw-r--r--   0 tw         (501) staff       (20)     3877 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/config.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     3549 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/create.rst
+-rw-r--r--   0 tw         (501) staff       (20)    43792 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/create.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1730 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/debug.rst
+-rw-r--r--   0 tw         (501) staff       (20)      505 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/delete.rst
+-rw-r--r--   0 tw         (501) staff       (20)    11543 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/delete.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      639 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/diff.rst
+-rw-r--r--   0 tw         (501) staff       (20)    10051 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/diff.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)    10329 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/export-tar.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      681 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/extract.rst
+-rw-r--r--   0 tw         (501) staff       (20)    11867 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/extract.rst.inc
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.866860 borgbackup-2.0.0b6/docs/usage/general/
+-rw-r--r--   0 tw         (501) staff       (20)      297 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/date-time.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)    11915 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/environment.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     3078 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/file-metadata.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1478 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/file-systems.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1666 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/logging.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      621 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/positional-arguments.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      614 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/repository-locations.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1007 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/repository-urls.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     4621 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/resources.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      634 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/return-codes.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      499 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general/units.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     2249 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/general.rst
+-rw-r--r--   0 tw         (501) staff       (20)       65 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/help.rst
+-rw-r--r--   0 tw         (501) staff       (20)    18248 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/help.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)    15346 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/import-tar.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      636 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/info.rst
+-rw-r--r--   0 tw         (501) staff       (20)     8303 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/info.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1513 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/key.rst
+-rw-r--r--   0 tw         (501) staff       (20)     2945 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/key_change-location.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1299 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/key_change-passphrase.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     4672 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/key_export.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     3265 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/key_import.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1677 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/list.rst
+-rw-r--r--   0 tw         (501) staff       (20)    12026 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/list.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)       64 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/lock.rst
+-rw-r--r--   0 tw         (501) staff       (20)     1663 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/mount.rst
+-rw-r--r--   0 tw         (501) staff       (20)    17486 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/mount.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)    14258 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/notes.rst
+-rw-r--r--   0 tw         (501) staff       (20)     1587 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/prune.rst
+-rw-r--r--   0 tw         (501) staff       (20)    18446 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/prune.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      250 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rcompress.rst
+-rw-r--r--   0 tw         (501) staff       (20)     4892 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rcompress.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      914 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rcreate.rst
+-rw-r--r--   0 tw         (501) staff       (20)    13440 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rcreate.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      489 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rdelete.rst
+-rw-r--r--   0 tw         (501) staff       (20)     4497 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rdelete.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      994 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/recreate.rst
+-rw-r--r--   0 tw         (501) staff       (20)    46482 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/recreate.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      289 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rename.rst
+-rw-r--r--   0 tw         (501) staff       (20)     1887 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rename.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      553 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rinfo.rst
+-rw-r--r--   0 tw         (501) staff       (20)     1918 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rinfo.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      340 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rlist.rst
+-rw-r--r--   0 tw         (501) staff       (20)    13882 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/rlist.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     4289 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/serve.rst
+-rw-r--r--   0 tw         (501) staff       (20)    10588 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/serve.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1647 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/tar.rst
+-rw-r--r--   0 tw         (501) staff       (20)     1621 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/transfer.rst
+-rw-r--r--   0 tw         (501) staff       (20)    20173 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/transfer.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1873 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/umount.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      523 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/usage_general.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     2327 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage/with-lock.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)     1637 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage.rst
+-rw-r--r--   0 tw         (501) staff       (20)      539 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/docs/usage_general.rst.inc
+-rw-r--r--   0 tw         (501) staff       (20)      544 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/pyproject.toml
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.867510 borgbackup-2.0.0b6/requirements.d/
+-rw-r--r--   0 tw         (501) staff       (20)      118 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/requirements.d/coala.txt
+-rw-r--r--   0 tw         (501) staff       (20)       18 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/requirements.d/codestyle.txt
+-rw-r--r--   0 tw         (501) staff       (20)      238 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/requirements.d/development.lock.txt
+-rw-r--r--   0 tw         (501) staff       (20)      158 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/requirements.d/development.txt
+-rw-r--r--   0 tw         (501) staff       (20)       27 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/requirements.d/docs.txt
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.868558 borgbackup-2.0.0b6/scripts/
+-rw-r--r--   0 tw         (501) staff       (20)     2254 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/borg.exe.spec
+-rwxr-xr-x   0 tw         (501) staff       (20)      480 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/errorlist.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.868819 borgbackup-2.0.0b6/scripts/fuzz-cache-sync/
+-rw-r--r--   0 tw         (501) staff       (20)      361 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/fuzz-cache-sync/HOWTO
+-rw-r--r--   0 tw         (501) staff       (20)      705 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/fuzz-cache-sync/main.c
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.868956 borgbackup-2.0.0b6/scripts/fuzz-cache-sync/testcase_dir/
+-rw-r--r--   0 tw         (501) staff       (20)      147 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/fuzz-cache-sync/testcase_dir/test_simple
+-rwxr-xr-x   0 tw         (501) staff       (20)     1611 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/glibc_check.py
+-rw-r--r--   0 tw         (501) staff       (20)     2881 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/hash_sizes.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.869096 borgbackup-2.0.0b6/scripts/make-testdata/
+-rwxr-xr-x   0 tw         (501) staff       (20)     1608 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/make-testdata/test_transfer_upgrade.sh
+-rw-r--r--   0 tw         (501) staff       (20)      453 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/msys2-install-deps
+-rwxr-xr-x   0 tw         (501) staff       (20)      315 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/sdist-sign
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.833240 borgbackup-2.0.0b6/scripts/shell_completions/
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.869246 borgbackup-2.0.0b6/scripts/shell_completions/bash/
+-rw-r--r--   0 tw         (501) staff       (20)    10481 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/shell_completions/bash/borg
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.869398 borgbackup-2.0.0b6/scripts/shell_completions/fish/
+-rw-r--r--   0 tw         (501) staff       (20)    33656 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/shell_completions/fish/borg.fish
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.869597 borgbackup-2.0.0b6/scripts/shell_completions/zsh/
+-rw-r--r--   0 tw         (501) staff       (20)    56985 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/shell_completions/zsh/_borg
+-rwxr-xr-x   0 tw         (501) staff       (20)      338 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/sign-binaries
+-rwxr-xr-x   0 tw         (501) staff       (20)      260 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/scripts/upload-pypi
+-rw-r--r--   0 tw         (501) staff       (20)     5387 2023-06-12 08:18:26.913140 borgbackup-2.0.0b6/setup.cfg
+-rw-r--r--   0 tw         (501) staff       (20)     9029 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/setup.py
+-rw-r--r--   0 tw         (501) staff       (20)    22194 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/setup_docs.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.833845 borgbackup-2.0.0b6/src/
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.884699 borgbackup-2.0.0b6/src/borg/
+-rw-r--r--   0 tw         (501) staff       (20)      699 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/__init__.py
+-rw-r--r--   0 tw         (501) staff       (20)      705 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/__main__.py
+-rw-r--r--   0 tw         (501) staff       (20)    12045 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/_chunker.c
+-rw-r--r--   0 tw         (501) staff       (20)     1039 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/_endian.h
+-rw-r--r--   0 tw         (501) staff       (20)    29154 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/_hashindex.c
+-rw-r--r--   0 tw         (501) staff       (20)     1486 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/_item.c
+-rw-r--r--   0 tw         (501) staff       (20)       34 2023-06-12 08:18:26.000000 borgbackup-2.0.0b6/src/borg/_version.py
+-rw-r--r--   0 tw         (501) staff       (20)   112010 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archive.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.889196 borgbackup-2.0.0b6/src/borg/archiver/
+-rw-r--r--   0 tw         (501) staff       (20)    32233 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/__init__.py
+-rw-r--r--   0 tw         (501) staff       (20)    21170 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/_common.py
+-rw-r--r--   0 tw         (501) staff       (20)    13641 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/benchmark_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     9343 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/check_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     2524 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/compact_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     8076 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/config_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    44920 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/create_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    30636 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/debug_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     7086 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/delete_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     6373 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/diff_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     7935 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/extract_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    22803 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/help_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     3348 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/info_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    13054 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/key_cmds.py
+-rw-r--r--   0 tw         (501) staff       (20)     4461 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/list_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     4669 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/lock_cmds.py
+-rw-r--r--   0 tw         (501) staff       (20)     8119 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/mount_cmds.py
+-rw-r--r--   0 tw         (501) staff       (20)    15743 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/prune_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    10963 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/rcompress_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    11081 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/rcreate_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     5587 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/rdelete_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    10332 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/recreate_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     1592 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/rename_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     3623 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/rinfo_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     4162 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/rlist_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     3979 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/serve_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    24356 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/tar_cmds.py
+-rw-r--r--   0 tw         (501) staff       (20)    13605 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/archiver/transfer_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    54631 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/cache.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.890018 borgbackup-2.0.0b6/src/borg/cache_sync/
+-rw-r--r--   0 tw         (501) staff       (20)     3472 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/cache_sync/cache_sync.c
+-rw-r--r--   0 tw         (501) staff       (20)     6465 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/cache_sync/sysdep.h
+-rw-r--r--   0 tw         (501) staff       (20)    11163 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/cache_sync/unpack.h
+-rw-r--r--   0 tw         (501) staff       (20)     2359 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/cache_sync/unpack_define.h
+-rw-r--r--   0 tw         (501) staff       (20)    12353 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/cache_sync/unpack_template.h
+-rw-r--r--   0 tw         (501) staff       (20)   218064 2023-06-12 08:16:48.000000 borgbackup-2.0.0b6/src/borg/checksums.c
+-rw-r--r--   0 tw         (501) staff       (20)      295 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/checksums.pyi
+-rw-r--r--   0 tw         (501) staff       (20)     2729 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/checksums.pyx
+-rw-r--r--   0 tw         (501) staff       (20)   661676 2023-06-12 08:16:48.000000 borgbackup-2.0.0b6/src/borg/chunker.c
+-rw-r--r--   0 tw         (501) staff       (20)     1159 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/chunker.pyi
+-rw-r--r--   0 tw         (501) staff       (20)    14029 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/chunker.pyx
+-rw-r--r--   0 tw         (501) staff       (20)  1096165 2023-06-12 08:16:48.000000 borgbackup-2.0.0b6/src/borg/compress.c
+-rw-r--r--   0 tw         (501) staff       (20)     1969 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/compress.pyi
+-rw-r--r--   0 tw         (501) staff       (20)    27477 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/compress.pyx
+-rw-r--r--   0 tw         (501) staff       (20)     7186 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/constants.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.893045 borgbackup-2.0.0b6/src/borg/crypto/
+-rw-r--r--   0 tw         (501) staff       (20)        0 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/crypto/__init__.py
+-rw-r--r--   0 tw         (501) staff       (20)     8430 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/crypto/file_integrity.py
+-rw-r--r--   0 tw         (501) staff       (20)    39230 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/crypto/key.py
+-rw-r--r--   0 tw         (501) staff       (20)     8321 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/crypto/keymanager.py
+-rw-r--r--   0 tw         (501) staff       (20)   910372 2023-06-12 08:16:49.000000 borgbackup-2.0.0b6/src/borg/crypto/low_level.c
+-rw-r--r--   0 tw         (501) staff       (20)    29891 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/crypto/low_level.pyx
+-rw-r--r--   0 tw         (501) staff       (20)    31544 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/fuse.py
+-rw-r--r--   0 tw         (501) staff       (20)      866 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/fuse_impl.py
+-rw-r--r--   0 tw         (501) staff       (20)   679997 2023-06-12 08:16:49.000000 borgbackup-2.0.0b6/src/borg/hashindex.c
+-rw-r--r--   0 tw         (501) staff       (20)     3104 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/hashindex.pyi
+-rw-r--r--   0 tw         (501) staff       (20)    22418 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/hashindex.pyx
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.895187 borgbackup-2.0.0b6/src/borg/helpers/
+-rw-r--r--   0 tw         (501) staff       (20)     3911 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/__init__.py
+-rw-r--r--   0 tw         (501) staff       (20)     1212 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/checks.py
+-rw-r--r--   0 tw         (501) staff       (20)     4268 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/datastruct.py
+-rw-r--r--   0 tw         (501) staff       (20)      962 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/errors.py
+-rw-r--r--   0 tw         (501) staff       (20)    22926 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/fs.py
+-rw-r--r--   0 tw         (501) staff       (20)     2300 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/lrucache.py
+-rw-r--r--   0 tw         (501) staff       (20)     6104 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/misc.py
+-rw-r--r--   0 tw         (501) staff       (20)     7564 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/msgpack.py
+-rw-r--r--   0 tw         (501) staff       (20)     7010 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/nanorst.py
+-rw-r--r--   0 tw         (501) staff       (20)    47463 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/parseformat.py
+-rw-r--r--   0 tw         (501) staff       (20)     5028 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/passphrase.py
+-rw-r--r--   0 tw         (501) staff       (20)    14370 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/process.py
+-rw-r--r--   0 tw         (501) staff       (20)     2887 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/progress.py
+-rw-r--r--   0 tw         (501) staff       (20)     5542 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/shellpattern.py
+-rw-r--r--   0 tw         (501) staff       (20)     6157 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/time.py
+-rw-r--r--   0 tw         (501) staff       (20)     4671 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/helpers/yes_no.py
+-rw-r--r--   0 tw         (501) staff       (20)  1321877 2023-06-12 08:16:49.000000 borgbackup-2.0.0b6/src/borg/item.c
+-rw-r--r--   0 tw         (501) staff       (20)    10038 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/item.pyi
+-rw-r--r--   0 tw         (501) staff       (20)    31672 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/item.pyx
+-rw-r--r--   0 tw         (501) staff       (20)    16494 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/locking.py
+-rw-r--r--   0 tw         (501) staff       (20)    13598 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/logger.py
+-rw-r--r--   0 tw         (501) staff       (20)    13556 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/manifest.py
+-rw-r--r--   0 tw         (501) staff       (20)    66029 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/paperkey.html
+-rw-r--r--   0 tw         (501) staff       (20)    14408 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/patterns.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.902500 borgbackup-2.0.0b6/src/borg/platform/
+-rw-r--r--   0 tw         (501) staff       (20)     2593 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platform/__init__.py
+-rw-r--r--   0 tw         (501) staff       (20)    10626 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platform/base.py
+-rw-r--r--   0 tw         (501) staff       (20)   379319 2023-06-12 08:16:48.000000 borgbackup-2.0.0b6/src/borg/platform/darwin.c
+-rw-r--r--   0 tw         (501) staff       (20)     5483 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platform/darwin.pyx
+-rw-r--r--   0 tw         (501) staff       (20)   401291 2023-06-12 08:16:48.000000 borgbackup-2.0.0b6/src/borg/platform/freebsd.c
+-rw-r--r--   0 tw         (501) staff       (20)     7800 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platform/freebsd.pyx
+-rw-r--r--   0 tw         (501) staff       (20)   641332 2023-06-12 08:16:48.000000 borgbackup-2.0.0b6/src/borg/platform/linux.c
+-rw-r--r--   0 tw         (501) staff       (20)    12980 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platform/linux.pyx
+-rw-r--r--   0 tw         (501) staff       (20)   268724 2023-06-12 08:16:48.000000 borgbackup-2.0.0b6/src/borg/platform/posix.c
+-rw-r--r--   0 tw         (501) staff       (20)     3667 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platform/posix.pyx
+-rw-r--r--   0 tw         (501) staff       (20)   107402 2023-06-12 08:16:48.000000 borgbackup-2.0.0b6/src/borg/platform/syncfilerange.c
+-rw-r--r--   0 tw         (501) staff       (20)      587 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platform/syncfilerange.pyx
+-rw-r--r--   0 tw         (501) staff       (20)   208122 2023-06-12 08:16:48.000000 borgbackup-2.0.0b6/src/borg/platform/windows.c
+-rw-r--r--   0 tw         (501) staff       (20)     1519 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platform/windows.pyx
+-rw-r--r--   0 tw         (501) staff       (20)     2894 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platform/xattr.py
+-rw-r--r--   0 tw         (501) staff       (20)      359 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/platformflags.py
+-rw-r--r--   0 tw         (501) staff       (20)    51663 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/remote.py
+-rw-r--r--   0 tw         (501) staff       (20)     7590 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/repoobj.py
+-rw-r--r--   0 tw         (501) staff       (20)    89986 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/repository.py
+-rw-r--r--   0 tw         (501) staff       (20)     3671 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/selftest.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.906771 borgbackup-2.0.0b6/src/borg/testsuite/
+-rw-r--r--   0 tw         (501) staff       (20)    14989 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/__init__.py
+-rw-r--r--   0 tw         (501) staff       (20)    13605 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archive.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.911641 borgbackup-2.0.0b6/src/borg/testsuite/archiver/
+-rw-r--r--   0 tw         (501) staff       (20)    17456 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/__init__.py
+-rw-r--r--   0 tw         (501) staff       (20)     8249 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/argparsing.py
+-rw-r--r--   0 tw         (501) staff       (20)      436 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/benchmark_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     7126 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/bypass_lock_option.py
+-rw-r--r--   0 tw         (501) staff       (20)    14570 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/check_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    21501 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/checks.py
+-rw-r--r--   0 tw         (501) staff       (20)     2603 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/config_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     4677 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/corruption.py
+-rw-r--r--   0 tw         (501) staff       (20)    47043 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/create_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     8088 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/debug_cmds.py
+-rw-r--r--   0 tw         (501) staff       (20)     4892 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/delete_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    16632 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/diff_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     3475 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/disk_full.py
+-rw-r--r--   0 tw         (501) staff       (20)    10240 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/dotdot_path.tar
+-rw-r--r--   0 tw         (501) staff       (20)    35795 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/extract_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     1985 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/help_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     2443 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/info_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    13434 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/key_cmds.py
+-rw-r--r--   0 tw         (501) staff       (20)     4145 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/list_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     1137 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/lock_cmds.py
+-rw-r--r--   0 tw         (501) staff       (20)    18729 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/mount_cmds.py
+-rw-r--r--   0 tw         (501) staff       (20)      979 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/patterns.py
+-rw-r--r--   0 tw         (501) staff       (20)    11939 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/prune_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     4344 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/rcompress_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     3390 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/rcreate_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     1392 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/rdelete_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    15761 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/recreate_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     1980 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/rename_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     7499 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/repo12.tar.gz
+-rw-r--r--   0 tw         (501) staff       (20)      844 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/return_codes.py
+-rw-r--r--   0 tw         (501) staff       (20)     2799 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/rinfo_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     6009 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/rlist_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)     1971 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/serve_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    11368 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/tar_cmds.py
+-rw-r--r--   0 tw         (501) staff       (20)    15794 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/transfer_cmd.py
+-rw-r--r--   0 tw         (501) staff       (20)    10240 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/archiver/unusual_paths.tar
+-rw-r--r--   0 tw         (501) staff       (20)     3702 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/benchmark.py
+-rw-r--r--   0 tw         (501) staff       (20)     8662 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/cache.py
+-rw-r--r--   0 tw         (501) staff       (20)      897 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/checksums.py
+-rw-r--r--   0 tw         (501) staff       (20)     6466 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/chunker.py
+-rw-r--r--   0 tw         (501) staff       (20)     6486 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/chunker_pytest.py
+-rw-r--r--   0 tw         (501) staff       (20)     1552 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/chunker_slow.py
+-rw-r--r--   0 tw         (501) staff       (20)     8493 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/compress.py
+-rw-r--r--   0 tw         (501) staff       (20)    15593 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/crypto.py
+-rw-r--r--   0 tw         (501) staff       (20)     1606 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/efficient_collection_queue.py
+-rw-r--r--   0 tw         (501) staff       (20)     6239 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/file_integrity.py
+-rw-r--r--   0 tw         (501) staff       (20)    23138 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/hashindex.py
+-rw-r--r--   0 tw         (501) staff       (20)     2510 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/hashindex_pytest.py
+-rw-r--r--   0 tw         (501) staff       (20)    53725 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/helpers.py
+-rw-r--r--   0 tw         (501) staff       (20)     5121 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/item.py
+-rw-r--r--   0 tw         (501) staff       (20)    16261 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/key.py
+-rw-r--r--   0 tw         (501) staff       (20)    14267 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/locking.py
+-rw-r--r--   0 tw         (501) staff       (20)     1576 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/logger.py
+-rw-r--r--   0 tw         (501) staff       (20)     1413 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/lrucache.py
+-rw-r--r--   0 tw         (501) staff       (20)     1002 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/nanorst.py
+-rw-r--r--   0 tw         (501) staff       (20)    20361 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/patterns.py
+-rw-r--r--   0 tw         (501) staff       (20)     9007 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/platform.py
+-rw-r--r--   0 tw         (501) staff       (20)     8277 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/remote.py
+-rw-r--r--   0 tw         (501) staff       (20)     3717 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/repoobj.py
+-rw-r--r--   0 tw         (501) staff       (20)    45630 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/repository.py
+-rw-r--r--   0 tw         (501) staff       (20)     4005 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/shellpattern.py
+-rw-r--r--   0 tw         (501) staff       (20)     1762 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/version.py
+-rw-r--r--   0 tw         (501) staff       (20)     3319 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/testsuite/xattr.py
+-rw-r--r--   0 tw         (501) staff       (20)     6789 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/upgrade.py
+-rw-r--r--   0 tw         (501) staff       (20)     1819 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/version.py
+-rw-r--r--   0 tw         (501) staff       (20)     5652 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/src/borg/xattr.py
+drwxr-xr-x   0 tw         (501) staff       (20)        0 2023-06-12 08:18:26.912464 borgbackup-2.0.0b6/src/borgbackup.egg-info/
+-rw-r--r--   0 tw         (501) staff       (20)     7652 2023-06-12 08:18:26.000000 borgbackup-2.0.0b6/src/borgbackup.egg-info/PKG-INFO
+-rw-r--r--   0 tw         (501) staff       (20)    11335 2023-06-12 08:18:26.000000 borgbackup-2.0.0b6/src/borgbackup.egg-info/SOURCES.txt
+-rw-r--r--   0 tw         (501) staff       (20)        1 2023-06-12 08:18:26.000000 borgbackup-2.0.0b6/src/borgbackup.egg-info/dependency_links.txt
+-rw-r--r--   0 tw         (501) staff       (20)       72 2023-06-12 08:18:26.000000 borgbackup-2.0.0b6/src/borgbackup.egg-info/entry_points.txt
+-rw-r--r--   0 tw         (501) staff       (20)        1 2023-06-12 08:16:47.000000 borgbackup-2.0.0b6/src/borgbackup.egg-info/not-zip-safe
+-rw-r--r--   0 tw         (501) staff       (20)      217 2023-06-12 08:18:26.000000 borgbackup-2.0.0b6/src/borgbackup.egg-info/requires.txt
+-rw-r--r--   0 tw         (501) staff       (20)        5 2023-06-12 08:18:26.000000 borgbackup-2.0.0b6/src/borgbackup.egg-info/top_level.txt
+-rw-r--r--   0 tw         (501) staff       (20)      962 2023-06-12 08:14:16.000000 borgbackup-2.0.0b6/tox.ini
```

### Comparing `borgbackup-2.0.0b5/.readthedocs.yaml` & `borgbackup-2.0.0b6/.readthedocs.yaml`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/AUTHORS` & `borgbackup-2.0.0b6/AUTHORS`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/CHANGES.rst` & `borgbackup-2.0.0b6/CHANGES.rst`

 * *Files 17% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 (nothing to see here yet)
 
 .. _changelog:
 
 Change Log 2.x
 ==============
 
-Version 2.0.0b5 (2023-02-27)
+Version 2.0.0b6 (2023-06-11)
 ----------------------------
 
 Please note:
 
 This is a beta release, only for testing - do not use for production repos.
 
 Compatibility notes:
@@ -104,16 +104,116 @@
 - create: different included/excluded status chars, #7321
 
   - dry-run: now uses "+" (was: "-") and "-" (was: "x") for included/excluded status
   - non-dry-run: now uses "-" (was: "x") for excluded files
 
   Option --filter=... might need an update, if you filter for the status chars
   that were changed.
+- borg is now more strict and disallows giving some options multiple times -
+  if that makes no sense. Highlander options, see #6269. That might make scripts
+  fail now that somehow "worked" before (but maybe didn't work as intended due to
+  the contradicting options).
+
+New features:
+
+- diff: include changes in ctime and mtime, #7248
+- diff: sort JSON output alphabetically
+- diff --content-only: option added to ignore metadata changes
+- diff: add --format option, #4634
+- import-tar --ignore-zeros: new option to support importing concatenated tars, #7432
+- debug id-hash / parse-obj / format-obj: new debug commands, #7406
+- transfer --compression=C --recompress=M: recompress while transferring, #7529
+- extract --continue: continue a previously interrupted extraction, #1356
+- prune --list-kept/--list-pruned: only list the kept (or pruned) archives, #7511
+- prune --short/--format: enable users to format the list output, #3238
+- implement BORG_<CMD>_FORMAT env vars for prune, list, rlist, #5166
+- rlist: size and nfiles format keys
+- implement unix domain (ipc) socket support, #6183::
+
+      borg serve --socket  # server side (not started automatically!)
+      borg -r socket:///path/to/repo ...  # client side
+- add get_runtime_dir / BORG_RUNTIME_DIR (contains e.g. .sock and .pid file)
+- support shell-style alternatives, like: sh:image.{png,jpg}, #7602
+
+Fixes:
+
+- do not retry on permission errors (pointless)
+- transfer: verify chunks we get using assert_id, #7383
+- fix config/cache dir compatibility issues, #7445
+- xattrs: fix namespace processing on FreeBSD, #6997
+- ProgressIndicatorPercent: fix space computation for wide chars, #3027
+- delete: remove --cache-only option, #7440.
+  for deleting the cache only, use: borg rdelete --cache-only
+- borg debug get-obj/put-obj: fixed chunk id
+- create: ignore empty paths, print warning, #5637
+- extract: support extraction of atime/mtime on win32
+- benchmark crud: use TemporaryDirectory below given path, #4706
+- Ensure that cli options specified with action=Highlander can only be set once, even
+  if the set value is a default value. Add tests for action=Highlander, #7500, #6269.
+- Fix argparse error messages from misc. validators (being more specific).
+- put security infos into data dir, add BORG_DATA_DIR env var, #5760
+- setup.cfg: remove setup_requires (we have a pyproject.toml for that), #7574
+- do not crash for empty archives list in borg rlist date based matching, #7522
+- sanitize paths during archive creation and extraction, #7108 #7099
+- make sure we do not get backslashes into item paths
+
+Other changes:
+
+- allow msgpack 1.0.5 also
+- development.lock.txt: upgrade cython to 0.29.35, misc. other upgrades
+- clarify platformdirs requirements, #7393.
+  3.0.0 is only required for macOS due to breaking changes.
+  2.6.0 was the last breaking change for Linux/UNIX.
+- mount: improve mountpoint error msgs, see #7496
+- more Highlander options, #6269
+- Windows: simplify building (just use pip)
+- refactor toplevel exception handling, #6018
+- remove nonce management, related repo methods (not needed for borg2)
+- borg.remote: remove support for borg < 1.1.0
+  ($LOG, logging setup, exceptions, rpc tuple data format, version)
+- new remote and progress logging, #7604
+- borg.logger: add logging debugging functionality
+- add function to clear empty directories at end of compact process
+- unify scanning and listing of segment dirs / segment files, #7597
+- replace `LRUCache` internals with `OrderedDict`
+- docs:
+
+  - add installation instructions for Windows
+  - improve --one-file-system help and docs (macOS APFS), #5618 #4876
+  - BORG_KEY_FILE: clarify docs, #7444
+  - installation: add link to OS dependencies, #7356
+  - update FAQ about locale/unicode issues, #6999
+  - improve mount options rendering, #7359
+  - make timestamps in manual pages reproducible.
+  - describe performing pull-backups via ssh remote forwarding
+  - suggest to use forced command when using remote-fowarding via ssh
+  - fix some -a / --match-archives docs issues
+  - incl./excl. options header, clarify --path-from-stdin exclusive control
+  - add note about MAX_DATA_SIZE
+  - update security support docs
+  - improve patterns help
+
+- CI / tests / vagrant:
+
+  - added pre-commit for linting purposes, #7476
+  - resolved mode bug and added sleep clause for darwin systems, #7470
+  - "auto" compressor tests: do not assume zlib is better than lz4, #7363
+  - add stretch64 VM with deps built from source
+  - misc. other CI / test fixes and updates
+  - vagrant: add lunar64 VM, fix packages_netbsd
+  - avoid long ids in pytest output
+  - tox: package = editable-legacy, #7580
+  - tox under fakeroot: fix finding setup_docs, #7391
+  - check buzhash chunksize distribution, #7586
+  - use debian/bookworm64 box
 
 
+Version 2.0.0b5 (2023-02-27)
+----------------------------
+
 New features:
 
 - create: implement retries for individual fs files
   (e.g. if a file changed while we read it, if a file had an OSError)
 - info: add used storage quota, #7121
 - transfer: support --progress
 - create/recreate/import-tar: add --checkpoint-volume option
```

### Comparing `borgbackup-2.0.0b5/LICENSE` & `borgbackup-2.0.0b6/LICENSE`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-Copyright (C) 2015-2022 The Borg Collective (see AUTHORS file)
+Copyright (C) 2015-2023 The Borg Collective (see AUTHORS file)
 Copyright (C) 2010-2014 Jonas Borgstrm <jonas@borgstrom.se>
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
```

### Comparing `borgbackup-2.0.0b5/PKG-INFO` & `borgbackup-2.0.0b6/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: borgbackup
-Version: 2.0.0b5
+Version: 2.0.0b6
 Summary: Deduplicated, encrypted, authenticated and compressed backups
 Home-page: https://borgbackup.org
 Author: The Borg Collective (see AUTHORS file)
 License: BSD
 Project-URL: Bug Tracker, https://github.com/borgbackup/borg/issues
 Project-URL: Documentation, https://borgbackup.readthedocs.io
 Project-URL: Source Code, https://github.com/borgbackup/borg
```

### Comparing `borgbackup-2.0.0b5/README.rst` & `borgbackup-2.0.0b6/README.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/conftest.py` & `borgbackup-2.0.0b6/conftest.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/Makefile` & `borgbackup-2.0.0b6/docs/Makefile`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/_static/favicon.ico` & `borgbackup-2.0.0b6/docs/_static/favicon.ico`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/_static/logo.pdf` & `borgbackup-2.0.0b6/docs/_static/logo.pdf`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/_static/logo.png` & `borgbackup-2.0.0b6/docs/_static/logo.png`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/_static/logo.svg` & `borgbackup-2.0.0b6/docs/_static/logo.svg`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/_templates/globaltoc.html` & `borgbackup-2.0.0b6/docs/_templates/globaltoc.html`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/borg_theme/css/borg.css` & `borgbackup-2.0.0b6/docs/borg_theme/css/borg.css`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/changes.rst` & `borgbackup-2.0.0b6/docs/changes.rst`

 * *Files 17% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 (nothing to see here yet)
 
 .. _changelog:
 
 Change Log 2.x
 ==============
 
-Version 2.0.0b5 (2023-02-27)
+Version 2.0.0b6 (2023-06-11)
 ----------------------------
 
 Please note:
 
 This is a beta release, only for testing - do not use for production repos.
 
 Compatibility notes:
@@ -104,16 +104,116 @@
 - create: different included/excluded status chars, #7321
 
   - dry-run: now uses "+" (was: "-") and "-" (was: "x") for included/excluded status
   - non-dry-run: now uses "-" (was: "x") for excluded files
 
   Option --filter=... might need an update, if you filter for the status chars
   that were changed.
+- borg is now more strict and disallows giving some options multiple times -
+  if that makes no sense. Highlander options, see #6269. That might make scripts
+  fail now that somehow "worked" before (but maybe didn't work as intended due to
+  the contradicting options).
+
+New features:
+
+- diff: include changes in ctime and mtime, #7248
+- diff: sort JSON output alphabetically
+- diff --content-only: option added to ignore metadata changes
+- diff: add --format option, #4634
+- import-tar --ignore-zeros: new option to support importing concatenated tars, #7432
+- debug id-hash / parse-obj / format-obj: new debug commands, #7406
+- transfer --compression=C --recompress=M: recompress while transferring, #7529
+- extract --continue: continue a previously interrupted extraction, #1356
+- prune --list-kept/--list-pruned: only list the kept (or pruned) archives, #7511
+- prune --short/--format: enable users to format the list output, #3238
+- implement BORG_<CMD>_FORMAT env vars for prune, list, rlist, #5166
+- rlist: size and nfiles format keys
+- implement unix domain (ipc) socket support, #6183::
+
+      borg serve --socket  # server side (not started automatically!)
+      borg -r socket:///path/to/repo ...  # client side
+- add get_runtime_dir / BORG_RUNTIME_DIR (contains e.g. .sock and .pid file)
+- support shell-style alternatives, like: sh:image.{png,jpg}, #7602
+
+Fixes:
+
+- do not retry on permission errors (pointless)
+- transfer: verify chunks we get using assert_id, #7383
+- fix config/cache dir compatibility issues, #7445
+- xattrs: fix namespace processing on FreeBSD, #6997
+- ProgressIndicatorPercent: fix space computation for wide chars, #3027
+- delete: remove --cache-only option, #7440.
+  for deleting the cache only, use: borg rdelete --cache-only
+- borg debug get-obj/put-obj: fixed chunk id
+- create: ignore empty paths, print warning, #5637
+- extract: support extraction of atime/mtime on win32
+- benchmark crud: use TemporaryDirectory below given path, #4706
+- Ensure that cli options specified with action=Highlander can only be set once, even
+  if the set value is a default value. Add tests for action=Highlander, #7500, #6269.
+- Fix argparse error messages from misc. validators (being more specific).
+- put security infos into data dir, add BORG_DATA_DIR env var, #5760
+- setup.cfg: remove setup_requires (we have a pyproject.toml for that), #7574
+- do not crash for empty archives list in borg rlist date based matching, #7522
+- sanitize paths during archive creation and extraction, #7108 #7099
+- make sure we do not get backslashes into item paths
+
+Other changes:
+
+- allow msgpack 1.0.5 also
+- development.lock.txt: upgrade cython to 0.29.35, misc. other upgrades
+- clarify platformdirs requirements, #7393.
+  3.0.0 is only required for macOS due to breaking changes.
+  2.6.0 was the last breaking change for Linux/UNIX.
+- mount: improve mountpoint error msgs, see #7496
+- more Highlander options, #6269
+- Windows: simplify building (just use pip)
+- refactor toplevel exception handling, #6018
+- remove nonce management, related repo methods (not needed for borg2)
+- borg.remote: remove support for borg < 1.1.0
+  ($LOG, logging setup, exceptions, rpc tuple data format, version)
+- new remote and progress logging, #7604
+- borg.logger: add logging debugging functionality
+- add function to clear empty directories at end of compact process
+- unify scanning and listing of segment dirs / segment files, #7597
+- replace `LRUCache` internals with `OrderedDict`
+- docs:
+
+  - add installation instructions for Windows
+  - improve --one-file-system help and docs (macOS APFS), #5618 #4876
+  - BORG_KEY_FILE: clarify docs, #7444
+  - installation: add link to OS dependencies, #7356
+  - update FAQ about locale/unicode issues, #6999
+  - improve mount options rendering, #7359
+  - make timestamps in manual pages reproducible.
+  - describe performing pull-backups via ssh remote forwarding
+  - suggest to use forced command when using remote-fowarding via ssh
+  - fix some -a / --match-archives docs issues
+  - incl./excl. options header, clarify --path-from-stdin exclusive control
+  - add note about MAX_DATA_SIZE
+  - update security support docs
+  - improve patterns help
+
+- CI / tests / vagrant:
+
+  - added pre-commit for linting purposes, #7476
+  - resolved mode bug and added sleep clause for darwin systems, #7470
+  - "auto" compressor tests: do not assume zlib is better than lz4, #7363
+  - add stretch64 VM with deps built from source
+  - misc. other CI / test fixes and updates
+  - vagrant: add lunar64 VM, fix packages_netbsd
+  - avoid long ids in pytest output
+  - tox: package = editable-legacy, #7580
+  - tox under fakeroot: fix finding setup_docs, #7391
+  - check buzhash chunksize distribution, #7586
+  - use debian/bookworm64 box
 
 
+Version 2.0.0b5 (2023-02-27)
+----------------------------
+
 New features:
 
 - create: implement retries for individual fs files
   (e.g. if a file changed while we read it, if a file had an OSError)
 - info: add used storage quota, #7121
 - transfer: support --progress
 - create/recreate/import-tar: add --checkpoint-volume option
```

### Comparing `borgbackup-2.0.0b5/docs/changes_0.x.rst` & `borgbackup-2.0.0b6/docs/changes_0.x.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/changes_1.x.rst` & `borgbackup-2.0.0b6/docs/changes_1.x.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/conf.py` & `borgbackup-2.0.0b6/docs/conf.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/deployment/automated-local.rst` & `borgbackup-2.0.0b6/docs/deployment/automated-local.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/deployment/central-backup-server.rst` & `borgbackup-2.0.0b6/docs/deployment/central-backup-server.rst`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 .. include:: ../global.rst.inc
 .. highlight:: none
+.. _central-backup-server:
 
 Central repository server with Ansible or Salt
 ==============================================
 
 This section will give an example how to set up a borg repository server for multiple
 clients.
```

### Comparing `borgbackup-2.0.0b5/docs/deployment/hosting-repositories.rst` & `borgbackup-2.0.0b6/docs/deployment/hosting-repositories.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/deployment/image-backup.rst` & `borgbackup-2.0.0b6/docs/deployment/image-backup.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/deployment/pull-backup.rst` & `borgbackup-2.0.0b6/docs/deployment/pull-backup.rst`

 * *Files 22% similar despite different names*

```diff
@@ -418,7 +418,87 @@
   *ssh://borgs@borg-server/~/repo* refers to the repository *repo* within borgs's home directory on *borg-server*.
 
   *StrictHostKeyChecking=no* is used to add host keys automatically to *~/.ssh/known_hosts* without user intervention.
 
 ``kill "${SSH_AGENT_PID}"``
 
   Kill ssh-agent with loaded keys when it is not needed anymore.
+
+Remote forwarding
+=================
+
+The standard ssh client allows to create tunnels to forward local ports to a remote server (local forwarding) and also
+to allow remote ports to be forwarded to local ports (remote forwarding).
+
+This remote forwarding can be used to allow remote backup clients to access the backup server even if the backup server
+cannot be reached by the backup client.
+
+This can even be used in cases where neither the backup server can reach the backup client and the backup client cannot
+reach the backup server, but some intermediate host can access both.
+
+A schematic approach is as follows
+
+::
+
+      Backup Server (backup@mybackup)          Intermediate Machine (john@myinter)              Backup Client (bob@myclient)
+
+                                              1. Establish SSH remote forwarding  ----------->  SSH listen on local port
+
+                                                                                                2. Starting ``borg create`` establishes
+                                              3. SSH forwards to intermediate machine  <------- SSH connection to the local port
+      4. Receives backup connection <-------  and further on to backup server
+      via SSH
+
+So for the backup client the backup is done via SSH to a local port and for the backup server there is a normal backup
+performed via ssh.
+
+In order to achieve this, the following commands can be used to create the remote port forwarding:
+
+1. On machine ``myinter``
+
+``ssh bob@myclient -v -C -R 8022:mybackup:22 -N``
+
+This will listen for ssh-connections on port ``8022`` on ``myclient`` and forward connections to port 22 on ``mybackup``.
+
+You can also remove the need for machine ``myinter`` and create the port forwarding on the backup server directly by
+using ``localhost`` instead of ``mybackup``
+
+2. On machine ``myclient``
+
+``borg create -v --progress --stats ssh://backup@localhost:8022/home/backup/repos/myclient /``
+
+Make sure to use port ``8022`` and ``localhost`` for the repository as this instructs borg on ``myclient`` to use the
+remote forwarded ssh connection.
+
+SSH Keys
+--------
+
+If you want to automate backups when using this method, the ssh ``known_hosts`` and ``authorized_keys`` need to be set up
+to allow connections.
+
+Security Considerations
+-----------------------
+
+Opening up SSH access this way can pose a security risk as it effectively opens remote access to your
+backup server on the client even if it is located outside of your company network.
+
+To reduce the chances of compromise, you should configure a forced command in ``authorized_keys`` to prevent
+anyone from performing any other action on the backup server.
+
+This can be done e.g. by adding the following in ``$HOME/.ssh/authorized_keys`` on ``mybackup`` with proper
+path and client-fqdn:
+
+::
+
+  command="cd /home/backup/repos/<client fqdn>;borg serve --restrict-to-path /home/backup/repos/<client fqdn>"
+
+
+All the additional security considerations for borg should be applied, see :ref:`central-backup-server` for some additional
+hints.
+
+More information
+----------------
+
+See `remote forwarding`_ and the `ssh man page`_ for more information about remote forwarding.
+
+   .. _remote forwarding: https://linuxize.com/post/how-to-setup-ssh-tunneling/
+   .. _ssh man page: https://manpages.debian.org/testing/manpages-de/ssh.1.de.html
```

### Comparing `borgbackup-2.0.0b5/docs/development.rst` & `borgbackup-2.0.0b6/docs/development.rst`

 * *Files 3% similar despite different names*

```diff
@@ -175,14 +175,21 @@
 
 To install some additional packages needed for running the tests, activate your
 virtual env and run::
 
   pip install -r requirements.d/development.txt
 
 
+This project utilizes pre-commit to format and lint code before it is committed.
+Although pre-commit is installed when running the command above, the pre-commit hooks
+will have to be installed separately. Run this command to install the pre-commit hooks::
+
+  pre-commit install
+
+
 Running the tests
 -----------------
 
 The tests are in the borg/testsuite package.
 
 To run all the tests, you need to have fakeroot installed. If you do not have
 fakeroot, you still will be able to run most tests, just leave away the
```

### Comparing `borgbackup-2.0.0b5/docs/faq.rst` & `borgbackup-2.0.0b6/docs/faq.rst`

 * *Files 1% similar despite different names*

```diff
@@ -21,15 +21,15 @@
 
 When Borg is writing to a repo on a locally mounted remote file system, e.g.
 SSHFS, the Borg client only can do file system operations and has no agent
 running on the remote side, so *every* operation needs to go over the network,
 which is slower.
 
 Can I back up from multiple servers into a single repository?
-------------------------------------------------------------
+-------------------------------------------------------------
 
 In order for the deduplication used by Borg to work, it
 needs to keep a local cache containing checksums of all file
 chunks already stored in the repository. This cache is stored in
 ``~/.cache/borg/``.  If Borg detects that a repository has been
 modified since the local cache was updated it will need to rebuild
 the cache. This rebuild can be quite time consuming.
@@ -158,15 +158,15 @@
 in a checkpoint archive named ``<filename>.borg_part``. Such partial files
 won't be contained in the final archive.
 This is done so that checkpoints work cleanly and promptly while a big
 file is being processed.
 
 
 How can I back up huge file(s) over a unstable connection?
----------------------------------------------------------
+----------------------------------------------------------
 
 Yes. For more details, see :ref:`checkpoints_parts`.
 
 How can I restore huge file(s) over an unstable connection?
 -----------------------------------------------------------
 
 Try using ``borg mount`` and ``rsync`` (or a similar tool that supports
@@ -365,16 +365,16 @@
 different prefixes. For example, you could have a script that does::
 
     borg create --exclude var/log main-$(date +%Y-%m-%d) /
     borg create logs-$(date +%Y-%m-%d) /var/log
 
 Then you would have two different prune calls with different policies::
 
-    borg prune --verbose --list -d 30 -a 'main-*'
-    borg prune --verbose --list -d 7  -a 'logs-*'
+    borg prune --verbose --list -d 30 -a 'sh:main-*'
+    borg prune --verbose --list -d 7  -a 'sh:logs-*'
 
 This will keep 7 days of logs and 30 days of everything else.
 
 How do I remove files from an existing backup?
 ----------------------------------------------
 
 A file is only removed from a BorgBackup repository if all archives that contain
@@ -406,30 +406,39 @@
 .. _home_config_borg:
 
 How important is the $HOME/.config/borg directory?
 --------------------------------------------------
 
 The Borg config directory has content that you should take care of:
 
-``security`` subdirectory
-  Each directory here represents one Borg repository by its ID and contains the last known status.
-  If a repository's status is different from this information at the beginning of BorgBackup
-  operation, Borg outputs warning messages and asks for confirmation, so make sure you do not lose
-  or manipulate these files. However, apart from those warnings, a loss of these files can be
-  recovered.
-
 ``keys`` subdirectory
   All your borg keyfile keys are stored in this directory. Please note that
   borg repokey keys are stored inside the repository. You MUST make sure to have an
   independent backup of these keyfiles, otherwise you cannot access your backups anymore if you lose
   them. You also MUST keep these files secret; everyone who gains access to your repository and has
   the corresponding keyfile (and the key passphrase) can extract it.
 
 Make sure that only you have access to the Borg config directory.
 
+.. _home_data_borg:
+
+How important is the $HOME/.local/share/borg directory?
+-------------------------------------------------------
+
+The Borg data directory has content that you should take care of:
+
+``security`` subdirectory
+  Each directory here represents one Borg repository by its ID and contains the last known status.
+  If a repository's status is different from this information at the beginning of BorgBackup
+  operation, Borg outputs warning messages and asks for confirmation, so make sure you do not lose
+  or manipulate these files. However, apart from those warnings, a loss of these files can be
+  recovered.
+
+Make sure that only you have access to the Borg data directory.
+
 .. _cache_security:
 
 Do I need to take security precautions regarding the cache?
 -----------------------------------------------------------
 
 The cache contains a lot of metadata information about the files in
 your repositories and it is not encrypted.
@@ -731,28 +740,34 @@
   chunk cache resyncs happen e.g. if your repo was written to by another
   machine (if you share same backup repo between multiple machines) or if
   your local chunks cache was lost somehow.
 
 The long term plan to improve this is called "borgception", see :issue:`474`.
 
 Can I back up my root partition (/) with Borg?
----------------------------------------------
+----------------------------------------------
 
 Backing up your entire root partition works just fine, but remember to
 exclude directories that make no sense to back up, such as /dev, /proc,
 /sys, /tmp and /run, and to use ``--one-file-system`` if you only want to
 back up the root partition (and not any mounted devices e.g.).
 
 If it crashes with a UnicodeError, what can I do?
 -------------------------------------------------
 
 Check if your encoding is set correctly. For most POSIX-like systems, try::
 
   export LANG=en_US.UTF-8  # or similar, important is correct charset
 
+If that does not help:
+
+- check for typos, check if you really used ``export``.
+- check if you have set ``LC_ALL`` - if so, try not setting it.
+- check if you generated the respective locale via ``locale-gen``.
+
 I can't extract non-ascii filenames by giving them on the commandline!?
 -----------------------------------------------------------------------
 
 This might be due to different ways to represent some characters in unicode
 or due to other non-ascii encoding issues.
 
 If you run into that, try this:
```

### Comparing `borgbackup-2.0.0b5/docs/global.rst.inc` & `borgbackup-2.0.0b6/docs/global.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/installation.rst` & `borgbackup-2.0.0b6/docs/installation.rst`

 * *Files 8% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 
 - :ref:`distribution-package` - easy and fast if a package is
   available from your distribution.
 - :ref:`pyinstaller-binary` - easy and fast, we provide a ready-to-use binary file
   that comes bundled with all dependencies.
 - :ref:`source-install`, either:
 
+  - :ref:`windows-binary` - builds a binary file for Windows using MSYS2.
   - :ref:`pip-installation` - installing a source package with pip needs
     more installation steps and requires all dependencies with
     development headers and a compiler.
   - :ref:`git-installation`  - for developers and power users who want to
     have the latest code or use revision control (each release is
     tagged).
 
@@ -290,14 +291,28 @@
      python3 -m ensurepip # to install pip for Python3
      To use the mount command:
      echo 'fuse_load="YES"' >> /boot/loader.conf
      echo 'vfs.usermount=1' >> /etc/sysctl.conf
      kldload fuse
      sysctl vfs.usermount=1
 
+.. _windows_deps:
+
+Windows
++++++++
+
+.. note::
+    Running under Windows is experimental.
+
+.. warning::
+    This script needs to be run in the UCRT64 environment in MSYS2.
+
+Install the dependencies with the provided script::
+
+    ./scripts/msys2-install-deps
 
 Windows 10's Linux Subsystem
 ++++++++++++++++++++++++++++
 
 .. note::
     Running under Windows 10's Linux Subsystem is experimental and has not been tested much yet.
 
@@ -314,23 +329,46 @@
 
     python39 python39-devel python39-pkgconfig
     python39-setuptools python39-pip python39-wheel python39-virtualenv
     libssl-devel libxxhash-devel liblz4-devel libzstd-devel
     binutils gcc-g++ git make openssh
 
 
+.. _windows-binary:
+
+Building a binary on Windows
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. note::
+    This is experimental.
+
+.. warning::
+    This needs to be run in the UCRT64 environment in MSYS2.
+
+Ensure to install the dependencies as described within :ref:`Dependencies: Windows <windows_deps>`.
+
+::
+
+    export SETUPTOOLS_USE_DISTUTILS=stdlib # Needed for pip to work - https://www.msys2.org/docs/python/#known-issues
+    pip install -e .
+    pyinstaller -y scripts/borg.exe.spec
+
+A standalone executable will be created in ``dist/borg.exe``.
+
 .. _pip-installation:
 
 Using pip
 ~~~~~~~~~
 
 Virtualenv_ can be used to build and install Borg without affecting
 the system Python or requiring root access.  Using a virtual environment is
 optional, but recommended except for the most simple use cases.
 
+Ensure to install the dependencies as described within :ref:`source-install`.
+
 .. note::
     If you install into a virtual environment, you need to **activate** it
     first (``source borg-env/bin/activate``), before running ``borg``.
     Alternatively, symlink ``borg-env/bin/borg`` into some directory that is in
     your ``PATH`` so you can run ``borg``.
 
 This will use ``pip`` to install the latest release from PyPi::
@@ -372,14 +410,16 @@
 
 Using git
 ~~~~~~~~~
 
 This uses latest, unreleased development code from git.
 While we try not to break master, there are no guarantees on anything.
 
+Ensure to install the dependencies as described within :ref:`source-install`.
+
 ::
 
     # get borg from github
     git clone https://github.com/borgbackup/borg.git
 
     # create a virtual environment
     virtualenv --python=$(which python3) borg-env
```

### Comparing `borgbackup-2.0.0b5/docs/internals/compaction.odg` & `borgbackup-2.0.0b6/docs/internals/compaction.odg`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/compaction.png` & `borgbackup-2.0.0b6/docs/internals/compaction.png`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/data-structures.rst` & `borgbackup-2.0.0b6/docs/internals/data-structures.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/encryption-aead.odg` & `borgbackup-2.0.0b6/docs/internals/encryption-aead.odg`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/encryption-aead.png` & `borgbackup-2.0.0b6/docs/internals/encryption-aead.png`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/frontends.rst` & `borgbackup-2.0.0b6/docs/internals/frontends.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/object-graph.odg` & `borgbackup-2.0.0b6/docs/internals/object-graph.odg`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/object-graph.png` & `borgbackup-2.0.0b6/docs/internals/object-graph.png`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/security.rst` & `borgbackup-2.0.0b6/docs/internals/security.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/structure.odg` & `borgbackup-2.0.0b6/docs/internals/structure.odg`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals/structure.png` & `borgbackup-2.0.0b6/docs/internals/structure.png`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/internals.rst` & `borgbackup-2.0.0b6/docs/internals.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/man/borg-benchmark-cpu.1` & `borgbackup-2.0.0b6/docs/man/borg-benchmark-cpu.1`

 * *Files 7% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-BENCHMARK-CPU" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-BENCHMARK-CPU" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-benchmark-cpu \- Benchmark CPU bound operations.
 .SH SYNOPSIS
 .sp
 borg [common options] benchmark cpu [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-benchmark-crud.1` & `borgbackup-2.0.0b6/docs/man/borg-benchmark-crud.1`

 * *Files 2% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-BENCHMARK-CRUD" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-BENCHMARK-CRUD" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-benchmark-crud \- Benchmark Create, Read, Update, Delete for archives.
 .SH SYNOPSIS
 .sp
 borg [common options] benchmark crud [options] PATH
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-benchmark.1` & `borgbackup-2.0.0b6/docs/man/borg-benchmark.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-BENCHMARK" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-BENCHMARK" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-benchmark \- benchmark command
 .SH SYNOPSIS
 .nf
 borg [common options] benchmark crud ...
 borg [common options] benchmark cpu ...
 .fi
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-break-lock.1` & `borgbackup-2.0.0b6/docs/man/borg-break-lock.1`

 * *Files 9% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-BREAK-LOCK" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-BREAK-LOCK" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-break-lock \- Break the repository lock (e.g. in case it was left by a dead borg.
 .SH SYNOPSIS
 .sp
 borg [common options] break\-lock [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-change-passphrase.1` & `borgbackup-2.0.0b6/docs/man/borg-change-passphrase.1`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/man/borg-check.1` & `borgbackup-2.0.0b6/docs/man/borg-check.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-CHECK" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-CHECK" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-check \- Check repository consistency
 .SH SYNOPSIS
 .sp
 borg [common options] check [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-common.1` & `borgbackup-2.0.0b6/docs/man/borg-common.1`

 * *Files 5% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-COMMON" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-COMMON" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-common \- Common options of Borg commands
 .SH SYNOPSIS
 .INDENT 0.0
 .TP
 .B  \-h\fP,\fB  \-\-help
 show this help message and exit
@@ -89,14 +89,17 @@
 .TP
 .BI \-\-debug\-profile \ FILE
 Write execution profile in Borg format into FILE. For local use a Python\-compatible file can be generated by suffixing FILE with \(dq.pyprof\(dq.
 .TP
 .BI \-\-rsh \ RSH
 Use this command to connect to the \(aqborg serve\(aq process (default: \(aqssh\(aq)
 .TP
+.BI \-\-socket \ PATH
+Use UNIX DOMAIN (IPC) socket at PATH for client/server communication with socket: protocol.
+.TP
 .BI \-r \ REPO\fR,\fB \ \-\-repo \ REPO
 repository to use
 .UNINDENT
 .SH SEE ALSO
 .sp
 \fIborg\-common(1)\fP
 .SH AUTHOR
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-compact.1` & `borgbackup-2.0.0b6/docs/man/borg-compact.1`

 * *Files 0% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-COMPACT" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-COMPACT" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-compact \- compact segment files in the repository
 .SH SYNOPSIS
 .sp
 borg [common options] compact [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-compression.1` & `borgbackup-2.0.0b6/docs/man/borg-compression.1`

 * *Files 6% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-COMPRESSION" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-COMPRESSION" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-compression \- Details regarding compression
 .SH DESCRIPTION
 .sp
 It is no problem to mix different compression methods in one repo,
 deduplication is done on the source data chunks (not on the compressed
 or encrypted data).
@@ -78,37 +78,78 @@
 The heuristic tries with lz4 whether the data is compressible.
 For incompressible data, it will not use compression (uses \(dqnone\(dq).
 For compressible data, it uses the given C[,L] compression \- with C[,L]
 being any valid compression specifier.
 .TP
 .B obfuscate,SPEC,C[,L]
 Use compressed\-size obfuscation to make fingerprinting attacks based on
-the observable stored chunk size more difficult.
-Note:
-\- you must combine this with encryption or it won\(aqt make any sense.
-\- your repo size will be bigger, of course.
+the observable stored chunk size more difficult. Note:
+.INDENT 7.0
+.IP \(bu 2
+You must combine this with encryption, or it won\(aqt make any sense.
+.IP \(bu 2
+Your repo size will be bigger, of course.
+.IP \(bu 2
+A chunk is limited by the constant \fBMAX_DATA_SIZE\fP (cur. ~20MiB).
+.UNINDENT
+.sp
+The SPEC value determines how the size obfuscation works:
 .sp
-The SPEC value will determine how the size obfuscation will work:
+\fIRelative random reciprocal size variation\fP (multiplicative)
 .sp
-Relative random reciprocal size variation:
 Size will increase by a factor, relative to the compressed data size.
-Smaller factors are often used, larger factors rarely.
-1: factor 0.01 .. 100.0
-2: factor 0.1 .. 1000.0
-3: factor 1.0 .. 10000.0
-4: factor 10.0 .. 100000.0
-5: factor 100.0 .. 1000000.0
-6: factor 1000.0 .. 10000000.0
+Smaller factors are used often, larger factors rarely.
+.sp
+Available factors:
+.INDENT 7.0
+.INDENT 3.5
+.sp
+.nf
+.ft C
+1:     0.01 ..        100
+2:     0.1  ..      1,000
+3:     1    ..     10,000
+4:    10    ..    100,000
+5:   100    ..  1,000,000
+6: 1,000    .. 10,000,000
+.ft P
+.fi
+.UNINDENT
+.UNINDENT
+.sp
+Example probabilities for SPEC \fB1\fP:
+.INDENT 7.0
+.INDENT 3.5
+.sp
+.nf
+.ft C
+90   %  0.01 ..   0.1
+ 9   %  0.1  ..   1
+ 0.9 %  1    ..  10
+ 0.09% 10    .. 100
+.ft P
+.fi
+.UNINDENT
+.UNINDENT
+.sp
+\fIRandomly sized padding up to the given size\fP (additive)
+.INDENT 7.0
+.INDENT 3.5
 .sp
-Add a randomly sized padding up to the given size:
-110: 1kiB
+.nf
+.ft C
+110: 1kiB (2 ^ (SPEC \- 100))
 \&...
 120: 1MiB
 \&...
 123: 8MiB (max.)
+.ft P
+.fi
+.UNINDENT
+.UNINDENT
 .UNINDENT
 .sp
 Examples:
 .INDENT 0.0
 .INDENT 3.5
 .sp
 .nf
@@ -116,15 +157,15 @@
 borg create \-\-compression lz4 REPO::ARCHIVE data
 borg create \-\-compression zstd REPO::ARCHIVE data
 borg create \-\-compression zstd,10 REPO::ARCHIVE data
 borg create \-\-compression zlib REPO::ARCHIVE data
 borg create \-\-compression zlib,1 REPO::ARCHIVE data
 borg create \-\-compression auto,lzma,6 REPO::ARCHIVE data
 borg create \-\-compression auto,lzma ...
-borg create \-\-compression obfuscate,3,none ...
+borg create \-\-compression obfuscate,110,none ...
 borg create \-\-compression obfuscate,3,auto,zstd,10 ...
 borg create \-\-compression obfuscate,2,zstd,6 ...
 .ft P
 .fi
 .UNINDENT
 .UNINDENT
 .SH AUTHOR
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-config.1` & `borgbackup-2.0.0b6/docs/man/borg-config.1`

 * *Files 2% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-CONFIG" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-CONFIG" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-config \- get, set, and delete values in a repository or cache config file
 .SH SYNOPSIS
 .sp
 borg [common options] config [options] [NAME] [VALUE]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-create.1` & `borgbackup-2.0.0b6/docs/man/borg-create.1`

 * *Files 2% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-CREATE" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-CREATE" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-create \- Create new archive
 .SH SYNOPSIS
 .sp
 borg [common options] create [options] NAME [PATH...]
 .SH DESCRIPTION
 .sp
@@ -165,23 +165,23 @@
 .BI \-\-stdin\-mode \ M
 set mode to M in archive for stdin data (default: 0660)
 .TP
 .B  \-\-content\-from\-command
 interpret PATH as command and store its stdout. See also section Reading from stdin below.
 .TP
 .B  \-\-paths\-from\-stdin
-read DELIM\-separated list of paths to back up from stdin. Will not recurse into directories.
+read DELIM\-separated list of paths to back up from stdin. All control is external: it will back up all files given \- no more, no less.
 .TP
 .B  \-\-paths\-from\-command
 interpret PATH as command and treat its output as \fB\-\-paths\-from\-stdin\fP
 .TP
 .BI \-\-paths\-delimiter \ DELIM
-set path delimiter for \fB\-\-paths\-from\-stdin\fP and \fB\-\-paths\-from\-command\fP (default: n)
+set path delimiter for \fB\-\-paths\-from\-stdin\fP and \fB\-\-paths\-from\-command\fP (default: \fB\en\fP)
 .UNINDENT
-.SS Exclusion options
+.SS Include/Exclude options
 .INDENT 0.0
 .TP
 .BI \-e \ PATTERN\fR,\fB \ \-\-exclude \ PATTERN
 exclude paths matching PATTERN
 .TP
 .BI \-\-exclude\-from \ EXCLUDEFILE
 read exclude patterns from EXCLUDEFILE, one per line
@@ -204,15 +204,15 @@
 .B  \-\-exclude\-nodump
 exclude files flagged NODUMP
 .UNINDENT
 .SS Filesystem options
 .INDENT 0.0
 .TP
 .B  \-x\fP,\fB  \-\-one\-file\-system
-stay in the same file system and do not store mount points of other file systems.  This might behave different from your expectations, see the docs.
+stay in the same file system and do not store mount points of other file systems \- this might behave different from your expectations, see the description below.
 .TP
 .B  \-\-numeric\-ids
 only store numeric user and group identifiers
 .TP
 .B  \-\-atime
 do store atime into archive
 .TP
@@ -364,21 +364,21 @@
 only include the objects specified by \fB\-\-exclude\-if\-present\fP in your backup,
 and not include any other contents of the containing folder, this can be enabled
 through using the \fB\-\-keep\-exclude\-tags\fP option.
 .sp
 The \fB\-x\fP or \fB\-\-one\-file\-system\fP option excludes directories, that are mountpoints (and everything in them).
 It detects mountpoints by comparing the device number from the output of \fBstat()\fP of the directory and its
 parent directory. Specifically, it excludes directories for which \fBstat()\fP reports a device number different
-from the device number of their parent. Be aware that in Linux (and possibly elsewhere) there are directories
-with device number different from their parent, which the kernel does not consider a mountpoint and also the
-other way around. Examples are bind mounts (possibly same device number, but always a mountpoint) and ALL
-subvolumes of a btrfs (different device number from parent but not necessarily a mountpoint). Therefore when
-using \fB\-\-one\-file\-system\fP, one should make doubly sure that the backup works as intended especially when using
-btrfs. This is even more important, if the btrfs layout was created by someone else, e.g. a distribution
-installer.
+from the device number of their parent.
+In general: be aware that there are directories with device number different from their parent, which the kernel
+does not consider a mountpoint and also the other way around.
+Linux examples for this are bind mounts (possibly same device number, but always a mountpoint) and ALL
+subvolumes of a btrfs (different device number from parent but not necessarily a mountpoint).
+macOS examples are the apfs mounts of a typical macOS installation.
+Therefore, when using \fB\-\-one\-file\-system\fP, you should double\-check that the backup works as intended.
 .SS Item flags
 .sp
 \fB\-\-list\fP outputs a list of all files, directories and other
 file system items it considered (no matter whether they had content changes
 or not). For each item, it prefixes a single\-letter flag that indicates type
 and/or status of the item.
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-delete.1` & `borgbackup-2.0.0b6/docs/man/borg-delete.1`

 * *Files 3% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-DELETE" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-DELETE" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-delete \- Delete archives
 .SH SYNOPSIS
 .sp
 borg [common options] delete [options]
 .SH DESCRIPTION
 .sp
@@ -66,17 +66,14 @@
 .TP
 .B  \-\-consider\-checkpoints
 consider checkpoint archives for deletion (default: not considered).
 .TP
 .B  \-s\fP,\fB  \-\-stats
 print statistics for the deleted archive
 .TP
-.B  \-\-cache\-only
-delete only the local cache for the given repository
-.TP
 .B  \-\-force
 force deletion of corrupted archives, use \fB\-\-force \-\-force\fP in case \fB\-\-force\fP does not work.
 .TP
 .BI \-c \ SECONDS\fR,\fB \ \-\-checkpoint\-interval \ SECONDS
 write checkpoint every SECONDS seconds (Default: 1800)
 .UNINDENT
 .SS Archive filters
@@ -114,21 +111,21 @@
 .ft C
 # delete a single backup archive:
 $ borg delete Monday
 # actually free disk space:
 $ borg compact
 
 # delete all archives whose names begin with the machine\(aqs hostname followed by \(dq\-\(dq
-$ borg delete \-a \(aq{hostname}\-*\(aq
+$ borg delete \-a \(aqsh:{hostname}\-*\(aq
 
 # delete all archives whose names contain \(dq\-2012\-\(dq
-$ borg delete \-a \(aq*\-2012\-*\(aq
+$ borg delete \-a \(aqsh:*\-2012\-*\(aq
 
 # see what would be deleted if delete was run without \-\-dry\-run
-$ borg delete \-\-list \-\-dry\-run \-a \(aq*\-May\-*\(aq
+$ borg delete \-\-list \-\-dry\-run \-a \(aqsh:*\-May\-*\(aq
 .ft P
 .fi
 .UNINDENT
 .UNINDENT
 .SH SEE ALSO
 .sp
 \fIborg\-common(1)\fP, \fIborg\-compact(1)\fP, \fIborg\-rdelete(1)\fP
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-export-tar.1` & `borgbackup-2.0.0b6/docs/man/borg-export-tar.1`

 * *Files 2% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-EXPORT-TAR" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-EXPORT-TAR" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-export-tar \- Export archive contents as a tarball
 .SH SYNOPSIS
 .sp
 borg [common options] export\-tar [options] NAME FILE [PATH...]
 .SH DESCRIPTION
 .sp
@@ -132,15 +132,15 @@
 .TP
 .B  \-\-list
 output verbose list of items (files, dirs, ...)
 .TP
 .BI \-\-tar\-format \ FMT
 select tar format: BORG, PAX or GNU
 .UNINDENT
-.SS Exclusion options
+.SS Include/Exclude options
 .INDENT 0.0
 .TP
 .BI \-e \ PATTERN\fR,\fB \ \-\-exclude \ PATTERN
 exclude paths matching PATTERN
 .TP
 .BI \-\-exclude\-from \ EXCLUDEFILE
 read exclude patterns from EXCLUDEFILE, one per line
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-extract.1` & `borgbackup-2.0.0b6/docs/man/borg-extract.1`

 * *Files 3% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-EXTRACT" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-EXTRACT" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-extract \- Extract archive contents
 .SH SYNOPSIS
 .sp
 borg [common options] extract [options] NAME [PATH...]
 .SH DESCRIPTION
 .sp
@@ -94,16 +94,19 @@
 do not extract/set xattrs
 .TP
 .B  \-\-stdout
 write all extracted data to stdout
 .TP
 .B  \-\-sparse
 create holes in output sparse file from all\-zero chunks
+.TP
+.B  \-\-continue
+continue a previously interrupted extraction of same archive
 .UNINDENT
-.SS Exclusion options
+.SS Include/Exclude options
 .INDENT 0.0
 .TP
 .BI \-e \ PATTERN\fR,\fB \ \-\-exclude \ PATTERN
 exclude paths matching PATTERN
 .TP
 .BI \-\-exclude\-from \ EXCLUDEFILE
 read exclude patterns from EXCLUDEFILE, one per line
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-import-tar.1` & `borgbackup-2.0.0b6/docs/man/borg-import-tar.1`

 * *Files 5% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-IMPORT-TAR" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-IMPORT-TAR" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-import-tar \- Create a backup archive from a tarball
 .SH SYNOPSIS
 .sp
 borg [common options] import\-tar [options] NAME TARFILE
 .SH DESCRIPTION
 .sp
@@ -76,14 +76,18 @@
 .IP \(bu 2
 POSIX.1\-1988 (ustar)
 .IP \(bu 2
 UNIX V7 tar
 .IP \(bu 2
 SunOS tar with extended attributes
 .UNINDENT
+.sp
+To import multiple tarballs into a single archive, they can be simply
+concatenated (e.g. using \(dqcat\(dq) into a single file, and imported with an
+\fB\-\-ignore\-zeros\fP option to skip through the stop markers between them.
 .SH OPTIONS
 .sp
 See \fIborg\-common(1)\fP for common options of Borg commands.
 .SS arguments
 .INDENT 0.0
 .TP
 .B NAME
@@ -105,14 +109,17 @@
 output verbose list of items (files, dirs, ...)
 .TP
 .BI \-\-filter \ STATUSCHARS
 only display items with the given status characters
 .TP
 .B  \-\-json
 output stats as JSON (implies \-\-stats)
+.TP
+.B  \-\-ignore\-zeros
+ignore zero\-filled blocks in the input tarball
 .UNINDENT
 .SS Archive options
 .INDENT 0.0
 .TP
 .BI \-\-comment \ COMMENT
 add a comment text to the archive
 .TP
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-info.1` & `borgbackup-2.0.0b6/docs/man/borg-info.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-INFO" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-INFO" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-info \- Show archive details such as disk space used
 .SH SYNOPSIS
 .sp
 borg [common options] info [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-key-change-algorithm.1` & `borgbackup-2.0.0b6/docs/man/borg-key-change-algorithm.1`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/man/borg-key-change-location.1` & `borgbackup-2.0.0b6/docs/man/borg-key-change-location.1`

 * *Files 4% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-KEY-CHANGE-LOCATION" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-KEY-CHANGE-LOCATION" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-key-change-location \- Change repository key location
 .SH SYNOPSIS
 .sp
 borg [common options] key change\-location [options] KEY_LOCATION
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-key-change-passphrase.1` & `borgbackup-2.0.0b6/docs/man/borg-key-change-passphrase.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-KEY-CHANGE-PASSPHRASE" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-KEY-CHANGE-PASSPHRASE" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-key-change-passphrase \- Change repository key file passphrase
 .SH SYNOPSIS
 .sp
 borg [common options] key change\-passphrase [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-key-export.1` & `borgbackup-2.0.0b6/docs/man/borg-key-export.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-KEY-EXPORT" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-KEY-EXPORT" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-key-export \- Export the repository key for backup
 .SH SYNOPSIS
 .sp
 borg [common options] key export [options] [PATH]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-key-import.1` & `borgbackup-2.0.0b6/docs/man/borg-key-import.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-KEY-IMPORT" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-KEY-IMPORT" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-key-import \- Import the repository key from backup
 .SH SYNOPSIS
 .sp
 borg [common options] key import [options] [PATH]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-key-migrate-to-repokey.1` & `borgbackup-2.0.0b6/docs/man/borg-key-migrate-to-repokey.1`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/man/borg-key.1` & `borgbackup-2.0.0b6/docs/man/borg-key.1`

 * *Files 7% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-KEY" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-KEY" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-key \- Manage a keyfile or repokey of a repository
 .SH SYNOPSIS
 .nf
 borg [common options] key export ...
 borg [common options] key import ...
 borg [common options] key change\-passphrase ...
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-list.1` & `borgbackup-2.0.0b6/docs/man/borg-list.1`

 * *Files 10% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-LIST" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-LIST" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-list \- List archive contents
 .SH SYNOPSIS
 .sp
 borg [common options] list [options] NAME [PATH...]
 .SH DESCRIPTION
 .sp
@@ -58,15 +58,15 @@
 .TP
 .BI \-\-format \ FORMAT
 specify format for file listing (default: \(dq{mode} {user:6} {group:6} {size:8} {mtime} {path}{extra}{NL}\(dq)
 .TP
 .B  \-\-json\-lines
 Format output as JSON Lines. The form of \fB\-\-format\fP is ignored, but keys used in it are added to the JSON output. Some keys are always present. Note: JSON can only represent text.
 .UNINDENT
-.SS Exclusion options
+.SS Include/Exclude options
 .INDENT 0.0
 .TP
 .BI \-e \ PATTERN\fR,\fB \ \-\-exclude \ PATTERN
 exclude paths matching PATTERN
 .TP
 .BI \-\-exclude\-from \ EXCLUDEFILE
 read exclude patterns from EXCLUDEFILE, one per line
@@ -148,65 +148,65 @@
 .IP \(bu 2
 NEWLINE: OS dependent line separator
 .IP \(bu 2
 NL: alias of NEWLINE
 .IP \(bu 2
 NUL: NUL character for creating print0 / xargs \-0 like output
 .IP \(bu 2
-SPACE
+SPACE: space character
 .IP \(bu 2
-TAB
+TAB: tab character
 .IP \(bu 2
-CR
+CR: carriage return character
 .IP \(bu 2
-LF
+LF: line feed character
 .UNINDENT
 .sp
 Keys available only when listing files in an archive:
 .INDENT 0.0
 .IP \(bu 2
-type
+type: file type (file, dir, symlink, ...)
 .IP \(bu 2
-mode
+mode: file mode (as in stat)
 .IP \(bu 2
-uid
+uid: user id of file owner
 .IP \(bu 2
-gid
+gid: group id of file owner
 .IP \(bu 2
-user
+user: user name of file owner
 .IP \(bu 2
-group
+group: group name of file owner
 .IP \(bu 2
 path: file path
 .IP \(bu 2
 target: link target for symlinks
 .IP \(bu 2
 hlid: hard link identity (same if hardlinking same fs object)
 .IP \(bu 2
-flags
+flags: file flags
 .IP \(bu 2
-size
+size: file size
 .IP \(bu 2
 dsize: deduplicated size
 .IP \(bu 2
 num_chunks: number of chunks in this file
 .IP \(bu 2
 unique_chunks: number of unique chunks in this file
 .IP \(bu 2
-mtime
+mtime: file modification time
 .IP \(bu 2
-ctime
+ctime: file change time
 .IP \(bu 2
-atime
+atime: file access time
 .IP \(bu 2
-isomtime
+isomtime: file modification time (ISO 8601 format)
 .IP \(bu 2
-isoctime
+isoctime: file change time (ISO 8601 format)
 .IP \(bu 2
-isoatime
+isoatime: file access time (ISO 8601 format)
 .IP \(bu 2
 blake2b
 .IP \(bu 2
 blake2s
 .IP \(bu 2
 md5
 .IP \(bu 2
@@ -226,17 +226,17 @@
 .IP \(bu 2
 sha3_512
 .IP \(bu 2
 sha512
 .IP \(bu 2
 xxh64: XXH64 checksum of this file (note: this is NOT a cryptographic hash!)
 .IP \(bu 2
-archiveid
+archiveid: internal ID of the archive
 .IP \(bu 2
-archivename
+archivename: name of the archive
 .IP \(bu 2
 extra: prepends {target} with \(dq \-> \(dq for soft links and \(dq link to \(dq for hard links
 .IP \(bu 2
 health: either \(dqhealthy\(dq (file ok) or \(dqbroken\(dq (if file has all\-zero replacement chunks)
 .UNINDENT
 .SH SEE ALSO
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-match-archives.1` & `borgbackup-2.0.0b6/docs/man/borg-match-archives.1`

 * *Files 4% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-MATCH-ARCHIVES" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-MATCH-ARCHIVES" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-match-archives \- Details regarding match-archives
 .SH DESCRIPTION
 .sp
 The \fB\-\-match\-archives\fP option matches a given pattern against the list of all archive
 names in the repository.
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-mount.1` & `borgbackup-2.0.0b6/docs/man/borg-mount.1`

 * *Files 5% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-MOUNT" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-MOUNT" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-mount \- Mount archive or an entire repository as a FUSE filesystem
 .SH SYNOPSIS
 .sp
 borg [common options] mount [options] MOUNTPOINT [PATH...]
 .SH DESCRIPTION
 .sp
@@ -68,24 +68,24 @@
 manually. Unlike the \fBuid\fP and \fBgid\fP mount options which affect all files,
 \fBuser_id\fP and \fBgroup_id\fP affect the user and group id of the mounted
 (base) directory.
 .sp
 Additional mount options supported by borg:
 .INDENT 0.0
 .IP \(bu 2
-versions: when used with a repository mount, this gives a merged, versioned
+\fBversions\fP: when used with a repository mount, this gives a merged, versioned
 view of the files in the archives. EXPERIMENTAL, layout may change in future.
 .IP \(bu 2
-allow_damaged_files: by default damaged files (where missing chunks were
-replaced with runs of zeros by borg check \fB\-\-repair\fP) are not readable and
+\fBallow_damaged_files\fP: by default damaged files (where missing chunks were
+replaced with runs of zeros by \fBborg check \-\-repair\fP) are not readable and
 return EIO (I/O error). Set this option to read such files.
 .IP \(bu 2
-ignore_permissions: for security reasons the \(dqdefault_permissions\(dq mount
-option is internally enforced by borg. \(dqignore_permissions\(dq can be given to
-not enforce \(dqdefault_permissions\(dq.
+\fBignore_permissions\fP: for security reasons the \fBdefault_permissions\fP mount
+option is internally enforced by borg. \fBignore_permissions\fP can be given to
+not enforce \fBdefault_permissions\fP\&.
 .UNINDENT
 .sp
 The BORG_MOUNT_DATA_CACHE_ENTRIES environment variable is meant for advanced users
 to tweak the performance. It sets the number of cached data chunks; additional
 memory usage can be up to ~8 MiB times this number. The default is the number
 of CPU cores.
 .sp
@@ -145,15 +145,15 @@
 .TP
 .BI \-\-older \ TIMESPAN
 consider archives older than (now \- TIMESPAN), e.g. 7d oder 12m.
 .TP
 .BI \-\-newer \ TIMESPAN
 consider archives newer than (now \- TIMESPAN), e.g. 7d or 12m.
 .UNINDENT
-.SS Exclusion options
+.SS Include/Exclude options
 .INDENT 0.0
 .TP
 .BI \-e \ PATTERN\fR,\fB \ \-\-exclude \ PATTERN
 exclude paths matching PATTERN
 .TP
 .BI \-\-exclude\-from \ EXCLUDEFILE
 read exclude patterns from EXCLUDEFILE, one per line
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-patterns.1` & `borgbackup-2.0.0b6/docs/man/borg-patterns.1`

 * *Files 4% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-PATTERNS" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-PATTERNS" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-patterns \- Details regarding patterns
 .SH DESCRIPTION
 .sp
 When specifying one or more file paths in a Borg command that supports
 patterns for the respective option or argument, you can apply the
 patterns described here to include only desired files and/or exclude
@@ -52,23 +52,21 @@
 Borg always stores all file paths normalized and relative to the
 current recursion root. The recursion root is also named \fBPATH\fP in
 Borg commands like \fIborg create\fP that do a file discovery, so do not
 confuse the root with the \fBPATH\fP argument of e.g. \fIborg extract\fP\&.
 .sp
 Starting with Borg 1.2, paths that are matched against patterns always
 appear relative. If you give \fB/absolute/\fP as root, the paths going
-into the matcher will look relative like \fBabsolute/.../file.ext\fP\&.
-If you give \fB\&../some/path\fP as root, the paths will look like
-\fBsome/path/.../file.ext\fP\&.
-.sp
-File patterns support five different styles. If followed by a colon \(aq:\(aq,
-the first two characters of a pattern are used as a style selector.
-Explicit style selection is necessary if a non\-default style is desired
-or when the desired pattern starts with two alphanumeric characters
-followed by a colon (i.e. \fBaa:something/*\fP).
+into the matcher will start with \fBabsolute/\fP\&.
+If you give \fB\&../../relative\fP as root, the paths will be normalized
+as \fBrelative/\fP\&.
+.sp
+Borg supports different pattern styles. To define a non\-default
+style for a specific pattern, prefix it with two characters followed
+by a colon \(aq:\(aq (i.e. \fBfm:path/*\fP, \fBsh:path/**\fP).
 .INDENT 0.0
 .TP
 .B \fI\%Fnmatch\fP, selector \fBfm:\fP
 This is the default style for \fB\-\-exclude\fP and \fB\-\-exclude\-from\fP\&.
 These patterns use a variant of shell pattern syntax, with \(aq*\(aq matching
 any number of characters, \(aq?\(aq matching any single character, \(aq[...]\(aq
 matching any single character specified, including ranges, and \(aq[!...]\(aq
@@ -84,15 +82,16 @@
 path separator is always removed.
 .TP
 .B Shell\-style patterns, selector \fBsh:\fP
 This is the default style for \fB\-\-pattern\fP and \fB\-\-patterns\-from\fP\&.
 Like fnmatch patterns these are similar to shell patterns. The difference
 is that the pattern may include \fB**/\fP for matching zero or more directory
 levels, \fB*\fP for matching zero or more arbitrary characters with the
-exception of any path separator. A leading path separator is always removed.
+exception of any path separator, \fB{}\fP containing comma\-separated
+alternative patterns. A leading path separator is always removed.
 .TP
 .B \fI\%Regular expressions\fP, selector \fBre:\fP
 Unlike shell patterns, regular expressions are not required to match the full
 path and any substring match is sufficient. It is strongly recommended to
 anchor patterns to the start (\(aq^\(aq), to the end (\(aq$\(aq) or both. Path
 separators (backslash for Windows and \(aq/\(aq on other systems) in paths are
 always normalized to a forward slash \(aq/\(aq before applying a pattern.
@@ -218,14 +217,41 @@
 .UNINDENT
 .sp
 The first matching pattern is used, so if an include pattern matches
 before an exclude pattern, the file is backed up. Note that a no\-recurse
 exclude stops examination of subdirectories so that potential includes
 will not match \- use normal excludes for such use cases.
 .sp
+Example:
+.INDENT 0.0
+.INDENT 3.5
+.sp
+.nf
+.ft C
+# Define the recursion root
+R /
+# Exclude all iso files in any directory
+\- **/*.iso
+# Explicitly include all inside etc and root
++ etc/**
++ root/**
+# Exclude a specific directory under each user\(aqs home directories
+\- home/*/.cache
+# Explicitly include everything in /home
++ home/**
+# Explicitly exclude some directories without recursing into them
+! re:^(dev|proc|run|sys|tmp)
+# Exclude all other files and directories
+# that are not specifically included earlier.
+\- **
+.ft P
+.fi
+.UNINDENT
+.UNINDENT
+.sp
 \fBTip: You can easily test your patterns with \-\-dry\-run and  \-\-list\fP:
 .INDENT 0.0
 .INDENT 3.5
 .sp
 .nf
 .ft C
 $ borg create \-\-dry\-run \-\-list \-\-patterns\-from patterns.txt archive
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-placeholders.1` & `borgbackup-2.0.0b6/docs/man/borg-placeholders.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-PLACEHOLDERS" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-PLACEHOLDERS" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-placeholders \- Details regarding placeholders
 .SH DESCRIPTION
 .sp
 Repository URLs, \fB\-\-name\fP, \fB\-a\fP / \fB\-\-match\-archives\fP, \fB\-\-comment\fP
 and \fB\-\-remote\-path\fP values support these placeholders:
 .INDENT 0.0
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-prune.1` & `borgbackup-2.0.0b6/docs/man/borg-prune.1`

 * *Files 3% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-PRUNE" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-PRUNE" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-prune \- Prune repository archives according to specified rules
 .SH SYNOPSIS
 .sp
 borg [common options] prune [options]
 .SH DESCRIPTION
 .sp
@@ -85,14 +85,18 @@
 keep the last N archives under the assumption that you do not create more than one
 backup archive in the same second).
 .sp
 When using \fB\-\-stats\fP, you will get some statistics about how much data was
 deleted \- the \(dqDeleted data\(dq deduplicated size there is most interesting as
 that is how much your repository will shrink.
 Please note that the \(dqAll archives\(dq stats refer to the state after pruning.
+.sp
+You can influence how the \fB\-\-list\fP output is formatted by using the \fB\-\-short\fP
+option (less wide output) or by giving a custom format using \fB\-\-format\fP (see
+the \fBborg rlist\fP description for more details about the format string).
 .SH OPTIONS
 .sp
 See \fIborg\-common(1)\fP for common options of Borg commands.
 .SS options
 .INDENT 0.0
 .TP
 .B  \-n\fP,\fB  \-\-dry\-run
@@ -103,14 +107,26 @@
 .TP
 .B  \-s\fP,\fB  \-\-stats
 print statistics for the deleted archive
 .TP
 .B  \-\-list
 output verbose list of archives it keeps/prunes
 .TP
+.B  \-\-short
+use a less wide archive part format
+.TP
+.B  \-\-list\-pruned
+output verbose list of archives it prunes
+.TP
+.B  \-\-list\-kept
+output verbose list of archives it keeps
+.TP
+.BI \-\-format \ FORMAT
+specify format for the archive part (default: \(dq{archive:<36} {time} [{id}]\(dq)
+.TP
 .BI \-\-keep\-within \ INTERVAL
 keep all archives within this time interval
 .TP
 .B  \-\-keep\-last\fP,\fB  \-\-keep\-secondly
 number of secondly archives to keep
 .TP
 .B  \-\-keep\-minutely
@@ -154,15 +170,15 @@
 .UNINDENT
 .SH EXAMPLES
 .sp
 Be careful, prune is a potentially dangerous command, it will remove backup
 archives.
 .sp
 The default of prune is to apply to \fBall archives in the repository\fP unless
-you restrict its operation to a subset of the archives using \fB\-a\fP / \fB\-\-glob\-archives\fP\&.
+you restrict its operation to a subset of the archives using \fB\-a\fP / \fB\-\-match\-archives\fP\&.
 When using \fB\-a\fP, be careful to choose a good pattern \- e.g. do not use a
 prefix \(dqfoo\(dq if you do not also want to match \(dqfoobar\(dq.
 .sp
 It is strongly recommended to always run \fBprune \-v \-\-list \-\-dry\-run ...\fP
 first so you will see what it would do without it actually doing anything.
 .INDENT 0.0
 .INDENT 3.5
@@ -171,15 +187,15 @@
 .ft C
 # Keep 7 end of day and 4 additional end of week archives.
 # Do a dry\-run without actually deleting anything.
 $ borg prune \-v \-\-list \-\-dry\-run \-\-keep\-daily=7 \-\-keep\-weekly=4
 
 # Same as above but only apply to archive names starting with the hostname
 # of the machine followed by a \(dq\-\(dq character:
-$ borg prune \-v \-\-list \-\-keep\-daily=7 \-\-keep\-weekly=4 \-a \(aq{hostname}\-*\(aq
+$ borg prune \-v \-\-list \-\-keep\-daily=7 \-\-keep\-weekly=4 \-a \(aqsh:{hostname}\-*\(aq
 # actually free disk space:
 $ borg compact
 
 # Keep 7 end of day, 4 additional end of week archives,
 # and an end of month archive for every month:
 $ borg prune \-v \-\-list \-\-keep\-daily=7 \-\-keep\-weekly=4 \-\-keep\-monthly=\-1
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-rcompress.1` & `borgbackup-2.0.0b6/docs/man/borg-rcompress.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-RCOMPRESS" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-RCOMPRESS" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-rcompress \- Repository (re-)compression
 .SH SYNOPSIS
 .sp
 borg [common options] rcompress [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-rcreate.1` & `borgbackup-2.0.0b6/docs/man/borg-rcreate.1`

 * *Files 0% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-RCREATE" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-RCREATE" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-rcreate \- Create a new, empty repository
 .SH SYNOPSIS
 .sp
 borg [common options] rcreate [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-rdelete.1` & `borgbackup-2.0.0b6/docs/man/borg-rdelete.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-RDELETE" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-RDELETE" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-rdelete \- Delete a repository
 .SH SYNOPSIS
 .sp
 borg [common options] rdelete [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-recreate.1` & `borgbackup-2.0.0b6/docs/man/borg-recreate.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-RECREATE" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-RECREATE" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-recreate \- Re-create archives
 .SH SYNOPSIS
 .sp
 borg [common options] recreate [options] [PATH...]
 .SH DESCRIPTION
 .sp
@@ -104,15 +104,15 @@
 .TP
 .B  \-n\fP,\fB  \-\-dry\-run
 do not change anything
 .TP
 .B  \-s\fP,\fB  \-\-stats
 print statistics at end
 .UNINDENT
-.SS Exclusion options
+.SS Include/Exclude options
 .INDENT 0.0
 .TP
 .BI \-e \ PATTERN\fR,\fB \ \-\-exclude \ PATTERN
 exclude paths matching PATTERN
 .TP
 .BI \-\-exclude\-from \ EXCLUDEFILE
 read exclude patterns from EXCLUDEFILE, one per line
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-rename.1` & `borgbackup-2.0.0b6/docs/man/borg-rename.1`

 * *Files 6% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-RENAME" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-RENAME" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-rename \- Rename an existing archive
 .SH SYNOPSIS
 .sp
 borg [common options] rename [options] OLDNAME NEWNAME
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-rinfo.1` & `borgbackup-2.0.0b6/docs/man/borg-rinfo.1`

 * *Files 0% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-RINFO" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-RINFO" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-rinfo \- Show repository infos
 .SH SYNOPSIS
 .sp
 borg [common options] rinfo [options]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-rlist.1` & `borgbackup-2.0.0b6/docs/man/borg-rlist.1`

 * *Files 4% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-RLIST" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-RLIST" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-rlist \- List the archives contained in a repository
 .SH SYNOPSIS
 .sp
 borg [common options] rlist [options]
 .SH DESCRIPTION
 .sp
@@ -129,21 +129,21 @@
 .IP \(bu 2
 NEWLINE: OS dependent line separator
 .IP \(bu 2
 NL: alias of NEWLINE
 .IP \(bu 2
 NUL: NUL character for creating print0 / xargs \-0 like output
 .IP \(bu 2
-SPACE
+SPACE: space character
 .IP \(bu 2
-TAB
+TAB: tab character
 .IP \(bu 2
-CR
+CR: carriage return character
 .IP \(bu 2
-LF
+LF: line feed character
 .UNINDENT
 .sp
 Keys available only when listing archives in a repository:
 .INDENT 0.0
 .IP \(bu 2
 archive: archive name
 .IP \(bu 2
@@ -160,14 +160,18 @@
 end: time (end) of creation of the archive
 .IP \(bu 2
 command_line: command line which was used to create the archive
 .IP \(bu 2
 hostname: hostname of host on which this archive was created
 .IP \(bu 2
 username: username of user who created this archive
+.IP \(bu 2
+size: size of this archive (data plus metadata, not considering compression and deduplication)
+.IP \(bu 2
+nfiles: count of files in this archive
 .UNINDENT
 .SH SEE ALSO
 .sp
 \fIborg\-common(1)\fP
 .SH AUTHOR
 The Borg Collective
 .\" Generated by docutils manpage writer.
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-serve.1` & `borgbackup-2.0.0b6/docs/man/borg-serve.1`

 * *Files 5% similar despite different names*

```diff
@@ -23,23 +23,35 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-SERVE" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-SERVE" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-serve \- Start in server mode. This command is usually not used manually.
 .SH SYNOPSIS
 .sp
 borg [common options] serve [options]
 .SH DESCRIPTION
 .sp
-This command starts a repository server process. This command is usually not used manually.
+This command starts a repository server process.
+.sp
+borg serve can currently support:
+.INDENT 0.0
+.IP \(bu 2
+Getting automatically started via ssh when the borg client uses a \fI\%ssh://\fP\&...
+remote repository. In this mode, \fIborg serve\fP will live until that ssh connection
+gets terminated.
+.IP \(bu 2
+Getting started by some other means (not by the borg client) as a long\-running socket
+server to be used for borg clients using a socket://... repository (see the \fI\-\-socket\fP
+option if you do not want to use the default path for the socket and pid file).
+.UNINDENT
 .SH OPTIONS
 .sp
 See \fIborg\-common(1)\fP for common options of Borg commands.
 .SS options
 .INDENT 0.0
 .TP
 .BI \-\-restrict\-to\-path \ PATH
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-transfer.1` & `borgbackup-2.0.0b6/docs/man/borg-transfer.1`

 * *Files 14% similar despite different names*

```diff
@@ -23,24 +23,32 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-TRANSFER" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-TRANSFER" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-transfer \- archives transfer from other repository, optionally upgrade data format
 .SH SYNOPSIS
 .sp
 borg [common options] transfer [options]
 .SH DESCRIPTION
 .sp
 This command transfers archives from one repository to another repository.
 Optionally, it can also upgrade the transferred data.
+Optionally, it can also recompress the transferred data.
+.sp
+It is easiest (and fastest) to give \fB\-\-compression=COMPRESSION \-\-recompress=never\fP using
+the same COMPRESSION mode as in the SRC_REPO \- borg will use that COMPRESSION for metadata (in
+any case) and keep data compressed \(dqas is\(dq (saves time as no data compression is needed).
+.sp
+If you want to globally change compression while transferring archives to the DST_REPO,
+give \fB\-\-compress=WANTED_COMPRESSION \-\-recompress=always\fP\&.
 .sp
 Suggested use for general purpose archive transfer (not repo upgrades):
 .INDENT 0.0
 .INDENT 3.5
 .sp
 .nf
 .ft C
@@ -56,25 +64,31 @@
 .fi
 .UNINDENT
 .UNINDENT
 .sp
 The default is to transfer all archives, including checkpoint archives.
 .sp
 You could use the misc. archive filter options to limit which archives it will
-transfer, e.g. using the \-a option. This is recommended for big
+transfer, e.g. using the \fB\-a\fP option. This is recommended for big
 repositories with multiple data sets to keep the runtime per invocation lower.
 .sp
 For repository upgrades (e.g. from a borg 1.2 repo to a related borg 2.0 repo), usage is
 quite similar to the above:
 .INDENT 0.0
 .INDENT 3.5
 .sp
 .nf
 .ft C
-borg \-\-repo=DST_REPO transfer \-\-other\-repo=SRC_REPO \-\-upgrader=From12To20
+# fast: compress metadata with zstd,3, but keep data chunks compressed as they are:
+borg \-\-repo=DST_REPO transfer \-\-other\-repo=SRC_REPO \-\-upgrader=From12To20 \e
+     \-\-compress=zstd,3 \-\-recompress=never
+
+# compress metadata and recompress data with zstd,3
+borg \-\-repo=DST_REPO transfer \-\-other\-repo=SRC_REPO \-\-upgrader=From12To20 \e
+     \-\-compress=zstd,3 \-\-recompress=always
 .ft P
 .fi
 .UNINDENT
 .UNINDENT
 .SH OPTIONS
 .sp
 See \fIborg\-common(1)\fP for common options of Borg commands.
@@ -85,14 +99,20 @@
 do not change repository, just check
 .TP
 .BI \-\-other\-repo \ SRC_REPOSITORY
 transfer archives from the other repository
 .TP
 .BI \-\-upgrader \ UPGRADER
 use the upgrader to convert transferred data (default: no conversion)
+.TP
+.BI \-C \ COMPRESSION\fR,\fB \ \-\-compression \ COMPRESSION
+select compression algorithm, see the output of the \(dqborg help compression\(dq command for details.
+.TP
+.BI \-\-recompress \ MODE
+recompress data chunks according to \fIMODE\fP and \fB\-\-compression\fP\&. Possible modes are \fIalways\fP: recompress unconditionally; and \fInever\fP: do not recompress (faster: re\-uses compressed data chunks w/o change).If no MODE is given, \fIalways\fP will be used. Not passing \-\-recompress is equivalent to \(dq\-\-recompress never\(dq.
 .UNINDENT
 .SS Archive filters
 .INDENT 0.0
 .TP
 .BI \-a \ PATTERN\fR,\fB \ \-\-match\-archives \ PATTERN
 only consider archive names matching the pattern. see \(dqborg help match\-archives\(dq.
 .TP
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-umount.1` & `borgbackup-2.0.0b6/docs/man/borg-umount.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-UMOUNT" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-UMOUNT" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-umount \- un-mount the FUSE filesystem
 .SH SYNOPSIS
 .sp
 borg [common options] umount [options] MOUNTPOINT
 .SH DESCRIPTION
 .sp
@@ -70,15 +70,15 @@
 \-rw\-rw\-r\-\- 1 user group 12357 Aug 26 21:19 doc.cda00bc9.txt
 \-rw\-rw\-r\-\- 1 user group 12204 Aug 26 21:04 doc.fa760f28.txt
 $ borg umount /tmp/mymountpoint
 
 # Archive filters are supported.
 # These are especially handy for the \(dqversions view\(dq,
 # which does not support lazy processing of archives.
-$ borg mount \-o versions \-\-glob\-archives \(aq*\-my\-home\(aq \-\-last 10 /tmp/mymountpoint
+$ borg mount \-o versions \-\-match\-archives \(aqsh:*\-my\-home\(aq \-\-last 10 /tmp/mymountpoint
 
 # Exclusion options are supported.
 # These can speed up mounting and lower memory needs significantly.
 $ borg mount /path/to/repo /tmp/mymountpoint only/that/path
 $ borg mount \-\-exclude \(aq...\(aq /tmp/mymountpoint
 .ft P
 .fi
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg-upgrade.1` & `borgbackup-2.0.0b6/docs/man/borg-upgrade.1`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/man/borg-with-lock.1` & `borgbackup-2.0.0b6/docs/man/borg-with-lock.1`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG-WITH-LOCK" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG-WITH-LOCK" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg-with-lock \- run a user specified command with the repository lock held
 .SH SYNOPSIS
 .sp
 borg [common options] with\-lock [options] COMMAND [ARGS...]
 .SH DESCRIPTION
 .sp
```

### Comparing `borgbackup-2.0.0b5/docs/man/borg.1` & `borgbackup-2.0.0b6/docs/man/borg.1`

 * *Files 3% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORG" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORG" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borg \- deduplicating and encrypting backup tool
 .SH SYNOPSIS
 .sp
 borg [common options] <command> [options] [arguments]
 .SH DESCRIPTION
 .\" we don't include the README.rst here since we want to keep this terse.
@@ -164,16 +164,16 @@
 .ft C
 $ borg \-r /path/to/repo delete \-a Monday
 .ft P
 .fi
 .UNINDENT
 .UNINDENT
 .sp
-Please note the \fB\-a\fP option here (short for \fB\-\-glob\-archives\fP) which enables you
-to give a globbing pattern to delete multiple archives, like \fB\-a \(aqoldcrap\-*\(aq\fP\&.
+Please note the \fB\-a\fP option here (short for \fB\-\-match\-archives\fP) which enables you
+to give a pattern to delete multiple archives, like \fB\-a \(aqsh:oldcrap\-*\(aq\fP\&.
 You can also combine this with \fB\-\-first\fP, \fB\-\-last\fP and \fB\-\-sort\-by\fP\&.
 Be careful, always first use with \fB\-\-dry\-run\fP and \fB\-\-list\fP!
 .IP 8. 3
 Recover disk space by compacting the segment files in the repo:
 .INDENT 3.0
 .INDENT 3.5
 .sp
@@ -492,14 +492,27 @@
 .B retry_erofs
 Retry opening a file without O_NOATIME if opening a file with O_NOATIME
 caused EROFS. You will need this to make archives from volume shadow copies
 in WSL1 (Windows Subsystem for Linux 1).
 .UNINDENT
 .UNINDENT
 .TP
+.B Output formatting:
+.INDENT 7.0
+.TP
+.B BORG_LIST_FORMAT
+Giving the default value for \fBborg list \-\-format=X\fP\&.
+.TP
+.B BORG_RLIST_FORMAT
+Giving the default value for \fBborg rlist \-\-format=X\fP\&.
+.TP
+.B BORG_PRUNE_FORMAT
+Giving the default value for \fBborg prune \-\-format=X\fP\&.
+.UNINDENT
+.TP
 .B Some automatic \(dqanswerers\(dq (if set, they automatically answer confirmation questions):
 .INDENT 7.0
 .TP
 .B BORG_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK=no (or =yes)
 For \(dqWarning: Attempting to access a previously unknown unencrypted repository\(dq
 .TP
 .B BORG_RELOCATED_REPO_ACCESS_IS_OK=no (or =yes)
@@ -536,25 +549,52 @@
 .TP
 .B BORG_CONFIG_DIR
 Defaults to \fB$BORG_BASE_DIR/.config/borg\fP\&. If \fBBORG_BASE_DIR\fP is not explicitly set while
 \fI\%XDG env var\fP \fBXDG_CONFIG_HOME\fP is set, then \fB$XDG_CONFIG_HOME/borg\fP is being used instead.
 This directory contains all borg configuration directories, see the FAQ
 for a security advisory about the data in this directory: \fIhome_config_borg\fP
 .TP
+.B BORG_DATA_DIR
+Defaults to \fB$BORG_BASE_DIR/.local/share/borg\fP\&. If \fBBORG_BASE_DIR\fP is not explicitly set while
+\fI\%XDG env var\fP \fBXDG_DATA_HOME\fP is set, then \fB$XDG_DATA_HOME/borg\fP is being used instead.
+This directory contains all borg data directories, see the FAQ
+for a security advisory about the data in this directory: \fIhome_data_borg\fP
+.TP
+.B BORG_RUNTIME_DIR
+Defaults to \fB$BORG_BASE_DIR/.cache/borg\fP\&. If \fBBORG_BASE_DIR\fP is not explicitly set while
+\fI\%XDG env var\fP \fBXDG_RUNTIME_DIR\fP is set, then \fB$XDG_RUNTIME_DIR/borg\fP is being used instead.
+This directory contains borg runtime files, like e.g. the socket file.
+.TP
 .B BORG_SECURITY_DIR
-Defaults to \fB$BORG_CONFIG_DIR/security\fP\&.
-This directory contains information borg uses to track its usage of NONCES (\(dqnumbers used
-once\(dq \- usually in encryption context) and other security relevant data.
+Defaults to \fB$BORG_DATA_DIR/security\fP\&.
+This directory contains security relevant data.
 .TP
 .B BORG_KEYS_DIR
 Defaults to \fB$BORG_CONFIG_DIR/keys\fP\&.
 This directory contains keys for encrypted repositories.
 .TP
 .B BORG_KEY_FILE
-When set, use the given filename as repository key file.
+When set, use the given path as repository key file. Please note that this is only
+for rather special applications that externally fully manage the key files:
+.INDENT 7.0
+.IP \(bu 2
+this setting only applies to the keyfile modes (not to the repokey modes).
+.IP \(bu 2
+using a full, absolute path to the key file is recommended.
+.IP \(bu 2
+all directories in the given path must exist.
+.IP \(bu 2
+this setting forces borg to use the key file at the given location.
+.IP \(bu 2
+the key file must either exist (for most commands) or will be created (\fBborg rcreate\fP).
+.IP \(bu 2
+you need to give a different path for different repositories.
+.IP \(bu 2
+you need to point to the correct key file matching the repository the command will operate on.
+.UNINDENT
 .TP
 .B TMPDIR
 This is where temporary files are stored (might need a lot of temporary space for some
 operations), see \fI\%tempfile\fP for details.
 .UNINDENT
 .TP
 .B Building:
```

### Comparing `borgbackup-2.0.0b5/docs/man/borgfs.1` & `borgbackup-2.0.0b6/docs/man/borgfs.1`

 * *Files 2% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 . RE
 .\" indent \\n[an-margin]
 .\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .nr rst2man-indent-level -1
 .\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .in \\n[rst2man-indent\\n[rst2man-indent-level]]u
 ..
-.TH "BORGFS" 1 "2023-02-26" "" "borg backup tool"
+.TH "BORGFS" 1 "2023-06-11" "" "borg backup tool"
 .SH NAME
 borgfs \- Mount archive or an entire repository as a FUSE filesystem
 .SH SYNOPSIS
 .sp
 borgfs [options] MOUNTPOINT [PATH...]
 .SH DESCRIPTION
 .sp
@@ -89,15 +89,15 @@
 .TP
 .BI \-\-older \ TIMESPAN
 consider archives older than (now \- TIMESPAN), e.g. 7d oder 12m.
 .TP
 .BI \-\-newer \ TIMESPAN
 consider archives newer than (now \- TIMESPAN), e.g. 7d or 12m.
 .UNINDENT
-.SS Exclusion options
+.SS Include/Exclude options
 .INDENT 0.0
 .TP
 .BI \-e \ PATTERN\fR,\fB \ \-\-exclude \ PATTERN
 exclude paths matching PATTERN
 .TP
 .BI \-\-exclude\-from \ EXCLUDEFILE
 read exclude patterns from EXCLUDEFILE, one per line
```

### Comparing `borgbackup-2.0.0b5/docs/man_intro.rst` & `borgbackup-2.0.0b6/docs/man_intro.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/asciinema/Vagrantfile` & `borgbackup-2.0.0b6/docs/misc/asciinema/Vagrantfile`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/asciinema/advanced.json` & `borgbackup-2.0.0b6/docs/misc/asciinema/advanced.json`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/asciinema/advanced.tcl` & `borgbackup-2.0.0b6/docs/misc/asciinema/advanced.tcl`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/asciinema/basic.json` & `borgbackup-2.0.0b6/docs/misc/asciinema/basic.json`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/asciinema/basic.tcl` & `borgbackup-2.0.0b6/docs/misc/asciinema/basic.tcl`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/asciinema/install.json` & `borgbackup-2.0.0b6/docs/misc/asciinema/install.json`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/asciinema/install.tcl` & `borgbackup-2.0.0b6/docs/misc/asciinema/install.tcl`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/asciinema/sample-wallpapers.txt` & `borgbackup-2.0.0b6/docs/misc/asciinema/sample-wallpapers.txt`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/benchmark-crud.txt` & `borgbackup-2.0.0b6/docs/misc/benchmark-crud.txt`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/borg-data-flow.odg` & `borgbackup-2.0.0b6/docs/misc/borg-data-flow.odg`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/borg-data-flow.png` & `borgbackup-2.0.0b6/docs/misc/borg-data-flow.png`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/create_chunker-params.txt` & `borgbackup-2.0.0b6/docs/misc/create_chunker-params.txt`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/internals-picture.txt` & `borgbackup-2.0.0b6/docs/misc/internals-picture.txt`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/misc/prune-example.txt` & `borgbackup-2.0.0b6/docs/misc/prune-example.txt`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/quickstart.rst` & `borgbackup-2.0.0b6/docs/quickstart.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/quickstart_example.rst.inc` & `borgbackup-2.0.0b6/docs/quickstart_example.rst.inc`

 * *Files 4% similar despite different names*

```diff
@@ -44,16 +44,16 @@
 
     $ borg -r /path/to/repo extract Monday
 
 7. Delete the *Monday* archive (please note that this does **not** free repo disk space)::
 
     $ borg -r /path/to/repo delete -a Monday
 
-   Please note the ``-a`` option here (short for ``--glob-archives``) which enables you
-   to give a globbing pattern to delete multiple archives, like ``-a 'oldcrap-*'``.
+   Please note the ``-a`` option here (short for ``--match-archives``) which enables you
+   to give a pattern to delete multiple archives, like ``-a 'sh:oldcrap-*'``.
    You can also combine this with ``--first``, ``--last`` and ``--sort-by``.
    Be careful, always first use with ``--dry-run`` and ``--list``!
 
 8. Recover disk space by compacting the segment files in the repo::
 
     $ borg -r /path/to/repo compact
```

### Comparing `borgbackup-2.0.0b5/docs/support.rst` & `borgbackup-2.0.0b6/docs/support.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/benchmark_cpu.rst.inc` & `borgbackup-2.0.0b6/docs/usage/benchmark_cpu.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/benchmark_crud.rst.inc` & `borgbackup-2.0.0b6/docs/usage/benchmark_crud.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/borgfs.rst.inc` & `borgbackup-2.0.0b6/docs/usage/borgfs.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/break-lock.rst.inc` & `borgbackup-2.0.0b6/docs/usage/break-lock.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/change-passphrase.rst.inc` & `borgbackup-2.0.0b6/docs/usage/change-passphrase.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/check.rst.inc` & `borgbackup-2.0.0b6/docs/usage/check.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/common-options.rst.inc` & `borgbackup-2.0.0b6/docs/usage/common-options.rst.inc`

 * *Files 20% similar despite different names*

```diff
@@ -14,8 +14,9 @@
 --show-rc                show/log the return code (rc)
 --umask M                set umask to M (local only, default: 0077)
 --remote-path PATH       use PATH as borg executable on the remote (default: "borg")
 --upload-ratelimit RATE    set network upload rate limit in kiByte/s (default: 0=unlimited)
 --upload-buffer UPLOAD_BUFFER    set network upload buffer size in MiB. (default: 0=no buffer)
 --debug-profile FILE     Write execution profile in Borg format into FILE. For local use a Python-compatible file can be generated by suffixing FILE with ".pyprof".
 --rsh RSH                Use this command to connect to the 'borg serve' process (default: 'ssh')
+--socket PATH            Use UNIX DOMAIN (IPC) socket at PATH for client/server communication with socket: protocol.
 -r REPO, --repo REPO     repository to use
```

### Comparing `borgbackup-2.0.0b5/docs/usage/compact.rst.inc` & `borgbackup-2.0.0b6/docs/usage/compact.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/config.rst.inc` & `borgbackup-2.0.0b6/docs/usage/config.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/create.rst` & `borgbackup-2.0.0b6/docs/usage/create.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/create.rst.inc` & `borgbackup-2.0.0b6/docs/usage/create.rst.inc`

 * *Files 2% similar despite different names*

```diff
@@ -39,25 +39,25 @@
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--stdin-group GROUP``                           | set group GROUP in archive for stdin data (default: do not store group/gid)                                                                                                                       |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--stdin-mode M``                                | set mode to M in archive for stdin data (default: 0660)                                                                                                                                           |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--content-from-command``                        | interpret PATH as command and store its stdout. See also section Reading from stdin below.                                                                                                        |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-    |                                                       | ``--paths-from-stdin``                            | read DELIM-separated list of paths to back up from stdin. Will not recurse into directories.                                                                                                      |
+    |                                                       | ``--paths-from-stdin``                            | read DELIM-separated list of paths to back up from stdin. All control is external: it will back up all files given - no more, no less.                                                            |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--paths-from-command``                          | interpret PATH as command and treat its output as ``--paths-from-stdin``                                                                                                                          |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-    |                                                       | ``--paths-delimiter DELIM``                       | set path delimiter for ``--paths-from-stdin`` and ``--paths-from-command`` (default: \n)                                                                                                          |
+    |                                                       | ``--paths-delimiter DELIM``                       | set path delimiter for ``--paths-from-stdin`` and ``--paths-from-command`` (default: ``\n``)                                                                                                      |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     | .. class:: borg-common-opt-ref                                                                                                                                                                                                                                                                                |
     |                                                                                                                                                                                                                                                                                                               |
     | :ref:`common_options`                                                                                                                                                                                                                                                                                         |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-    | **Exclusion options**                                                                                                                                                                                                                                                                                         |
+    | **Include/Exclude options**                                                                                                                                                                                                                                                                                   |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``-e PATTERN``, ``--exclude PATTERN``             | exclude paths matching PATTERN                                                                                                                                                                    |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--exclude-from EXCLUDEFILE``                    | read exclude patterns from EXCLUDEFILE, one per line                                                                                                                                              |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--pattern PATTERN``                             | include/exclude paths matching PATTERN                                                                                                                                                            |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
@@ -69,15 +69,15 @@
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--keep-exclude-tags``                           | if tag objects are specified with ``--exclude-if-present``, don't omit the tag objects themselves from the backup archive                                                                         |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--exclude-nodump``                              | exclude files flagged NODUMP                                                                                                                                                                      |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     | **Filesystem options**                                                                                                                                                                                                                                                                                        |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-    |                                                       | ``-x``, ``--one-file-system``                     | stay in the same file system and do not store mount points of other file systems.  This might behave different from your expectations, see the docs.                                              |
+    |                                                       | ``-x``, ``--one-file-system``                     | stay in the same file system and do not store mount points of other file systems - this might behave different from your expectations, see the description below.                                 |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--numeric-ids``                                 | only store numeric user and group identifiers                                                                                                                                                     |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--atime``                                       | do store atime into archive                                                                                                                                                                       |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--noctime``                                     | do not store ctime into archive                                                                                                                                                                   |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
@@ -134,35 +134,35 @@
         --json          output stats as JSON. Implies ``--stats``.
         --no-cache-sync    experimental: do not synchronize the cache. Implies not using the files cache.
         --stdin-name NAME    use NAME in archive for stdin data (default: 'stdin')
         --stdin-user USER    set user USER in archive for stdin data (default: do not store user/uid)
         --stdin-group GROUP    set group GROUP in archive for stdin data (default: do not store group/gid)
         --stdin-mode M    set mode to M in archive for stdin data (default: 0660)
         --content-from-command    interpret PATH as command and store its stdout. See also section Reading from stdin below.
-        --paths-from-stdin    read DELIM-separated list of paths to back up from stdin. Will not recurse into directories.
+        --paths-from-stdin    read DELIM-separated list of paths to back up from stdin. All control is external: it will back up all files given - no more, no less.
         --paths-from-command    interpret PATH as command and treat its output as ``--paths-from-stdin``
-        --paths-delimiter DELIM    set path delimiter for ``--paths-from-stdin`` and ``--paths-from-command`` (default: \n) 
+        --paths-delimiter DELIM    set path delimiter for ``--paths-from-stdin`` and ``--paths-from-command`` (default: ``\n``) 
 
 
     :ref:`common_options`
         |
 
-    Exclusion options
+    Include/Exclude options
         -e PATTERN, --exclude PATTERN     exclude paths matching PATTERN
         --exclude-from EXCLUDEFILE        read exclude patterns from EXCLUDEFILE, one per line
         --pattern PATTERN                 include/exclude paths matching PATTERN
         --patterns-from PATTERNFILE       read include/exclude patterns from PATTERNFILE, one per line
         --exclude-caches                  exclude directories that contain a CACHEDIR.TAG file (http://www.bford.info/cachedir/spec.html)
         --exclude-if-present NAME         exclude directories that are tagged by containing a filesystem object with the given NAME
         --keep-exclude-tags               if tag objects are specified with ``--exclude-if-present``, don't omit the tag objects themselves from the backup archive
         --exclude-nodump                  exclude files flagged NODUMP
 
 
     Filesystem options
-        -x, --one-file-system     stay in the same file system and do not store mount points of other file systems.  This might behave different from your expectations, see the docs.
+        -x, --one-file-system     stay in the same file system and do not store mount points of other file systems - this might behave different from your expectations, see the description below.
         --numeric-ids             only store numeric user and group identifiers
         --atime                   do store atime into archive
         --noctime                 do not store ctime into archive
         --nobirthtime             do not store birthtime (creation date) into archive
         --noflags                 do not read and store flags (e.g. NODUMP, IMMUTABLE) into archive
         --noacls                  do not read and store ACLs into archive
         --noxattrs                do not read and store xattrs into archive
@@ -272,21 +272,21 @@
 only include the objects specified by ``--exclude-if-present`` in your backup,
 and not include any other contents of the containing folder, this can be enabled
 through using the ``--keep-exclude-tags`` option.
 
 The ``-x`` or ``--one-file-system`` option excludes directories, that are mountpoints (and everything in them).
 It detects mountpoints by comparing the device number from the output of ``stat()`` of the directory and its
 parent directory. Specifically, it excludes directories for which ``stat()`` reports a device number different
-from the device number of their parent. Be aware that in Linux (and possibly elsewhere) there are directories
-with device number different from their parent, which the kernel does not consider a mountpoint and also the
-other way around. Examples are bind mounts (possibly same device number, but always a mountpoint) and ALL
-subvolumes of a btrfs (different device number from parent but not necessarily a mountpoint). Therefore when
-using ``--one-file-system``, one should make doubly sure that the backup works as intended especially when using
-btrfs. This is even more important, if the btrfs layout was created by someone else, e.g. a distribution
-installer.
+from the device number of their parent.
+In general: be aware that there are directories with device number different from their parent, which the kernel
+does not consider a mountpoint and also the other way around.
+Linux examples for this are bind mounts (possibly same device number, but always a mountpoint) and ALL
+subvolumes of a btrfs (different device number from parent but not necessarily a mountpoint).
+macOS examples are the apfs mounts of a typical macOS installation.
+Therefore, when using ``--one-file-system``, you should double-check that the backup works as intended.
 
 
 .. _list_item_flags:
 
 Item flags
 ++++++++++
```

### Comparing `borgbackup-2.0.0b5/docs/usage/debug.rst` & `borgbackup-2.0.0b6/docs/usage/debug.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/delete.rst.inc` & `borgbackup-2.0.0b6/docs/usage/delete.rst.inc`

 * *Files 9% similar despite different names*

```diff
@@ -19,16 +19,14 @@
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``--list``                                        | output verbose list of archives                                                                   |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``--consider-checkpoints``                        | consider checkpoint archives for deletion (default: not considered).                              |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``-s``, ``--stats``                               | print statistics for the deleted archive                                                          |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
-    |                                                                             | ``--cache-only``                                  | delete only the local cache for the given repository                                              |
-    +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``--force``                                       | force deletion of corrupted archives, use ``--force --force`` in case ``--force`` does not work.  |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``-c SECONDS``, ``--checkpoint-interval SECONDS`` | write checkpoint every SECONDS seconds (Default: 1800)                                            |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     | .. class:: borg-common-opt-ref                                                                                                                                                                                                      |
     |                                                                                                                                                                                                                                     |
     | :ref:`common_options`                                                                                                                                                                                                               |
@@ -65,15 +63,14 @@
 
 
     options
         -n, --dry-run    do not change repository
         --list          output verbose list of archives
         --consider-checkpoints    consider checkpoint archives for deletion (default: not considered).
         -s, --stats     print statistics for the deleted archive
-        --cache-only    delete only the local cache for the given repository
         --force         force deletion of corrupted archives, use ``--force --force`` in case ``--force`` does not work.
         -c SECONDS, --checkpoint-interval SECONDS    write checkpoint every SECONDS seconds (Default: 1800)
 
 
     :ref:`common_options`
         |
```

### Comparing `borgbackup-2.0.0b5/docs/usage/diff.rst` & `borgbackup-2.0.0b6/docs/usage/diff.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/diff.rst.inc` & `borgbackup-2.0.0b6/docs/usage/info.rst.inc`

 * *Files 23% similar despite different names*

```diff
@@ -1,102 +1,85 @@
 .. IMPORTANT: this file is auto-generated from borg's built-in help, do not edit!
 
-.. _borg_diff:
+.. _borg_info:
 
-borg diff
+borg info
 ---------
 .. code-block:: none
 
-    borg [common options] diff [options] ARCHIVE1 ARCHIVE2 [PATH...]
+    borg [common options] info [options]
 
 .. only:: html
 
     .. class:: borg-options-table
 
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    | **positional arguments**                                                                                                                                              |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``ARCHIVE1``                          | ARCHIVE1 name                                                         |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``ARCHIVE2``                          | ARCHIVE2 name                                                         |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``PATH``                              | paths of items inside the archives to compare; patterns are supported |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    | **options**                                                                                                                                                           |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``--numeric-ids``                     | only consider numeric user and group identifiers                      |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``--same-chunker-params``             | Override check of chunker parameters.                                 |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``--sort``                            | Sort the output lines by file path.                                   |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``--json-lines``                      | Format output as JSON Lines.                                          |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    | .. class:: borg-common-opt-ref                                                                                                                                        |
-    |                                                                                                                                                                       |
-    | :ref:`common_options`                                                                                                                                                 |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    | **Exclusion options**                                                                                                                                                 |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``-e PATTERN``, ``--exclude PATTERN`` | exclude paths matching PATTERN                                        |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``--exclude-from EXCLUDEFILE``        | read exclude patterns from EXCLUDEFILE, one per line                  |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``--pattern PATTERN``                 | include/exclude paths matching PATTERN                                |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
-    |                                                       | ``--patterns-from PATTERNFILE``       | read include/exclude patterns from PATTERNFILE, one per line          |
-    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------+
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    | **options**                                                                                                                                                                                                                    |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--json``                                   | format output as JSON                                                                             |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    | .. class:: borg-common-opt-ref                                                                                                                                                                                                 |
+    |                                                                                                                                                                                                                                |
+    | :ref:`common_options`                                                                                                                                                                                                          |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    | **Archive filters**  Archive filters can be applied to repository targets.                                                                                                                                                    |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``-a PATTERN``, ``--match-archives PATTERN`` | only consider archive names matching the pattern. see "borg help match-archives".                 |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--sort-by KEYS``                           | Comma-separated list of sorting keys; valid keys are: timestamp, name, id; default is: timestamp  |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--first N``                                | consider first N archives after other filters were applied                                        |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--last N``                                 | consider last N archives after other filters were applied                                         |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--oldest TIMESPAN``                        | consider archives between the oldest archive's timestamp and (oldest + TIMESPAN), e.g. 7d or 12m. |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--newest TIMESPAN``                        | consider archives between the newest archive's timestamp and (newest - TIMESPAN), e.g. 7d or 12m. |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--older TIMESPAN``                         | consider archives older than (now - TIMESPAN), e.g. 7d oder 12m.                                  |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--newer TIMESPAN``                         | consider archives newer than (now - TIMESPAN), e.g. 7d or 12m.                                    |
+    +-----------------------------------------------------------------------------+----------------------------------------------+---------------------------------------------------------------------------------------------------+
 
     .. raw:: html
 
         <script type='text/javascript'>
         $(document).ready(function () {
             $('.borg-options-table colgroup').remove();
         })
         </script>
 
 .. only:: latex
 
-    ARCHIVE1
-        ARCHIVE1 name
-    ARCHIVE2
-        ARCHIVE2 name
-    PATH
-        paths of items inside the archives to compare; patterns are supported
 
 
     options
-        --numeric-ids    only consider numeric user and group identifiers
-        --same-chunker-params    Override check of chunker parameters.
-        --sort     Sort the output lines by file path.
-        --json-lines    Format output as JSON Lines. 
+        --json     format output as JSON
 
 
     :ref:`common_options`
         |
 
-    Exclusion options
-        -e PATTERN, --exclude PATTERN     exclude paths matching PATTERN
-        --exclude-from EXCLUDEFILE        read exclude patterns from EXCLUDEFILE, one per line
-        --pattern PATTERN                 include/exclude paths matching PATTERN
-        --patterns-from PATTERNFILE       read include/exclude patterns from PATTERNFILE, one per line
+    Archive filters
+        -a PATTERN, --match-archives PATTERN     only consider archive names matching the pattern. see "borg help match-archives".
+        --sort-by KEYS                           Comma-separated list of sorting keys; valid keys are: timestamp, name, id; default is: timestamp
+        --first N                                consider first N archives after other filters were applied
+        --last N                                 consider last N archives after other filters were applied
+        --oldest TIMESPAN                        consider archives between the oldest archive's timestamp and (oldest + TIMESPAN), e.g. 7d or 12m.
+        --newest TIMESPAN                        consider archives between the newest archive's timestamp and (newest - TIMESPAN), e.g. 7d or 12m.
+        --older TIMESPAN                         consider archives older than (now - TIMESPAN), e.g. 7d oder 12m.
+        --newer TIMESPAN                         consider archives newer than (now - TIMESPAN), e.g. 7d or 12m.
 
 
 Description
 ~~~~~~~~~~~
 
-This command finds differences (file contents, user/group/mode) between archives.
+This command displays detailed information about the specified archive.
 
-A repository location and an archive name must be specified for REPO::ARCHIVE1.
-ARCHIVE2 is just another archive name in same repository (no repository location
-allowed).
-
-For archives created with Borg 1.1 or newer diff automatically detects whether
-the archives are created with the same chunker params. If so, only chunk IDs
-are compared, which is very fast.
-
-For archives prior to Borg 1.1 chunk contents are compared by default.
-If you did not create the archives with different chunker params,
-pass ``--same-chunker-params``.
-Note that the chunker params changed from Borg 0.xx to 1.0.
-
-For more help on include/exclude patterns, see the :ref:`borg_patterns` command output.
+Please note that the deduplicated sizes of the individual archives do not add
+up to the deduplicated size of the repository ("all archives"), because the two
+are meaning different things:
+
+This archive / deduplicated size = amount of data stored ONLY for this archive
+= unique chunks of this archive.
+All archives / deduplicated size = amount of data stored in the repo
+= all chunks in the repository.
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `borgbackup-2.0.0b5/docs/usage/export-tar.rst.inc` & `borgbackup-2.0.0b6/docs/usage/export-tar.rst.inc`

 * *Files 2% similar despite different names*

```diff
@@ -29,15 +29,15 @@
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``--tar-format FMT``                  | select tar format: BORG, PAX or GNU                                                                       |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     | .. class:: borg-common-opt-ref                                                                                                                                                                            |
     |                                                                                                                                                                                                           |
     | :ref:`common_options`                                                                                                                                                                                     |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
-    | **Exclusion options**                                                                                                                                                                                     |
+    | **Include/Exclude options**                                                                                                                                                                               |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``-e PATTERN``, ``--exclude PATTERN`` | exclude paths matching PATTERN                                                                            |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``--exclude-from EXCLUDEFILE``        | read exclude patterns from EXCLUDEFILE, one per line                                                      |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``--pattern PATTERN``                 | include/exclude paths matching PATTERN                                                                    |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
@@ -69,15 +69,15 @@
         --list               output verbose list of items (files, dirs, ...)
         --tar-format FMT     select tar format: BORG, PAX or GNU
 
 
     :ref:`common_options`
         |
 
-    Exclusion options
+    Include/Exclude options
         -e PATTERN, --exclude PATTERN     exclude paths matching PATTERN
         --exclude-from EXCLUDEFILE        read exclude patterns from EXCLUDEFILE, one per line
         --pattern PATTERN                 include/exclude paths matching PATTERN
         --patterns-from PATTERNFILE       read include/exclude patterns from PATTERNFILE, one per line
         --strip-components NUMBER         Remove the specified number of leading path elements. Paths with fewer elements will be silently skipped.
```

### Comparing `borgbackup-2.0.0b5/docs/usage/extract.rst` & `borgbackup-2.0.0b6/docs/usage/extract.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/extract.rst.inc` & `borgbackup-2.0.0b6/docs/usage/extract.rst.inc`

 * *Files 2% similar despite different names*

```diff
@@ -33,19 +33,21 @@
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``--noxattrs``                        | do not extract/set xattrs                                                                                 |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``--stdout``                          | write all extracted data to stdout                                                                        |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``--sparse``                          | create holes in output sparse file from all-zero chunks                                                   |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
+    |                                                       | ``--continue``                        | continue a previously interrupted extraction of same archive                                              |
+    +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     | .. class:: borg-common-opt-ref                                                                                                                                                                            |
     |                                                                                                                                                                                                           |
     | :ref:`common_options`                                                                                                                                                                                     |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
-    | **Exclusion options**                                                                                                                                                                                     |
+    | **Include/Exclude options**                                                                                                                                                                               |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``-e PATTERN``, ``--exclude PATTERN`` | exclude paths matching PATTERN                                                                            |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``--exclude-from EXCLUDEFILE``        | read exclude patterns from EXCLUDEFILE, one per line                                                      |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                       | ``--pattern PATTERN``                 | include/exclude paths matching PATTERN                                                                    |
     +-------------------------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------+
@@ -75,20 +77,21 @@
         -n, --dry-run     do not actually change any files
         --numeric-ids     only obey numeric user and group identifiers
         --noflags         do not extract/set flags (e.g. NODUMP, IMMUTABLE)
         --noacls          do not extract/set ACLs
         --noxattrs        do not extract/set xattrs
         --stdout          write all extracted data to stdout
         --sparse          create holes in output sparse file from all-zero chunks
+        --continue        continue a previously interrupted extraction of same archive
 
 
     :ref:`common_options`
         |
 
-    Exclusion options
+    Include/Exclude options
         -e PATTERN, --exclude PATTERN     exclude paths matching PATTERN
         --exclude-from EXCLUDEFILE        read exclude patterns from EXCLUDEFILE, one per line
         --pattern PATTERN                 include/exclude paths matching PATTERN
         --patterns-from PATTERNFILE       read include/exclude patterns from PATTERNFILE, one per line
         --strip-components NUMBER         Remove the specified number of leading path elements. Paths with fewer elements will be silently skipped.
```

### Comparing `borgbackup-2.0.0b5/docs/usage/general/environment.rst.inc` & `borgbackup-2.0.0b6/docs/usage/general/environment.rst.inc`

 * *Files 6% similar despite different names*

```diff
@@ -100,14 +100,22 @@
             write to disk behaviour (not continuously streaming to disk).
 
         retry_erofs
             Retry opening a file without O_NOATIME if opening a file with O_NOATIME
             caused EROFS. You will need this to make archives from volume shadow copies
             in WSL1 (Windows Subsystem for Linux 1).
 
+Output formatting:
+    BORG_LIST_FORMAT
+        Giving the default value for ``borg list --format=X``.
+    BORG_RLIST_FORMAT
+        Giving the default value for ``borg rlist --format=X``.
+    BORG_PRUNE_FORMAT
+        Giving the default value for ``borg prune --format=X``.
+
 Some automatic "answerers" (if set, they automatically answer confirmation questions):
     BORG_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK=no (or =yes)
         For "Warning: Attempting to access a previously unknown unencrypted repository"
     BORG_RELOCATED_REPO_ACCESS_IS_OK=no (or =yes)
         For "Warning: The repository at location ... was previously located at ..."
     BORG_CHECK_I_KNOW_WHAT_I_AM_DOING=NO (or =YES)
         For "This is a potentially dangerous function..." (check --repair)
@@ -133,23 +141,40 @@
         of space for dealing with big repositories. Make sure you're aware of the associated
         security aspects of the cache location: :ref:`cache_security`
     BORG_CONFIG_DIR
         Defaults to ``$BORG_BASE_DIR/.config/borg``. If ``BORG_BASE_DIR`` is not explicitly set while
         `XDG env var`_ ``XDG_CONFIG_HOME`` is set, then ``$XDG_CONFIG_HOME/borg`` is being used instead.
         This directory contains all borg configuration directories, see the FAQ
         for a security advisory about the data in this directory: :ref:`home_config_borg`
+    BORG_DATA_DIR
+        Defaults to ``$BORG_BASE_DIR/.local/share/borg``. If ``BORG_BASE_DIR`` is not explicitly set while
+        `XDG env var`_ ``XDG_DATA_HOME`` is set, then ``$XDG_DATA_HOME/borg`` is being used instead.
+        This directory contains all borg data directories, see the FAQ
+        for a security advisory about the data in this directory: :ref:`home_data_borg`
+    BORG_RUNTIME_DIR
+        Defaults to ``$BORG_BASE_DIR/.cache/borg``. If ``BORG_BASE_DIR`` is not explicitly set while
+        `XDG env var`_ ``XDG_RUNTIME_DIR`` is set, then ``$XDG_RUNTIME_DIR/borg`` is being used instead.
+        This directory contains borg runtime files, like e.g. the socket file.
     BORG_SECURITY_DIR
-        Defaults to ``$BORG_CONFIG_DIR/security``.
-        This directory contains information borg uses to track its usage of NONCES ("numbers used
-        once" - usually in encryption context) and other security relevant data.
+        Defaults to ``$BORG_DATA_DIR/security``.
+        This directory contains security relevant data.
     BORG_KEYS_DIR
         Defaults to ``$BORG_CONFIG_DIR/keys``.
         This directory contains keys for encrypted repositories.
     BORG_KEY_FILE
-        When set, use the given filename as repository key file.
+        When set, use the given path as repository key file. Please note that this is only
+        for rather special applications that externally fully manage the key files:
+
+        - this setting only applies to the keyfile modes (not to the repokey modes).
+        - using a full, absolute path to the key file is recommended.
+        - all directories in the given path must exist.
+        - this setting forces borg to use the key file at the given location.
+        - the key file must either exist (for most commands) or will be created (``borg rcreate``).
+        - you need to give a different path for different repositories.
+        - you need to point to the correct key file matching the repository the command will operate on.
     TMPDIR
         This is where temporary files are stored (might need a lot of temporary space for some
         operations), see tempfile_ for details.
 
 Building:
     BORG_OPENSSL_PREFIX
         Adds given OpenSSL header file directory to the default locations (setup.py).
```

### Comparing `borgbackup-2.0.0b5/docs/usage/general/file-metadata.rst.inc` & `borgbackup-2.0.0b6/docs/usage/general/file-metadata.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/general/file-systems.rst.inc` & `borgbackup-2.0.0b6/docs/usage/general/file-systems.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/general/logging.rst.inc` & `borgbackup-2.0.0b6/docs/usage/general/logging.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/general/positional-arguments.rst.inc` & `borgbackup-2.0.0b6/docs/usage/general/positional-arguments.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/general/repository-locations.rst.inc` & `borgbackup-2.0.0b6/docs/usage/general/repository-locations.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/general/repository-urls.rst.inc` & `borgbackup-2.0.0b6/docs/usage/general/repository-urls.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/general/resources.rst.inc` & `borgbackup-2.0.0b6/docs/usage/general/resources.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/general/return-codes.rst.inc` & `borgbackup-2.0.0b6/docs/usage/general/return-codes.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/general.rst` & `borgbackup-2.0.0b6/docs/usage/general.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/help.rst.inc` & `borgbackup-2.0.0b6/docs/usage/help.rst.inc`

 * *Files 5% similar despite different names*

```diff
@@ -20,23 +20,21 @@
 Borg always stores all file paths normalized and relative to the
 current recursion root. The recursion root is also named ``PATH`` in
 Borg commands like `borg create` that do a file discovery, so do not
 confuse the root with the ``PATH`` argument of e.g. `borg extract`.
 
 Starting with Borg 1.2, paths that are matched against patterns always
 appear relative. If you give ``/absolute/`` as root, the paths going
-into the matcher will look relative like ``absolute/.../file.ext``.
-If you give ``../some/path`` as root, the paths will look like
-``some/path/.../file.ext``.
-
-File patterns support five different styles. If followed by a colon ':',
-the first two characters of a pattern are used as a style selector.
-Explicit style selection is necessary if a non-default style is desired
-or when the desired pattern starts with two alphanumeric characters
-followed by a colon (i.e. ``aa:something/*``).
+into the matcher will start with ``absolute/``.
+If you give ``../../relative`` as root, the paths will be normalized
+as ``relative/``.
+
+Borg supports different pattern styles. To define a non-default
+style for a specific pattern, prefix it with two characters followed
+by a colon ':' (i.e. ``fm:path/*``, ``sh:path/**``).
 
 `Fnmatch <https://docs.python.org/3/library/fnmatch.html>`_, selector ``fm:``
     This is the default style for ``--exclude`` and ``--exclude-from``.
     These patterns use a variant of shell pattern syntax, with '\*' matching
     any number of characters, '?' matching any single character, '[...]'
     matching any single character specified, including ranges, and '[!...]'
     matching any character not specified. For the purpose of these patterns,
@@ -51,15 +49,16 @@
     path separator is always removed.
 
 Shell-style patterns, selector ``sh:``
     This is the default style for ``--pattern`` and ``--patterns-from``.
     Like fnmatch patterns these are similar to shell patterns. The difference
     is that the pattern may include ``**/`` for matching zero or more directory
     levels, ``*`` for matching zero or more arbitrary characters with the
-    exception of any path separator. A leading path separator is always removed.
+    exception of any path separator, ``{}`` containing comma-separated
+    alternative patterns. A leading path separator is always removed.
 
 `Regular expressions <https://docs.python.org/3/library/re.html>`_, selector ``re:``
     Unlike shell patterns, regular expressions are not required to match the full
     path and any substring match is sufficient. It is strongly recommended to
     anchor patterns to the start ('^'), to the end ('$') or both. Path
     separators (backslash for Windows and '/' on other systems) in paths are
     always normalized to a forward slash '/' before applying a pattern.
@@ -171,14 +170,33 @@
     pattern and would otherwise not be backed up.
 
 The first matching pattern is used, so if an include pattern matches
 before an exclude pattern, the file is backed up. Note that a no-recurse
 exclude stops examination of subdirectories so that potential includes
 will not match - use normal excludes for such use cases.
 
+Example::
+
+    # Define the recursion root
+    R /
+    # Exclude all iso files in any directory
+    - **/*.iso
+    # Explicitly include all inside etc and root
+    + etc/**
+    + root/**
+    # Exclude a specific directory under each user's home directories
+    - home/*/.cache
+    # Explicitly include everything in /home
+    + home/**
+    # Explicitly exclude some directories without recursing into them
+    ! re:^(dev|proc|run|sys|tmp)
+    # Exclude all other files and directories
+    # that are not specifically included earlier.
+    - **
+
 **Tip: You can easily test your patterns with --dry-run and  --list**::
 
     $ borg create --dry-run --list --patterns-from patterns.txt archive
 
 This will list the considered files one per line, prefixed with a
 character that indicates the action (e.g. 'x' for excluding, see
 **Item flags** in `borg create` usage docs).
@@ -389,44 +407,59 @@
     The heuristic tries with lz4 whether the data is compressible.
     For incompressible data, it will not use compression (uses "none").
     For compressible data, it uses the given C[,L] compression - with C[,L]
     being any valid compression specifier.
 
 obfuscate,SPEC,C[,L]
     Use compressed-size obfuscation to make fingerprinting attacks based on
-    the observable stored chunk size more difficult.
-    Note:
-    - you must combine this with encryption or it won't make any sense.
-    - your repo size will be bigger, of course.
+    the observable stored chunk size more difficult. Note:
 
-    The SPEC value will determine how the size obfuscation will work:
+    - You must combine this with encryption, or it won't make any sense.
+    - Your repo size will be bigger, of course.
+    - A chunk is limited by the constant ``MAX_DATA_SIZE`` (cur. ~20MiB).
+
+    The SPEC value determines how the size obfuscation works:
+
+    *Relative random reciprocal size variation* (multiplicative)
 
-    Relative random reciprocal size variation:
     Size will increase by a factor, relative to the compressed data size.
-    Smaller factors are often used, larger factors rarely.
-    1: factor 0.01 .. 100.0
-    2: factor 0.1 .. 1000.0
-    3: factor 1.0 .. 10000.0
-    4: factor 10.0 .. 100000.0
-    5: factor 100.0 .. 1000000.0
-    6: factor 1000.0 .. 10000000.0
-
-    Add a randomly sized padding up to the given size:
-    110: 1kiB
-    ...
-    120: 1MiB
-    ...
-    123: 8MiB (max.)
+    Smaller factors are used often, larger factors rarely.
+
+    Available factors::
+
+      1:     0.01 ..        100
+      2:     0.1  ..      1,000
+      3:     1    ..     10,000
+      4:    10    ..    100,000
+      5:   100    ..  1,000,000
+      6: 1,000    .. 10,000,000
+
+    Example probabilities for SPEC ``1``::
+
+      90   %  0.01 ..   0.1
+       9   %  0.1  ..   1
+       0.9 %  1    ..  10
+       0.09% 10    .. 100
+
+    *Randomly sized padding up to the given size* (additive)
+
+    ::
+
+      110: 1kiB (2 ^ (SPEC - 100))
+      ...
+      120: 1MiB
+      ...
+      123: 8MiB (max.)
 
 Examples::
 
     borg create --compression lz4 REPO::ARCHIVE data
     borg create --compression zstd REPO::ARCHIVE data
     borg create --compression zstd,10 REPO::ARCHIVE data
     borg create --compression zlib REPO::ARCHIVE data
     borg create --compression zlib,1 REPO::ARCHIVE data
     borg create --compression auto,lzma,6 REPO::ARCHIVE data
     borg create --compression auto,lzma ...
-    borg create --compression obfuscate,3,none ...
+    borg create --compression obfuscate,110,none ...
     borg create --compression obfuscate,3,auto,zstd,10 ...
     borg create --compression obfuscate,2,zstd,6 ...
```

### Comparing `borgbackup-2.0.0b5/docs/usage/import-tar.rst.inc` & `borgbackup-2.0.0b6/docs/usage/import-tar.rst.inc`

 * *Files 5% similar despite different names*

```diff
@@ -27,14 +27,16 @@
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--list``                                        | output verbose list of items (files, dirs, ...)                                                                                                                                                   |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--filter STATUSCHARS``                          | only display items with the given status characters                                                                                                                                               |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--json``                                        | output stats as JSON (implies --stats)                                                                                                                                                            |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
+    |                                                       | ``--ignore-zeros``                                | ignore zero-filled blocks in the input tarball                                                                                                                                                    |
+    +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     | .. class:: borg-common-opt-ref                                                                                                                                                                                                                                                                                |
     |                                                                                                                                                                                                                                                                                                               |
     | :ref:`common_options`                                                                                                                                                                                                                                                                                         |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     | **Archive options**                                                                                                                                                                                                                                                                                           |
     +-------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--comment COMMENT``                             | add a comment text to the archive                                                                                                                                                                 |
@@ -68,14 +70,15 @@
 
     options
         --tar-filter    filter program to pipe data through
         -s, --stats     print statistics for the created archive
         --list          output verbose list of items (files, dirs, ...)
         --filter STATUSCHARS    only display items with the given status characters
         --json          output stats as JSON (implies --stats)
+        --ignore-zeros    ignore zero-filled blocks in the input tarball
 
 
     :ref:`common_options`
         |
 
     Archive options
         --comment COMMENT                             add a comment text to the archive
@@ -117,7 +120,11 @@
 
 - BORG: borg specific (PAX-based)
 - PAX: POSIX.1-2001
 - GNU: GNU tar
 - POSIX.1-1988 (ustar)
 - UNIX V7 tar
 - SunOS tar with extended attributes
+
+To import multiple tarballs into a single archive, they can be simply
+concatenated (e.g. using "cat") into a single file, and imported with an
+``--ignore-zeros`` option to skip through the stop markers between them.
```

### Comparing `borgbackup-2.0.0b5/docs/usage/info.rst` & `borgbackup-2.0.0b6/docs/usage/info.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/key.rst` & `borgbackup-2.0.0b6/docs/usage/key.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/key_change-location.rst.inc` & `borgbackup-2.0.0b6/docs/usage/key_change-location.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/key_change-passphrase.rst.inc` & `borgbackup-2.0.0b6/docs/usage/key_change-passphrase.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/key_export.rst.inc` & `borgbackup-2.0.0b6/docs/usage/key_export.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/key_import.rst.inc` & `borgbackup-2.0.0b6/docs/usage/key_import.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/list.rst` & `borgbackup-2.0.0b6/docs/usage/list.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/list.rst.inc` & `borgbackup-2.0.0b6/docs/usage/list.rst.inc`

 * *Files 12% similar despite different names*

```diff
@@ -27,15 +27,15 @@
     +-------------------------------------------------------+---------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--json-lines``                      | Format output as JSON Lines. The form of ``--format`` is ignored, but keys used in it are added to the JSON output. Some keys are always present. Note: JSON can only represent text. |
     +-------------------------------------------------------+---------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     | .. class:: borg-common-opt-ref                                                                                                                                                                                                                                                        |
     |                                                                                                                                                                                                                                                                                       |
     | :ref:`common_options`                                                                                                                                                                                                                                                                 |
     +-------------------------------------------------------+---------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-    | **Exclusion options**                                                                                                                                                                                                                                                                 |
+    | **Include/Exclude options**                                                                                                                                                                                                                                                           |
     +-------------------------------------------------------+---------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``-e PATTERN``, ``--exclude PATTERN`` | exclude paths matching PATTERN                                                                                                                                                        |
     +-------------------------------------------------------+---------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--exclude-from EXCLUDEFILE``        | read exclude patterns from EXCLUDEFILE, one per line                                                                                                                                  |
     +-------------------------------------------------------+---------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                       | ``--pattern PATTERN``                 | include/exclude paths matching PATTERN                                                                                                                                                |
     +-------------------------------------------------------+---------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
@@ -63,15 +63,15 @@
         --format FORMAT    specify format for file listing (default: "{mode} {user:6} {group:6} {size:8} {mtime} {path}{extra}{NL}")
         --json-lines    Format output as JSON Lines. The form of ``--format`` is ignored, but keys used in it are added to the JSON output. Some keys are always present. Note: JSON can only represent text.
 
 
     :ref:`common_options`
         |
 
-    Exclusion options
+    Include/Exclude options
         -e PATTERN, --exclude PATTERN     exclude paths matching PATTERN
         --exclude-from EXCLUDEFILE        read exclude patterns from EXCLUDEFILE, one per line
         --pattern PATTERN                 include/exclude paths matching PATTERN
         --patterns-from PATTERNFILE       read include/exclude patterns from PATTERNFILE, one per line
 
 
 Description
@@ -103,43 +103,44 @@
     ...
 
 The following keys are always available:
 
 - NEWLINE: OS dependent line separator
 - NL: alias of NEWLINE
 - NUL: NUL character for creating print0 / xargs -0 like output
-- SPACE
-- TAB
-- CR
-- LF
+- SPACE: space character
+- TAB: tab character
+- CR: carriage return character
+- LF: line feed character
+
 
 Keys available only when listing files in an archive:
 
-- type
-- mode
-- uid
-- gid
-- user
-- group
+- type: file type (file, dir, symlink, ...)
+- mode: file mode (as in stat)
+- uid: user id of file owner
+- gid: group id of file owner
+- user: user name of file owner
+- group: group name of file owner
 - path: file path
 - target: link target for symlinks
 - hlid: hard link identity (same if hardlinking same fs object)
-- flags
+- flags: file flags
 
-- size
+- size: file size
 - dsize: deduplicated size
 - num_chunks: number of chunks in this file
 - unique_chunks: number of unique chunks in this file
 
-- mtime
-- ctime
-- atime
-- isomtime
-- isoctime
-- isoatime
+- mtime: file modification time
+- ctime: file change time
+- atime: file access time
+- isomtime: file modification time (ISO 8601 format)
+- isoctime: file change time (ISO 8601 format)
+- isoatime: file access time (ISO 8601 format)
 
 - blake2b
 - blake2s
 - md5
 - sha1
 - sha224
 - sha256
@@ -147,12 +148,12 @@
 - sha3_224
 - sha3_256
 - sha3_384
 - sha3_512
 - sha512
 - xxh64: XXH64 checksum of this file (note: this is NOT a cryptographic hash!)
 
-- archiveid
-- archivename
+- archiveid: internal ID of the archive
+- archivename: name of the archive
 - extra: prepends {target} with " -> " for soft links and " link to " for hard links
 
 - health: either "healthy" (file ok) or "broken" (if file has all-zero replacement chunks)
```

### Comparing `borgbackup-2.0.0b5/docs/usage/mount.rst` & `borgbackup-2.0.0b6/docs/usage/mount.rst`

 * *Files 2% similar despite different names*

```diff
@@ -23,15 +23,15 @@
     -rw-rw-r-- 1 user group 12357 Aug 26 21:19 doc.cda00bc9.txt
     -rw-rw-r-- 1 user group 12204 Aug 26 21:04 doc.fa760f28.txt
     $ borg umount /tmp/mymountpoint
 
     # Archive filters are supported.
     # These are especially handy for the "versions view",
     # which does not support lazy processing of archives.
-    $ borg mount -o versions --glob-archives '*-my-home' --last 10 /tmp/mymountpoint
+    $ borg mount -o versions --match-archives 'sh:*-my-home' --last 10 /tmp/mymountpoint
 
     # Exclusion options are supported.
     # These can speed up mounting and lower memory needs significantly.
     $ borg mount /path/to/repo /tmp/mymountpoint only/that/path
     $ borg mount --exclude '...' /tmp/mymountpoint
```

### Comparing `borgbackup-2.0.0b5/docs/usage/mount.rst.inc` & `borgbackup-2.0.0b6/docs/usage/mount.rst.inc`

 * *Files 2% similar despite different names*

```diff
@@ -47,15 +47,15 @@
     +-----------------------------------------------------------------------------+----------------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                                             | ``--newest TIMESPAN``                        | consider archives between the newest archive's timestamp and (newest - TIMESPAN), e.g. 7d or 12m.         |
     +-----------------------------------------------------------------------------+----------------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                                             | ``--older TIMESPAN``                         | consider archives older than (now - TIMESPAN), e.g. 7d oder 12m.                                          |
     +-----------------------------------------------------------------------------+----------------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                                             | ``--newer TIMESPAN``                         | consider archives newer than (now - TIMESPAN), e.g. 7d or 12m.                                            |
     +-----------------------------------------------------------------------------+----------------------------------------------+-----------------------------------------------------------------------------------------------------------+
-    | **Exclusion options**                                                                                                                                                                                                                  |
+    | **Include/Exclude options**                                                                                                                                                                                                            |
     +-----------------------------------------------------------------------------+----------------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                                             | ``-e PATTERN``, ``--exclude PATTERN``        | exclude paths matching PATTERN                                                                            |
     +-----------------------------------------------------------------------------+----------------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                                             | ``--exclude-from EXCLUDEFILE``               | read exclude patterns from EXCLUDEFILE, one per line                                                      |
     +-----------------------------------------------------------------------------+----------------------------------------------+-----------------------------------------------------------------------------------------------------------+
     |                                                                             | ``--pattern PATTERN``                        | include/exclude paths matching PATTERN                                                                    |
     +-----------------------------------------------------------------------------+----------------------------------------------+-----------------------------------------------------------------------------------------------------------+
@@ -97,15 +97,15 @@
         --last N                                 consider last N archives after other filters were applied
         --oldest TIMESPAN                        consider archives between the oldest archive's timestamp and (oldest + TIMESPAN), e.g. 7d or 12m.
         --newest TIMESPAN                        consider archives between the newest archive's timestamp and (newest - TIMESPAN), e.g. 7d or 12m.
         --older TIMESPAN                         consider archives older than (now - TIMESPAN), e.g. 7d oder 12m.
         --newer TIMESPAN                         consider archives newer than (now - TIMESPAN), e.g. 7d or 12m.
 
 
-    Exclusion options
+    Include/Exclude options
         -e PATTERN, --exclude PATTERN     exclude paths matching PATTERN
         --exclude-from EXCLUDEFILE        read exclude patterns from EXCLUDEFILE, one per line
         --pattern PATTERN                 include/exclude paths matching PATTERN
         --patterns-from PATTERNFILE       read include/exclude patterns from PATTERNFILE, one per line
         --strip-components NUMBER         Remove the specified number of leading path elements. Paths with fewer elements will be silently skipped.
 
 
@@ -144,22 +144,22 @@
 the filesystem if libfuse is not used). However, you should not specify these
 manually. Unlike the ``uid`` and ``gid`` mount options which affect all files,
 ``user_id`` and ``group_id`` affect the user and group id of the mounted
 (base) directory.
 
 Additional mount options supported by borg:
 
-- versions: when used with a repository mount, this gives a merged, versioned
+- ``versions``: when used with a repository mount, this gives a merged, versioned
   view of the files in the archives. EXPERIMENTAL, layout may change in future.
-- allow_damaged_files: by default damaged files (where missing chunks were
-  replaced with runs of zeros by borg check ``--repair``) are not readable and
+- ``allow_damaged_files``: by default damaged files (where missing chunks were
+  replaced with runs of zeros by ``borg check --repair``) are not readable and
   return EIO (I/O error). Set this option to read such files.
-- ignore_permissions: for security reasons the "default_permissions" mount
-  option is internally enforced by borg. "ignore_permissions" can be given to
-  not enforce "default_permissions".
+- ``ignore_permissions``: for security reasons the ``default_permissions`` mount
+  option is internally enforced by borg. ``ignore_permissions`` can be given to
+  not enforce ``default_permissions``.
 
 The BORG_MOUNT_DATA_CACHE_ENTRIES environment variable is meant for advanced users
 to tweak the performance. It sets the number of cached data chunks; additional
 memory usage can be up to ~8 MiB times this number. The default is the number
 of CPU cores.
 
 When the daemonized process receives a signal or crashes, it does not unmount.
```

### Comparing `borgbackup-2.0.0b5/docs/usage/notes.rst` & `borgbackup-2.0.0b6/docs/usage/notes.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/prune.rst` & `borgbackup-2.0.0b6/docs/usage/prune.rst`

 * *Files 11% similar despite different names*

```diff
@@ -3,30 +3,30 @@
 Examples
 ~~~~~~~~
 
 Be careful, prune is a potentially dangerous command, it will remove backup
 archives.
 
 The default of prune is to apply to **all archives in the repository** unless
-you restrict its operation to a subset of the archives using ``-a`` / ``--glob-archives``.
+you restrict its operation to a subset of the archives using ``-a`` / ``--match-archives``.
 When using ``-a``, be careful to choose a good pattern - e.g. do not use a
 prefix "foo" if you do not also want to match "foobar".
 
 It is strongly recommended to always run ``prune -v --list --dry-run ...``
 first so you will see what it would do without it actually doing anything.
 
 ::
 
     # Keep 7 end of day and 4 additional end of week archives.
     # Do a dry-run without actually deleting anything.
     $ borg prune -v --list --dry-run --keep-daily=7 --keep-weekly=4
 
     # Same as above but only apply to archive names starting with the hostname
     # of the machine followed by a "-" character:
-    $ borg prune -v --list --keep-daily=7 --keep-weekly=4 -a '{hostname}-*'
+    $ borg prune -v --list --keep-daily=7 --keep-weekly=4 -a 'sh:{hostname}-*'
     # actually free disk space:
     $ borg compact
 
     # Keep 7 end of day, 4 additional end of week archives,
     # and an end of month archive for every month:
     $ borg prune -v --list --keep-daily=7 --keep-weekly=4 --keep-monthly=-1
```

### Comparing `borgbackup-2.0.0b5/docs/usage/prune.rst.inc` & `borgbackup-2.0.0b6/docs/usage/prune.rst.inc`

 * *Files 9% similar despite different names*

```diff
@@ -19,14 +19,22 @@
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``--force``                                       | force pruning of corrupted archives, use ``--force --force`` in case ``--force`` does not work.   |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``-s``, ``--stats``                               | print statistics for the deleted archive                                                          |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``--list``                                        | output verbose list of archives it keeps/prunes                                                   |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--short``                                       | use a less wide archive part format                                                               |
+    +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--list-pruned``                                 | output verbose list of archives it prunes                                                         |
+    +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--list-kept``                                   | output verbose list of archives it keeps                                                          |
+    +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
+    |                                                                             | ``--format FORMAT``                               | specify format for the archive part (default: "{archive:<36} {time} [{id}]")                      |
+    +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``--keep-within INTERVAL``                        | keep all archives within this time interval                                                       |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``--keep-last``, ``--keep-secondly``              | number of secondly archives to keep                                                               |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``--keep-minutely``                               | number of minutely archives to keep                                                               |
     +-----------------------------------------------------------------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------------+
     |                                                                             | ``-H``, ``--keep-hourly``                         | number of hourly archives to keep                                                                 |
@@ -71,14 +79,18 @@
 
 
     options
         -n, --dry-run         do not change repository
         --force               force pruning of corrupted archives, use ``--force --force`` in case ``--force`` does not work.
         -s, --stats           print statistics for the deleted archive
         --list                output verbose list of archives it keeps/prunes
+        --short               use a less wide archive part format
+        --list-pruned         output verbose list of archives it prunes
+        --list-kept           output verbose list of archives it keeps
+        --format FORMAT       specify format for the archive part (default: "{archive:<36} {time} [{id}]")
         --keep-within INTERVAL    keep all archives within this time interval
         --keep-last, --keep-secondly    number of secondly archives to keep
         --keep-minutely       number of minutely archives to keep
         -H, --keep-hourly     number of hourly archives to keep
         -d, --keep-daily      number of daily archives to keep
         -w, --keep-weekly     number of weekly archives to keep
         -m, --keep-monthly    number of monthly archives to keep
@@ -149,8 +161,12 @@
 The ``--keep-last N`` option is doing the same as ``--keep-secondly N`` (and it will
 keep the last N archives under the assumption that you do not create more than one
 backup archive in the same second).
 
 When using ``--stats``, you will get some statistics about how much data was
 deleted - the "Deleted data" deduplicated size there is most interesting as
 that is how much your repository will shrink.
-Please note that the "All archives" stats refer to the state after pruning.
+Please note that the "All archives" stats refer to the state after pruning.
+
+You can influence how the ``--list`` output is formatted by using the ``--short``
+option (less wide output) or by giving a custom format using ``--format`` (see
+the ``borg rlist`` description for more details about the format string).
```

### Comparing `borgbackup-2.0.0b5/docs/usage/rcompress.rst.inc` & `borgbackup-2.0.0b6/docs/usage/rcompress.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/rcreate.rst` & `borgbackup-2.0.0b6/docs/usage/rcreate.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/rcreate.rst.inc` & `borgbackup-2.0.0b6/docs/usage/rcreate.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/rdelete.rst.inc` & `borgbackup-2.0.0b6/docs/usage/rdelete.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/recreate.rst` & `borgbackup-2.0.0b6/docs/usage/recreate.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/recreate.rst.inc` & `borgbackup-2.0.0b6/docs/usage/recreate.rst.inc`

 * *Files 2% similar despite different names*

```diff
@@ -27,15 +27,15 @@
     +-----------------------------------------------------------------------------+---------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                                             | ``-s``, ``--stats``                               | print statistics at end                                                                                                                                                                                                                                                                                                                                                                                                                            |
     +-----------------------------------------------------------------------------+---------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     | .. class:: borg-common-opt-ref                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     | :ref:`common_options`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     +-----------------------------------------------------------------------------+---------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-    | **Exclusion options**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
+    | **Include/Exclude options**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
     +-----------------------------------------------------------------------------+---------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                                             | ``-e PATTERN``, ``--exclude PATTERN``             | exclude paths matching PATTERN                                                                                                                                                                                                                                                                                                                                                                                                                     |
     +-----------------------------------------------------------------------------+---------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                                             | ``--exclude-from EXCLUDEFILE``                    | read exclude patterns from EXCLUDEFILE, one per line                                                                                                                                                                                                                                                                                                                                                                                               |
     +-----------------------------------------------------------------------------+---------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     |                                                                             | ``--pattern PATTERN``                             | include/exclude paths matching PATTERN                                                                                                                                                                                                                                                                                                                                                                                                             |
     +-----------------------------------------------------------------------------+---------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
@@ -102,15 +102,15 @@
         -n, --dry-run    do not change anything
         -s, --stats     print statistics at end
 
 
     :ref:`common_options`
         |
 
-    Exclusion options
+    Include/Exclude options
         -e PATTERN, --exclude PATTERN     exclude paths matching PATTERN
         --exclude-from EXCLUDEFILE        read exclude patterns from EXCLUDEFILE, one per line
         --pattern PATTERN                 include/exclude paths matching PATTERN
         --patterns-from PATTERNFILE       read include/exclude patterns from PATTERNFILE, one per line
         --exclude-caches                  exclude directories that contain a CACHEDIR.TAG file (http://www.bford.info/cachedir/spec.html)
         --exclude-if-present NAME         exclude directories that are tagged by containing a filesystem object with the given NAME
         --keep-exclude-tags               if tag objects are specified with ``--exclude-if-present``, don't omit the tag objects themselves from the backup archive
```

### Comparing `borgbackup-2.0.0b5/docs/usage/rename.rst.inc` & `borgbackup-2.0.0b6/docs/usage/rename.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/rinfo.rst` & `borgbackup-2.0.0b6/docs/usage/rinfo.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/rinfo.rst.inc` & `borgbackup-2.0.0b6/docs/usage/rinfo.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/rlist.rst.inc` & `borgbackup-2.0.0b6/docs/usage/rlist.rst.inc`

 * *Files 3% similar despite different names*

```diff
@@ -108,18 +108,19 @@
     ...
 
 The following keys are always available:
 
 - NEWLINE: OS dependent line separator
 - NL: alias of NEWLINE
 - NUL: NUL character for creating print0 / xargs -0 like output
-- SPACE
-- TAB
-- CR
-- LF
+- SPACE: space character
+- TAB: tab character
+- CR: carriage return character
+- LF: line feed character
+
 
 Keys available only when listing archives in a repository:
 
 - archive: archive name
 - name: alias of "archive"
 - comment: archive comment
 - id: internal ID of the archive
@@ -127,7 +128,10 @@
 - start: time (start) of creation of the archive
 - time: alias of "start"
 - end: time (end) of creation of the archive
 - command_line: command line which was used to create the archive
 
 - hostname: hostname of host on which this archive was created
 - username: username of user who created this archive
+
+- size: size of this archive (data plus metadata, not considering compression and deduplication)
+- nfiles: count of files in this archive
```

### Comparing `borgbackup-2.0.0b5/docs/usage/serve.rst` & `borgbackup-2.0.0b6/docs/usage/serve.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/serve.rst.inc` & `borgbackup-2.0.0b6/docs/usage/serve.rst.inc`

 * *Files 15% similar despite different names*

```diff
@@ -49,8 +49,18 @@
 
     :ref:`common_options`
         |
 
 Description
 ~~~~~~~~~~~
 
-This command starts a repository server process. This command is usually not used manually.
+This command starts a repository server process.
+
+borg serve can currently support:
+
+- Getting automatically started via ssh when the borg client uses a ssh://...
+  remote repository. In this mode, `borg serve` will live until that ssh connection
+  gets terminated.
+
+- Getting started by some other means (not by the borg client) as a long-running socket
+  server to be used for borg clients using a socket://... repository (see the `--socket`
+  option if you do not want to use the default path for the socket and pid file).
```

### Comparing `borgbackup-2.0.0b5/docs/usage/tar.rst` & `borgbackup-2.0.0b6/docs/usage/tar.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/transfer.rst` & `borgbackup-2.0.0b6/docs/usage/transfer.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/umount.rst.inc` & `borgbackup-2.0.0b6/docs/usage/umount.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/usage_general.rst.inc` & `borgbackup-2.0.0b6/docs/usage/usage_general.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage/with-lock.rst.inc` & `borgbackup-2.0.0b6/docs/usage/with-lock.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage.rst` & `borgbackup-2.0.0b6/docs/usage.rst`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/docs/usage_general.rst.inc` & `borgbackup-2.0.0b6/docs/usage_general.rst.inc`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/pyproject.toml` & `borgbackup-2.0.0b6/pyproject.toml`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/scripts/borg.exe.spec` & `borgbackup-2.0.0b6/scripts/borg.exe.spec`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/scripts/fuzz-cache-sync/main.c` & `borgbackup-2.0.0b6/scripts/fuzz-cache-sync/main.c`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/scripts/glibc_check.py` & `borgbackup-2.0.0b6/scripts/glibc_check.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/scripts/hash_sizes.py` & `borgbackup-2.0.0b6/scripts/hash_sizes.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/scripts/make-testdata/test_transfer_upgrade.sh` & `borgbackup-2.0.0b6/scripts/make-testdata/test_transfer_upgrade.sh`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/scripts/shell_completions/bash/borg` & `borgbackup-2.0.0b6/scripts/shell_completions/bash/borg`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/scripts/shell_completions/fish/borg.fish` & `borgbackup-2.0.0b6/scripts/shell_completions/fish/borg.fish`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/scripts/shell_completions/zsh/_borg` & `borgbackup-2.0.0b6/scripts/shell_completions/zsh/_borg`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/setup.cfg` & `borgbackup-2.0.0b6/setup.cfg`

 * *Files 3% similar despite different names*

```diff
@@ -32,20 +32,19 @@
 	Source Code = https://github.com/borgbackup/borg
 
 [options]
 packages = find_namespace:
 package_dir = 
 	=src
 python_requires = >=3.9
-setup_requires = 
-	setuptools_scm[toml] >= 6.2
 install_requires = 
-	msgpack >=1.0.3, <=1.0.4
+	msgpack >=1.0.3, <=1.0.5
 	packaging
-	platformdirs >=3.0.0, <4.0.0
+	platformdirs >=3.0.0, <4.0.0; sys_platform == 'darwin'  # for macOS: breaking changes in 3.0.0,
+	platformdirs >=2.6.0, <4.0.0; sys_platform != 'darwin'  # for others: 2.6+ works consistently.
 	argon2-cffi
 tests_require = 
 	pytest
 zip_safe = False
 include_package_data = true
 
 [options.exclude_package_data]
```

### Comparing `borgbackup-2.0.0b5/setup.py` & `borgbackup-2.0.0b6/setup.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/setup_docs.py` & `borgbackup-2.0.0b6/setup_docs.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 import os
 import io
 import re
 import sys
 import textwrap
 from collections import OrderedDict
 from datetime import datetime
+import time
 
 from setuptools import Command
 
 
 def long_desc_from_readme():
     with open("README.rst") as fd:
         long_description = fd.read()
@@ -466,15 +467,18 @@
         write()
 
     def write_man_header(self, write, title, description):
         self.write_heading(write, title, "=", double_sided=True)
         self.write_heading(write, description, double_sided=True)
         # man page metadata
         write(":Author: The Borg Collective")
-        write(":Date:", datetime.utcnow().date().isoformat())
+        write(
+            ":Date:",
+            datetime.utcfromtimestamp(int(os.environ.get("SOURCE_DATE_EPOCH", time.time()))).date().isoformat(),
+        )
         write(":Manual section: 1")
         write(":Manual group: borg backup tool")
         write()
 
     def write_examples(self, write, command):
         command = command.replace(" ", "_")
         with open("docs/usage/%s.rst" % self.usage_group.get(command, command)) as fd:
```

### Comparing `borgbackup-2.0.0b5/src/borg/__init__.py` & `borgbackup-2.0.0b6/src/borg/__init__.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/__main__.py` & `borgbackup-2.0.0b6/src/borg/__main__.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/_chunker.c` & `borgbackup-2.0.0b6/src/borg/_chunker.c`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/_endian.h` & `borgbackup-2.0.0b6/src/borg/_endian.h`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/_hashindex.c` & `borgbackup-2.0.0b6/src/borg/_hashindex.c`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/_item.c` & `borgbackup-2.0.0b6/src/borg/_item.c`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/archive.py` & `borgbackup-2.0.0b6/src/borg/archive.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,14 +7,15 @@
 from collections import OrderedDict, defaultdict
 from contextlib import contextmanager
 from datetime import datetime, timedelta
 from functools import partial
 from getpass import getuser
 from io import BytesIO
 from itertools import groupby, zip_longest
+from typing import Iterator
 from shutil import get_terminal_size
 
 from .platformflags import is_win32
 from .logger import create_logger
 
 logger = create_logger()
 
@@ -28,15 +29,15 @@
 from .hashindex import ChunkIndex, ChunkIndexEntry, CacheSynchronizer
 from .helpers import HardLinkManager
 from .helpers import ChunkIteratorFileWrapper, open_item
 from .helpers import Error, IntegrityError, set_ec
 from .platform import uid2user, user2uid, gid2group, group2gid
 from .helpers import parse_timestamp, archive_ts_now
 from .helpers import OutputTimestamp, format_timedelta, format_file_size, file_status, FileSize
-from .helpers import safe_encode, make_path_safe, remove_surrogates, text_to_json, join_cmd
+from .helpers import safe_encode, make_path_safe, remove_surrogates, text_to_json, join_cmd, remove_dotdot_prefixes
 from .helpers import StableDict
 from .helpers import bin_to_hex
 from .helpers import safe_ns
 from .helpers import ellipsis_truncate, ProgressIndicatorPercent, log_multi
 from .helpers import os_open, flags_normal, flags_dir
 from .helpers import os_stat
 from .helpers import msgpack
@@ -293,39 +294,32 @@
         Warning: if *preload* is True then all data chunks of every yielded item have to be retrieved,
         otherwise preloaded chunks will accumulate in RemoteRepository and create a memory leak.
         """
         hlids_preloaded = set()
         unpacker = msgpack.Unpacker(use_list=False)
         for data in self.fetch_many(ids):
             unpacker.feed(data)
-            items = [Item(internal_dict=item) for item in unpacker]
-            for item in items:
+            for _item in unpacker:
+                item = Item(internal_dict=_item)
                 if "chunks" in item:
                     item.chunks = [ChunkListEntry(*e) for e in item.chunks]
-
-            if filter:
-                items = [item for item in items if filter(item)]
-
-            if preload:
-                for item in items:
-                    if "chunks" in item:
-                        hlid = item.get("hlid", None)
-                        if hlid is None:
-                            preload_chunks = True
-                        else:
-                            if hlid in hlids_preloaded:
-                                preload_chunks = False
-                            else:
-                                # not having the hardlink's chunks already preloaded for other hardlink to same inode
-                                preload_chunks = True
-                                hlids_preloaded.add(hlid)
-                        if preload_chunks:
-                            self.repository.preload([c.id for c in item.chunks])
-
-            for item in items:
+                if filter and not filter(item):
+                    continue
+                if preload and "chunks" in item:
+                    hlid = item.get("hlid", None)
+                    if hlid is None:
+                        preload_chunks = True
+                    elif hlid in hlids_preloaded:
+                        preload_chunks = False
+                    else:
+                        # not having the hardlink's chunks already preloaded for other hardlink to same inode
+                        preload_chunks = True
+                        hlids_preloaded.add(hlid)
+                    if preload_chunks:
+                        self.repository.preload([c.id for c in item.chunks])
                 yield item
 
     def fetch_many(self, ids, is_preloaded=False):
         for id_, cdata in zip(ids, self.repository.get_many(ids, is_preloaded=is_preloaded)):
             _, data = self.repo_objs.parse(id_, cdata)
             yield data
 
@@ -627,18 +621,17 @@
 
     def item_filter(self, item, filter=None):
         return filter(item) if filter else True
 
     def iter_items(self, filter=None, preload=False):
         # note: when calling this with preload=True, later fetch_many() must be called with
         # is_preloaded=True or the RemoteRepository code will leak memory!
-        for item in self.pipeline.unpack_many(
+        yield from self.pipeline.unpack_many(
             self.metadata.items, preload=preload, filter=lambda item: self.item_filter(item, filter)
-        ):
-            yield item
+        )
 
     def add_item(self, item, show_progress=True, stats=None):
         if show_progress and self.show_progress:
             if stats is None:
                 stats = self.stats
             stats.show_progress(item=item, dt=0.2)
         self.items_buffer.add(item)
@@ -779,36 +772,54 @@
                 # Broken platform with no hardlinking support.
                 # In this case, we *want* to extract twice, because there is no other way.
                 pass
 
     def extract_item(
         self,
         item,
+        *,
         restore_attrs=True,
         dry_run=False,
         stdout=False,
         sparse=False,
         hlm=None,
-        stripped_components=0,
-        original_path=None,
         pi=None,
+        continue_extraction=False,
     ):
         """
         Extract archive item.
 
         :param item: the item to extract
         :param restore_attrs: restore file attributes
         :param dry_run: do not write any data
         :param stdout: write extracted data to stdout
         :param sparse: write sparse files (chunk-granularity, independent of the original being sparse)
         :param hlm: maps hlid to link_target for extracting subtrees with hardlinks correctly
-        :param stripped_components: stripped leading path components to correct hard link extraction
-        :param original_path: 'path' key as stored in archive
         :param pi: ProgressIndicatorPercent (or similar) for file extraction progress (in bytes)
+        :param continue_extraction: continue a previously interrupted extraction of same archive
         """
+
+        def same_item(item, st):
+            """is the archived item the same as the fs item at same path with stat st?"""
+            if not stat.S_ISREG(st.st_mode):
+                # we only "optimize" for regular files.
+                # other file types are less frequent and have no content extraction we could "optimize away".
+                return False
+            if item.mode != st.st_mode or item.size != st.st_size:
+                # the size check catches incomplete previous file extraction
+                return False
+            if item.get("mtime") != st.st_mtime_ns:
+                # note: mtime is "extracted" late, after xattrs and ACLs, but before flags.
+                return False
+            # this is good enough for the intended use case:
+            # continuing an extraction of same archive that initially started in an empty directory.
+            # there is a very small risk that "bsdflags" of one file are wrong:
+            # if a previous extraction was interrupted between setting the mtime and setting non-default flags.
+            return True
+
         has_damaged_chunks = "chunks_healthy" in item
         if dry_run or stdout:
             with self.extract_helper(item, "", hlm, dry_run=dry_run or stdout) as hardlink_set:
                 if not hardlink_set:
                     # it does not really set hardlinks due to dry_run, but we need to behave same
                     # as non-dry_run concerning fetching preloaded chunks from the pipeline or
                     # it would get stuck.
@@ -830,23 +841,22 @@
                                         item_size, item_chunks_size
                                     )
                                 )
             if has_damaged_chunks:
                 raise BackupError("File has damaged (all-zero) chunks. Try running borg check --repair.")
             return
 
-        original_path = original_path or item.path
         dest = self.cwd
-        if item.path.startswith(("/", "../")):
-            raise Exception("Path should be relative and local")
         path = os.path.join(dest, item.path)
         # Attempt to remove existing files, ignore errors on failure
         try:
             st = os.stat(path, follow_symlinks=False)
-            if stat.S_ISDIR(st.st_mode):
+            if continue_extraction and same_item(item, st):
+                return  # done! we already have fully extracted this file in a previous run.
+            elif stat.S_ISDIR(st.st_mode):
                 os.rmdir(path)
             else:
                 os.unlink(path)
         except UnicodeEncodeError:
             raise self.IncompatibleFilesystemEncodingError(path, sys.getfilesystemencoding()) from None
         except OSError:
             pass
@@ -881,15 +891,15 @@
                         fd.truncate(pos)
                         fd.flush()
                         self.restore_attrs(path, item, fd=fd.fileno())
                 if "size" in item:
                     item_size = item.size
                     if item_size != item_chunks_size:
                         raise BackupError(
-                            "Size inconsistency detected: size {}, chunks size {}".format(item_size, item_chunks_size)
+                            f"Size inconsistency detected: size {item_size}, chunks size {item_chunks_size}"
                         )
                 if has_damaged_chunks:
                     raise BackupError("File has damaged (all-zero) chunks. Try running borg check --repair.")
             return
         with backup_io:
             # No repository access beyond this point.
             if stat.S_ISDIR(mode):
@@ -994,14 +1004,24 @@
                 pass
             # bsdflags include the immutable flag and need to be set last:
             if not self.noflags and "bsdflags" in item:
                 try:
                     set_flags(path, item.bsdflags, fd=fd)
                 except OSError:
                     pass
+        else:  # win32
+            # set timestamps rather late
+            mtime = item.mtime
+            atime = item.atime if "atime" in item else mtime
+            try:
+                # note: no fd support on win32
+                os.utime(path, None, ns=(atime, mtime))
+            except OSError:
+                # some systems don't support calling utime on a symlink
+                pass
 
     def set_meta(self, key, value):
         metadata = self._load_meta(self.id)
         setattr(metadata, key, value)
         if "items" in metadata:
             del metadata.items
         data = msgpack.packb(metadata.as_dict())
@@ -1092,62 +1112,67 @@
             # so there is nothing pending when we return and our caller wants to commit.
             pass
         if error:
             logger.warning("forced deletion succeeded, but the deleted archive was corrupted.")
             logger.warning("borg check --repair is required to free all space.")
 
     @staticmethod
-    def compare_archives_iter(archive1, archive2, matcher=None, can_compare_chunk_ids=False):
+    def compare_archives_iter(
+        archive1: "Archive", archive2: "Archive", matcher=None, can_compare_chunk_ids=False
+    ) -> Iterator[ItemDiff]:
         """
-        Yields tuples with a path and an ItemDiff instance describing changes/indicating equality.
+        Yields an ItemDiff instance describing changes/indicating equality.
 
         :param matcher: PatternMatcher class to restrict results to only matching paths.
         :param can_compare_chunk_ids: Whether --chunker-params are the same for both archives.
         """
 
-        def compare_items(item1, item2):
+        def compare_items(path: str, item1: Item, item2: Item):
             return ItemDiff(
+                path,
                 item1,
                 item2,
                 archive1.pipeline.fetch_many([c.id for c in item1.get("chunks", [])]),
                 archive2.pipeline.fetch_many([c.id for c in item2.get("chunks", [])]),
                 can_compare_chunk_ids=can_compare_chunk_ids,
             )
 
-        orphans_archive1 = OrderedDict()
-        orphans_archive2 = OrderedDict()
+        orphans_archive1: OrderedDict[str, Item] = OrderedDict()
+        orphans_archive2: OrderedDict[str, Item] = OrderedDict()
+
+        assert matcher is not None, "matcher must be set"
 
         for item1, item2 in zip_longest(
             archive1.iter_items(lambda item: matcher.match(item.path)),
             archive2.iter_items(lambda item: matcher.match(item.path)),
         ):
             if item1 and item2 and item1.path == item2.path:
-                yield (item1.path, compare_items(item1, item2))
+                yield compare_items(item1.path, item1, item2)
                 continue
             if item1:
                 matching_orphan = orphans_archive2.pop(item1.path, None)
                 if matching_orphan:
-                    yield (item1.path, compare_items(item1, matching_orphan))
+                    yield compare_items(item1.path, item1, matching_orphan)
                 else:
                     orphans_archive1[item1.path] = item1
             if item2:
                 matching_orphan = orphans_archive1.pop(item2.path, None)
                 if matching_orphan:
-                    yield (matching_orphan.path, compare_items(matching_orphan, item2))
+                    yield compare_items(matching_orphan.path, matching_orphan, item2)
                 else:
                     orphans_archive2[item2.path] = item2
         # At this point orphans_* contain items that had no matching partner in the other archive
         for added in orphans_archive2.values():
             path = added.path
             deleted_item = Item.create_deleted(path)
-            yield (path, compare_items(deleted_item, added))
+            yield compare_items(path, deleted_item, added)
         for deleted in orphans_archive1.values():
             path = deleted.path
             deleted_item = Item.create_deleted(path)
-            yield (path, compare_items(deleted, deleted_item))
+            yield compare_items(path, deleted, deleted_item)
 
 
 class MetadataCollector:
     def __init__(self, *, noatime, noctime, nobirthtime, numeric_ids, noflags, noacls, noxattrs):
         self.noatime = noatime
         self.noctime = noctime
         self.numeric_ids = numeric_ids
@@ -1202,15 +1227,15 @@
         return attrs
 
 
 # remember a few recently used all-zero chunk hashes in this mapping.
 # (hash_func, chunk_length) -> chunk_hash
 # we play safe and have the hash_func in the mapping key, in case we
 # have different hash_funcs within the same borg run.
-zero_chunk_ids = LRUCache(10, dispose=lambda _: None)
+zero_chunk_ids = LRUCache(10)  # type: ignore[var-annotated]
 
 
 def cached_hash(chunk, id_hash):
     allocation = chunk.meta["allocation"]
     if allocation == CH_DATA:
         data = chunk.data
         chunk_id = id_hash(data)
@@ -1342,16 +1367,16 @@
         self.hlm = HardLinkManager(id_type=tuple, info_type=(list, type(None)))  # (dev, ino) -> chunks or None
         self.stats = Statistics(output_json=log_json, iec=iec)  # threading: done by cache (including progress)
         self.cwd = os.getcwd()
         self.chunker = get_chunker(*chunker_params, seed=key.chunk_seed, sparse=sparse)
 
     @contextmanager
     def create_helper(self, path, st, status=None, hardlinkable=True):
-        safe_path = make_path_safe(path)
-        item = Item(path=safe_path)
+        sanitized_path = remove_dotdot_prefixes(path)
+        item = Item(path=sanitized_path)
         hardlinked = hardlinkable and st.st_nlink > 1
         hl_chunks = None
         update_map = False
         if hardlinked:
             status = "h"  # hardlink
             nothing = object()
             chunks = self.hlm.retrieve(id=(st.st_ino, st.st_dev), default=nothing)
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/__init__.py` & `borgbackup-2.0.0b6/src/borg/archiver/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -17,14 +17,15 @@
     import time
     from datetime import datetime, timezone
 
     from ..logger import create_logger, setup_logging
 
     logger = create_logger()
 
+    from ._common import Highlander
     from .. import __version__
     from ..constants import *  # NOQA
     from ..helpers import EXIT_SUCCESS, EXIT_WARNING, EXIT_ERROR, EXIT_SIGNAL_BASE
     from ..helpers import Error, set_ec
     from ..helpers import format_file_size
     from ..helpers import remove_surrogates, text_to_json
     from ..helpers import DatetimeWrapper, replace_placeholders
@@ -215,15 +216,23 @@
             of __init__.
             """
             assert suffix in self.suffix_precedence
 
             def add_argument(*args, **kwargs):
                 if "dest" in kwargs:
                     kwargs.setdefault("action", "store")
-                    assert kwargs["action"] in ("help", "store_const", "store_true", "store_false", "store", "append")
+                    assert kwargs["action"] in (
+                        Highlander,
+                        "help",
+                        "store_const",
+                        "store_true",
+                        "store_false",
+                        "store",
+                        "append",
+                    )
                     is_append = kwargs["action"] == "append"
                     if is_append:
                         self.append_options.add(kwargs["dest"])
                         assert (
                             kwargs["default"] == []
                         ), "The default is explicitly constructed as an empty list in resolve()"
                     else:
@@ -428,24 +437,27 @@
         check_extension_modules()
         selftest(logger)
 
     def _setup_implied_logging(self, args):
         """turn on INFO level logging for args that imply that they will produce output"""
         # map of option name to name of logger for that option
         option_logger = {
-            "output_list": "borg.output.list",
             "show_version": "borg.output.show-version",
             "show_rc": "borg.output.show-rc",
             "stats": "borg.output.stats",
             "progress": "borg.output.progress",
         }
         for option, logger_name in option_logger.items():
             option_set = args.get(option, False)
             logging.getLogger(logger_name).setLevel("INFO" if option_set else "WARN")
 
+        # special-case --list / --list-kept / --list-pruned as they all work on same logger
+        options = [args.get(name, False) for name in ("output_list", "list_kept", "list_pruned")]
+        logging.getLogger("borg.output.list").setLevel("INFO" if any(options) else "WARN")
+
     def _setup_topic_debugging(self, args):
         """Turn on DEBUG level logging for specified --debug-topics."""
         for topic in args.debug_topics:
             if "." not in topic:
                 topic = "borg.debug." + topic
             logger.debug("Enabling debug topic %s", topic)
             logging.getLogger(topic).setLevel("DEBUG")
@@ -466,16 +478,17 @@
 
     def run(self, args):
         os.umask(args.umask)  # early, before opening files
         self.lock_wait = args.lock_wait
         func = get_func(args)
         # do not use loggers before this!
         is_serve = func == self.do_serve
-        setup_logging(level=args.log_level, is_serve=is_serve, json=args.log_json)
-        self.log_json = args.log_json
+        self.log_json = args.log_json and not is_serve
+        func_name = getattr(func, "__name__", "none")
+        setup_logging(level=args.log_level, is_serve=is_serve, log_json=self.log_json, func=func_name)
         args.progress |= is_serve
         self._setup_implied_logging(vars(args))
         self._setup_topic_debugging(args)
         if getattr(args, "stats", False) and getattr(args, "dry_run", False):
             # the data needed for --stats is not computed when using --dry-run, so we can't do it.
             # for ease of scripting, we just ignore --stats when given with --dry-run.
             logger.warning("Ignoring --stats. It is not supported when using --dry-run.")
@@ -548,14 +561,37 @@
 
 
 def sig_trace_handler(sig_no, stack):  # pragma: no cover
     print("\nReceived SIGUSR2 at %s, dumping trace..." % datetime.now().replace(microsecond=0), file=sys.stderr)
     faulthandler.dump_traceback()
 
 
+def format_tb(exc):
+    qualname = type(exc).__qualname__
+    remote = isinstance(exc, RemoteRepository.RPCError)
+    if remote:
+        prefix = "Borg server: "
+        trace_back = "\n".join(prefix + l for l in exc.exception_full.splitlines())
+        sys_info = "\n".join(prefix + l for l in exc.sysinfo.splitlines())
+    else:
+        trace_back = traceback.format_exc()
+        sys_info = sysinfo()
+    result = f"""
+Error:
+
+{qualname}: {exc}
+
+If reporting bugs, please include the following:
+
+{trace_back}
+{sys_info}
+"""
+    return result
+
+
 def main():  # pragma: no cover
     # Make sure stdout and stderr have errors='replace' to avoid unicode
     # issues when print()-ing unicode file names
     sys.stdout = ErrorIgnoringTextIOWrapper(sys.stdout.buffer, sys.stdout.encoding, "replace", line_buffering=True)
     sys.stderr = ErrorIgnoringTextIOWrapper(sys.stderr.buffer, sys.stderr.encoding, "replace", line_buffering=True)
 
     # If we receive SIGINT (ctrl-c), SIGTERM (kill) or SIGHUP (kill -HUP),
@@ -578,62 +614,59 @@
     ):
         archiver = Archiver()
         msg = msgid = tb = None
         tb_log_level = logging.ERROR
         try:
             args = archiver.get_args(sys.argv, os.environ.get("SSH_ORIGINAL_COMMAND"))
         except Error as e:
-            msg = e.get_message()
-            tb_log_level = logging.ERROR if e.traceback else logging.DEBUG
-            tb = f"{traceback.format_exc()}\n{sysinfo()}"
             # we might not have logging setup yet, so get out quickly
+            msg = e.get_message()
             print(msg, file=sys.stderr)
-            if tb_log_level == logging.ERROR:
+            if e.traceback:
+                tb = format_tb(e)
                 print(tb, file=sys.stderr)
             sys.exit(e.exit_code)
         try:
             with sig_int:
                 exit_code = archiver.run(args)
         except Error as e:
             msg = e.get_message()
             msgid = type(e).__qualname__
             tb_log_level = logging.ERROR if e.traceback else logging.DEBUG
-            tb = f"{traceback.format_exc()}\n{sysinfo()}"
+            tb = format_tb(e)
             exit_code = e.exit_code
         except RemoteRepository.RPCError as e:
             important = e.exception_class not in ("LockTimeout",) and e.traceback
+            msg = e.exception_full if important else e.get_message()
             msgid = e.exception_class
             tb_log_level = logging.ERROR if important else logging.DEBUG
-            if important:
-                msg = e.exception_full
-            else:
-                msg = e.get_message()
-            tb = "\n".join("Borg server: " + l for l in e.sysinfo.splitlines())
-            tb += "\n" + sysinfo()
+            tb = format_tb(e)
             exit_code = EXIT_ERROR
-        except Exception:
+        except Exception as e:
             msg = "Local Exception"
             msgid = "Exception"
             tb_log_level = logging.ERROR
-            tb = f"{traceback.format_exc()}\n{sysinfo()}"
+            tb = format_tb(e)
             exit_code = EXIT_ERROR
-        except KeyboardInterrupt:
+        except KeyboardInterrupt as e:
             msg = "Keyboard interrupt"
             tb_log_level = logging.DEBUG
-            tb = f"{traceback.format_exc()}\n{sysinfo()}"
+            tb = format_tb(e)
             exit_code = EXIT_SIGNAL_BASE + 2
-        except SigTerm:
+        except SigTerm as e:
             msg = "Received SIGTERM"
             msgid = "Signal.SIGTERM"
             tb_log_level = logging.DEBUG
-            tb = f"{traceback.format_exc()}\n{sysinfo()}"
+            tb = format_tb(e)
             exit_code = EXIT_SIGNAL_BASE + 15
-        except SigHup:
+        except SigHup as e:
             msg = "Received SIGHUP."
             msgid = "Signal.SIGHUP"
+            tb_log_level = logging.DEBUG
+            tb = format_tb(e)
             exit_code = EXIT_SIGNAL_BASE + 1
         if msg:
             logger.error(msg, msgid=msgid)
         if tb:
             logger.log(tb_log_level, tb)
         if args.show_rc:
             rc_logger = logging.getLogger("borg.output.show-rc")
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/_common.py` & `borgbackup-2.0.0b6/src/borg/archiver/_common.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 
 import borg
 from ..archive import Archive
 from ..constants import *  # NOQA
 from ..cache import Cache, assert_secure
 from ..helpers import Error
 from ..helpers import SortBySpec, positive_int_validator, location_validator, Location, relative_time_marker_validator
+from ..helpers import Highlander
 from ..helpers.nanorst import rst_to_terminal
 from ..manifest import Manifest, AI_HUMAN_SORT_KEYS
 from ..patterns import PatternMatcher
 from ..remote import RemoteRepository
 from ..repository import Repository
 from ..repoobj import RepoObj, RepoObj1
 from ..patterns import (
@@ -25,15 +26,15 @@
 
 from ..logger import create_logger
 
 logger = create_logger(__name__)
 
 
 def get_repository(location, *, create, exclusive, lock_wait, lock, append_only, make_parent_dirs, storage_quota, args):
-    if location.proto == "ssh":
+    if location.proto in ("ssh", "socket"):
         repository = RemoteRepository(
             location,
             create=create,
             exclusive=exclusive,
             lock_wait=lock_wait,
             lock=lock,
             append_only=append_only,
@@ -242,23 +243,14 @@
             iec=args.iec,
         )
         return method(self, args, repository=repository, manifest=manifest, archive=archive, **kwargs)
 
     return wrapper
 
 
-class Highlander(argparse.Action):
-    """make sure some option is only given once"""
-
-    def __call__(self, parser, namespace, values, option_string=None):
-        if getattr(namespace, self.dest, None) != self.default:
-            raise argparse.ArgumentError(self, "There can be only one.")
-        setattr(namespace, self.dest, values)
-
-
 # You can use :ref:`xyz` in the following usage pages. However, for plain-text view,
 # e.g. through "borg ... --help", define a substitution for the reference here.
 # It will replace the entire :ref:`foo` verbatim.
 rst_plain_text_references = {
     "a_status_oddity": '"I am seeing A (added) status for a unchanged file!?"',
     "separate_compaction": '"Separate compaction"',
     "list_item_flags": '"Item flags"',
@@ -335,21 +327,22 @@
     if strip_components:
         add_option(
             "--strip-components",
             metavar="NUMBER",
             dest="strip_components",
             type=int,
             default=0,
+            action=Highlander,
             help="Remove the specified number of leading path elements. "
             "Paths with fewer elements will be silently skipped.",
         )
 
 
 def define_exclusion_group(subparser, **kwargs):
-    exclude_group = subparser.add_argument_group("Exclusion options")
+    exclude_group = subparser.add_argument_group("Include/Exclude options")
     define_exclude_and_patterns(exclude_group.add_argument, **kwargs)
     return exclude_group
 
 
 def define_archive_filters_group(subparser, *, sort_by=True, first_last=True, oldest_newest=True, older_newer=True):
     filters_group = subparser.add_argument_group(
         "Archive filters", "Archive filters can be applied to repository targets."
@@ -368,69 +361,76 @@
         sort_by_default = "timestamp"
         filters_group.add_argument(
             "--sort-by",
             metavar="KEYS",
             dest="sort_by",
             type=SortBySpec,
             default=sort_by_default,
+            action=Highlander,
             help="Comma-separated list of sorting keys; valid keys are: {}; default is: {}".format(
                 ", ".join(AI_HUMAN_SORT_KEYS), sort_by_default
             ),
         )
 
     if first_last:
         group = filters_group.add_mutually_exclusive_group()
         group.add_argument(
             "--first",
             metavar="N",
             dest="first",
-            default=0,
             type=positive_int_validator,
+            default=0,
+            action=Highlander,
             help="consider first N archives after other filters were applied",
         )
         group.add_argument(
             "--last",
             metavar="N",
             dest="last",
-            default=0,
             type=positive_int_validator,
+            default=0,
+            action=Highlander,
             help="consider last N archives after other filters were applied",
         )
 
     if oldest_newest:
         group = filters_group.add_mutually_exclusive_group()
         group.add_argument(
             "--oldest",
             metavar="TIMESPAN",
-            type=relative_time_marker_validator,
             dest="oldest",
+            type=relative_time_marker_validator,
+            action=Highlander,
             help="consider archives between the oldest archive's timestamp and (oldest + TIMESPAN), e.g. 7d or 12m.",
         )
         group.add_argument(
             "--newest",
             metavar="TIMESPAN",
-            type=relative_time_marker_validator,
             dest="newest",
+            type=relative_time_marker_validator,
+            action=Highlander,
             help="consider archives between the newest archive's timestamp and (newest - TIMESPAN), e.g. 7d or 12m.",
         )
 
     if older_newer:
         group = filters_group.add_mutually_exclusive_group()
         group.add_argument(
             "--older",
             metavar="TIMESPAN",
-            type=relative_time_marker_validator,
             dest="older",
+            type=relative_time_marker_validator,
+            action=Highlander,
             help="consider archives older than (now - TIMESPAN), e.g. 7d oder 12m.",
         )
         group.add_argument(
             "--newer",
             metavar="TIMESPAN",
-            type=relative_time_marker_validator,
             dest="newer",
+            type=relative_time_marker_validator,
+            action=Highlander,
             help="consider archives newer than (now - TIMESPAN), e.g. 7d or 12m.",
         )
 
     return filters_group
 
 
 def define_common_options(add_common_option):
@@ -496,14 +496,15 @@
     )
     add_common_option(
         "--lock-wait",
         metavar="SECONDS",
         dest="lock_wait",
         type=int,
         default=int(os.environ.get("BORG_LOCK_WAIT", 1)),
+        action=Highlander,
         help="wait at most SECONDS for acquiring a repository/cache lock (default: %(default)d).",
     )
     add_common_option(
         "--bypass-lock",
         dest="lock",
         action="store_false",
         default=argparse.SUPPRESS,  # only create args attribute if option is specified
@@ -513,57 +514,74 @@
     add_common_option("--show-rc", dest="show_rc", action="store_true", help="show/log the return code (rc)")
     add_common_option(
         "--umask",
         metavar="M",
         dest="umask",
         type=lambda s: int(s, 8),
         default=UMASK_DEFAULT,
+        action=Highlander,
         help="set umask to M (local only, default: %(default)04o)",
     )
     add_common_option(
         "--remote-path",
         metavar="PATH",
         dest="remote_path",
+        action=Highlander,
         help='use PATH as borg executable on the remote (default: "borg")',
     )
     add_common_option(
         "--upload-ratelimit",
         metavar="RATE",
         dest="upload_ratelimit",
         type=int,
+        action=Highlander,
         help="set network upload rate limit in kiByte/s (default: 0=unlimited)",
     )
     add_common_option(
         "--upload-buffer",
         metavar="UPLOAD_BUFFER",
         dest="upload_buffer",
         type=int,
+        action=Highlander,
         help="set network upload buffer size in MiB. (default: 0=no buffer)",
     )
     add_common_option(
         "--debug-profile",
         metavar="FILE",
         dest="debug_profile",
         default=None,
+        action=Highlander,
         help="Write execution profile in Borg format into FILE. For local use a Python-"
         'compatible file can be generated by suffixing FILE with ".pyprof".',
     )
     add_common_option(
         "--rsh",
         metavar="RSH",
         dest="rsh",
+        action=Highlander,
         help="Use this command to connect to the 'borg serve' process (default: 'ssh')",
     )
     add_common_option(
+        "--socket",
+        metavar="PATH",
+        dest="use_socket",
+        default=False,
+        const=True,
+        nargs="?",
+        action=Highlander,
+        help="Use UNIX DOMAIN (IPC) socket at PATH for client/server communication with socket: protocol.",
+    )
+    add_common_option(
         "-r",
         "--repo",
         metavar="REPO",
         dest="location",
         type=location_validator(other=False),
         default=Location(other=False),
+        action=Highlander,
         help="repository to use",
     )
 
 
 def build_matcher(inclexcl_patterns, include_paths):
     matcher = PatternMatcher()
     matcher.add_inclexcl(inclexcl_patterns)
@@ -571,15 +589,15 @@
     return matcher
 
 
 def build_filter(matcher, strip_components):
     if strip_components:
 
         def item_filter(item):
-            matched = matcher.match(item.path) and os.sep.join(item.path.split(os.sep)[strip_components:])
+            matched = matcher.match(item.path) and len(item.path.split(os.sep)) > strip_components
             return matched
 
     else:
 
         def item_filter(item):
             matched = matcher.match(item.path)
             return matched
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/benchmark_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/benchmark_cmd.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import argparse
 from contextlib import contextmanager
 import functools
 import os
-import shutil
+import tempfile
 import time
 
 from ..constants import *  # NOQA
 from ..crypto.key import FlexiKey
 from ..helpers import format_file_size
 from ..helpers import msgpack
 from ..item import Item
@@ -56,26 +56,22 @@
             t_end = time.monotonic()
             dt_delete = t_end - t_start
             assert rc == 0
             return dt_create, dt_update, dt_extract, dt_delete
 
         @contextmanager
         def test_files(path, count, size, random):
-            try:
-                path = os.path.join(path, "borg-test-data")
-                os.makedirs(path)
+            with tempfile.TemporaryDirectory(prefix="borg-test-data-", dir=path) as path:
                 z_buff = None if random else memoryview(zeros)[:size] if size <= len(zeros) else b"\0" * size
                 for i in range(count):
                     fname = os.path.join(path, "file_%d" % i)
                     data = z_buff if not random else os.urandom(size)
                     with SyncFile(fname, binary=True) as fd:  # used for posix_fadvise's sake
                         fd.write(data)
                 yield path
-            finally:
-                shutil.rmtree(path)
 
         if "_BORG_BENCHMARK_CRUD_TEST" in os.environ:
             tests = [("Z-TEST", 1, 1, False), ("R-TEST", 1, 1, True)]
         else:
             tests = [
                 ("Z-BIG", 10, 100000000, False),
                 ("R-BIG", 10, 100000000, True),
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/check_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/check_cmd.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import argparse
-from ._common import with_repository
+from ._common import with_repository, Highlander
 from ..archive import ArchiveChecker
 from ..constants import *  # NOQA
 from ..helpers import EXIT_SUCCESS, EXIT_WARNING, EXIT_ERROR
 from ..helpers import yes
 
 from ..logger import create_logger
 
@@ -172,10 +172,11 @@
         )
         subparser.add_argument(
             "--max-duration",
             metavar="SECONDS",
             dest="max_duration",
             type=int,
             default=0,
+            action=Highlander,
             help="do only a partial repo check for max. SECONDS seconds (Default: unlimited)",
         )
         define_archive_filters_group(subparser)
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/compact_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/compact_cmd.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import argparse
 
-from ._common import with_repository
+from ._common import with_repository, Highlander
 from ..constants import *  # NOQA
 from ..helpers import EXIT_SUCCESS
 from ..manifest import Manifest
 
 from ..logger import create_logger
 
 logger = create_logger()
@@ -57,9 +57,10 @@
         subparser.set_defaults(func=self.do_compact)
         subparser.add_argument(
             "--threshold",
             metavar="PERCENT",
             dest="threshold",
             type=int,
             default=10,
+            action=Highlander,
             help="set minimum threshold for saved space in PERCENT (Default: 10)",
         )
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/config_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/config_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/create_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/create_cmd.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+import errno
 import sys
 import argparse
 import logging
 import os
 import stat
 import subprocess
 import time
@@ -22,14 +23,15 @@
 from ..helpers import get_cache_dir, os_stat
 from ..helpers import dir_is_tagged
 from ..helpers import log_multi
 from ..helpers import basic_json_data, json_print
 from ..helpers import flags_root, flags_dir, flags_special_follow, flags_special
 from ..helpers import sig_int, ignore_sigint
 from ..helpers import iter_separated
+from ..helpers import MakePathSafeAction
 from ..manifest import Manifest
 from ..patterns import PatternMatcher
 from ..platform import is_win32
 from ..platform import get_flags
 
 from ..logger import create_logger
 
@@ -127,14 +129,17 @@
                 if args.paths_from_command:
                     rc = proc.wait()
                     if rc != 0:
                         self.print_error("Command %r exited with status %d", args.paths[0], rc)
                         return self.exit_code
             else:
                 for path in args.paths:
+                    if path == "":  # issue #5637
+                        self.print_warning("An empty string was given as PATH, ignoring.")
+                        continue
                     if path == "-":  # stdin
                         path = args.stdin_name
                         mode = args.stdin_mode
                         user = args.stdin_user
                         group = args.stdin_group
                         if not dry_run:
                             try:
@@ -366,14 +371,18 @@
                 elif stat.S_ISPORT(st.st_mode):
                     # Ignore Solaris event ports
                     return
                 else:
                     self.print_warning("Unknown file type: %s", path)
                     return
             except (BackupError, BackupOSError) as err:
+                if isinstance(err, BackupOSError):
+                    if err.errno in (errno.EPERM, errno.EACCES):
+                        # Do not try again, such errors can not be fixed by retrying.
+                        raise
                 # sleep a bit, so temporary problems might go away...
                 sleep_s = 1000.0 / 1e6 * 10 ** (retry / 2)  # retry 0: 1ms, retry 6: 1s, ...
                 time.sleep(sleep_s)
                 if retry < MAX_RETRIES - 1:
                     logger.warning(
                         f"{path}: {err}, slept {sleep_s:.3f}s, next: retry: {retry + 1} of {MAX_RETRIES - 1}..."
                     )
@@ -626,21 +635,21 @@
         only include the objects specified by ``--exclude-if-present`` in your backup,
         and not include any other contents of the containing folder, this can be enabled
         through using the ``--keep-exclude-tags`` option.
 
         The ``-x`` or ``--one-file-system`` option excludes directories, that are mountpoints (and everything in them).
         It detects mountpoints by comparing the device number from the output of ``stat()`` of the directory and its
         parent directory. Specifically, it excludes directories for which ``stat()`` reports a device number different
-        from the device number of their parent. Be aware that in Linux (and possibly elsewhere) there are directories
-        with device number different from their parent, which the kernel does not consider a mountpoint and also the
-        other way around. Examples are bind mounts (possibly same device number, but always a mountpoint) and ALL
-        subvolumes of a btrfs (different device number from parent but not necessarily a mountpoint). Therefore when
-        using ``--one-file-system``, one should make doubly sure that the backup works as intended especially when using
-        btrfs. This is even more important, if the btrfs layout was created by someone else, e.g. a distribution
-        installer.
+        from the device number of their parent.
+        In general: be aware that there are directories with device number different from their parent, which the kernel
+        does not consider a mountpoint and also the other way around.
+        Linux examples for this are bind mounts (possibly same device number, but always a mountpoint) and ALL
+        subvolumes of a btrfs (different device number from parent but not necessarily a mountpoint).
+        macOS examples are the apfs mounts of a typical macOS installation.
+        Therefore, when using ``--one-file-system``, you should double-check that the backup works as intended.
 
 
         .. _list_item_flags:
 
         Item flags
         ++++++++++
 
@@ -754,71 +763,78 @@
             help="experimental: do not synchronize the cache. Implies not using the files cache.",
         )
         subparser.add_argument(
             "--stdin-name",
             metavar="NAME",
             dest="stdin_name",
             default="stdin",
+            action=MakePathSafeAction,
             help="use NAME in archive for stdin data (default: %(default)r)",
         )
         subparser.add_argument(
             "--stdin-user",
             metavar="USER",
             dest="stdin_user",
             default=None,
+            action=Highlander,
             help="set user USER in archive for stdin data (default: do not store user/uid)",
         )
         subparser.add_argument(
             "--stdin-group",
             metavar="GROUP",
             dest="stdin_group",
             default=None,
+            action=Highlander,
             help="set group GROUP in archive for stdin data (default: do not store group/gid)",
         )
         subparser.add_argument(
             "--stdin-mode",
             metavar="M",
             dest="stdin_mode",
             type=lambda s: int(s, 8),
             default=STDIN_MODE_DEFAULT,
+            action=Highlander,
             help="set mode to M in archive for stdin data (default: %(default)04o)",
         )
         subparser.add_argument(
             "--content-from-command",
             action="store_true",
             help="interpret PATH as command and store its stdout. See also section Reading from" " stdin below.",
         )
         subparser.add_argument(
             "--paths-from-stdin",
             action="store_true",
-            help="read DELIM-separated list of paths to back up from stdin. Will not " "recurse into directories.",
+            help="read DELIM-separated list of paths to back up from stdin. All control is external: it will back"
+            " up all files given - no more, no less.",
         )
         subparser.add_argument(
             "--paths-from-command",
             action="store_true",
             help="interpret PATH as command and treat its output as ``--paths-from-stdin``",
         )
         subparser.add_argument(
             "--paths-delimiter",
+            action=Highlander,
             metavar="DELIM",
-            help="set path delimiter for ``--paths-from-stdin`` and ``--paths-from-command`` (default: \\n) ",
+            help="set path delimiter for ``--paths-from-stdin`` and ``--paths-from-command`` (default: ``\\n``) ",
         )
 
         exclude_group = define_exclusion_group(subparser, tag_files=True)
         exclude_group.add_argument(
             "--exclude-nodump", dest="exclude_nodump", action="store_true", help="exclude files flagged NODUMP"
         )
 
         fs_group = subparser.add_argument_group("Filesystem options")
         fs_group.add_argument(
             "-x",
             "--one-file-system",
             dest="one_file_system",
             action="store_true",
-            help="stay in the same file system and do not store mount points of other file systems.  This might behave different from your expectations, see the docs.",
+            help="stay in the same file system and do not store mount points of other file systems - "
+            "this might behave different from your expectations, see the description below.",
         )
         fs_group.add_argument(
             "--numeric-ids",
             dest="numeric_ids",
             action="store_true",
             help="only store numeric user and group identifiers",
         )
@@ -868,40 +884,44 @@
         archive_group = subparser.add_argument_group("Archive options")
         archive_group.add_argument(
             "--comment",
             metavar="COMMENT",
             dest="comment",
             type=comment_validator,
             default="",
+            action=Highlander,
             help="add a comment text to the archive",
         )
         archive_group.add_argument(
             "--timestamp",
             metavar="TIMESTAMP",
             dest="timestamp",
             type=timestamp,
             default=None,
+            action=Highlander,
             help="manually specify the archive creation date/time (yyyy-mm-ddThh:mm:ss[(+|-)HH:MM] format, "
             "(+|-)HH:MM is the UTC offset, default: local time zone). Alternatively, give a reference file/directory.",
         )
         archive_group.add_argument(
             "-c",
             "--checkpoint-interval",
             metavar="SECONDS",
             dest="checkpoint_interval",
             type=int,
             default=1800,
+            action=Highlander,
             help="write checkpoint every SECONDS seconds (Default: 1800)",
         )
         archive_group.add_argument(
             "--checkpoint-volume",
             metavar="BYTES",
             dest="checkpoint_volume",
             type=int,
             default=0,
+            action=Highlander,
             help="write checkpoint every BYTES bytes (Default: 0, meaning no volume based checkpointing)",
         )
         archive_group.add_argument(
             "--chunker-params",
             metavar="PARAMS",
             dest="chunker_params",
             type=ChunkerParams,
@@ -913,12 +933,13 @@
         archive_group.add_argument(
             "-C",
             "--compression",
             metavar="COMPRESSION",
             dest="compression",
             type=CompressionSpec,
             default=CompressionSpec("lz4"),
+            action=Highlander,
             help="select compression algorithm, see the output of the " '"borg help compression" command for details.',
         )
 
         subparser.add_argument("name", metavar="NAME", type=archivename_validator, help="specify the archive name")
         subparser.add_argument("paths", metavar="PATH", nargs="*", type=str, action="extend", help="paths to archive")
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/debug_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/debug_cmd.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 import argparse
 from binascii import unhexlify, hexlify
 import functools
-import hashlib
 import json
 import textwrap
 
 from ..archive import Archive
+from ..compress import CompressionSpec
 from ..constants import *  # NOQA
 from ..helpers import msgpack
 from ..helpers import sysinfo
 from ..helpers import bin_to_hex, prepare_dump_dict
 from ..helpers import dash_open
 from ..helpers import StableDict
 from ..helpers import positive_int_validator, archivename_validator
 from ..manifest import Manifest
 from ..platform import get_process_id
 from ..repository import Repository, LIST_SCAN_LIMIT, TAG_PUT, TAG_DELETE, TAG_COMMIT
 from ..repoobj import RepoObj
 
-from ._common import with_repository
+from ._common import with_repository, Highlander
 from ._common import process_epilog
 
 
 class DebugMixIn:
     def do_debug_info(self, args):
         """display system information for debugging / bug reports"""
         print(sysinfo())
@@ -237,36 +237,109 @@
 
     @with_repository(manifest=False)
     def do_debug_get_obj(self, args, repository):
         """get object contents from the repository and write it into file"""
         hex_id = args.id
         try:
             id = unhexlify(hex_id)
-        except ValueError:
-            print("object id %s is invalid." % hex_id)
-        else:
-            try:
-                data = repository.get(id)
-            except Repository.ObjectNotFound:
-                print("object %s not found." % hex_id)
-            else:
-                with open(args.path, "wb") as f:
-                    f.write(data)
-                print("object %s fetched." % hex_id)
+            if len(id) != 32:  # 256bit
+                raise ValueError("id must be 256bits or 64 hex digits")
+        except ValueError as err:
+            print(f"object id {hex_id} is invalid [{str(err)}].")
+            return EXIT_ERROR
+        try:
+            data = repository.get(id)
+        except Repository.ObjectNotFound:
+            print("object %s not found." % hex_id)
+            return EXIT_ERROR
+        with open(args.path, "wb") as f:
+            f.write(data)
+        print("object %s fetched." % hex_id)
+        return EXIT_SUCCESS
+
+    @with_repository(compatibility=Manifest.NO_OPERATION_CHECK)
+    def do_debug_id_hash(self, args, repository, manifest):
+        """compute id-hash for file contents"""
+        with open(args.path, "rb") as f:
+            data = f.read()
+        key = manifest.key
+        id = key.id_hash(data)
+        print(id.hex())
+        return EXIT_SUCCESS
+
+    @with_repository(compatibility=Manifest.NO_OPERATION_CHECK)
+    def do_debug_parse_obj(self, args, repository, manifest):
+        """parse borg object file into meta dict and data (decrypting, decompressing)"""
+
+        # get the object from id
+        hex_id = args.id
+        try:
+            id = unhexlify(hex_id)
+            if len(id) != 32:  # 256bit
+                raise ValueError("id must be 256bits or 64 hex digits")
+        except ValueError as err:
+            print(f"object id {hex_id} is invalid [{str(err)}].")
+            return EXIT_ERROR
+
+        with open(args.object_path, "rb") as f:
+            cdata = f.read()
+
+        repo_objs = manifest.repo_objs
+        meta, data = repo_objs.parse(id=id, cdata=cdata)
+
+        with open(args.json_path, "w") as f:
+            json.dump(meta, f)
+
+        with open(args.binary_path, "wb") as f:
+            f.write(data)
+
+        return EXIT_SUCCESS
+
+    @with_repository(compatibility=Manifest.NO_OPERATION_CHECK)
+    def do_debug_format_obj(self, args, repository, manifest):
+        """format file and metadata into borg object file"""
+
+        # get the object from id
+        hex_id = args.id
+        try:
+            id = unhexlify(hex_id)
+            if len(id) != 32:  # 256bit
+                raise ValueError("id must be 256bits or 64 hex digits")
+        except ValueError as err:
+            print(f"object id {hex_id} is invalid [{str(err)}].")
+            return EXIT_ERROR
+
+        with open(args.binary_path, "rb") as f:
+            data = f.read()
+
+        with open(args.json_path) as f:
+            meta = json.load(f)
+
+        repo_objs = manifest.repo_objs
+        data_encrypted = repo_objs.format(id=id, meta=meta, data=data)
+
+        with open(args.object_path, "wb") as f:
+            f.write(data_encrypted)
         return EXIT_SUCCESS
 
     @with_repository(manifest=False, exclusive=True)
     def do_debug_put_obj(self, args, repository):
-        """put file(s) contents into the repository"""
-        for path in args.paths:
-            with open(path, "rb") as f:
-                data = f.read()
-            h = hashlib.sha256(data)  # XXX hardcoded
-            repository.put(h.digest(), data)
-            print("object %s put." % h.hexdigest())
+        """put file contents into the repository"""
+        with open(args.path, "rb") as f:
+            data = f.read()
+        hex_id = args.id
+        try:
+            id = unhexlify(hex_id)
+            if len(id) != 32:  # 256bit
+                raise ValueError("id must be 256bits or 64 hex digits")
+        except ValueError as err:
+            print(f"object id {hex_id} is invalid [{str(err)}].")
+            return EXIT_ERROR
+        repository.put(id, data)
+        print("object %s put." % hex_id)
         repository.commit(compact=False)
         return EXIT_SUCCESS
 
     @with_repository(manifest=False, exclusive=True)
     def do_debug_delete_obj(self, args, repository):
         """delete the objects with the given IDs from the repo"""
         modified = False
@@ -444,24 +517,26 @@
             action="store_true",
             help="dump all segment file contents, including deleted/uncommitted objects and commits.",
         )
         subparser.add_argument(
             "--segment",
             metavar="SEG",
             dest="segment",
-            default=None,
             type=positive_int_validator,
+            default=None,
+            action=Highlander,
             help="used together with --ghost: limit processing to given segment.",
         )
         subparser.add_argument(
             "--offset",
             metavar="OFFS",
             dest="offset",
-            default=None,
             type=positive_int_validator,
+            default=None,
+            action=Highlander,
             help="used together with --ghost: limit processing to given offset.",
         )
 
         debug_search_repo_objs_epilog = process_epilog(
             """
         This command searches raw (but decrypted and decompressed) repo objects for a specific bytes sequence.
         """
@@ -476,16 +551,102 @@
             help="search repo objects (debug)",
         )
         subparser.set_defaults(func=self.do_debug_search_repo_objs)
         subparser.add_argument(
             "wanted",
             metavar="WANTED",
             type=str,
+            action=Highlander,
             help="term to search the repo for, either 0x1234abcd hex term or a string",
         )
+        debug_id_hash_epilog = process_epilog(
+            """
+                This command computes the id-hash for some file content.
+                """
+        )
+        subparser = debug_parsers.add_parser(
+            "id-hash",
+            parents=[common_parser],
+            add_help=False,
+            description=self.do_debug_id_hash.__doc__,
+            epilog=debug_id_hash_epilog,
+            formatter_class=argparse.RawDescriptionHelpFormatter,
+            help="compute id-hash for some file content (debug)",
+        )
+        subparser.set_defaults(func=self.do_debug_id_hash)
+        subparser.add_argument(
+            "path", metavar="PATH", type=str, help="content for which the id-hash shall get computed"
+        )
+
+        # parse_obj
+        debug_parse_obj_epilog = process_epilog(
+            """
+                This command parses the object file into metadata (as json) and uncompressed data.
+                """
+        )
+        subparser = debug_parsers.add_parser(
+            "parse-obj",
+            parents=[common_parser],
+            add_help=False,
+            description=self.do_debug_parse_obj.__doc__,
+            epilog=debug_parse_obj_epilog,
+            formatter_class=argparse.RawDescriptionHelpFormatter,
+            help="parse borg object file into meta dict and data",
+        )
+        subparser.set_defaults(func=self.do_debug_parse_obj)
+        subparser.add_argument("id", metavar="ID", type=str, help="hex object ID to get from the repo")
+        subparser.add_argument(
+            "object_path", metavar="OBJECT_PATH", type=str, help="path of the object file to parse data from"
+        )
+        subparser.add_argument(
+            "binary_path", metavar="BINARY_PATH", type=str, help="path of the file to write uncompressed data into"
+        )
+        subparser.add_argument(
+            "json_path", metavar="JSON_PATH", type=str, help="path of the json file to write metadata into"
+        )
+
+        # format_obj
+        debug_format_obj_epilog = process_epilog(
+            """
+                This command formats the file and metadata into objectfile.
+                """
+        )
+        subparser = debug_parsers.add_parser(
+            "format-obj",
+            parents=[common_parser],
+            add_help=False,
+            description=self.do_debug_format_obj.__doc__,
+            epilog=debug_format_obj_epilog,
+            formatter_class=argparse.RawDescriptionHelpFormatter,
+            help="format file and metadata into borg objectfile",
+        )
+        subparser.set_defaults(func=self.do_debug_format_obj)
+        subparser.add_argument("id", metavar="ID", type=str, help="hex object ID to get from the repo")
+        subparser.add_argument(
+            "binary_path", metavar="BINARY_PATH", type=str, help="path of the file to convert into objectfile"
+        )
+        subparser.add_argument(
+            "json_path", metavar="JSON_PATH", type=str, help="path of the json file to read metadata from"
+        )
+        subparser.add_argument(
+            "-C",
+            "--compression",
+            metavar="COMPRESSION",
+            dest="compression",
+            type=CompressionSpec,
+            default=CompressionSpec("lz4"),
+            action=Highlander,
+            help="select compression algorithm, see the output of the " '"borg help compression" command for details.',
+        )
+        subparser.add_argument(
+            "object_path",
+            metavar="OBJECT_PATH",
+            type=str,
+            help="path of the objectfile to write compressed encrypted data into",
+        )
 
         debug_get_obj_epilog = process_epilog(
             """
         This command gets an object from the repository.
         """
         )
         subparser = debug_parsers.add_parser(
@@ -499,30 +660,29 @@
         )
         subparser.set_defaults(func=self.do_debug_get_obj)
         subparser.add_argument("id", metavar="ID", type=str, help="hex object ID to get from the repo")
         subparser.add_argument("path", metavar="PATH", type=str, help="file to write object data into")
 
         debug_put_obj_epilog = process_epilog(
             """
-        This command puts objects into the repository.
+        This command puts an object into the repository.
         """
         )
         subparser = debug_parsers.add_parser(
             "put-obj",
             parents=[common_parser],
             add_help=False,
             description=self.do_debug_put_obj.__doc__,
             epilog=debug_put_obj_epilog,
             formatter_class=argparse.RawDescriptionHelpFormatter,
             help="put object to repository (debug)",
         )
         subparser.set_defaults(func=self.do_debug_put_obj)
-        subparser.add_argument(
-            "paths", metavar="PATH", nargs="+", type=str, help="file(s) to read and create object(s) from"
-        )
+        subparser.add_argument("id", metavar="ID", type=str, help="hex object ID to put into the repo")
+        subparser.add_argument("path", metavar="PATH", type=str, help="file to read and create object from")
 
         debug_delete_obj_epilog = process_epilog(
             """
         This command deletes objects from the repository.
         """
         )
         subparser = debug_parsers.add_parser(
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/delete_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/delete_cmd.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import argparse
 import logging
 
-from ._common import with_repository
+from ._common import with_repository, Highlander
 from ..archive import Archive, Statistics
 from ..cache import Cache
 from ..constants import *  # NOQA
 from ..helpers import log_multi, format_archive, sig_int
 from ..manifest import Manifest
 
 from ..logger import create_logger
@@ -139,29 +139,24 @@
             dest="consider_checkpoints",
             help="consider checkpoint archives for deletion (default: not considered).",
         )
         subparser.add_argument(
             "-s", "--stats", dest="stats", action="store_true", help="print statistics for the deleted archive"
         )
         subparser.add_argument(
-            "--cache-only",
-            dest="cache_only",
-            action="store_true",
-            help="delete only the local cache for the given repository",
-        )
-        subparser.add_argument(
             "--force",
             dest="forced",
             action="count",
             default=0,
             help="force deletion of corrupted archives, " "use ``--force --force`` in case ``--force`` does not work.",
         )
         subparser.add_argument(
             "-c",
             "--checkpoint-interval",
             metavar="SECONDS",
             dest="checkpoint_interval",
             type=int,
             default=1800,
+            action=Highlander,
             help="write checkpoint every SECONDS seconds (Default: 1800)",
         )
         define_archive_filters_group(subparser)
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/diff_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/diff_cmd.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,34 +1,34 @@
 import argparse
+import textwrap
 import json
+import sys
+import os
 
-from ._common import with_repository, with_archive, build_matcher
+from ._common import with_repository, with_archive, build_matcher, Highlander
 from ..archive import Archive
 from ..constants import *  # NOQA
-from ..helpers import archivename_validator
+from ..helpers import BaseFormatter, DiffFormatter, archivename_validator, BorgJsonEncoder
 from ..manifest import Manifest
-
 from ..logger import create_logger
 
 logger = create_logger()
 
 
 class DiffMixIn:
     @with_repository(compatibility=(Manifest.Operation.READ,))
     @with_archive
     def do_diff(self, args, repository, manifest, archive):
         """Diff contents of two archives"""
-
-        def print_json_output(diff, path):
-            print(json.dumps({"path": path, "changes": [j for j, str in diff]}))
-
-        def print_text_output(diff, path):
-            print("{:<19} {}".format(" ".join([str for j, str in diff]), path))
-
-        print_output = print_json_output if args.json_lines else print_text_output
+        if args.format is not None:
+            format = args.format
+        elif args.content_only:
+            format = "{content}{link}{directory}{blkdev}{chrdev}{fifo} {path}{NL}"
+        else:
+            format = os.environ.get("BORG_DIFF_FORMAT", "{change} {path}{NL}")
 
         archive1 = archive
         archive2 = Archive(manifest, args.other_name)
 
         can_compare_chunk_ids = (
             archive1.metadata.get("chunker_params", False) == archive2.metadata.get("chunker_params", True)
             or args.same_chunker_params
@@ -38,52 +38,96 @@
                 "--chunker-params might be different between archives, diff will be slow.\n"
                 "If you know for certain that they are the same, pass --same-chunker-params "
                 "to override this check."
             )
 
         matcher = build_matcher(args.patterns, args.paths)
 
-        diffs = Archive.compare_archives_iter(archive1, archive2, matcher, can_compare_chunk_ids=can_compare_chunk_ids)
+        diffs_iter = Archive.compare_archives_iter(
+            archive1, archive2, matcher, can_compare_chunk_ids=can_compare_chunk_ids
+        )
         # Conversion to string and filtering for diff.equal to save memory if sorting
-        diffs = ((path, diff.changes()) for path, diff in diffs if not diff.equal)
+        diffs = (diff for diff in diffs_iter if not diff.equal(args.content_only))
 
         if args.sort:
-            diffs = sorted(diffs)
+            diffs = sorted(diffs, key=lambda diff: diff.path)
 
-        for path, diff in diffs:
-            print_output(diff, path)
+        formatter = DiffFormatter(format, args.content_only)
+        for diff in diffs:
+            if args.json_lines:
+                print(
+                    json.dumps(
+                        {
+                            "path": diff.path,
+                            "changes": [
+                                change.to_dict()
+                                for name, change in diff.changes().items()
+                                if not args.content_only or (name not in DiffFormatter.METADATA)
+                            ],
+                        },
+                        sort_keys=True,
+                        cls=BorgJsonEncoder,
+                    )
+                )
+            else:
+                res: str = formatter.format_item(diff)
+                if res.strip():
+                    sys.stdout.write(res)
 
         for pattern in matcher.get_unmatched_include_patterns():
             self.print_warning("Include pattern '%s' never matched.", pattern)
 
         return self.exit_code
 
     def build_parser_diff(self, subparsers, common_parser, mid_common_parser):
         from ._common import process_epilog
         from ._common import define_exclusion_group
 
-        diff_epilog = process_epilog(
-            """
-            This command finds differences (file contents, user/group/mode) between archives.
-
-            A repository location and an archive name must be specified for REPO::ARCHIVE1.
-            ARCHIVE2 is just another archive name in same repository (no repository location
-            allowed).
-
-            For archives created with Borg 1.1 or newer diff automatically detects whether
-            the archives are created with the same chunker params. If so, only chunk IDs
-            are compared, which is very fast.
-
-            For archives prior to Borg 1.1 chunk contents are compared by default.
-            If you did not create the archives with different chunker params,
-            pass ``--same-chunker-params``.
-            Note that the chunker params changed from Borg 0.xx to 1.0.
+        diff_epilog = (
+            process_epilog(
+                """
+        This command finds differences (file contents, metadata) between ARCHIVE1 and ARCHIVE2.
+
+        For more help on include/exclude patterns, see the :ref:`borg_patterns` command output.
+
+        .. man NOTES
+
+        The FORMAT specifier syntax
+        +++++++++++++++++++++++++++
+
+        The ``--format`` option uses python's `format string syntax
+        <https://docs.python.org/3.9/library/string.html#formatstrings>`_.
+
+        Examples:
+        ::
+
+            $ borg diff --format '{content:30} {path}{NL}' ArchiveFoo ArchiveBar
+            modified:  +4.1 kB  -1.0 kB    file-diff
+            ...
+
+            # {VAR:<NUMBER} - pad to NUMBER columns left-aligned.
+            # {VAR:>NUMBER} - pad to NUMBER columns right-aligned.
+            $ borg diff --format '{content:>30} {path}{NL}' ArchiveFoo ArchiveBar
+               modified:  +4.1 kB  -1.0 kB file-diff
+            ...
 
-            For more help on include/exclude patterns, see the :ref:`borg_patterns` command output.
-            """
+        The following keys are always available:
+
+
+        """
+            )
+            + BaseFormatter.keys_help()
+            + textwrap.dedent(
+                """
+
+        Keys available only when showing differences between archives:
+
+        """
+            )
+            + DiffFormatter.keys_help()
         )
         subparser = subparsers.add_parser(
             "diff",
             parents=[common_parser],
             add_help=False,
             description=self.do_diff.__doc__,
             epilog=diff_epilog,
@@ -100,15 +144,27 @@
         subparser.add_argument(
             "--same-chunker-params",
             dest="same_chunker_params",
             action="store_true",
             help="Override check of chunker parameters.",
         )
         subparser.add_argument("--sort", dest="sort", action="store_true", help="Sort the output lines by file path.")
+        subparser.add_argument(
+            "--format",
+            metavar="FORMAT",
+            dest="format",
+            action=Highlander,
+            help='specify format for differences between archives (default: "{change} {path}{NL}")',
+        )
         subparser.add_argument("--json-lines", action="store_true", help="Format output as JSON Lines. ")
+        subparser.add_argument(
+            "--content-only",
+            action="store_true",
+            help="Only compare differences in content (exclude metadata differences)",
+        )
         subparser.add_argument("name", metavar="ARCHIVE1", type=archivename_validator, help="ARCHIVE1 name")
         subparser.add_argument("other_name", metavar="ARCHIVE2", type=archivename_validator, help="ARCHIVE2 name")
         subparser.add_argument(
             "paths",
             metavar="PATH",
             nargs="*",
             type=str,
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/extract_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/extract_cmd.py`

 * *Files 8% similar despite different names*

```diff
@@ -38,14 +38,15 @@
 
         progress = args.progress
         output_list = args.output_list
         dry_run = args.dry_run
         stdout = args.stdout
         sparse = args.sparse
         strip_components = args.strip_components
+        continue_extraction = args.continue_extraction
         dirs = []
         hlm = HardLinkManager(id_type=bytes, info_type=str)  # hlid -> path
 
         filter = build_filter(matcher, strip_components)
         if progress:
             pi = ProgressIndicatorPercent(msg="%5.1f%% Extracting: %s", step=0.1, msgid="extract")
             pi.output("Calculating total archive size for the progress indicator (might take long for large archives)")
@@ -72,21 +73,15 @@
                     archive.extract_item(item, dry_run=True, hlm=hlm, pi=pi)
                 else:
                     if stat.S_ISDIR(item.mode):
                         dirs.append(item)
                         archive.extract_item(item, stdout=stdout, restore_attrs=False)
                     else:
                         archive.extract_item(
-                            item,
-                            stdout=stdout,
-                            sparse=sparse,
-                            hlm=hlm,
-                            stripped_components=strip_components,
-                            original_path=orig_path,
-                            pi=pi,
+                            item, stdout=stdout, sparse=sparse, hlm=hlm, pi=pi, continue_extraction=continue_extraction
                         )
             except (BackupOSError, BackupError) as e:
                 self.print_warning("%s: %s", remove_surrogates(orig_path), e)
 
         if pi:
             pi.finish()
 
@@ -170,12 +165,18 @@
         )
         subparser.add_argument(
             "--sparse",
             dest="sparse",
             action="store_true",
             help="create holes in output sparse file from all-zero chunks",
         )
+        subparser.add_argument(
+            "--continue",
+            dest="continue_extraction",
+            action="store_true",
+            help="continue a previously interrupted extraction of same archive",
+        )
         subparser.add_argument("name", metavar="NAME", type=archivename_validator, help="specify the archive name")
         subparser.add_argument(
             "paths", metavar="PATH", nargs="*", type=str, help="paths to extract; patterns are supported"
         )
         define_exclusion_group(subparser, strip_components=True)
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/help_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/help_cmd.py`

 * *Files 3% similar despite different names*

```diff
@@ -24,23 +24,21 @@
         Borg always stores all file paths normalized and relative to the
         current recursion root. The recursion root is also named ``PATH`` in
         Borg commands like `borg create` that do a file discovery, so do not
         confuse the root with the ``PATH`` argument of e.g. `borg extract`.
 
         Starting with Borg 1.2, paths that are matched against patterns always
         appear relative. If you give ``/absolute/`` as root, the paths going
-        into the matcher will look relative like ``absolute/.../file.ext``.
-        If you give ``../some/path`` as root, the paths will look like
-        ``some/path/.../file.ext``.
-
-        File patterns support five different styles. If followed by a colon ':',
-        the first two characters of a pattern are used as a style selector.
-        Explicit style selection is necessary if a non-default style is desired
-        or when the desired pattern starts with two alphanumeric characters
-        followed by a colon (i.e. ``aa:something/*``).
+        into the matcher will start with ``absolute/``.
+        If you give ``../../relative`` as root, the paths will be normalized
+        as ``relative/``.
+
+        Borg supports different pattern styles. To define a non-default
+        style for a specific pattern, prefix it with two characters followed
+        by a colon ':' (i.e. ``fm:path/*``, ``sh:path/**``).
 
         `Fnmatch <https://docs.python.org/3/library/fnmatch.html>`_, selector ``fm:``
             This is the default style for ``--exclude`` and ``--exclude-from``.
             These patterns use a variant of shell pattern syntax, with '\\*' matching
             any number of characters, '?' matching any single character, '[...]'
             matching any single character specified, including ranges, and '[!...]'
             matching any character not specified. For the purpose of these patterns,
@@ -55,15 +53,16 @@
             path separator is always removed.
 
         Shell-style patterns, selector ``sh:``
             This is the default style for ``--pattern`` and ``--patterns-from``.
             Like fnmatch patterns these are similar to shell patterns. The difference
             is that the pattern may include ``**/`` for matching zero or more directory
             levels, ``*`` for matching zero or more arbitrary characters with the
-            exception of any path separator. A leading path separator is always removed.
+            exception of any path separator, ``{}`` containing comma-separated
+            alternative patterns. A leading path separator is always removed.
 
         `Regular expressions <https://docs.python.org/3/library/re.html>`_, selector ``re:``
             Unlike shell patterns, regular expressions are not required to match the full
             path and any substring match is sufficient. It is strongly recommended to
             anchor patterns to the start ('^'), to the end ('$') or both. Path
             separators (backslash for Windows and '/' on other systems) in paths are
             always normalized to a forward slash '/' before applying a pattern.
@@ -175,14 +174,33 @@
             pattern and would otherwise not be backed up.
 
         The first matching pattern is used, so if an include pattern matches
         before an exclude pattern, the file is backed up. Note that a no-recurse
         exclude stops examination of subdirectories so that potential includes
         will not match - use normal excludes for such use cases.
 
+        Example::
+
+            # Define the recursion root
+            R /
+            # Exclude all iso files in any directory
+            - **/*.iso
+            # Explicitly include all inside etc and root
+            + etc/**
+            + root/**
+            # Exclude a specific directory under each user's home directories
+            - home/*/.cache
+            # Explicitly include everything in /home
+            + home/**
+            # Explicitly exclude some directories without recursing into them
+            ! re:^(dev|proc|run|sys|tmp)
+            # Exclude all other files and directories
+            # that are not specifically included earlier.
+            - **
+
         **Tip: You can easily test your patterns with --dry-run and  --list**::
 
             $ borg create --dry-run --list --patterns-from patterns.txt archive
 
         This will list the considered files one per line, prefixed with a
         character that indicates the action (e.g. 'x' for excluding, see
         **Item flags** in `borg create` usage docs).
@@ -381,48 +399,63 @@
             The heuristic tries with lz4 whether the data is compressible.
             For incompressible data, it will not use compression (uses "none").
             For compressible data, it uses the given C[,L] compression - with C[,L]
             being any valid compression specifier.
 
         obfuscate,SPEC,C[,L]
             Use compressed-size obfuscation to make fingerprinting attacks based on
-            the observable stored chunk size more difficult.
-            Note:
-            - you must combine this with encryption or it won't make any sense.
-            - your repo size will be bigger, of course.
+            the observable stored chunk size more difficult. Note:
 
-            The SPEC value will determine how the size obfuscation will work:
+            - You must combine this with encryption, or it won't make any sense.
+            - Your repo size will be bigger, of course.
+            - A chunk is limited by the constant ``MAX_DATA_SIZE`` (cur. ~20MiB).
+
+            The SPEC value determines how the size obfuscation works:
+
+            *Relative random reciprocal size variation* (multiplicative)
 
-            Relative random reciprocal size variation:
             Size will increase by a factor, relative to the compressed data size.
-            Smaller factors are often used, larger factors rarely.
-            1: factor 0.01 .. 100.0
-            2: factor 0.1 .. 1000.0
-            3: factor 1.0 .. 10000.0
-            4: factor 10.0 .. 100000.0
-            5: factor 100.0 .. 1000000.0
-            6: factor 1000.0 .. 10000000.0
-
-            Add a randomly sized padding up to the given size:
-            110: 1kiB
-            ...
-            120: 1MiB
-            ...
-            123: 8MiB (max.)
+            Smaller factors are used often, larger factors rarely.
+
+            Available factors::
+
+              1:     0.01 ..        100
+              2:     0.1  ..      1,000
+              3:     1    ..     10,000
+              4:    10    ..    100,000
+              5:   100    ..  1,000,000
+              6: 1,000    .. 10,000,000
+
+            Example probabilities for SPEC ``1``::
+
+              90   %  0.01 ..   0.1
+               9   %  0.1  ..   1
+               0.9 %  1    ..  10
+               0.09% 10    .. 100
+
+            *Randomly sized padding up to the given size* (additive)
+
+            ::
+
+              110: 1kiB (2 ^ (SPEC - 100))
+              ...
+              120: 1MiB
+              ...
+              123: 8MiB (max.)
 
         Examples::
 
             borg create --compression lz4 REPO::ARCHIVE data
             borg create --compression zstd REPO::ARCHIVE data
             borg create --compression zstd,10 REPO::ARCHIVE data
             borg create --compression zlib REPO::ARCHIVE data
             borg create --compression zlib,1 REPO::ARCHIVE data
             borg create --compression auto,lzma,6 REPO::ARCHIVE data
             borg create --compression auto,lzma ...
-            borg create --compression obfuscate,3,none ...
+            borg create --compression obfuscate,110,none ...
             borg create --compression obfuscate,3,auto,zstd,10 ...
             borg create --compression obfuscate,2,zstd,6 ...\n\n"""
     )
 
     def do_help(self, parser, commands, args):
         if not args.topic:
             parser.print_help()
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/info_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/info_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/key_cmds.py` & `borgbackup-2.0.0b6/src/borg/archiver/key_cmds.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/list_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/list_cmd.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import argparse
+import os
 import textwrap
 import sys
 
-from ._common import with_repository, build_matcher
+from ._common import with_repository, build_matcher, Highlander
 from ..archive import Archive
 from ..cache import Cache
 from ..constants import *  # NOQA
 from ..helpers import ItemFormatter, BaseFormatter, archivename_validator
 from ..manifest import Manifest
 
 from ..logger import create_logger
@@ -20,22 +21,21 @@
         """List archive contents"""
         matcher = build_matcher(args.patterns, args.paths)
         if args.format is not None:
             format = args.format
         elif args.short:
             format = "{path}{NL}"
         else:
-            format = "{mode} {user:6} {group:6} {size:8} {mtime} {path}{extra}{NL}"
+            format = os.environ.get("BORG_LIST_FORMAT", "{mode} {user:6} {group:6} {size:8} {mtime} {path}{extra}{NL}")
 
         def _list_inner(cache):
             archive = Archive(manifest, args.name, cache=cache)
-
-            formatter = ItemFormatter(archive, format, json_lines=args.json_lines)
+            formatter = ItemFormatter(archive, format)
             for item in archive.iter_items(lambda item: matcher.match(item.path)):
-                sys.stdout.write(formatter.format_item(item))
+                sys.stdout.write(formatter.format_item(item, args.json_lines, sort=True))
 
         # Only load the cache if it will be used
         if ItemFormatter.format_needs_cache(format):
             with Cache(repository, manifest, lock_wait=self.lock_wait) as cache:
                 _list_inner(cache)
         else:
             _list_inner(cache=None)
@@ -101,14 +101,15 @@
         subparser.add_argument(
             "--short", dest="short", action="store_true", help="only print file/directory names, nothing else"
         )
         subparser.add_argument(
             "--format",
             metavar="FORMAT",
             dest="format",
+            action=Highlander,
             help="specify format for file listing "
             '(default: "{mode} {user:6} {group:6} {size:8} {mtime} {path}{extra}{NL}")',
         )
         subparser.add_argument(
             "--json-lines",
             action="store_true",
             help="Format output as JSON Lines. "
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/lock_cmds.py` & `borgbackup-2.0.0b6/src/borg/archiver/lock_cmds.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/mount_cmds.py` & `borgbackup-2.0.0b6/src/borg/archiver/mount_cmds.py`

 * *Files 3% similar despite different names*

```diff
@@ -20,16 +20,20 @@
 
         from ..fuse_impl import llfuse, BORG_FUSE_IMPL
 
         if llfuse is None:
             self.print_error("borg mount not available: no FUSE support, BORG_FUSE_IMPL=%s." % BORG_FUSE_IMPL)
             return self.exit_code
 
-        if not os.path.isdir(args.mountpoint) or not os.access(args.mountpoint, os.R_OK | os.W_OK | os.X_OK):
-            self.print_error("%s: Mountpoint must be a writable directory" % args.mountpoint)
+        if not os.path.isdir(args.mountpoint):
+            self.print_error(f"{args.mountpoint}: Mountpoint must be an **existing directory**")
+            return self.exit_code
+
+        if not os.access(args.mountpoint, os.R_OK | os.W_OK | os.X_OK):
+            self.print_error(f"{args.mountpoint}: Mountpoint must be a **writable** directory")
             return self.exit_code
 
         return self._do_mount(args)
 
     @with_repository(compatibility=(Manifest.Operation.READ,))
     def _do_mount(self, args, repository, manifest):
         from ..fuse import FuseOperations
@@ -85,22 +89,22 @@
         the filesystem if libfuse is not used). However, you should not specify these
         manually. Unlike the ``uid`` and ``gid`` mount options which affect all files,
         ``user_id`` and ``group_id`` affect the user and group id of the mounted
         (base) directory.
 
         Additional mount options supported by borg:
 
-        - versions: when used with a repository mount, this gives a merged, versioned
+        - ``versions``: when used with a repository mount, this gives a merged, versioned
           view of the files in the archives. EXPERIMENTAL, layout may change in future.
-        - allow_damaged_files: by default damaged files (where missing chunks were
-          replaced with runs of zeros by borg check ``--repair``) are not readable and
+        - ``allow_damaged_files``: by default damaged files (where missing chunks were
+          replaced with runs of zeros by ``borg check --repair``) are not readable and
           return EIO (I/O error). Set this option to read such files.
-        - ignore_permissions: for security reasons the "default_permissions" mount
-          option is internally enforced by borg. "ignore_permissions" can be given to
-          not enforce "default_permissions".
+        - ``ignore_permissions``: for security reasons the ``default_permissions`` mount
+          option is internally enforced by borg. ``ignore_permissions`` can be given to
+          not enforce ``default_permissions``.
 
         The BORG_MOUNT_DATA_CACHE_ENTRIES environment variable is meant for advanced users
         to tweak the performance. It sets the number of cached data chunks; additional
         memory usage can be up to ~8 MiB times this number. The default is the number
         of CPU cores.
 
         When the daemonized process receives a signal or crashes, it does not unmount.
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/prune_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/prune_cmd.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 import argparse
 from collections import OrderedDict
 from datetime import datetime, timezone, timedelta
 import logging
 from operator import attrgetter
+import os
 import re
 
-from ._common import with_repository
+from ._common import with_repository, Highlander
 from ..archive import Archive, Statistics
 from ..cache import Cache
 from ..constants import *  # NOQA
-from ..helpers import format_archive, interval, sig_int, log_multi, ProgressIndicatorPercent
+from ..helpers import ArchiveFormatter, interval, sig_int, log_multi, ProgressIndicatorPercent
 from ..manifest import Manifest
 
 from ..logger import create_logger
 
 logger = create_logger()
 
 
@@ -78,14 +79,22 @@
         ):
             self.print_error(
                 'At least one of the "keep-within", "keep-last", '
                 '"keep-secondly", "keep-minutely", "keep-hourly", "keep-daily", '
                 '"keep-weekly", "keep-monthly" or "keep-yearly" settings must be specified.'
             )
             return self.exit_code
+        if args.format is not None:
+            format = args.format
+        elif args.short:
+            format = "{archive}"
+        else:
+            format = os.environ.get("BORG_PRUNE_FORMAT", "{archive:<36} {time} [{id}]")
+        formatter = ArchiveFormatter(format, repository, manifest, manifest.key, iec=args.iec)
+
         checkpoint_re = r"\.checkpoint(\.\d+)?"
         archives_checkpoints = manifest.archives.list(
             match=args.match_archives,
             consider_checkpoints=True,
             match_end=r"(%s)?\Z" % checkpoint_re,
             sort_by=["ts"],
             reverse=True,
@@ -151,18 +160,20 @@
                 else:
                     if is_checkpoint(archive.name):
                         log_message = "Keeping checkpoint archive:"
                     else:
                         log_message = "Keeping archive (rule: {rule} #{num}):".format(
                             rule=kept_because[archive.id][0], num=kept_because[archive.id][1]
                         )
-                if args.output_list:
-                    list_logger.info(
-                        "{message:<40} {archive}".format(message=log_message, archive=format_archive(archive))
-                    )
+                if (
+                    args.output_list
+                    or (args.list_pruned and archive in to_delete)
+                    or (args.list_kept and archive not in to_delete)
+                ):
+                    list_logger.info(f"{log_message:<40} {formatter.format_item(archive, jsonline=False)}")
             pi.finish()
             if sig_int:
                 # Ctrl-C / SIGINT: do not checkpoint (commit) again, we already have a checkpoint in this case.
                 self.print_error("Got Ctrl-C / SIGINT.")
             elif uncommitted_deletes > 0:
                 checkpoint_func()
             if args.stats:
@@ -225,14 +236,18 @@
         keep the last N archives under the assumption that you do not create more than one
         backup archive in the same second).
 
         When using ``--stats``, you will get some statistics about how much data was
         deleted - the "Deleted data" deduplicated size there is most interesting as
         that is how much your repository will shrink.
         Please note that the "All archives" stats refer to the state after pruning.
+
+        You can influence how the ``--list`` output is formatted by using the ``--short``
+        option (less wide output) or by giving a custom format using ``--format`` (see
+        the ``borg rlist`` description for more details about the format string).
         """
         )
         subparser = subparsers.add_parser(
             "prune",
             parents=[common_parser],
             add_help=False,
             description=self.do_prune.__doc__,
@@ -250,50 +265,102 @@
         )
         subparser.add_argument(
             "-s", "--stats", dest="stats", action="store_true", help="print statistics for the deleted archive"
         )
         subparser.add_argument(
             "--list", dest="output_list", action="store_true", help="output verbose list of archives it keeps/prunes"
         )
+        subparser.add_argument("--short", dest="short", action="store_true", help="use a less wide archive part format")
+        subparser.add_argument(
+            "--list-pruned", dest="list_pruned", action="store_true", help="output verbose list of archives it prunes"
+        )
+        subparser.add_argument(
+            "--list-kept", dest="list_kept", action="store_true", help="output verbose list of archives it keeps"
+        )
+        subparser.add_argument(
+            "--format",
+            metavar="FORMAT",
+            dest="format",
+            action=Highlander,
+            help="specify format for the archive part " '(default: "{archive:<36} {time} [{id}]")',
+        )
         subparser.add_argument(
             "--keep-within",
             metavar="INTERVAL",
             dest="within",
             type=interval,
+            action=Highlander,
             help="keep all archives within this time interval",
         )
         subparser.add_argument(
             "--keep-last",
             "--keep-secondly",
             dest="secondly",
             type=int,
             default=0,
+            action=Highlander,
             help="number of secondly archives to keep",
         )
         subparser.add_argument(
-            "--keep-minutely", dest="minutely", type=int, default=0, help="number of minutely archives to keep"
+            "--keep-minutely",
+            dest="minutely",
+            type=int,
+            default=0,
+            action=Highlander,
+            help="number of minutely archives to keep",
         )
         subparser.add_argument(
-            "-H", "--keep-hourly", dest="hourly", type=int, default=0, help="number of hourly archives to keep"
+            "-H",
+            "--keep-hourly",
+            dest="hourly",
+            type=int,
+            default=0,
+            action=Highlander,
+            help="number of hourly archives to keep",
         )
         subparser.add_argument(
-            "-d", "--keep-daily", dest="daily", type=int, default=0, help="number of daily archives to keep"
+            "-d",
+            "--keep-daily",
+            dest="daily",
+            type=int,
+            default=0,
+            action=Highlander,
+            help="number of daily archives to keep",
         )
         subparser.add_argument(
-            "-w", "--keep-weekly", dest="weekly", type=int, default=0, help="number of weekly archives to keep"
+            "-w",
+            "--keep-weekly",
+            dest="weekly",
+            type=int,
+            default=0,
+            action=Highlander,
+            help="number of weekly archives to keep",
         )
         subparser.add_argument(
-            "-m", "--keep-monthly", dest="monthly", type=int, default=0, help="number of monthly archives to keep"
+            "-m",
+            "--keep-monthly",
+            dest="monthly",
+            type=int,
+            default=0,
+            action=Highlander,
+            help="number of monthly archives to keep",
         )
         subparser.add_argument(
-            "-y", "--keep-yearly", dest="yearly", type=int, default=0, help="number of yearly archives to keep"
+            "-y",
+            "--keep-yearly",
+            dest="yearly",
+            type=int,
+            default=0,
+            action=Highlander,
+            help="number of yearly archives to keep",
         )
         define_archive_filters_group(subparser, sort_by=False, first_last=False)
         subparser.add_argument(
             "-c",
             "--checkpoint-interval",
             metavar="SECONDS",
             dest="checkpoint_interval",
             type=int,
             default=1800,
+            action=Highlander,
             help="write checkpoint every SECONDS seconds (Default: 1800)",
         )
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/rcompress_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/rcompress_cmd.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import argparse
 from collections import defaultdict
 
-from ._common import with_repository
+from ._common import with_repository, Highlander
 from ..constants import *  # NOQA
 from ..compress import CompressionSpec, ObfuscateSize, Auto, COMPRESSOR_TABLE
 from ..helpers import sig_int, ProgressIndicatorPercent
 
 from ..manifest import Manifest
 
 from ..logger import create_logger
@@ -226,21 +226,23 @@
         subparser.add_argument(
             "-C",
             "--compression",
             metavar="COMPRESSION",
             dest="compression",
             type=CompressionSpec,
             default=CompressionSpec("lz4"),
+            action=Highlander,
             help="select compression algorithm, see the output of the " '"borg help compression" command for details.',
         )
 
         subparser.add_argument("-s", "--stats", dest="stats", action="store_true", help="print statistics")
 
         subparser.add_argument(
             "-c",
             "--checkpoint-interval",
             metavar="SECONDS",
             dest="checkpoint_interval",
             type=int,
             default=1800,
+            action=Highlander,
             help="write checkpoint every SECONDS seconds (Default: 1800)",
         )
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/rcreate_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/rcreate_cmd.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import argparse
 
-from ._common import with_repository, with_other_repository
+from ._common import with_repository, with_other_repository, Highlander
 from ..cache import Cache
 from ..constants import *  # NOQA
 from ..crypto.key import key_creator, key_argument_names, tam_required_file
 from ..helpers import EXIT_WARNING
 from ..helpers import location_validator, Location
 from ..helpers import parse_storage_quota
 from ..manifest import Manifest
@@ -180,23 +180,25 @@
         subparser.set_defaults(func=self.do_rcreate)
         subparser.add_argument(
             "--other-repo",
             metavar="SRC_REPOSITORY",
             dest="other_location",
             type=location_validator(other=True),
             default=Location(other=True),
+            action=Highlander,
             help="reuse the key material from the other repository",
         )
         subparser.add_argument(
             "-e",
             "--encryption",
             metavar="MODE",
             dest="encryption",
             required=True,
             choices=key_argument_names(),
+            action=Highlander,
             help="select encryption key mode **(required)**",
         )
         subparser.add_argument(
             "--append-only",
             dest="append_only",
             action="store_true",
             help="create an append-only mode repository. Note that this only affects "
@@ -206,14 +208,15 @@
         )
         subparser.add_argument(
             "--storage-quota",
             metavar="QUOTA",
             dest="storage_quota",
             default=None,
             type=parse_storage_quota,
+            action=Highlander,
             help="Set storage quota of the new repository (e.g. 5G, 1.5T). Default: no quota.",
         )
         subparser.add_argument(
             "--make-parent-dirs",
             dest="make_parent_dirs",
             action="store_true",
             help="create the parent directories of the repository directory, if they are missing.",
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/rdelete_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/rdelete_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/recreate_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/recreate_cmd.py`

 * *Files 4% similar despite different names*

```diff
@@ -145,85 +145,92 @@
         archive_group = define_archive_filters_group(subparser)
         archive_group.add_argument(
             "--target",
             dest="target",
             metavar="TARGET",
             default=None,
             type=archivename_validator,
+            action=Highlander,
             help="create a new archive with the name ARCHIVE, do not replace existing archive "
             "(only applies for a single archive)",
         )
         archive_group.add_argument(
             "-c",
             "--checkpoint-interval",
             dest="checkpoint_interval",
             type=int,
             default=1800,
+            action=Highlander,
             metavar="SECONDS",
             help="write checkpoint every SECONDS seconds (Default: 1800)",
         )
         archive_group.add_argument(
             "--checkpoint-volume",
             metavar="BYTES",
             dest="checkpoint_volume",
             type=int,
             default=0,
+            action=Highlander,
             help="write checkpoint every BYTES bytes (Default: 0, meaning no volume based checkpointing)",
         )
         archive_group.add_argument(
             "--comment",
             metavar="COMMENT",
             dest="comment",
             type=comment_validator,
             default=None,
+            action=Highlander,
             help="add a comment text to the archive",
         )
         archive_group.add_argument(
             "--timestamp",
             metavar="TIMESTAMP",
             dest="timestamp",
             type=timestamp,
             default=None,
+            action=Highlander,
             help="manually specify the archive creation date/time (yyyy-mm-ddThh:mm:ss[(+|-)HH:MM] format, "
             "(+|-)HH:MM is the UTC offset, default: local time zone). Alternatively, give a reference file/directory.",
         )
         archive_group.add_argument(
             "-C",
             "--compression",
             metavar="COMPRESSION",
             dest="compression",
             type=CompressionSpec,
             default=CompressionSpec("lz4"),
+            action=Highlander,
             help="select compression algorithm, see the output of the " '"borg help compression" command for details.',
         )
         archive_group.add_argument(
             "--recompress",
             metavar="MODE",
             dest="recompress",
             nargs="?",
             default="never",
             const="if-different",
             choices=("never", "if-different", "always"),
+            action=Highlander,
             help="recompress data chunks according to `MODE` and ``--compression``. "
             "Possible modes are "
             "`if-different`: recompress if current compression is with a different "
             "compression algorithm or different level; "
             "`always`: recompress unconditionally; and "
             "`never`: do not recompress (use this option explicitly to prevent "
             "recompression). "
             "If no MODE is given, `if-different` will be used. "
             'Not passing --recompress is equivalent to "--recompress never".',
         )
         archive_group.add_argument(
             "--chunker-params",
             metavar="PARAMS",
             dest="chunker_params",
-            action=Highlander,
             type=ChunkerParams,
             default=None,
+            action=Highlander,
             help="rechunk using given chunker parameters (ALGO, CHUNK_MIN_EXP, CHUNK_MAX_EXP, "
             "HASH_MASK_BITS, HASH_WINDOW_SIZE) or `default` to use the chunker defaults. "
             "default: do not rechunk",
         )
 
         subparser.add_argument(
             "paths", metavar="PATH", nargs="*", type=str, help="paths to recreate; patterns are supported"
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/rename_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/rename_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/rinfo_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/rinfo_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/rlist_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/rlist_cmd.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import argparse
+import os
 import textwrap
 import sys
 
-from ._common import with_repository
+from ._common import with_repository, Highlander
 from ..constants import *  # NOQA
 from ..helpers import BaseFormatter, ArchiveFormatter, json_print, basic_json_data
 from ..manifest import Manifest
 
 from ..logger import create_logger
 
 logger = create_logger()
@@ -17,24 +18,24 @@
     def do_rlist(self, args, repository, manifest):
         """List the archives contained in a repository"""
         if args.format is not None:
             format = args.format
         elif args.short:
             format = "{archive}{NL}"
         else:
-            format = "{archive:<36} {time} [{id}]{NL}"
-        formatter = ArchiveFormatter(format, repository, manifest, manifest.key, json=args.json, iec=args.iec)
+            format = os.environ.get("BORG_RLIST_FORMAT", "{archive:<36} {time} [{id}]{NL}")
+        formatter = ArchiveFormatter(format, repository, manifest, manifest.key, iec=args.iec)
 
         output_data = []
 
         for archive_info in manifest.archives.list_considering(args):
             if args.json:
-                output_data.append(formatter.get_item_data(archive_info))
+                output_data.append(formatter.get_item_data(archive_info, args.json))
             else:
-                sys.stdout.write(formatter.format_item(archive_info))
+                sys.stdout.write(formatter.format_item(archive_info, args.json))
 
         if args.json:
             json_print(basic_json_data(manifest, extra={"archives": output_data}))
 
         return self.exit_code
 
     def build_parser_rlist(self, subparsers, common_parser, mid_common_parser):
@@ -102,14 +103,15 @@
         subparser.add_argument(
             "--short", dest="short", action="store_true", help="only print the archive names, nothing else"
         )
         subparser.add_argument(
             "--format",
             metavar="FORMAT",
             dest="format",
+            action=Highlander,
             help="specify format for archive listing " '(default: "{archive:<36} {time} [{id}]{NL}")',
         )
         subparser.add_argument(
             "--json",
             action="store_true",
             help="Format output as JSON. "
             "The form of ``--format`` is ignored, "
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/serve_cmd.py` & `borgbackup-2.0.0b6/src/borg/archiver/serve_cmd.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 import argparse
 
+from ._common import Highlander
 from ..constants import *  # NOQA
 from ..helpers import EXIT_SUCCESS
 from ..helpers import parse_storage_quota
 from ..remote import RepositoryServer
 
 from ..logger import create_logger
 
@@ -14,23 +15,34 @@
     def do_serve(self, args):
         """Start in server mode. This command is usually not used manually."""
         RepositoryServer(
             restrict_to_paths=args.restrict_to_paths,
             restrict_to_repositories=args.restrict_to_repositories,
             append_only=args.append_only,
             storage_quota=args.storage_quota,
+            use_socket=args.use_socket,
         ).serve()
         return EXIT_SUCCESS
 
     def build_parser_serve(self, subparsers, common_parser, mid_common_parser):
         from ._common import process_epilog
 
         serve_epilog = process_epilog(
             """
-        This command starts a repository server process. This command is usually not used manually.
+        This command starts a repository server process.
+
+        borg serve can currently support:
+
+        - Getting automatically started via ssh when the borg client uses a ssh://...
+          remote repository. In this mode, `borg serve` will live until that ssh connection
+          gets terminated.
+
+        - Getting started by some other means (not by the borg client) as a long-running socket
+          server to be used for borg clients using a socket://... repository (see the `--socket`
+          option if you do not want to use the default path for the socket and pid file).
         """
         )
         subparser = subparsers.add_parser(
             "serve",
             parents=[common_parser],
             add_help=False,
             description=self.do_serve.__doc__,
@@ -72,11 +84,12 @@
         )
         subparser.add_argument(
             "--storage-quota",
             metavar="QUOTA",
             dest="storage_quota",
             type=parse_storage_quota,
             default=None,
+            action=Highlander,
             help="Override storage quota of the repository (e.g. 5G, 1.5T). "
             "When a new repository is initialized, sets the storage quota on the new "
             "repository as well. Default: no quota.",
         )
```

### Comparing `borgbackup-2.0.0b5/src/borg/archiver/tar_cmds.py` & `borgbackup-2.0.0b6/src/borg/archiver/tar_cmds.py`

 * *Files 4% similar despite different names*

```diff
@@ -285,15 +285,15 @@
             chunker_params=args.chunker_params,
             show_progress=args.progress,
             log_json=args.log_json,
             iec=args.iec,
             file_status_printer=self.print_file_status,
         )
 
-        tar = tarfile.open(fileobj=tarstream, mode="r|")
+        tar = tarfile.open(fileobj=tarstream, mode="r|", ignore_zeros=args.ignore_zeros)
 
         while True:
             tarinfo = tar.next()
             if not tarinfo:
                 break
             if tarinfo.isreg():
                 status = tfo.process_file(tarinfo=tarinfo, status="A", type=stat.S_IFREG, tar=tar)
@@ -386,25 +386,30 @@
             description=self.do_export_tar.__doc__,
             epilog=export_tar_epilog,
             formatter_class=argparse.RawDescriptionHelpFormatter,
             help="create tarball from archive",
         )
         subparser.set_defaults(func=self.do_export_tar)
         subparser.add_argument(
-            "--tar-filter", dest="tar_filter", default="auto", help="filter program to pipe data through"
+            "--tar-filter",
+            dest="tar_filter",
+            default="auto",
+            action=Highlander,
+            help="filter program to pipe data through",
         )
         subparser.add_argument(
             "--list", dest="output_list", action="store_true", help="output verbose list of items (files, dirs, ...)"
         )
         subparser.add_argument(
             "--tar-format",
             metavar="FMT",
             dest="tar_format",
             default="GNU",
             choices=("BORG", "PAX", "GNU"),
+            action=Highlander,
             help="select tar format: BORG, PAX or GNU",
         )
         subparser.add_argument("name", metavar="NAME", type=archivename_validator, help="specify the archive name")
         subparser.add_argument("tarfile", metavar="FILE", help='output tar file. "-" to write to stdout instead.')
         subparser.add_argument(
             "paths", metavar="PATH", nargs="*", type=str, help="paths to extract; patterns are supported"
         )
@@ -441,14 +446,17 @@
         - BORG: borg specific (PAX-based)
         - PAX: POSIX.1-2001
         - GNU: GNU tar
         - POSIX.1-1988 (ustar)
         - UNIX V7 tar
         - SunOS tar with extended attributes
 
+        To import multiple tarballs into a single archive, they can be simply
+        concatenated (e.g. using "cat") into a single file, and imported with an
+        ``--ignore-zeros`` option to skip through the stop markers between them.
         """
         )
         subparser = subparsers.add_parser(
             "import-tar",
             parents=[common_parser],
             add_help=False,
             description=self.do_import_tar.__doc__,
@@ -483,65 +491,76 @@
             "--filter",
             dest="output_filter",
             metavar="STATUSCHARS",
             action=Highlander,
             help="only display items with the given status characters",
         )
         subparser.add_argument("--json", action="store_true", help="output stats as JSON (implies --stats)")
+        subparser.add_argument(
+            "--ignore-zeros",
+            dest="ignore_zeros",
+            action="store_true",
+            help="ignore zero-filled blocks in the input tarball",
+        )
 
         archive_group = subparser.add_argument_group("Archive options")
         archive_group.add_argument(
             "--comment",
             metavar="COMMENT",
             dest="comment",
             type=comment_validator,
             default="",
+            action=Highlander,
             help="add a comment text to the archive",
         )
         archive_group.add_argument(
             "--timestamp",
             dest="timestamp",
             type=timestamp,
             default=None,
+            action=Highlander,
             metavar="TIMESTAMP",
             help="manually specify the archive creation date/time (yyyy-mm-ddThh:mm:ss[(+|-)HH:MM] format, "
             "(+|-)HH:MM is the UTC offset, default: local time zone). Alternatively, give a reference file/directory.",
         )
         archive_group.add_argument(
             "-c",
             "--checkpoint-interval",
             dest="checkpoint_interval",
             type=int,
             default=1800,
+            action=Highlander,
             metavar="SECONDS",
             help="write checkpoint every SECONDS seconds (Default: 1800)",
         )
         archive_group.add_argument(
             "--checkpoint-volume",
             metavar="BYTES",
             dest="checkpoint_volume",
             type=int,
             default=0,
+            action=Highlander,
             help="write checkpoint every BYTES bytes (Default: 0, meaning no volume based checkpointing)",
         )
         archive_group.add_argument(
             "--chunker-params",
             dest="chunker_params",
-            action=Highlander,
             type=ChunkerParams,
             default=CHUNKER_PARAMS,
+            action=Highlander,
             metavar="PARAMS",
             help="specify the chunker parameters (ALGO, CHUNK_MIN_EXP, CHUNK_MAX_EXP, "
             "HASH_MASK_BITS, HASH_WINDOW_SIZE). default: %s,%d,%d,%d,%d" % CHUNKER_PARAMS,
         )
         archive_group.add_argument(
             "-C",
             "--compression",
             metavar="COMPRESSION",
             dest="compression",
             type=CompressionSpec,
             default=CompressionSpec("lz4"),
+            action=Highlander,
             help="select compression algorithm, see the output of the " '"borg help compression" command for details.',
         )
 
         subparser.add_argument("name", metavar="NAME", type=archivename_validator, help="specify the archive name")
         subparser.add_argument("tarfile", metavar="TARFILE", help='input tar file. "-" to read from stdin instead.')
```

### Comparing `borgbackup-2.0.0b5/src/borg/cache.py` & `borgbackup-2.0.0b6/src/borg/cache.py`

 * *Files 1% similar despite different names*

```diff
@@ -58,24 +58,24 @@
     the code has to deal with a cache existing but no security DB entry,
     or inconsistencies between the security DB and the cache which have to
     be reconciled, and also with no cache existing but a security DB entry.
     """
 
     def __init__(self, repository):
         self.repository = repository
-        self.dir = get_security_dir(repository.id_str)
+        self.dir = get_security_dir(repository.id_str, legacy=(repository.version == 1))
         self.cache_dir = cache_dir(repository)
         self.key_type_file = os.path.join(self.dir, "key-type")
         self.location_file = os.path.join(self.dir, "location")
         self.manifest_ts_file = os.path.join(self.dir, "manifest-timestamp")
 
     @staticmethod
     def destroy(repository, path=None):
         """destroy the security dir for ``repository`` or at ``path``"""
-        path = path or get_security_dir(repository.id_str)
+        path = path or get_security_dir(repository.id_str, legacy=(repository.version == 1))
         if os.path.exists(path):
             shutil.rmtree(path)
 
     def known(self):
         return all(os.path.exists(f) for f in (self.key_type_file, self.location_file, self.manifest_ts_file))
 
     def key_matches(self, key):
```

### Comparing `borgbackup-2.0.0b5/src/borg/cache_sync/cache_sync.c` & `borgbackup-2.0.0b6/src/borg/cache_sync/cache_sync.c`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/cache_sync/sysdep.h` & `borgbackup-2.0.0b6/src/borg/cache_sync/sysdep.h`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/cache_sync/unpack.h` & `borgbackup-2.0.0b6/src/borg/cache_sync/unpack.h`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/cache_sync/unpack_define.h` & `borgbackup-2.0.0b6/src/borg/cache_sync/unpack_define.h`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/cache_sync/unpack_template.h` & `borgbackup-2.0.0b6/src/borg/cache_sync/unpack_template.h`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/checksums.c` & `borgbackup-2.0.0b6/src/borg/checksums.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
             "/opt/homebrew/Cellar/xxhash/0.8.1/include/xxhash.h"
         ],
@@ -34,16 +34,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -103,16 +103,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -228,15 +232,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -267,15 +271,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -1296,22 +1300,30 @@
 /* PyObjectGetAttrStrNoError.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
 
 /* SetupReduce.proto */
 static int __Pyx_setup_reduce(PyObject* type_obj);
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto
-#define __PYX_HAVE_RT_ImportType_proto
-enum __Pyx_ImportType_CheckSize {
-   __Pyx_ImportType_CheckSize_Error = 0,
-   __Pyx_ImportType_CheckSize_Warn = 1,
-   __Pyx_ImportType_CheckSize_Ignore = 2
+#ifndef __PYX_HAVE_RT_ImportType_proto_0_29_35
+#define __PYX_HAVE_RT_ImportType_proto_0_29_35
+#if __STDC_VERSION__ >= 201112L
+#include <stdalign.h>
+#endif
+#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) alignof(s)
+#else
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) sizeof(void*)
+#endif
+enum __Pyx_ImportType_CheckSize_0_29_35 {
+   __Pyx_ImportType_CheckSize_Error_0_29_35 = 0,
+   __Pyx_ImportType_CheckSize_Warn_0_29_35 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_0_29_35 = 2
 };
-static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size);
 #endif
 
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
@@ -2485,15 +2497,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
@@ -2713,22 +2725,21 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_0_29_35(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -3430,28 +3441,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -4133,61 +4144,79 @@
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 
 /* TypeImport */
-#ifndef __PYX_HAVE_RT_ImportType
-#define __PYX_HAVE_RT_ImportType
-static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, enum __Pyx_ImportType_CheckSize check_size)
+#ifndef __PYX_HAVE_RT_ImportType_0_29_35
+#define __PYX_HAVE_RT_ImportType_0_29_35
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
+    Py_ssize_t itemsize;
 #ifdef Py_LIMITED_API
     PyObject *py_basicsize;
+    PyObject *py_itemsize;
 #endif
     result = PyObject_GetAttrString(module, class_name);
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
             "%.200s.%.200s is not a type object",
             module_name, class_name);
         goto bad;
     }
 #ifndef Py_LIMITED_API
     basicsize = ((PyTypeObject *)result)->tp_basicsize;
+    itemsize = ((PyTypeObject *)result)->tp_itemsize;
 #else
     py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
     if (!py_basicsize)
         goto bad;
     basicsize = PyLong_AsSsize_t(py_basicsize);
     Py_DECREF(py_basicsize);
     py_basicsize = 0;
     if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
         goto bad;
+    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
+    if (!py_itemsize)
+        goto bad;
+    itemsize = PyLong_AsSsize_t(py_itemsize);
+    Py_DECREF(py_itemsize);
+    py_itemsize = 0;
+    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
 #endif
-    if ((size_t)basicsize < size) {
+    if (itemsize) {
+        if (size % alignment) {
+            alignment = size % alignment;
+        }
+        if (itemsize < (Py_ssize_t)alignment)
+            itemsize = (Py_ssize_t)alignment;
+    }
+    if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
+    if (check_size == __Pyx_ImportType_CheckSize_Error_0_29_35 && (size_t)basicsize != size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_0_29_35 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
@@ -4583,15 +4612,15 @@
                         } else if (8 * sizeof(unsigned PY_LONG_LONG) >= 4 * PyLong_SHIFT) {
                             return (unsigned PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -4817,15 +4846,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -5013,15 +5042,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/checksums.pyx` & `borgbackup-2.0.0b6/src/borg/checksums.pyx`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/chunker.c` & `borgbackup-2.0.0b6/src/borg/chunker.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
             "src/borg/_chunker.c"
         ],
@@ -31,16 +31,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -100,16 +100,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -225,15 +229,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -264,15 +268,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -8608,15 +8612,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_7chunker___pyx_scope_struct__sparsemap *__pyx_freelist_4borg_7chunker___pyx_scope_struct__sparsemap[8];
 static int __pyx_freecount_4borg_7chunker___pyx_scope_struct__sparsemap = 0;
 
@@ -8773,15 +8777,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_7chunker___pyx_scope_struct_1_chunkify *__pyx_freelist_4borg_7chunker___pyx_scope_struct_1_chunkify[8];
 static int __pyx_freecount_4borg_7chunker___pyx_scope_struct_1_chunkify = 0;
 
@@ -8914,15 +8918,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_7chunker___pyx_scope_struct_2_chunkify *__pyx_freelist_4borg_7chunker___pyx_scope_struct_2_chunkify[8];
 static int __pyx_freecount_4borg_7chunker___pyx_scope_struct_2_chunkify = 0;
 
@@ -9091,15 +9095,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
@@ -11191,28 +11195,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -12514,15 +12518,18 @@
 #endif
 #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
     0,
 #endif
 };
 static int __pyx_CyFunction_init(void) {
     __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
     if (unlikely(__pyx_CyFunctionType == NULL)) {
         return -1;
@@ -12981,15 +12988,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -13177,15 +13184,15 @@
                         } else if (8 * sizeof(unsigned long) >= 4 * PyLong_SHIFT) {
                             return (unsigned long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -13373,15 +13380,15 @@
                         } else if (8 * sizeof(uint32_t) >= 4 * PyLong_SHIFT) {
                             return (uint32_t) (((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -13569,15 +13576,15 @@
                         } else if (8 * sizeof(unsigned char) >= 4 * PyLong_SHIFT) {
                             return (unsigned char) (((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -13765,15 +13772,15 @@
                         } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
                             return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -14113,15 +14120,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -15443,15 +15450,18 @@
 #endif
 #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
     0,
 #endif
 };
 static int __pyx_Generator_init(void) {
     __pyx_GeneratorType_type.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
     __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
     __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
```

### Comparing `borgbackup-2.0.0b5/src/borg/chunker.pyi` & `borgbackup-2.0.0b6/src/borg/chunker.pyi`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/chunker.pyx` & `borgbackup-2.0.0b6/src/borg/chunker.pyx`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/compress.c` & `borgbackup-2.0.0b6/src/borg/compress.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
             "/opt/homebrew/Cellar/lz4/1.9.4/include/lz4.h",
-            "/opt/homebrew/Cellar/zstd/1.5.4/include/zstd.h"
+            "/opt/homebrew/Cellar/zstd/1.5.5/include/zstd.h"
         ],
         "extra_compile_args": [
             "-Wall",
             "-Wextra",
             "-Wpointer-arith"
         ],
         "include_dirs": [
             "/opt/homebrew/Cellar/lz4/1.9.4/include",
-            "/opt/homebrew/Cellar/zstd/1.5.4/include"
+            "/opt/homebrew/Cellar/zstd/1.5.5/include"
         ],
         "libraries": [
             "lz4",
             "zstd"
         ],
         "library_dirs": [
             "/opt/homebrew/Cellar/lz4/1.9.4/lib",
-            "/opt/homebrew/Cellar/zstd/1.5.4/lib"
+            "/opt/homebrew/Cellar/zstd/1.5.5/lib"
         ],
         "name": "borg.compress",
         "sources": [
             "src/borg/compress.pyx"
         ]
     },
     "module_name": "borg.compress"
@@ -38,16 +38,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -107,16 +107,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -232,15 +236,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -271,15 +275,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -1001,27 +1005,27 @@
 #endif
 
 
 /*--- Type declarations ---*/
 struct __pyx_obj_4borg_8compress_CompressorBase;
 struct __pyx_obj_4borg_8compress_DecidingCompressor;
 
-/* "borg/compress.pyx":53
+/* "borg/compress.pyx":54
  * 
  * 
  * cdef class CompressorBase:             # <<<<<<<<<<<<<<
  *     """
  *     base class for all (de)compression classes,
  */
 struct __pyx_obj_4borg_8compress_CompressorBase {
   PyObject_HEAD
 };
 
 
-/* "borg/compress.pyx":130
+/* "borg/compress.pyx":131
  * 
  * 
  * cdef class DecidingCompressor(CompressorBase):             # <<<<<<<<<<<<<<
  *     """
  *     base class for (de)compression classes that (based on an internal _decide
  */
 struct __pyx_obj_4borg_8compress_DecidingCompressor {
@@ -1777,14 +1781,15 @@
 static const char __pyx_k_unpack[] = "unpack";
 static const char __pyx_k_update[] = "update";
 static const char __pyx_k_values[] = "values";
 static const char __pyx_k_helpers[] = "helpers";
 static const char __pyx_k_prepare[] = "__prepare__";
 static const char __pyx_k_to_meta[] = "to_meta";
 static const char __pyx_k_trailer[] = "trailer";
+static const char __pyx_k_argparse[] = "argparse";
 static const char __pyx_k_check_ok[] = "check_ok";
 static const char __pyx_k_compress[] = "compress";
 static const char __pyx_k_decide_2[] = "decide";
 static const char __pyx_k_get_meta[] = "get_meta";
 static const char __pyx_k_getstate[] = "__getstate__";
 static const char __pyx_k_property[] = "property";
 static const char __pyx_k_pyx_type[] = "__pyx_type";
@@ -1836,14 +1841,15 @@
 static const char __pyx_k_ZSTD__decide[] = "ZSTD._decide";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
 static const char __pyx_k_staticmethod[] = "staticmethod";
 static const char __pyx_k_stringsource[] = "stringsource";
 static const char __pyx_k_Auto_compress[] = "Auto.compress";
 static const char __pyx_k_MAX_DATA_SIZE[] = "MAX_DATA_SIZE";
 static const char __pyx_k_ObfuscateSize[] = "ObfuscateSize";
+static const char __pyx_k_bad_arguments[] = "bad arguments";
 static const char __pyx_k_borg_compress[] = "borg.compress";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_CNONE_compress[] = "CNONE.compress";
 static const char __pyx_k_CompressorBase[] = "CompressorBase";
 static const char __pyx_k_LZ4_COMPRESSOR[] = "LZ4_COMPRESSOR";
 static const char __pyx_k_LZ4_decompress[] = "LZ4.decompress";
 static const char __pyx_k_NotImplemented[] = "NotImplemented";
@@ -1863,42 +1869,48 @@
 static const char __pyx_k_decidebaseclass[] = "decidebaseclass";
 static const char __pyx_k_obfuscated_data[] = "obfuscated_data";
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
 static const char __pyx_k_CNONE_decompress[] = "CNONE.decompress";
 static const char __pyx_k_COMPRESSOR_TABLE[] = "COMPRESSOR_TABLE";
 static const char __pyx_k_max_padding_size[] = "max_padding_size";
+static const char __pyx_k_ArgumentTypeError[] = "ArgumentTypeError";
 static const char __pyx_k_Compressor___init[] = "Compressor.__init__";
 static const char __pyx_k_Compressor_detect[] = "Compressor.detect";
 static const char __pyx_k_DecidingCompressor[] = "DecidingCompressor";
 static const char __pyx_k_DecompressionError[] = "DecompressionError";
 static const char __pyx_k_ZLIB_legacy___init[] = "ZLIB_legacy.__init__";
 static const char __pyx_k_ZLIB_legacy_detect[] = "ZLIB_legacy.detect";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
+static const char __pyx_k_too_many_arguments[] = "too many arguments";
 static const char __pyx_k_Compressor_compress[] = "Compressor.compress";
 static const char __pyx_k_NotImplementedError[] = "NotImplementedError";
 static const char __pyx_k_lz4_compress_failed[] = "lz4 compress failed";
 static const char __pyx_k_ObfuscateSize___init[] = "ObfuscateSize.__init__";
 static const char __pyx_k_ZLIB_legacy_compress[] = "ZLIB_legacy.compress";
+static const char __pyx_k_not_enough_arguments[] = "not enough arguments";
 static const char __pyx_k_Compressor_decompress[] = "Compressor.decompress";
 static const char __pyx_k_No_lzma_support_found[] = "No lzma support found.";
 static const char __pyx_k_cheap_compressed_data[] = "cheap_compressed_data";
+static const char __pyx_k_level_must_be_0_and_9[] = "level must be >= 0 and <= 9";
 static const char __pyx_k_lz4_decompress_failed[] = "lz4 decompress failed";
 static const char __pyx_k_src_borg_compress_pyx[] = "src/borg/compress.pyx";
 static const char __pyx_k_CompressionSpec___init[] = "CompressionSpec.__init__";
 static const char __pyx_k_ObfuscateSize_compress[] = "ObfuscateSize.compress";
 static const char __pyx_k_ZLIB_legacy_decompress[] = "ZLIB_legacy.decompress";
+static const char __pyx_k_level_must_be_1_and_22[] = "level must be >= 1 and <= 22";
 static const char __pyx_k_zstd_compress_failed_s[] = "zstd compress failed: %s";
 static const char __pyx_k_ObfuscateSize__obfuscate[] = "ObfuscateSize._obfuscate";
 static const char __pyx_k_ObfuscateSize_decompress[] = "ObfuscateSize.decompress";
 static const char __pyx_k_random_padding_obfuscate[] = "_random_padding_obfuscate";
 static const char __pyx_k_zstd_decompress_failed_s[] = "zstd decompress failed: %s";
 static const char __pyx_k_expensive_compressed_data[] = "expensive_compressed_data";
 static const char __pyx_k_CompressionSpec_compressor[] = "CompressionSpec.compressor";
 static const char __pyx_k_pyx_unpickle_CompressorBase[] = "__pyx_unpickle_CompressorBase";
+static const char __pyx_k_unsupported_compression_type[] = "unsupported compression type";
 static const char __pyx_k_Auto_compress_locals_get_meta[] = "Auto.compress.<locals>.get_meta";
 static const char __pyx_k_lzma_compression_decompression[] = "\n    lzma compression / decompression\n    ";
 static const char __pyx_k_pyx_unpickle_DecidingCompresso[] = "__pyx_unpickle_DecidingCompressor";
 static const char __pyx_k_zlib_compression_decompression[] = "\n    zlib compression / decompression (python stdlib)\n    ";
 static const char __pyx_k_Meta_Compressor_that_decides_wh[] = "\n    Meta-Compressor that decides which compression to use based on LZ4's ratio.\n\n    As a meta-Compressor the actual compression is deferred to other Compressors,\n    therefore this Compressor has no ID, no detect() and no decompress().\n    ";
 static const char __pyx_k_Meta_Compressor_that_obfuscates[] = "\n    Meta-Compressor that obfuscates the compressed data size.\n    ";
 static const char __pyx_k_borg_compress_Compression_is_ap[] = "\nborg.compress\n=============\n\nCompression is applied to chunks after ID hashing (so the ID is a direct function of the\nplain chunk, compression is irrelevant to it), and of course before encryption.\n\nThe \"auto\" mode (e.g. --compression auto,lzma,4) is implemented as a meta Compressor,\nmeaning that Auto acts like a Compressor, but defers actual work to others (namely\nLZ4 as a heuristic whether compression is worth it, and the specified Compressor\nfor the actual compression).\n\nDecompression is normally handled through Compressor.decompress which will detect\nwhich compressor has been used to compress the data and dispatch to the correct\ndecompressor.\n";
@@ -1906,21 +1918,23 @@
 static const char __pyx_k_none_no_compression_just_pass_t[] = "\n    none - no compression, just pass through data\n    ";
 static const char __pyx_k_raw_LZ4_compression_decompressi[] = "\n    raw LZ4 compression / decompression (liblz4).\n\n    Features:\n        - lz4 is super fast\n        - wrapper releases CPython's GIL to support multithreaded code\n        - uses safe lz4 methods that never go beyond the end of the output buffer\n    ";
 static const char __pyx_k_relative_random_reciprocal_obfu[] = "_relative_random_reciprocal_obfuscate";
 static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0xd41d8cd, 0xe3b0c44, 0xda39a3e) = ())";
 static const char __pyx_k_No_decompressor_for_this_data_fo[] = "No decompressor for this data found: %r.";
 static const char __pyx_k_ObfuscateSize__random_padding_ob[] = "ObfuscateSize._random_padding_obfuscate";
 static const char __pyx_k_ObfuscateSize__relative_random_r[] = "ObfuscateSize._relative_random_reciprocal_obfuscate";
+static const char __pyx_k_level_must_be_1_and_6_or_110_and[] = "level must be >= 1 and <= 6 or >= 110 and <= 123";
 static const char __pyx_k_zlib_compression_decompression_2[] = "\n    zlib compression / decompression (python stdlib)\n\n    Note: This is the legacy ZLIB support as used by borg < 1.3.\n          It still suffers from attic *only* supporting zlib and not having separate\n          ID bytes to differentiate between differently compressed chunks.\n          This just works because zlib compressed stuff always starts with 0x.8.. bytes.\n          Newer borg uses the ZLIB class that has separate ID bytes (as all the other\n          compressors) and does not need this hack.\n    ";
 static const char __pyx_k_zstd_compression_decompression_p[] = "zstd compression / decompression (pypi: zstandard, gh: python-zstandard)";
 static const char __pyx_k_zstd_decompress_failed_size_mism[] = "zstd decompress failed: size mismatch";
 static const char __pyx_k_zstd_get_size_failed_data_was_no[] = "zstd get size failed: data was not compressed by zstd";
 static const char __pyx_k_zstd_get_size_failed_original_si[] = "zstd get size failed: original size unknown";
 static PyObject *__pyx_kp_s_1_2_02;
 static PyObject *__pyx_n_s_API_VERSION;
+static PyObject *__pyx_n_s_ArgumentTypeError;
 static PyObject *__pyx_n_s_Auto;
 static PyObject *__pyx_n_s_Auto___init;
 static PyObject *__pyx_n_s_Auto__decide;
 static PyObject *__pyx_n_s_Auto_compress;
 static PyObject *__pyx_n_s_Auto_compress_locals_get_meta;
 static PyObject *__pyx_n_s_Auto_decide;
 static PyObject *__pyx_n_s_Auto_decompress;
@@ -1988,15 +2002,17 @@
 static PyObject *__pyx_n_s_ZLIB_legacy_detect;
 static PyObject *__pyx_n_s_ZSTD;
 static PyObject *__pyx_n_s_ZSTD___init;
 static PyObject *__pyx_n_s_ZSTD__decide;
 static PyObject *__pyx_n_s_ZSTD_decompress;
 static PyObject *__pyx_kp_s__8;
 static PyObject *__pyx_n_s_addtl_size;
+static PyObject *__pyx_n_s_argparse;
 static PyObject *__pyx_n_s_auto;
+static PyObject *__pyx_kp_s_bad_arguments;
 static PyObject *__pyx_n_s_baseclass;
 static PyObject *__pyx_n_s_borg_compress;
 static PyObject *__pyx_n_s_buf;
 static PyObject *__pyx_n_s_buffer;
 static PyObject *__pyx_n_s_cheap_compressed_data;
 static PyObject *__pyx_n_s_cheap_meta;
 static PyObject *__pyx_n_s_check;
@@ -2051,14 +2067,17 @@
 static PyObject *__pyx_n_s_isize;
 static PyObject *__pyx_n_s_items;
 static PyObject *__pyx_n_s_join;
 static PyObject *__pyx_n_s_key;
 static PyObject *__pyx_n_s_kwargs;
 static PyObject *__pyx_n_s_legacy_mode;
 static PyObject *__pyx_n_s_level;
+static PyObject *__pyx_kp_s_level_must_be_0_and_9;
+static PyObject *__pyx_kp_s_level_must_be_1_and_22;
+static PyObject *__pyx_kp_s_level_must_be_1_and_6_or_110_and;
 static PyObject *__pyx_n_s_lz4;
 static PyObject *__pyx_kp_s_lz4_compress_failed;
 static PyObject *__pyx_kp_s_lz4_decompress_failed;
 static PyObject *__pyx_n_s_lzma;
 static PyObject *__pyx_kp_s_lzma_compression_decompression;
 static PyObject *__pyx_n_s_lzma_data;
 static PyObject *__pyx_n_s_main;
@@ -2068,14 +2087,15 @@
 static PyObject *__pyx_n_s_min_r;
 static PyObject *__pyx_n_s_module;
 static PyObject *__pyx_n_s_name;
 static PyObject *__pyx_n_s_name_2;
 static PyObject *__pyx_n_s_new;
 static PyObject *__pyx_n_s_none;
 static PyObject *__pyx_kp_s_none_no_compression_just_pass_t;
+static PyObject *__pyx_kp_s_not_enough_arguments;
 static PyObject *__pyx_n_s_null;
 static PyObject *__pyx_n_s_obfuscate;
 static PyObject *__pyx_n_s_obfuscate_2;
 static PyObject *__pyx_n_s_obfuscated_data;
 static PyObject *__pyx_n_s_olevel;
 static PyObject *__pyx_n_s_osize;
 static PyObject *__pyx_n_s_pack;
@@ -2113,16 +2133,18 @@
 static PyObject *__pyx_kp_s_src_borg_compress_pyx;
 static PyObject *__pyx_n_s_staticmethod;
 static PyObject *__pyx_kp_s_stringsource;
 static PyObject *__pyx_n_s_struct;
 static PyObject *__pyx_n_s_super;
 static PyObject *__pyx_n_s_test;
 static PyObject *__pyx_n_s_to_meta;
+static PyObject *__pyx_kp_s_too_many_arguments;
 static PyObject *__pyx_n_s_trailer;
 static PyObject *__pyx_n_s_unpack;
+static PyObject *__pyx_kp_s_unsupported_compression_type;
 static PyObject *__pyx_n_s_update;
 static PyObject *__pyx_n_s_values;
 static PyObject *__pyx_n_s_zlib;
 static PyObject *__pyx_kp_s_zlib_compression_decompression;
 static PyObject *__pyx_kp_s_zlib_compression_decompression_2;
 static PyObject *__pyx_n_s_zlib_data;
 static PyObject *__pyx_n_s_zlib_legacy;
@@ -2312,15 +2334,15 @@
 static PyObject *__pyx_codeobj__92;
 static PyObject *__pyx_codeobj__94;
 static PyObject *__pyx_codeobj__96;
 static PyObject *__pyx_codeobj__98;
 static PyObject *__pyx_codeobj__100;
 /* Late includes */
 
-/* "borg/compress.pyx":64
+/* "borg/compress.pyx":65
  * 
  *     @classmethod
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         return data and data[0] == cls.ID
  * 
  */
 
@@ -2346,45 +2368,45 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("detect", 0);
 
-  /* "borg/compress.pyx":65
+  /* "borg/compress.pyx":66
  *     @classmethod
  *     def detect(cls, data):
  *         return data and data[0] == cls.ID             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_data); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_data); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 66, __pyx_L1_error)
   if (__pyx_t_2) {
   } else {
     __Pyx_INCREF(__pyx_v_data);
     __pyx_t_1 = __pyx_v_data;
     goto __pyx_L3_bool_binop_done;
   }
-  __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_data, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_data, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 66, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_ID); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_cls), __pyx_n_s_ID); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 66, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 66, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_INCREF(__pyx_t_5);
   __pyx_t_1 = __pyx_t_5;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_L3_bool_binop_done:;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":64
+  /* "borg/compress.pyx":65
  * 
  *     @classmethod
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         return data and data[0] == cls.ID
  * 
  */
 
@@ -2398,15 +2420,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":67
+/* "borg/compress.pyx":68
  *         return data and data[0] == cls.ID
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         assert 0 <= level <= 255
  *         self.level = level
  */
 
@@ -2451,15 +2473,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_legacy_mode);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 67, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 68, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
@@ -2468,15 +2490,15 @@
       }
     }
     __pyx_v_level = values[0];
     __pyx_v_legacy_mode = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 67, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 68, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.CompressorBase.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_14CompressorBase_2__init__(((struct __pyx_obj_4borg_8compress_CompressorBase *)__pyx_v_self), __pyx_v_level, __pyx_v_legacy_mode, __pyx_v_kwargs);
@@ -2493,56 +2515,56 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":68
+  /* "borg/compress.pyx":69
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):
  *         assert 0 <= level <= 255             # <<<<<<<<<<<<<<
  *         self.level = level
  *         self.legacy_mode = legacy_mode  # True: support prefixed ctype/clevel bytes
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
-    __pyx_t_1 = PyObject_RichCompare(__pyx_int_0, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
+    __pyx_t_1 = PyObject_RichCompare(__pyx_int_0, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
     if (__Pyx_PyObject_IsTrue(__pyx_t_1)) {
       __Pyx_DECREF(__pyx_t_1);
-      __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_255, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
+      __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_255, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
     }
-    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 68, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 69, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     if (unlikely(!__pyx_t_2)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 68, __pyx_L1_error)
+      __PYX_ERR(0, 69, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/compress.pyx":69
+  /* "borg/compress.pyx":70
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):
  *         assert 0 <= level <= 255
  *         self.level = level             # <<<<<<<<<<<<<<
  *         self.legacy_mode = legacy_mode  # True: support prefixed ctype/clevel bytes
  * 
  */
-  if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 69, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
 
-  /* "borg/compress.pyx":70
+  /* "borg/compress.pyx":71
  *         assert 0 <= level <= 255
  *         self.level = level
  *         self.legacy_mode = legacy_mode  # True: support prefixed ctype/clevel bytes             # <<<<<<<<<<<<<<
  * 
  *     def decide(self, data):
  */
-  if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 71, __pyx_L1_error)
 
-  /* "borg/compress.pyx":67
+  /* "borg/compress.pyx":68
  *         return data and data[0] == cls.ID
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         assert 0 <= level <= 255
  *         self.level = level
  */
 
@@ -2554,15 +2576,15 @@
   __Pyx_AddTraceback("borg.compress.CompressorBase.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":72
+/* "borg/compress.pyx":73
  *         self.legacy_mode = legacy_mode  # True: support prefixed ctype/clevel bytes
  * 
  *     def decide(self, data):             # <<<<<<<<<<<<<<
  *         """
  *         Return which compressor will perform the actual compression for *data*.
  */
 
@@ -2581,42 +2603,42 @@
 }
 
 static PyObject *__pyx_pf_4borg_8compress_14CompressorBase_4decide(struct __pyx_obj_4borg_8compress_CompressorBase *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_data) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("decide", 0);
 
-  /* "borg/compress.pyx":83
+  /* "borg/compress.pyx":84
  *         and should actually do so if *data* would become larger on compression.
  *         """
  *         return self             # <<<<<<<<<<<<<<
  * 
  *     def compress(self, meta, data):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __pyx_r = ((PyObject *)__pyx_v_self);
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":72
+  /* "borg/compress.pyx":73
  *         self.legacy_mode = legacy_mode  # True: support prefixed ctype/clevel bytes
  * 
  *     def decide(self, data):             # <<<<<<<<<<<<<<
  *         """
  *         Return which compressor will perform the actual compression for *data*.
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":85
+/* "borg/compress.pyx":86
  *         return self
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Compress *data* (bytes) and return compression metadata and compressed bytes.
  */
 
@@ -2651,32 +2673,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 2, 2, 1); __PYX_ERR(0, 85, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 2, 2, 1); __PYX_ERR(0, 86, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 85, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 86, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_meta = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("compress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 85, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("compress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 86, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.CompressorBase.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_14CompressorBase_6compress(((struct __pyx_obj_4borg_8compress_CompressorBase *)__pyx_v_self), __pyx_v_meta, __pyx_v_data);
 
@@ -2696,166 +2718,166 @@
   Py_ssize_t __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
   __Pyx_INCREF(__pyx_v_data);
 
-  /* "borg/compress.pyx":89
+  /* "borg/compress.pyx":90
  *         Compress *data* (bytes) and return compression metadata and compressed bytes.
  *         """
  *         if not isinstance(data, bytes):             # <<<<<<<<<<<<<<
  *             data = bytes(data)  # code below does not work with memoryview
  *         if self.legacy_mode:
  */
   __pyx_t_1 = PyBytes_Check(__pyx_v_data); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":90
+    /* "borg/compress.pyx":91
  *         """
  *         if not isinstance(data, bytes):
  *             data = bytes(data)  # code below does not work with memoryview             # <<<<<<<<<<<<<<
  *         if self.legacy_mode:
  *             return None, bytes((self.ID, self.level)) + data
  */
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_data); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 90, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_data); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 91, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "borg/compress.pyx":89
+    /* "borg/compress.pyx":90
  *         Compress *data* (bytes) and return compression metadata and compressed bytes.
  *         """
  *         if not isinstance(data, bytes):             # <<<<<<<<<<<<<<
  *             data = bytes(data)  # code below does not work with memoryview
  *         if self.legacy_mode:
  */
   }
 
-  /* "borg/compress.pyx":91
+  /* "borg/compress.pyx":92
  *         if not isinstance(data, bytes):
  *             data = bytes(data)  # code below does not work with memoryview
  *         if self.legacy_mode:             # <<<<<<<<<<<<<<
  *             return None, bytes((self.ID, self.level)) + data
  *         else:
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 92, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 92, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":92
+    /* "borg/compress.pyx":93
  *             data = bytes(data)  # code below does not work with memoryview
  *         if self.legacy_mode:
  *             return None, bytes((self.ID, self.level)) + data             # <<<<<<<<<<<<<<
  *         else:
  *             meta["ctype"] = self.ID
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_ID); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_ID); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_level); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_level); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_4);
     __pyx_t_3 = 0;
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = PyNumber_Add(__pyx_t_4, __pyx_v_data); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_5 = PyNumber_Add(__pyx_t_4, __pyx_v_data); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     PyTuple_SET_ITEM(__pyx_t_4, 0, Py_None);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_5);
     __pyx_t_5 = 0;
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":91
+    /* "borg/compress.pyx":92
  *         if not isinstance(data, bytes):
  *             data = bytes(data)  # code below does not work with memoryview
  *         if self.legacy_mode:             # <<<<<<<<<<<<<<
  *             return None, bytes((self.ID, self.level)) + data
  *         else:
  */
   }
 
-  /* "borg/compress.pyx":94
+  /* "borg/compress.pyx":95
  *             return None, bytes((self.ID, self.level)) + data
  *         else:
  *             meta["ctype"] = self.ID             # <<<<<<<<<<<<<<
  *             meta["clevel"] = self.level
  *             meta["csize"] = len(data)
  */
   /*else*/ {
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_ID); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 94, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_ID); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 95, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_ctype, __pyx_t_4) < 0)) __PYX_ERR(0, 94, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_ctype, __pyx_t_4) < 0)) __PYX_ERR(0, 95, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "borg/compress.pyx":95
+    /* "borg/compress.pyx":96
  *         else:
  *             meta["ctype"] = self.ID
  *             meta["clevel"] = self.level             # <<<<<<<<<<<<<<
  *             meta["csize"] = len(data)
  *             return meta, data
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_level); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 95, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_level); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 96, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_clevel, __pyx_t_4) < 0)) __PYX_ERR(0, 95, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_clevel, __pyx_t_4) < 0)) __PYX_ERR(0, 96, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "borg/compress.pyx":96
+    /* "borg/compress.pyx":97
  *             meta["ctype"] = self.ID
  *             meta["clevel"] = self.level
  *             meta["csize"] = len(data)             # <<<<<<<<<<<<<<
  *             return meta, data
  * 
  */
-    __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 96, __pyx_L1_error)
-    __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 96, __pyx_L1_error)
+    __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 97, __pyx_L1_error)
+    __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 97, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_csize, __pyx_t_4) < 0)) __PYX_ERR(0, 96, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_csize, __pyx_t_4) < 0)) __PYX_ERR(0, 97, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "borg/compress.pyx":97
+    /* "borg/compress.pyx":98
  *             meta["clevel"] = self.level
  *             meta["csize"] = len(data)
  *             return meta, data             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, meta, data):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 97, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 98, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_data);
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":85
+  /* "borg/compress.pyx":86
  *         return self
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Compress *data* (bytes) and return compression metadata and compressed bytes.
  */
 
@@ -2869,15 +2891,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":99
+/* "borg/compress.pyx":100
  *             return meta, data
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decompress *data* (preferably a memoryview, bytes also acceptable) and return bytes result.
  */
 
@@ -2912,32 +2934,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 2, 2, 1); __PYX_ERR(0, 99, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 2, 2, 1); __PYX_ERR(0, 100, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 99, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 100, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_meta = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 99, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 100, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.CompressorBase.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_14CompressorBase_8decompress(((struct __pyx_obj_4borg_8compress_CompressorBase *)__pyx_v_self), __pyx_v_meta, __pyx_v_data);
 
@@ -2955,198 +2977,198 @@
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
   __Pyx_INCREF(__pyx_v_meta);
 
-  /* "borg/compress.pyx":108
+  /* "borg/compress.pyx":109
  *         decompression method see *Compressor.decompress*.
  *         """
  *         if self.legacy_mode:             # <<<<<<<<<<<<<<
  *             assert meta is None
  *             meta = {}
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 109, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 108, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 109, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":109
+    /* "borg/compress.pyx":110
  *         """
  *         if self.legacy_mode:
  *             assert meta is None             # <<<<<<<<<<<<<<
  *             meta = {}
  *             meta["ctype"] = data[0]
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
       __pyx_t_2 = (__pyx_v_meta == Py_None);
       if (unlikely(!(__pyx_t_2 != 0))) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 109, __pyx_L1_error)
+        __PYX_ERR(0, 110, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/compress.pyx":110
+    /* "borg/compress.pyx":111
  *         if self.legacy_mode:
  *             assert meta is None
  *             meta = {}             # <<<<<<<<<<<<<<
  *             meta["ctype"] = data[0]
  *             meta["clevel"] = data[1]
  */
-    __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 110, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 111, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_1);
     __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":111
+    /* "borg/compress.pyx":112
  *             assert meta is None
  *             meta = {}
  *             meta["ctype"] = data[0]             # <<<<<<<<<<<<<<
  *             meta["clevel"] = data[1]
  *             meta["csize"] = len(data)
  */
-    __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_data, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 111, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_data, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 112, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_ctype, __pyx_t_1) < 0)) __PYX_ERR(0, 111, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_ctype, __pyx_t_1) < 0)) __PYX_ERR(0, 112, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":112
+    /* "borg/compress.pyx":113
  *             meta = {}
  *             meta["ctype"] = data[0]
  *             meta["clevel"] = data[1]             # <<<<<<<<<<<<<<
  *             meta["csize"] = len(data)
  *             return meta, data[2:]
  */
-    __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_data, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 112, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_data, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 113, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_clevel, __pyx_t_1) < 0)) __PYX_ERR(0, 112, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_clevel, __pyx_t_1) < 0)) __PYX_ERR(0, 113, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":113
+    /* "borg/compress.pyx":114
  *             meta["ctype"] = data[0]
  *             meta["clevel"] = data[1]
  *             meta["csize"] = len(data)             # <<<<<<<<<<<<<<
  *             return meta, data[2:]
  *         else:
  */
-    __pyx_t_3 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 113, __pyx_L1_error)
-    __pyx_t_1 = PyInt_FromSsize_t(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 113, __pyx_L1_error)
+    __pyx_t_3 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 114, __pyx_L1_error)
+    __pyx_t_1 = PyInt_FromSsize_t(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 114, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_csize, __pyx_t_1) < 0)) __PYX_ERR(0, 113, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_csize, __pyx_t_1) < 0)) __PYX_ERR(0, 114, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":114
+    /* "borg/compress.pyx":115
  *             meta["clevel"] = data[1]
  *             meta["csize"] = len(data)
  *             return meta, data[2:]             # <<<<<<<<<<<<<<
  *         else:
  *             assert isinstance(meta, dict)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_data, 2, 0, NULL, NULL, &__pyx_slice_, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 114, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_data, 2, 0, NULL, NULL, &__pyx_slice_, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 115, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 114, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 115, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_meta);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
     __pyx_t_1 = 0;
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":108
+    /* "borg/compress.pyx":109
  *         decompression method see *Compressor.decompress*.
  *         """
  *         if self.legacy_mode:             # <<<<<<<<<<<<<<
  *             assert meta is None
  *             meta = {}
  */
   }
 
-  /* "borg/compress.pyx":116
+  /* "borg/compress.pyx":117
  *             return meta, data[2:]
  *         else:
  *             assert isinstance(meta, dict)             # <<<<<<<<<<<<<<
  *             assert "ctype" in meta
  *             assert "clevel" in meta
  */
   /*else*/ {
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
       __pyx_t_2 = PyDict_Check(__pyx_v_meta); 
       if (unlikely(!(__pyx_t_2 != 0))) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 116, __pyx_L1_error)
+        __PYX_ERR(0, 117, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/compress.pyx":117
+    /* "borg/compress.pyx":118
  *         else:
  *             assert isinstance(meta, dict)
  *             assert "ctype" in meta             # <<<<<<<<<<<<<<
  *             assert "clevel" in meta
  *             return meta, data
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
-      __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_ctype, __pyx_v_meta, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 117, __pyx_L1_error)
+      __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_ctype, __pyx_v_meta, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 118, __pyx_L1_error)
       if (unlikely(!(__pyx_t_2 != 0))) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 117, __pyx_L1_error)
+        __PYX_ERR(0, 118, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/compress.pyx":118
+    /* "borg/compress.pyx":119
  *             assert isinstance(meta, dict)
  *             assert "ctype" in meta
  *             assert "clevel" in meta             # <<<<<<<<<<<<<<
  *             return meta, data
  * 
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
-      __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_clevel, __pyx_v_meta, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 118, __pyx_L1_error)
+      __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_clevel, __pyx_v_meta, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 119, __pyx_L1_error)
       if (unlikely(!(__pyx_t_2 != 0))) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 118, __pyx_L1_error)
+        __PYX_ERR(0, 119, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/compress.pyx":119
+    /* "borg/compress.pyx":120
  *             assert "ctype" in meta
  *             assert "clevel" in meta
  *             return meta, data             # <<<<<<<<<<<<<<
  * 
  *     def check_fix_size(self, meta, data):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 119, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 120, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_data);
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":99
+  /* "borg/compress.pyx":100
  *             return meta, data
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decompress *data* (preferably a memoryview, bytes also acceptable) and return bytes result.
  */
 
@@ -3159,15 +3181,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":121
+/* "borg/compress.pyx":122
  *             return meta, data
  * 
  *     def check_fix_size(self, meta, data):             # <<<<<<<<<<<<<<
  *         if "size" in meta:
  *             assert meta["size"] == len(data)
  */
 
@@ -3201,32 +3223,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("check_fix_size", 1, 2, 2, 1); __PYX_ERR(0, 121, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("check_fix_size", 1, 2, 2, 1); __PYX_ERR(0, 122, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_fix_size") < 0)) __PYX_ERR(0, 121, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_fix_size") < 0)) __PYX_ERR(0, 122, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_meta = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("check_fix_size", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 121, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("check_fix_size", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 122, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.CompressorBase.check_fix_size", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_14CompressorBase_10check_fix_size(((struct __pyx_obj_4borg_8compress_CompressorBase *)__pyx_v_self), __pyx_v_meta, __pyx_v_data);
 
@@ -3245,109 +3267,109 @@
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("check_fix_size", 0);
 
-  /* "borg/compress.pyx":122
+  /* "borg/compress.pyx":123
  * 
  *     def check_fix_size(self, meta, data):
  *         if "size" in meta:             # <<<<<<<<<<<<<<
  *             assert meta["size"] == len(data)
  *         elif self.legacy_mode:
  */
-  __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_size, __pyx_v_meta, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 122, __pyx_L1_error)
+  __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_size, __pyx_v_meta, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 123, __pyx_L1_error)
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":123
+    /* "borg/compress.pyx":124
  *     def check_fix_size(self, meta, data):
  *         if "size" in meta:
  *             assert meta["size"] == len(data)             # <<<<<<<<<<<<<<
  *         elif self.legacy_mode:
  *             meta["size"] = len(data)
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
-      __pyx_t_3 = __Pyx_PyObject_Dict_GetItem(__pyx_v_meta, __pyx_n_s_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 123, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_Dict_GetItem(__pyx_v_meta, __pyx_n_s_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 124, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 123, __pyx_L1_error)
-      __pyx_t_5 = PyInt_FromSsize_t(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 123, __pyx_L1_error)
+      __pyx_t_4 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 124, __pyx_L1_error)
+      __pyx_t_5 = PyInt_FromSsize_t(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 124, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = PyObject_RichCompare(__pyx_t_3, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 123, __pyx_L1_error)
+      __pyx_t_6 = PyObject_RichCompare(__pyx_t_3, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 124, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 123, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 124, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       if (unlikely(!__pyx_t_2)) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 123, __pyx_L1_error)
+        __PYX_ERR(0, 124, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/compress.pyx":122
+    /* "borg/compress.pyx":123
  * 
  *     def check_fix_size(self, meta, data):
  *         if "size" in meta:             # <<<<<<<<<<<<<<
  *             assert meta["size"] == len(data)
  *         elif self.legacy_mode:
  */
     goto __pyx_L3;
   }
 
-  /* "borg/compress.pyx":124
+  /* "borg/compress.pyx":125
  *         if "size" in meta:
  *             assert meta["size"] == len(data)
  *         elif self.legacy_mode:             # <<<<<<<<<<<<<<
  *             meta["size"] = len(data)
  *         else:
  */
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 124, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 125, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 124, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 125, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":125
+    /* "borg/compress.pyx":126
  *             assert meta["size"] == len(data)
  *         elif self.legacy_mode:
  *             meta["size"] = len(data)             # <<<<<<<<<<<<<<
  *         else:
  *             pass  # raise ValueError("size not present and not in legacy mode")
  */
-    __pyx_t_4 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 125, __pyx_L1_error)
-    __pyx_t_6 = PyInt_FromSsize_t(__pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 125, __pyx_L1_error)
+    __pyx_t_4 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 126, __pyx_L1_error)
+    __pyx_t_6 = PyInt_FromSsize_t(__pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 126, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_size, __pyx_t_6) < 0)) __PYX_ERR(0, 125, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_size, __pyx_t_6) < 0)) __PYX_ERR(0, 126, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-    /* "borg/compress.pyx":124
+    /* "borg/compress.pyx":125
  *         if "size" in meta:
  *             assert meta["size"] == len(data)
  *         elif self.legacy_mode:             # <<<<<<<<<<<<<<
  *             meta["size"] = len(data)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "borg/compress.pyx":127
+  /* "borg/compress.pyx":128
  *             meta["size"] = len(data)
  *         else:
  *             pass  # raise ValueError("size not present and not in legacy mode")             # <<<<<<<<<<<<<<
  * 
  * 
  */
   /*else*/ {
   }
   __pyx_L3:;
 
-  /* "borg/compress.pyx":121
+  /* "borg/compress.pyx":122
  *             return meta, data
  * 
  *     def check_fix_size(self, meta, data):             # <<<<<<<<<<<<<<
  *         if "size" in meta:
  *             assert meta["size"] == len(data)
  */
 
@@ -3649,15 +3671,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":137
+/* "borg/compress.pyx":138
  *     name = 'decidebaseclass'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  * 
  */
 
@@ -3702,15 +3724,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_legacy_mode);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 137, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 138, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
@@ -3719,15 +3741,15 @@
       }
     }
     __pyx_v_level = values[0];
     __pyx_v_legacy_mode = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 137, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 138, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.DecidingCompressor.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_18DecidingCompressor___init__(((struct __pyx_obj_4borg_8compress_DecidingCompressor *)__pyx_v_self), __pyx_v_level, __pyx_v_legacy_mode, __pyx_v_kwargs);
@@ -3745,49 +3767,49 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":138
+  /* "borg/compress.pyx":139
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)             # <<<<<<<<<<<<<<
  * 
  *     def _decide(self, meta, data):
  */
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 138, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 139, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
   PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_v_self));
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 138, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 139, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 138, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 139, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 138, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 139, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 138, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 138, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 139, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 139, __pyx_L1_error)
   __pyx_t_2 = __pyx_t_3;
   __pyx_t_3 = 0;
-  if (__Pyx_MergeKeywords(__pyx_t_2, __pyx_v_kwargs) < 0) __PYX_ERR(0, 138, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_empty_tuple, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 138, __pyx_L1_error)
+  if (__Pyx_MergeKeywords(__pyx_t_2, __pyx_v_kwargs) < 0) __PYX_ERR(0, 139, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_empty_tuple, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 139, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":137
+  /* "borg/compress.pyx":138
  *     name = 'decidebaseclass'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  * 
  */
 
@@ -3801,15 +3823,15 @@
   __Pyx_AddTraceback("borg.compress.DecidingCompressor.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":140
+/* "borg/compress.pyx":141
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, meta, compressed_data).
  */
 
@@ -3844,32 +3866,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 2, 2, 1); __PYX_ERR(0, 140, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 2, 2, 1); __PYX_ERR(0, 141, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 140, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 141, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_meta = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_decide", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 140, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_decide", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 141, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.DecidingCompressor._decide", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_18DecidingCompressor_2_decide(((struct __pyx_obj_4borg_8compress_DecidingCompressor *)__pyx_v_self), __pyx_v_meta, __pyx_v_data);
 
@@ -3882,25 +3904,25 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decide", 0);
 
-  /* "borg/compress.pyx":150
+  /* "borg/compress.pyx":151
  *         and decide_compress() making use of *compressed_data*, if already generated.
  *         """
  *         raise NotImplementedError             # <<<<<<<<<<<<<<
  * 
  *     def decide(self, meta, data):
  */
   __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
-  __PYX_ERR(0, 150, __pyx_L1_error)
+  __PYX_ERR(0, 151, __pyx_L1_error)
 
-  /* "borg/compress.pyx":140
+  /* "borg/compress.pyx":141
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, meta, compressed_data).
  */
 
@@ -3909,15 +3931,15 @@
   __Pyx_AddTraceback("borg.compress.DecidingCompressor._decide", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":152
+/* "borg/compress.pyx":153
  *         raise NotImplementedError
  * 
  *     def decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self._decide(meta, data)[0]
  * 
  */
 
@@ -3951,32 +3973,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decide", 1, 2, 2, 1); __PYX_ERR(0, 152, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decide", 1, 2, 2, 1); __PYX_ERR(0, 153, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decide") < 0)) __PYX_ERR(0, 152, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decide") < 0)) __PYX_ERR(0, 153, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_meta = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decide", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 152, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decide", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 153, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.DecidingCompressor.decide", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_18DecidingCompressor_4decide(((struct __pyx_obj_4borg_8compress_DecidingCompressor *)__pyx_v_self), __pyx_v_meta, __pyx_v_data);
 
@@ -3994,23 +4016,23 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decide", 0);
 
-  /* "borg/compress.pyx":153
+  /* "borg/compress.pyx":154
  * 
  *     def decide(self, meta, data):
  *         return self._decide(meta, data)[0]             # <<<<<<<<<<<<<<
  * 
  *     def decide_compress(self, meta, data):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_decide); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 153, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_decide); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 154, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -4019,52 +4041,52 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 153, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 154, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 153, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 154, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 153, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 154, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_3) {
       __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 153, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 154, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 153, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 154, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":152
+  /* "borg/compress.pyx":153
  *         raise NotImplementedError
  * 
  *     def decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self._decide(meta, data)[0]
  * 
  */
 
@@ -4078,15 +4100,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":155
+/* "borg/compress.pyx":156
  *         return self._decide(meta, data)[0]
  * 
  *     def decide_compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data* and handle accordingly. Returns (compressor, compressed_data).
  */
 
@@ -4121,32 +4143,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decide_compress", 1, 2, 2, 1); __PYX_ERR(0, 155, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decide_compress", 1, 2, 2, 1); __PYX_ERR(0, 156, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decide_compress") < 0)) __PYX_ERR(0, 155, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decide_compress") < 0)) __PYX_ERR(0, 156, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_meta = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decide_compress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 155, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decide_compress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 156, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.DecidingCompressor.decide_compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_18DecidingCompressor_6decide_compress(((struct __pyx_obj_4borg_8compress_DecidingCompressor *)__pyx_v_self), __pyx_v_meta, __pyx_v_data);
 
@@ -4172,22 +4194,22 @@
   int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decide_compress", 0);
   __Pyx_INCREF(__pyx_v_meta);
 
-  /* "borg/compress.pyx":161
+  /* "borg/compress.pyx":162
  *         *compressed_data* is the result of *data* being processed by *compressor*.
  *         """
  *         compressor, (meta, compressed_data) = self._decide(meta, data)             # <<<<<<<<<<<<<<
  * 
  *         if compressed_data is None:
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_decide); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 161, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_decide); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -4196,162 +4218,162 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_3) {
       __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 161, __pyx_L1_error)
+      __PYX_ERR(0, 162, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_6 = Py_TYPE(__pyx_t_3)->tp_iternext;
     index = 0; __pyx_t_2 = __pyx_t_6(__pyx_t_3); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_2);
     index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_3); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_5);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_3), 2) < 0) __PYX_ERR(0, 161, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_3), 2) < 0) __PYX_ERR(0, 162, __pyx_L1_error)
     __pyx_t_6 = NULL;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 161, __pyx_L1_error)
+    __PYX_ERR(0, 162, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __pyx_v_compressor = __pyx_t_2;
   __pyx_t_2 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
     PyObject* sequence = __pyx_t_5;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 161, __pyx_L1_error)
+      __PYX_ERR(0, 162, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_7);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     #endif
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_8 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 161, __pyx_L1_error)
+    __pyx_t_8 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 162, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_6 = Py_TYPE(__pyx_t_8)->tp_iternext;
     index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_8); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
     index = 1; __pyx_t_7 = __pyx_t_6(__pyx_t_8); if (unlikely(!__pyx_t_7)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_7);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_8), 2) < 0) __PYX_ERR(0, 161, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_8), 2) < 0) __PYX_ERR(0, 162, __pyx_L1_error)
     __pyx_t_6 = NULL;
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     goto __pyx_L6_unpacking_done;
     __pyx_L5_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 161, __pyx_L1_error)
+    __PYX_ERR(0, 162, __pyx_L1_error)
     __pyx_L6_unpacking_done:;
   }
   __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_3);
   __pyx_t_3 = 0;
   __pyx_v_compressed_data = __pyx_t_7;
   __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":163
+  /* "borg/compress.pyx":164
  *         compressor, (meta, compressed_data) = self._decide(meta, data)
  * 
  *         if compressed_data is None:             # <<<<<<<<<<<<<<
  *             meta, compressed_data = compressor.compress(meta, data)
  * 
  */
   __pyx_t_9 = (__pyx_v_compressed_data == Py_None);
   __pyx_t_10 = (__pyx_t_9 != 0);
   if (__pyx_t_10) {
 
-    /* "borg/compress.pyx":164
+    /* "borg/compress.pyx":165
  * 
  *         if compressed_data is None:
  *             meta, compressed_data = compressor.compress(meta, data)             # <<<<<<<<<<<<<<
  * 
  *         if compressor is self:
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_compressor, __pyx_n_s_compress); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 164, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_compressor, __pyx_n_s_compress); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 165, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_2 = NULL;
     __pyx_t_4 = 0;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_2)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -4360,135 +4382,135 @@
         __Pyx_DECREF_SET(__pyx_t_5, function);
         __pyx_t_4 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 164, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_GOTREF(__pyx_t_1);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 164, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_GOTREF(__pyx_t_1);
     } else
     #endif
     {
-      __pyx_t_7 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 164, __pyx_L1_error)
+      __pyx_t_7 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 165, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_7);
       if (__pyx_t_2) {
         __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_2); __pyx_t_2 = NULL;
       }
       __Pyx_INCREF(__pyx_v_meta);
       __Pyx_GIVEREF(__pyx_v_meta);
       PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_4, __pyx_v_meta);
       __Pyx_INCREF(__pyx_v_data);
       __Pyx_GIVEREF(__pyx_v_data);
       PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_4, __pyx_v_data);
-      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 164, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     }
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
       PyObject* sequence = __pyx_t_1;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 2)) {
         if (size > 2) __Pyx_RaiseTooManyValuesError(2);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 164, __pyx_L1_error)
+        __PYX_ERR(0, 165, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
         __pyx_t_5 = PyTuple_GET_ITEM(sequence, 0); 
         __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
       } else {
         __pyx_t_5 = PyList_GET_ITEM(sequence, 0); 
         __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
       }
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_7);
       #else
-      __pyx_t_5 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 164, __pyx_L1_error)
+      __pyx_t_5 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 165, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 164, __pyx_L1_error)
+      __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 165, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_7);
       #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     } else {
       Py_ssize_t index = -1;
-      __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 164, __pyx_L1_error)
+      __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 165, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __pyx_t_6 = Py_TYPE(__pyx_t_2)->tp_iternext;
       index = 0; __pyx_t_5 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_5)) goto __pyx_L8_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_5);
       index = 1; __pyx_t_7 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_7)) goto __pyx_L8_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_7);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 164, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 165, __pyx_L1_error)
       __pyx_t_6 = NULL;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       goto __pyx_L9_unpacking_done;
       __pyx_L8_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_6 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 164, __pyx_L1_error)
+      __PYX_ERR(0, 165, __pyx_L1_error)
       __pyx_L9_unpacking_done:;
     }
     __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_5);
     __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_compressed_data, __pyx_t_7);
     __pyx_t_7 = 0;
 
-    /* "borg/compress.pyx":163
+    /* "borg/compress.pyx":164
  *         compressor, (meta, compressed_data) = self._decide(meta, data)
  * 
  *         if compressed_data is None:             # <<<<<<<<<<<<<<
  *             meta, compressed_data = compressor.compress(meta, data)
  * 
  */
   }
 
-  /* "borg/compress.pyx":166
+  /* "borg/compress.pyx":167
  *             meta, compressed_data = compressor.compress(meta, data)
  * 
  *         if compressor is self:             # <<<<<<<<<<<<<<
  *             # call super class to add ID bytes
  *             return self, super().compress(meta, compressed_data)
  */
   __pyx_t_10 = (__pyx_v_compressor == ((PyObject *)__pyx_v_self));
   __pyx_t_9 = (__pyx_t_10 != 0);
   if (__pyx_t_9) {
 
-    /* "borg/compress.pyx":168
+    /* "borg/compress.pyx":169
  *         if compressor is self:
  *             # call super class to add ID bytes
  *             return self, super().compress(meta, compressed_data)             # <<<<<<<<<<<<<<
  * 
  *         return compressor, (meta, compressed_data)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 168, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 169, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
     __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
     PyTuple_SET_ITEM(__pyx_t_7, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
     __Pyx_INCREF(((PyObject *)__pyx_v_self));
     __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
     PyTuple_SET_ITEM(__pyx_t_7, 1, ((PyObject *)__pyx_v_self));
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_7, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 168, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_7, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 169, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_compress); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 168, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_compress); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 169, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_5 = NULL;
     __pyx_t_4 = 0;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_5)) {
@@ -4498,94 +4520,94 @@
         __Pyx_DECREF_SET(__pyx_t_7, function);
         __pyx_t_4 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_7)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_meta, __pyx_v_compressed_data};
-      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 169, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_1);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_meta, __pyx_v_compressed_data};
-      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 169, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_1);
     } else
     #endif
     {
-      __pyx_t_2 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 168, __pyx_L1_error)
+      __pyx_t_2 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 169, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       if (__pyx_t_5) {
         __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
       __Pyx_INCREF(__pyx_v_meta);
       __Pyx_GIVEREF(__pyx_v_meta);
       PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_4, __pyx_v_meta);
       __Pyx_INCREF(__pyx_v_compressed_data);
       __Pyx_GIVEREF(__pyx_v_compressed_data);
       PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_4, __pyx_v_compressed_data);
-      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 169, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 168, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 169, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_INCREF(((PyObject *)__pyx_v_self));
     __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
     PyTuple_SET_ITEM(__pyx_t_7, 0, ((PyObject *)__pyx_v_self));
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_1);
     __pyx_t_1 = 0;
     __pyx_r = __pyx_t_7;
     __pyx_t_7 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":166
+    /* "borg/compress.pyx":167
  *             meta, compressed_data = compressor.compress(meta, data)
  * 
  *         if compressor is self:             # <<<<<<<<<<<<<<
  *             # call super class to add ID bytes
  *             return self, super().compress(meta, compressed_data)
  */
   }
 
-  /* "borg/compress.pyx":170
+  /* "borg/compress.pyx":171
  *             return self, super().compress(meta, compressed_data)
  * 
  *         return compressor, (meta, compressed_data)             # <<<<<<<<<<<<<<
  * 
  *     def compress(self, meta, data):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 170, __pyx_L1_error)
+  __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 171, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_GIVEREF(__pyx_v_meta);
   PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_meta);
   __Pyx_INCREF(__pyx_v_compressed_data);
   __Pyx_GIVEREF(__pyx_v_compressed_data);
   PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_v_compressed_data);
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 170, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_v_compressor);
   __Pyx_GIVEREF(__pyx_v_compressor);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_compressor);
   __Pyx_GIVEREF(__pyx_t_7);
   PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_7);
   __pyx_t_7 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":155
+  /* "borg/compress.pyx":156
  *         return self._decide(meta, data)[0]
  * 
  *     def decide_compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data* and handle accordingly. Returns (compressor, compressed_data).
  */
 
@@ -4604,15 +4626,15 @@
   __Pyx_XDECREF(__pyx_v_compressed_data);
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":172
+/* "borg/compress.pyx":173
  *         return compressor, (meta, compressed_data)
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta["size"] = len(data)
  *         return self.decide_compress(meta, data)[1]
  */
 
@@ -4646,32 +4668,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 2, 2, 1); __PYX_ERR(0, 172, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 2, 2, 1); __PYX_ERR(0, 173, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 172, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 173, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_meta = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("compress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 172, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("compress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 173, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.DecidingCompressor.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_18DecidingCompressor_8compress(((struct __pyx_obj_4borg_8compress_DecidingCompressor *)__pyx_v_self), __pyx_v_meta, __pyx_v_data);
 
@@ -4690,36 +4712,36 @@
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
 
-  /* "borg/compress.pyx":173
+  /* "borg/compress.pyx":174
  * 
  *     def compress(self, meta, data):
  *         meta["size"] = len(data)             # <<<<<<<<<<<<<<
  *         return self.decide_compress(meta, data)[1]
  * 
  */
-  __pyx_t_1 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 173, __pyx_L1_error)
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 173, __pyx_L1_error)
+  __pyx_t_1 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 174, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 174, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_size, __pyx_t_2) < 0)) __PYX_ERR(0, 173, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_size, __pyx_t_2) < 0)) __PYX_ERR(0, 174, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/compress.pyx":174
+  /* "borg/compress.pyx":175
  *     def compress(self, meta, data):
  *         meta["size"] = len(data)
  *         return self.decide_compress(meta, data)[1]             # <<<<<<<<<<<<<<
  * 
  * class CNONE(CompressorBase):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_decide_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 174, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_decide_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 175, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -4728,52 +4750,52 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 174, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 175, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 174, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 175, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 174, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 175, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_data);
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 174, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 175, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_2, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 174, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_2, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 175, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":172
+  /* "borg/compress.pyx":173
  *         return compressor, (meta, compressed_data)
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta["size"] = len(data)
  *         return self.decide_compress(meta, data)[1]
  */
 
@@ -5074,15 +5096,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":183
+/* "borg/compress.pyx":184
  *     name = 'none'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for CNONE, so just say "unknown"
  * 
  */
 
@@ -5135,15 +5157,15 @@
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_legacy_mode);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 183, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 184, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
@@ -5154,15 +5176,15 @@
     }
     __pyx_v_self = values[0];
     __pyx_v_level = values[1];
     __pyx_v_legacy_mode = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 183, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 184, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.CNONE.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_5CNONE___init__(__pyx_self, __pyx_v_self, __pyx_v_level, __pyx_v_legacy_mode, __pyx_v_kwargs);
@@ -5180,52 +5202,52 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":184
+  /* "borg/compress.pyx":185
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for CNONE, so just say "unknown"             # <<<<<<<<<<<<<<
  * 
  *     def compress(self, meta, data):
  */
   __pyx_t_1 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 184, __pyx_L1_error) }
+  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 185, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 184, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 185, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 185, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 184, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 185, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 184, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 185, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 184, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 184, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 185, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 185, __pyx_L1_error)
   __pyx_t_1 = __pyx_t_3;
   __pyx_t_3 = 0;
-  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 184, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 184, __pyx_L1_error)
+  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 185, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 185, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":183
+  /* "borg/compress.pyx":184
  *     name = 'none'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for CNONE, so just say "unknown"
  * 
  */
 
@@ -5240,15 +5262,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":186
+/* "borg/compress.pyx":187
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for CNONE, so just say "unknown"
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta["size"] = len(data)
  *         return super().compress(meta, data)
  */
 
@@ -5286,40 +5308,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 186, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 187, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 186, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 187, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 186, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 187, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 186, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 187, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.CNONE.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_5CNONE_2compress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -5338,50 +5360,50 @@
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
 
-  /* "borg/compress.pyx":187
+  /* "borg/compress.pyx":188
  * 
  *     def compress(self, meta, data):
  *         meta["size"] = len(data)             # <<<<<<<<<<<<<<
  *         return super().compress(meta, data)
  * 
  */
-  __pyx_t_1 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 187, __pyx_L1_error)
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 187, __pyx_L1_error)
+  __pyx_t_1 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 188, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 188, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_size, __pyx_t_2) < 0)) __PYX_ERR(0, 187, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_size, __pyx_t_2) < 0)) __PYX_ERR(0, 188, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/compress.pyx":188
+  /* "borg/compress.pyx":189
  *     def compress(self, meta, data):
  *         meta["size"] = len(data)
  *         return super().compress(meta, data)             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, meta, data):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_3 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_3) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 188, __pyx_L1_error) }
+  if (!__pyx_t_3) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 189, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_3);
-  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 188, __pyx_L1_error)
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 189, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_self);
   __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 188, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 189, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_compress); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 188, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_compress); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 189, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_3)) {
@@ -5391,49 +5413,49 @@
       __Pyx_DECREF_SET(__pyx_t_4, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 188, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 188, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 188, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 189, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_3) {
       __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_data);
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 188, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":186
+  /* "borg/compress.pyx":187
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for CNONE, so just say "unknown"
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta["size"] = len(data)
  *         return super().compress(meta, data)
  */
 
@@ -5447,15 +5469,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":190
+/* "borg/compress.pyx":191
  *         return super().compress(meta, data)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         if not isinstance(data, bytes):
  */
 
@@ -5493,40 +5515,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 190, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 191, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 190, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 191, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 190, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 191, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 190, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 191, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.CNONE.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_5CNONE_4decompress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -5549,36 +5571,36 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_INCREF(__pyx_v_data);
 
-  /* "borg/compress.pyx":191
+  /* "borg/compress.pyx":192
  * 
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)             # <<<<<<<<<<<<<<
  *         if not isinstance(data, bytes):
  *             data = bytes(data)
  */
   __pyx_t_2 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 191, __pyx_L1_error) }
+  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 192, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 191, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 191, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 192, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 191, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -5588,135 +5610,135 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 191, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 192, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 191, __pyx_L1_error)
+      __PYX_ERR(0, 192, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 191, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 191, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 192, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 191, __pyx_L1_error)
+    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 192, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_6 = Py_TYPE(__pyx_t_2)->tp_iternext;
     index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
     index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_5);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 191, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 192, __pyx_L1_error)
     __pyx_t_6 = NULL;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 191, __pyx_L1_error)
+    __PYX_ERR(0, 192, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_3);
   __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_5);
   __pyx_t_5 = 0;
 
-  /* "borg/compress.pyx":192
+  /* "borg/compress.pyx":193
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)
  *         if not isinstance(data, bytes):             # <<<<<<<<<<<<<<
  *             data = bytes(data)
  *         self.check_fix_size(meta, data)
  */
   __pyx_t_7 = PyBytes_Check(__pyx_v_data); 
   __pyx_t_8 = ((!(__pyx_t_7 != 0)) != 0);
   if (__pyx_t_8) {
 
-    /* "borg/compress.pyx":193
+    /* "borg/compress.pyx":194
  *         meta, data = super().decompress(meta, data)
  *         if not isinstance(data, bytes):
  *             data = bytes(data)             # <<<<<<<<<<<<<<
  *         self.check_fix_size(meta, data)
  *         return meta, data
  */
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_data); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 193, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_data); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_1);
     __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":192
+    /* "borg/compress.pyx":193
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)
  *         if not isinstance(data, bytes):             # <<<<<<<<<<<<<<
  *             data = bytes(data)
  *         self.check_fix_size(meta, data)
  */
   }
 
-  /* "borg/compress.pyx":194
+  /* "borg/compress.pyx":195
  *         if not isinstance(data, bytes):
  *             data = bytes(data)
  *         self.check_fix_size(meta, data)             # <<<<<<<<<<<<<<
  *         return meta, data
  * 
  */
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 194, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 195, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_3 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -5725,67 +5747,67 @@
       __Pyx_DECREF_SET(__pyx_t_5, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_2 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 194, __pyx_L1_error)
+    __pyx_t_2 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 195, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     if (__pyx_t_3) {
       __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3); __pyx_t_3 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":195
+  /* "borg/compress.pyx":196
  *             data = bytes(data)
  *         self.check_fix_size(meta, data)
  *         return meta, data             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 196, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_GIVEREF(__pyx_v_meta);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_meta);
   __Pyx_INCREF(__pyx_v_data);
   __Pyx_GIVEREF(__pyx_v_data);
   PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_data);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":190
+  /* "borg/compress.pyx":191
  *         return super().compress(meta, data)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         if not isinstance(data, bytes):
  */
 
@@ -5801,15 +5823,15 @@
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":210
+/* "borg/compress.pyx":211
  *     name = 'lz4'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for LZ4, so just say "unknown"
  * 
  */
 
@@ -5862,15 +5884,15 @@
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_legacy_mode);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 210, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 211, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
@@ -5881,15 +5903,15 @@
     }
     __pyx_v_self = values[0];
     __pyx_v_level = values[1];
     __pyx_v_legacy_mode = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 210, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 211, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.LZ4.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_3LZ4___init__(__pyx_self, __pyx_v_self, __pyx_v_level, __pyx_v_legacy_mode, __pyx_v_kwargs);
@@ -5907,52 +5929,52 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":211
+  /* "borg/compress.pyx":212
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for LZ4, so just say "unknown"             # <<<<<<<<<<<<<<
  * 
  *     def _decide(self, meta, idata):
  */
   __pyx_t_1 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 211, __pyx_L1_error) }
+  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 212, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 211, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 212, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 211, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 212, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 211, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 212, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 211, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 212, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 211, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 211, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 212, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 212, __pyx_L1_error)
   __pyx_t_1 = __pyx_t_3;
   __pyx_t_3 = 0;
-  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 211, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 211, __pyx_L1_error)
+  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 212, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 212, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":210
+  /* "borg/compress.pyx":211
  *     name = 'lz4'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for LZ4, so just say "unknown"
  * 
  */
 
@@ -5967,15 +5989,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":213
+/* "borg/compress.pyx":214
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for LZ4, so just say "unknown"
  * 
  *     def _decide(self, meta, idata):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, lz4_data).
  */
 
@@ -6014,40 +6036,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 213, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 214, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_idata)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 213, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 214, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 213, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 214, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_idata = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 213, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 214, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.LZ4._decide", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_3LZ4_2_decide(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_idata);
 
@@ -6074,144 +6096,144 @@
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decide", 0);
   __Pyx_INCREF(__pyx_v_idata);
 
-  /* "borg/compress.pyx":219
+  /* "borg/compress.pyx":220
  *         *lz4_data* is the LZ4 result if *compressor* is LZ4 as well, otherwise it is None.
  *         """
  *         if not isinstance(idata, bytes):             # <<<<<<<<<<<<<<
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)
  */
   __pyx_t_1 = PyBytes_Check(__pyx_v_idata); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":220
+    /* "borg/compress.pyx":221
  *         """
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview             # <<<<<<<<<<<<<<
  *         cdef int isize = len(idata)
  *         cdef int osize
  */
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_idata); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 220, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_idata); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 221, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF_SET(__pyx_v_idata, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "borg/compress.pyx":219
+    /* "borg/compress.pyx":220
  *         *lz4_data* is the LZ4 result if *compressor* is LZ4 as well, otherwise it is None.
  *         """
  *         if not isinstance(idata, bytes):             # <<<<<<<<<<<<<<
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)
  */
   }
 
-  /* "borg/compress.pyx":221
+  /* "borg/compress.pyx":222
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)             # <<<<<<<<<<<<<<
  *         cdef int osize
  *         cdef char *source = idata
  */
-  __pyx_t_4 = PyObject_Length(__pyx_v_idata); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 221, __pyx_L1_error)
+  __pyx_t_4 = PyObject_Length(__pyx_v_idata); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 222, __pyx_L1_error)
   __pyx_v_isize = __pyx_t_4;
 
-  /* "borg/compress.pyx":223
+  /* "borg/compress.pyx":224
  *         cdef int isize = len(idata)
  *         cdef int osize
  *         cdef char *source = idata             # <<<<<<<<<<<<<<
  *         cdef char *dest
  *         osize = LZ4_compressBound(isize)
  */
-  __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_idata); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 223, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_idata); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 224, __pyx_L1_error)
   __pyx_v_source = __pyx_t_5;
 
-  /* "borg/compress.pyx":225
+  /* "borg/compress.pyx":226
  *         cdef char *source = idata
  *         cdef char *dest
  *         osize = LZ4_compressBound(isize)             # <<<<<<<<<<<<<<
  *         buf = buffer.get(osize)
  *         dest = <char *> buf
  */
   __pyx_v_osize = LZ4_compressBound(__pyx_v_isize);
 
-  /* "borg/compress.pyx":226
+  /* "borg/compress.pyx":227
  *         cdef char *dest
  *         osize = LZ4_compressBound(isize)
  *         buf = buffer.get(osize)             # <<<<<<<<<<<<<<
  *         dest = <char *> buf
  *         with nogil:
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_buffer); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 226, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_buffer); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 227, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_get); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 226, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_get); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 227, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_osize); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 226, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_osize); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 227, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __pyx_t_8 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
     __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
     if (likely(__pyx_t_8)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
       __Pyx_INCREF(__pyx_t_8);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_7, function);
     }
   }
   __pyx_t_3 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
   __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 226, __pyx_L1_error)
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 227, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_v_buf = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":227
+  /* "borg/compress.pyx":228
  *         osize = LZ4_compressBound(isize)
  *         buf = buffer.get(osize)
  *         dest = <char *> buf             # <<<<<<<<<<<<<<
  *         with nogil:
  *             osize = LZ4_compress_default(source, dest, isize, osize)
  */
-  __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 227, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 228, __pyx_L1_error)
   __pyx_v_dest = ((char *)__pyx_t_5);
 
-  /* "borg/compress.pyx":228
+  /* "borg/compress.pyx":229
  *         buf = buffer.get(osize)
  *         dest = <char *> buf
  *         with nogil:             # <<<<<<<<<<<<<<
  *             osize = LZ4_compress_default(source, dest, isize, osize)
  *         if not osize:
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "borg/compress.pyx":229
+        /* "borg/compress.pyx":230
  *         dest = <char *> buf
  *         with nogil:
  *             osize = LZ4_compress_default(source, dest, isize, osize)             # <<<<<<<<<<<<<<
  *         if not osize:
  *             raise Exception('lz4 compress failed')
  */
         __pyx_v_osize = LZ4_compress_default(__pyx_v_source, __pyx_v_dest, __pyx_v_isize, __pyx_v_osize);
       }
 
-      /* "borg/compress.pyx":228
+      /* "borg/compress.pyx":229
  *         buf = buffer.get(osize)
  *         dest = <char *> buf
  *         with nogil:             # <<<<<<<<<<<<<<
  *             osize = LZ4_compress_default(source, dest, isize, osize)
  *         if not osize:
  */
       /*finally:*/ {
@@ -6222,128 +6244,128 @@
           #endif
           goto __pyx_L6;
         }
         __pyx_L6:;
       }
   }
 
-  /* "borg/compress.pyx":230
+  /* "borg/compress.pyx":231
  *         with nogil:
  *             osize = LZ4_compress_default(source, dest, isize, osize)
  *         if not osize:             # <<<<<<<<<<<<<<
  *             raise Exception('lz4 compress failed')
  *         # only compress if the result actually is smaller
  */
   __pyx_t_2 = ((!(__pyx_v_osize != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "borg/compress.pyx":231
+    /* "borg/compress.pyx":232
  *             osize = LZ4_compress_default(source, dest, isize, osize)
  *         if not osize:
  *             raise Exception('lz4 compress failed')             # <<<<<<<<<<<<<<
  *         # only compress if the result actually is smaller
  *         if osize < isize:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 231, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 232, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 231, __pyx_L1_error)
+    __PYX_ERR(0, 232, __pyx_L1_error)
 
-    /* "borg/compress.pyx":230
+    /* "borg/compress.pyx":231
  *         with nogil:
  *             osize = LZ4_compress_default(source, dest, isize, osize)
  *         if not osize:             # <<<<<<<<<<<<<<
  *             raise Exception('lz4 compress failed')
  *         # only compress if the result actually is smaller
  */
   }
 
-  /* "borg/compress.pyx":233
+  /* "borg/compress.pyx":234
  *             raise Exception('lz4 compress failed')
  *         # only compress if the result actually is smaller
  *         if osize < isize:             # <<<<<<<<<<<<<<
  *             return self, (meta, dest[:osize])
  *         else:
  */
   __pyx_t_2 = ((__pyx_v_osize < __pyx_v_isize) != 0);
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":234
+    /* "borg/compress.pyx":235
  *         # only compress if the result actually is smaller
  *         if osize < isize:
  *             return self, (meta, dest[:osize])             # <<<<<<<<<<<<<<
  *         else:
  *             return NONE_COMPRESSOR, (meta, None)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_dest + 0, __pyx_v_osize - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 234, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_dest + 0, __pyx_v_osize - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 235, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 234, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 235, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_meta);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 234, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 235, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_self);
     __Pyx_GIVEREF(__pyx_v_self);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_self);
     __Pyx_GIVEREF(__pyx_t_7);
     PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_7);
     __pyx_t_7 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":233
+    /* "borg/compress.pyx":234
  *             raise Exception('lz4 compress failed')
  *         # only compress if the result actually is smaller
  *         if osize < isize:             # <<<<<<<<<<<<<<
  *             return self, (meta, dest[:osize])
  *         else:
  */
   }
 
-  /* "borg/compress.pyx":236
+  /* "borg/compress.pyx":237
  *             return self, (meta, dest[:osize])
  *         else:
  *             return NONE_COMPRESSOR, (meta, None)             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, meta, data):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 236, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 237, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 236, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 237, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_meta);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     PyTuple_SET_ITEM(__pyx_t_7, 1, Py_None);
-    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 236, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 237, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_7);
     PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_7);
     __pyx_t_3 = 0;
     __pyx_t_7 = 0;
     __pyx_r = __pyx_t_6;
     __pyx_t_6 = 0;
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":213
+  /* "borg/compress.pyx":214
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for LZ4, so just say "unknown"
  * 
  *     def _decide(self, meta, idata):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, lz4_data).
  */
 
@@ -6359,15 +6381,15 @@
   __Pyx_XDECREF(__pyx_v_buf);
   __Pyx_XDECREF(__pyx_v_idata);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":238
+/* "borg/compress.pyx":239
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  */
 
@@ -6405,40 +6427,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 238, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 239, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 238, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 239, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 238, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 239, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 238, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 239, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.LZ4.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_3LZ4_4decompress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -6476,36 +6498,36 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_INCREF(__pyx_v_data);
 
-  /* "borg/compress.pyx":239
+  /* "borg/compress.pyx":240
  * 
  *     def decompress(self, meta, data):
  *         meta, idata = super().decompress(meta, data)             # <<<<<<<<<<<<<<
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview
  */
   __pyx_t_2 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 239, __pyx_L1_error) }
+  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 240, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 239, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 240, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 239, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 240, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 239, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 240, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -6515,187 +6537,187 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 239, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 240, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 239, __pyx_L1_error)
+      __PYX_ERR(0, 240, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 239, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 240, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 239, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 240, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 239, __pyx_L1_error)
+    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 240, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_6 = Py_TYPE(__pyx_t_2)->tp_iternext;
     index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
     index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_5);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 239, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 240, __pyx_L1_error)
     __pyx_t_6 = NULL;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 239, __pyx_L1_error)
+    __PYX_ERR(0, 240, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_3);
   __pyx_t_3 = 0;
   __pyx_v_idata = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "borg/compress.pyx":240
+  /* "borg/compress.pyx":241
  *     def decompress(self, meta, data):
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):             # <<<<<<<<<<<<<<
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)
  */
   __pyx_t_7 = PyBytes_Check(__pyx_v_idata); 
   __pyx_t_8 = ((!(__pyx_t_7 != 0)) != 0);
   if (__pyx_t_8) {
 
-    /* "borg/compress.pyx":241
+    /* "borg/compress.pyx":242
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview             # <<<<<<<<<<<<<<
  *         cdef int isize = len(idata)
  *         cdef int osize
  */
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_idata); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_idata); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF_SET(__pyx_v_idata, __pyx_t_1);
     __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":240
+    /* "borg/compress.pyx":241
  *     def decompress(self, meta, data):
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):             # <<<<<<<<<<<<<<
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)
  */
   }
 
-  /* "borg/compress.pyx":242
+  /* "borg/compress.pyx":243
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)             # <<<<<<<<<<<<<<
  *         cdef int osize
  *         cdef int rsize
  */
-  __pyx_t_9 = PyObject_Length(__pyx_v_idata); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 242, __pyx_L1_error)
+  __pyx_t_9 = PyObject_Length(__pyx_v_idata); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 243, __pyx_L1_error)
   __pyx_v_isize = __pyx_t_9;
 
-  /* "borg/compress.pyx":245
+  /* "borg/compress.pyx":246
  *         cdef int osize
  *         cdef int rsize
  *         cdef char *source = idata             # <<<<<<<<<<<<<<
  *         cdef char *dest
  *         # a bit more than 8MB is enough for the usual data sizes yielded by the chunker.
  */
-  __pyx_t_10 = __Pyx_PyObject_AsWritableString(__pyx_v_idata); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 245, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_PyObject_AsWritableString(__pyx_v_idata); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 246, __pyx_L1_error)
   __pyx_v_source = __pyx_t_10;
 
-  /* "borg/compress.pyx":249
+  /* "borg/compress.pyx":250
  *         # a bit more than 8MB is enough for the usual data sizes yielded by the chunker.
  *         # allocate more if isize * 3 is already bigger, to avoid having to resize often.
  *         osize = max(int(1.1 * 2**23), isize * 3)             # <<<<<<<<<<<<<<
  *         while True:
  *             try:
  */
   __pyx_t_11 = (__pyx_v_isize * 3);
-  __pyx_t_1 = __Pyx_PyInt_FromDouble((1.1 * 8388608.0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 249, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_FromDouble((1.1 * 8388608.0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 250, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyInt_From_long(__pyx_t_11); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 249, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_long(__pyx_t_11); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 250, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = PyObject_RichCompare(__pyx_t_3, __pyx_t_1, Py_GT); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 249, __pyx_L1_error)
+  __pyx_t_2 = PyObject_RichCompare(__pyx_t_3, __pyx_t_1, Py_GT); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 250, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 249, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 250, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (__pyx_t_8) {
-    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_t_11); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 249, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_t_11); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 250, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_t_5 = __pyx_t_2;
     __pyx_t_2 = 0;
   } else {
     __Pyx_INCREF(__pyx_t_1);
     __pyx_t_5 = __pyx_t_1;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_5); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 249, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_5); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 250, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_v_osize = __pyx_t_4;
 
-  /* "borg/compress.pyx":250
+  /* "borg/compress.pyx":251
  *         # allocate more if isize * 3 is already bigger, to avoid having to resize often.
  *         osize = max(int(1.1 * 2**23), isize * 3)
  *         while True:             # <<<<<<<<<<<<<<
  *             try:
  *                 buf = buffer.get(osize)
  */
   while (1) {
 
-    /* "borg/compress.pyx":251
+    /* "borg/compress.pyx":252
  *         osize = max(int(1.1 * 2**23), isize * 3)
  *         while True:
  *             try:             # <<<<<<<<<<<<<<
  *                 buf = buffer.get(osize)
  *             except MemoryError:
  */
     {
@@ -6703,48 +6725,48 @@
       __Pyx_PyThreadState_assign
       __Pyx_ExceptionSave(&__pyx_t_12, &__pyx_t_13, &__pyx_t_14);
       __Pyx_XGOTREF(__pyx_t_12);
       __Pyx_XGOTREF(__pyx_t_13);
       __Pyx_XGOTREF(__pyx_t_14);
       /*try:*/ {
 
-        /* "borg/compress.pyx":252
+        /* "borg/compress.pyx":253
  *         while True:
  *             try:
  *                 buf = buffer.get(osize)             # <<<<<<<<<<<<<<
  *             except MemoryError:
  *                 raise DecompressionError('MemoryError')
  */
-        __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 252, __pyx_L8_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 253, __pyx_L8_error)
         __Pyx_GOTREF(__pyx_t_1);
-        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 252, __pyx_L8_error)
+        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 253, __pyx_L8_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_osize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 252, __pyx_L8_error)
+        __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_osize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 253, __pyx_L8_error)
         __Pyx_GOTREF(__pyx_t_1);
         __pyx_t_3 = NULL;
         if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
           __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
           if (likely(__pyx_t_3)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
             __Pyx_INCREF(__pyx_t_3);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_2, function);
           }
         }
         __pyx_t_5 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_t_1) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_1);
         __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 252, __pyx_L8_error)
+        if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 253, __pyx_L8_error)
         __Pyx_GOTREF(__pyx_t_5);
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
         __Pyx_XDECREF_SET(__pyx_v_buf, __pyx_t_5);
         __pyx_t_5 = 0;
 
-        /* "borg/compress.pyx":251
+        /* "borg/compress.pyx":252
  *         osize = max(int(1.1 * 2**23), isize * 3)
  *         while True:
  *             try:             # <<<<<<<<<<<<<<
  *                 buf = buffer.get(osize)
  *             except MemoryError:
  */
       }
@@ -6754,111 +6776,111 @@
       goto __pyx_L15_try_end;
       __pyx_L8_error:;
       __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-      /* "borg/compress.pyx":253
+      /* "borg/compress.pyx":254
  *             try:
  *                 buf = buffer.get(osize)
  *             except MemoryError:             # <<<<<<<<<<<<<<
  *                 raise DecompressionError('MemoryError')
  *             dest = <char *> buf
  */
       __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_MemoryError);
       if (__pyx_t_4) {
         __Pyx_AddTraceback("borg.compress.LZ4.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
-        if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_2, &__pyx_t_1) < 0) __PYX_ERR(0, 253, __pyx_L10_except_error)
+        if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_2, &__pyx_t_1) < 0) __PYX_ERR(0, 254, __pyx_L10_except_error)
         __Pyx_GOTREF(__pyx_t_5);
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_GOTREF(__pyx_t_1);
 
-        /* "borg/compress.pyx":254
+        /* "borg/compress.pyx":255
  *                 buf = buffer.get(osize)
  *             except MemoryError:
  *                 raise DecompressionError('MemoryError')             # <<<<<<<<<<<<<<
  *             dest = <char *> buf
  *             with nogil:
  */
-        __Pyx_GetModuleGlobalName(__pyx_t_15, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 254, __pyx_L10_except_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_15, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 255, __pyx_L10_except_error)
         __Pyx_GOTREF(__pyx_t_15);
         __pyx_t_16 = NULL;
         if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_15))) {
           __pyx_t_16 = PyMethod_GET_SELF(__pyx_t_15);
           if (likely(__pyx_t_16)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_15);
             __Pyx_INCREF(__pyx_t_16);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_15, function);
           }
         }
         __pyx_t_3 = (__pyx_t_16) ? __Pyx_PyObject_Call2Args(__pyx_t_15, __pyx_t_16, __pyx_n_s_MemoryError) : __Pyx_PyObject_CallOneArg(__pyx_t_15, __pyx_n_s_MemoryError);
         __Pyx_XDECREF(__pyx_t_16); __pyx_t_16 = 0;
-        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 254, __pyx_L10_except_error)
+        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 255, __pyx_L10_except_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
         __Pyx_Raise(__pyx_t_3, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __PYX_ERR(0, 254, __pyx_L10_except_error)
+        __PYX_ERR(0, 255, __pyx_L10_except_error)
       }
       goto __pyx_L10_except_error;
       __pyx_L10_except_error:;
 
-      /* "borg/compress.pyx":251
+      /* "borg/compress.pyx":252
  *         osize = max(int(1.1 * 2**23), isize * 3)
  *         while True:
  *             try:             # <<<<<<<<<<<<<<
  *                 buf = buffer.get(osize)
  *             except MemoryError:
  */
       __Pyx_XGIVEREF(__pyx_t_12);
       __Pyx_XGIVEREF(__pyx_t_13);
       __Pyx_XGIVEREF(__pyx_t_14);
       __Pyx_ExceptionReset(__pyx_t_12, __pyx_t_13, __pyx_t_14);
       goto __pyx_L1_error;
       __pyx_L15_try_end:;
     }
 
-    /* "borg/compress.pyx":255
+    /* "borg/compress.pyx":256
  *             except MemoryError:
  *                 raise DecompressionError('MemoryError')
  *             dest = <char *> buf             # <<<<<<<<<<<<<<
  *             with nogil:
  *                 rsize = LZ4_decompress_safe(source, dest, isize, osize)
  */
-    __pyx_t_10 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 255, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 256, __pyx_L1_error)
     __pyx_v_dest = ((char *)__pyx_t_10);
 
-    /* "borg/compress.pyx":256
+    /* "borg/compress.pyx":257
  *                 raise DecompressionError('MemoryError')
  *             dest = <char *> buf
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 rsize = LZ4_decompress_safe(source, dest, isize, osize)
  *             if rsize >= 0:
  */
     {
         #ifdef WITH_THREAD
         PyThreadState *_save;
         Py_UNBLOCK_THREADS
         __Pyx_FastGIL_Remember();
         #endif
         /*try:*/ {
 
-          /* "borg/compress.pyx":257
+          /* "borg/compress.pyx":258
  *             dest = <char *> buf
  *             with nogil:
  *                 rsize = LZ4_decompress_safe(source, dest, isize, osize)             # <<<<<<<<<<<<<<
  *             if rsize >= 0:
  *                 break
  */
           __pyx_v_rsize = LZ4_decompress_safe(__pyx_v_source, __pyx_v_dest, __pyx_v_isize, __pyx_v_osize);
         }
 
-        /* "borg/compress.pyx":256
+        /* "borg/compress.pyx":257
  *                 raise DecompressionError('MemoryError')
  *             dest = <char *> buf
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 rsize = LZ4_decompress_safe(source, dest, isize, osize)
  *             if rsize >= 0:
  */
         /*finally:*/ {
@@ -6869,120 +6891,120 @@
             #endif
             goto __pyx_L22;
           }
           __pyx_L22:;
         }
     }
 
-    /* "borg/compress.pyx":258
+    /* "borg/compress.pyx":259
  *             with nogil:
  *                 rsize = LZ4_decompress_safe(source, dest, isize, osize)
  *             if rsize >= 0:             # <<<<<<<<<<<<<<
  *                 break
  *             if osize > 2 ** 27:  # 128MiB (should be enough, considering max. repo obj size and very good compression)
  */
     __pyx_t_8 = ((__pyx_v_rsize >= 0) != 0);
     if (__pyx_t_8) {
 
-      /* "borg/compress.pyx":259
+      /* "borg/compress.pyx":260
  *                 rsize = LZ4_decompress_safe(source, dest, isize, osize)
  *             if rsize >= 0:
  *                 break             # <<<<<<<<<<<<<<
  *             if osize > 2 ** 27:  # 128MiB (should be enough, considering max. repo obj size and very good compression)
  *                 # this is insane, get out of here
  */
       goto __pyx_L7_break;
 
-      /* "borg/compress.pyx":258
+      /* "borg/compress.pyx":259
  *             with nogil:
  *                 rsize = LZ4_decompress_safe(source, dest, isize, osize)
  *             if rsize >= 0:             # <<<<<<<<<<<<<<
  *                 break
  *             if osize > 2 ** 27:  # 128MiB (should be enough, considering max. repo obj size and very good compression)
  */
     }
 
-    /* "borg/compress.pyx":260
+    /* "borg/compress.pyx":261
  *             if rsize >= 0:
  *                 break
  *             if osize > 2 ** 27:  # 128MiB (should be enough, considering max. repo obj size and very good compression)             # <<<<<<<<<<<<<<
  *                 # this is insane, get out of here
  *                 raise DecompressionError('lz4 decompress failed')
  */
     __pyx_t_8 = ((__pyx_v_osize > 0x8000000) != 0);
     if (unlikely(__pyx_t_8)) {
 
-      /* "borg/compress.pyx":262
+      /* "borg/compress.pyx":263
  *             if osize > 2 ** 27:  # 128MiB (should be enough, considering max. repo obj size and very good compression)
  *                 # this is insane, get out of here
  *                 raise DecompressionError('lz4 decompress failed')             # <<<<<<<<<<<<<<
  *             # likely the buffer was too small, get a bigger one:
  *             osize = int(1.5 * osize)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 262, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 263, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_2, function);
         }
       }
       __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_kp_s_lz4_decompress_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_lz4_decompress_failed);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 262, __pyx_L1_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 263, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 262, __pyx_L1_error)
+      __PYX_ERR(0, 263, __pyx_L1_error)
 
-      /* "borg/compress.pyx":260
+      /* "borg/compress.pyx":261
  *             if rsize >= 0:
  *                 break
  *             if osize > 2 ** 27:  # 128MiB (should be enough, considering max. repo obj size and very good compression)             # <<<<<<<<<<<<<<
  *                 # this is insane, get out of here
  *                 raise DecompressionError('lz4 decompress failed')
  */
     }
 
-    /* "borg/compress.pyx":264
+    /* "borg/compress.pyx":265
  *                 raise DecompressionError('lz4 decompress failed')
  *             # likely the buffer was too small, get a bigger one:
  *             osize = int(1.5 * osize)             # <<<<<<<<<<<<<<
  *         data = dest[:rsize]
  *         self.check_fix_size(meta, data)
  */
     __pyx_v_osize = ((int)(1.5 * __pyx_v_osize));
   }
   __pyx_L7_break:;
 
-  /* "borg/compress.pyx":265
+  /* "borg/compress.pyx":266
  *             # likely the buffer was too small, get a bigger one:
  *             osize = int(1.5 * osize)
  *         data = dest[:rsize]             # <<<<<<<<<<<<<<
  *         self.check_fix_size(meta, data)
  *         return meta, data
  */
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_dest + 0, __pyx_v_rsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 265, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_dest + 0, __pyx_v_rsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":266
+  /* "borg/compress.pyx":267
  *             osize = int(1.5 * osize)
  *         data = dest[:rsize]
  *         self.check_fix_size(meta, data)             # <<<<<<<<<<<<<<
  *         return meta, data
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 266, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 267, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_5 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -6991,67 +7013,67 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_3 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 266, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 267, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     if (__pyx_t_5) {
       __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5); __pyx_t_5 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":267
+  /* "borg/compress.pyx":268
  *         data = dest[:rsize]
  *         self.check_fix_size(meta, data)
  *         return meta, data             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 268, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_GIVEREF(__pyx_v_meta);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_meta);
   __Pyx_INCREF(__pyx_v_data);
   __Pyx_GIVEREF(__pyx_v_data);
   PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_data);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":238
+  /* "borg/compress.pyx":239
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  */
 
@@ -7071,15 +7093,15 @@
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":277
+/* "borg/compress.pyx":278
  *     name = 'lzma'
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
 
@@ -7132,15 +7154,15 @@
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_legacy_mode);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 277, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 278, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
@@ -7151,15 +7173,15 @@
     }
     __pyx_v_self = values[0];
     __pyx_v_level = values[1];
     __pyx_v_legacy_mode = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 277, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 278, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.LZMA.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4LZMA___init__(__pyx_self, __pyx_v_self, __pyx_v_level, __pyx_v_legacy_mode, __pyx_v_kwargs);
@@ -7179,97 +7201,97 @@
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":278
+  /* "borg/compress.pyx":279
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)             # <<<<<<<<<<<<<<
  *         self.level = level
  *         if lzma is None:
  */
   __pyx_t_1 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 278, __pyx_L1_error) }
+  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 279, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 278, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 279, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 278, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 279, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 278, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 279, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 278, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 279, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 278, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 278, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 279, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 279, __pyx_L1_error)
   __pyx_t_1 = __pyx_t_3;
   __pyx_t_3 = 0;
-  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 278, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 278, __pyx_L1_error)
+  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 279, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 279, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":279
+  /* "borg/compress.pyx":280
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level             # <<<<<<<<<<<<<<
  *         if lzma is None:
  *             raise ValueError('No lzma support found.')
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 279, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 280, __pyx_L1_error)
 
-  /* "borg/compress.pyx":280
+  /* "borg/compress.pyx":281
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  *         if lzma is None:             # <<<<<<<<<<<<<<
  *             raise ValueError('No lzma support found.')
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_lzma); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 280, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_lzma); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 281, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = (__pyx_t_3 == Py_None);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_5 = (__pyx_t_4 != 0);
   if (unlikely(__pyx_t_5)) {
 
-    /* "borg/compress.pyx":281
+    /* "borg/compress.pyx":282
  *         self.level = level
  *         if lzma is None:
  *             raise ValueError('No lzma support found.')             # <<<<<<<<<<<<<<
  * 
  *     def _decide(self, meta, data):
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 281, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 282, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 281, __pyx_L1_error)
+    __PYX_ERR(0, 282, __pyx_L1_error)
 
-    /* "borg/compress.pyx":280
+    /* "borg/compress.pyx":281
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  *         if lzma is None:             # <<<<<<<<<<<<<<
  *             raise ValueError('No lzma support found.')
  * 
  */
   }
 
-  /* "borg/compress.pyx":277
+  /* "borg/compress.pyx":278
  *     name = 'lzma'
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
 
@@ -7284,15 +7306,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":283
+/* "borg/compress.pyx":284
  *             raise ValueError('No lzma support found.')
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, lzma_data).
  */
 
@@ -7331,40 +7353,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 283, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 284, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 283, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 284, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 283, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 284, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 283, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 284, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.LZMA._decide", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4LZMA_2_decide(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -7386,134 +7408,134 @@
   Py_ssize_t __pyx_t_7;
   int __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decide", 0);
 
-  /* "borg/compress.pyx":290
+  /* "borg/compress.pyx":291
  *         """
  *         # we do not need integrity checks in lzma, we do that already
  *         lzma_data = lzma.compress(data, preset=self.level, check=lzma.CHECK_NONE)             # <<<<<<<<<<<<<<
  *         if len(lzma_data) < len(data):
  *             return self, (meta, lzma_data)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_lzma); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_lzma); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_compress); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_compress); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_v_data);
   __Pyx_GIVEREF(__pyx_v_data);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_data);
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_preset, __pyx_t_4) < 0) __PYX_ERR(0, 290, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_preset, __pyx_t_4) < 0) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_lzma); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_lzma); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_CHECK_NONE); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_CHECK_NONE); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_check, __pyx_t_5) < 0) __PYX_ERR(0, 290, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_check, __pyx_t_5) < 0) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_lzma_data = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "borg/compress.pyx":291
+  /* "borg/compress.pyx":292
  *         # we do not need integrity checks in lzma, we do that already
  *         lzma_data = lzma.compress(data, preset=self.level, check=lzma.CHECK_NONE)
  *         if len(lzma_data) < len(data):             # <<<<<<<<<<<<<<
  *             return self, (meta, lzma_data)
  *         else:
  */
-  __pyx_t_6 = PyObject_Length(__pyx_v_lzma_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 291, __pyx_L1_error)
-  __pyx_t_7 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 291, __pyx_L1_error)
+  __pyx_t_6 = PyObject_Length(__pyx_v_lzma_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 292, __pyx_L1_error)
+  __pyx_t_7 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 292, __pyx_L1_error)
   __pyx_t_8 = ((__pyx_t_6 < __pyx_t_7) != 0);
   if (__pyx_t_8) {
 
-    /* "borg/compress.pyx":292
+    /* "borg/compress.pyx":293
  *         lzma_data = lzma.compress(data, preset=self.level, check=lzma.CHECK_NONE)
  *         if len(lzma_data) < len(data):
  *             return self, (meta, lzma_data)             # <<<<<<<<<<<<<<
  *         else:
  *             return NONE_COMPRESSOR, (meta, None)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 292, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 293, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_lzma_data);
     __Pyx_GIVEREF(__pyx_v_lzma_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_lzma_data);
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 292, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 293, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_self);
     __Pyx_GIVEREF(__pyx_v_self);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_self);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_5);
     __pyx_t_5 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":291
+    /* "borg/compress.pyx":292
  *         # we do not need integrity checks in lzma, we do that already
  *         lzma_data = lzma.compress(data, preset=self.level, check=lzma.CHECK_NONE)
  *         if len(lzma_data) < len(data):             # <<<<<<<<<<<<<<
  *             return self, (meta, lzma_data)
  *         else:
  */
   }
 
-  /* "borg/compress.pyx":294
+  /* "borg/compress.pyx":295
  *             return self, (meta, lzma_data)
  *         else:
  *             return NONE_COMPRESSOR, (meta, None)             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, meta, data):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 294, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 295, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 294, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 295, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_meta);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     PyTuple_SET_ITEM(__pyx_t_5, 1, Py_None);
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 294, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 295, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_5);
     __pyx_t_3 = 0;
     __pyx_t_5 = 0;
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":283
+  /* "borg/compress.pyx":284
  *             raise ValueError('No lzma support found.')
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, lzma_data).
  */
 
@@ -7529,15 +7551,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_lzma_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":296
+/* "borg/compress.pyx":297
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         try:
  */
 
@@ -7575,40 +7597,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 296, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 297, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 296, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 297, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 296, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 297, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 296, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 297, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.LZMA.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4LZMA_4decompress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -7644,36 +7666,36 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_INCREF(__pyx_v_data);
 
-  /* "borg/compress.pyx":297
+  /* "borg/compress.pyx":298
  * 
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)             # <<<<<<<<<<<<<<
  *         try:
  *             data = lzma.decompress(data)
  */
   __pyx_t_2 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 297, __pyx_L1_error) }
+  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 298, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 297, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 298, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 297, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 298, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 297, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 298, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -7683,96 +7705,96 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 297, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 298, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 297, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 298, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 297, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 298, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 297, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 298, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 297, __pyx_L1_error)
+      __PYX_ERR(0, 298, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 297, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 298, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 297, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 298, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 297, __pyx_L1_error)
+    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 298, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_6 = Py_TYPE(__pyx_t_2)->tp_iternext;
     index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
     index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_5);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 297, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 298, __pyx_L1_error)
     __pyx_t_6 = NULL;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 297, __pyx_L1_error)
+    __PYX_ERR(0, 298, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_3);
   __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_5);
   __pyx_t_5 = 0;
 
-  /* "borg/compress.pyx":298
+  /* "borg/compress.pyx":299
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)
  *         try:             # <<<<<<<<<<<<<<
  *             data = lzma.decompress(data)
  *             self.check_fix_size(meta, data)
  */
   {
@@ -7780,52 +7802,52 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
     __Pyx_XGOTREF(__pyx_t_7);
     __Pyx_XGOTREF(__pyx_t_8);
     __Pyx_XGOTREF(__pyx_t_9);
     /*try:*/ {
 
-      /* "borg/compress.pyx":299
+      /* "borg/compress.pyx":300
  *         meta, data = super().decompress(meta, data)
  *         try:
  *             data = lzma.decompress(data)             # <<<<<<<<<<<<<<
  *             self.check_fix_size(meta, data)
  *             return meta, data
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_lzma); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 299, __pyx_L5_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_lzma); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 300, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 299, __pyx_L5_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 300, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_data);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 299, __pyx_L5_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 300, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_1);
       __pyx_t_1 = 0;
 
-      /* "borg/compress.pyx":300
+      /* "borg/compress.pyx":301
  *         try:
  *             data = lzma.decompress(data)
  *             self.check_fix_size(meta, data)             # <<<<<<<<<<<<<<
  *             return meta, data
  *         except lzma.LZMAError as e:
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 300, __pyx_L5_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 301, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_5 = NULL;
       __pyx_t_4 = 0;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -7834,140 +7856,140 @@
           __Pyx_DECREF_SET(__pyx_t_3, function);
           __pyx_t_4 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_3)) {
         PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_meta, __pyx_v_data};
-        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 300, __pyx_L5_error)
+        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 301, __pyx_L5_error)
         __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
         __Pyx_GOTREF(__pyx_t_1);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
         PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_meta, __pyx_v_data};
-        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 300, __pyx_L5_error)
+        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 301, __pyx_L5_error)
         __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
         __Pyx_GOTREF(__pyx_t_1);
       } else
       #endif
       {
-        __pyx_t_2 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 300, __pyx_L5_error)
+        __pyx_t_2 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 301, __pyx_L5_error)
         __Pyx_GOTREF(__pyx_t_2);
         if (__pyx_t_5) {
           __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_5); __pyx_t_5 = NULL;
         }
         __Pyx_INCREF(__pyx_v_meta);
         __Pyx_GIVEREF(__pyx_v_meta);
         PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_4, __pyx_v_meta);
         __Pyx_INCREF(__pyx_v_data);
         __Pyx_GIVEREF(__pyx_v_data);
         PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_4, __pyx_v_data);
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 300, __pyx_L5_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 301, __pyx_L5_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       }
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "borg/compress.pyx":301
+      /* "borg/compress.pyx":302
  *             data = lzma.decompress(data)
  *             self.check_fix_size(meta, data)
  *             return meta, data             # <<<<<<<<<<<<<<
  *         except lzma.LZMAError as e:
  *             raise DecompressionError(str(e)) from None
  */
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 301, __pyx_L5_error)
+      __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 302, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_INCREF(__pyx_v_meta);
       __Pyx_GIVEREF(__pyx_v_meta);
       PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_meta);
       __Pyx_INCREF(__pyx_v_data);
       __Pyx_GIVEREF(__pyx_v_data);
       PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_data);
       __pyx_r = __pyx_t_1;
       __pyx_t_1 = 0;
       goto __pyx_L9_try_return;
 
-      /* "borg/compress.pyx":298
+      /* "borg/compress.pyx":299
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)
  *         try:             # <<<<<<<<<<<<<<
  *             data = lzma.decompress(data)
  *             self.check_fix_size(meta, data)
  */
     }
     __pyx_L5_error:;
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "borg/compress.pyx":302
+    /* "borg/compress.pyx":303
  *             self.check_fix_size(meta, data)
  *             return meta, data
  *         except lzma.LZMAError as e:             # <<<<<<<<<<<<<<
  *             raise DecompressionError(str(e)) from None
  * 
  */
     __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_3, &__pyx_t_2);
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_lzma); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 302, __pyx_L7_except_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_lzma); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 303, __pyx_L7_except_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_LZMAError); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 302, __pyx_L7_except_error)
+    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_LZMAError); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 303, __pyx_L7_except_error)
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_4 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_10);
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
     __Pyx_ErrRestore(__pyx_t_1, __pyx_t_3, __pyx_t_2);
     __pyx_t_1 = 0; __pyx_t_3 = 0; __pyx_t_2 = 0;
     if (__pyx_t_4) {
       __Pyx_AddTraceback("borg.compress.LZMA.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_3, &__pyx_t_1) < 0) __PYX_ERR(0, 302, __pyx_L7_except_error)
+      if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_3, &__pyx_t_1) < 0) __PYX_ERR(0, 303, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_INCREF(__pyx_t_3);
       __pyx_v_e = __pyx_t_3;
       /*try:*/ {
 
-        /* "borg/compress.pyx":303
+        /* "borg/compress.pyx":304
  *             return meta, data
  *         except lzma.LZMAError as e:
  *             raise DecompressionError(str(e)) from None             # <<<<<<<<<<<<<<
  * 
  * 
  */
-        __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 303, __pyx_L16_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 304, __pyx_L16_error)
         __Pyx_GOTREF(__pyx_t_5);
-        __pyx_t_11 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_e); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 303, __pyx_L16_error)
+        __pyx_t_11 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_e); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 304, __pyx_L16_error)
         __Pyx_GOTREF(__pyx_t_11);
         __pyx_t_12 = NULL;
         if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
           __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_5);
           if (likely(__pyx_t_12)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
             __Pyx_INCREF(__pyx_t_12);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_5, function);
           }
         }
         __pyx_t_10 = (__pyx_t_12) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_12, __pyx_t_11) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_11);
         __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
         __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 303, __pyx_L16_error)
+        if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 304, __pyx_L16_error)
         __Pyx_GOTREF(__pyx_t_10);
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
         __Pyx_Raise(__pyx_t_10, 0, 0, Py_None);
         __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-        __PYX_ERR(0, 303, __pyx_L16_error)
+        __PYX_ERR(0, 304, __pyx_L16_error)
       }
 
-      /* "borg/compress.pyx":302
+      /* "borg/compress.pyx":303
  *             self.check_fix_size(meta, data)
  *             return meta, data
  *         except lzma.LZMAError as e:             # <<<<<<<<<<<<<<
  *             raise DecompressionError(str(e)) from None
  * 
  */
       /*finally:*/ {
@@ -8008,15 +8030,15 @@
           goto __pyx_L7_except_error;
         }
       }
     }
     goto __pyx_L7_except_error;
     __pyx_L7_except_error:;
 
-    /* "borg/compress.pyx":298
+    /* "borg/compress.pyx":299
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)
  *         try:             # <<<<<<<<<<<<<<
  *             data = lzma.decompress(data)
  *             self.check_fix_size(meta, data)
  */
     __Pyx_XGIVEREF(__pyx_t_7);
@@ -8028,15 +8050,15 @@
     __Pyx_XGIVEREF(__pyx_t_7);
     __Pyx_XGIVEREF(__pyx_t_8);
     __Pyx_XGIVEREF(__pyx_t_9);
     __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":296
+  /* "borg/compress.pyx":297
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         try:
  */
 
@@ -8056,15 +8078,15 @@
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":314
+/* "borg/compress.pyx":315
  *     name = 'zstd'
  * 
  *     def __init__(self, level=3, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
 
@@ -8117,15 +8139,15 @@
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_legacy_mode);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 314, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 315, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
@@ -8136,15 +8158,15 @@
     }
     __pyx_v_self = values[0];
     __pyx_v_level = values[1];
     __pyx_v_legacy_mode = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 314, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 315, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.ZSTD.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4ZSTD___init__(__pyx_self, __pyx_v_self, __pyx_v_level, __pyx_v_legacy_mode, __pyx_v_kwargs);
@@ -8162,61 +8184,61 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":315
+  /* "borg/compress.pyx":316
  * 
  *     def __init__(self, level=3, legacy_mode=False, **kwargs):
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)             # <<<<<<<<<<<<<<
  *         self.level = level
  * 
  */
   __pyx_t_1 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 315, __pyx_L1_error) }
+  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 316, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 315, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 316, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 315, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 316, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 315, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 316, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 315, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 316, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 315, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 315, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 316, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 316, __pyx_L1_error)
   __pyx_t_1 = __pyx_t_3;
   __pyx_t_3 = 0;
-  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 315, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 315, __pyx_L1_error)
+  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 316, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 316, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":316
+  /* "borg/compress.pyx":317
  *     def __init__(self, level=3, legacy_mode=False, **kwargs):
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level             # <<<<<<<<<<<<<<
  * 
  *     def _decide(self, meta, idata):
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 316, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 317, __pyx_L1_error)
 
-  /* "borg/compress.pyx":314
+  /* "borg/compress.pyx":315
  *     name = 'zstd'
  * 
  *     def __init__(self, level=3, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
 
@@ -8231,15 +8253,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":318
+/* "borg/compress.pyx":319
  *         self.level = level
  * 
  *     def _decide(self, meta, idata):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, zstd_data).
  */
 
@@ -8278,40 +8300,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 318, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 319, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_idata)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 318, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 319, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 318, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 319, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_idata = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 318, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 319, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ZSTD._decide", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4ZSTD_2_decide(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_idata);
 
@@ -8340,157 +8362,157 @@
   PyObject *__pyx_t_9 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decide", 0);
   __Pyx_INCREF(__pyx_v_idata);
 
-  /* "borg/compress.pyx":324
+  /* "borg/compress.pyx":325
  *         *zstd_data* is the ZSTD result if *compressor* is ZSTD as well, otherwise it is None.
  *         """
  *         if not isinstance(idata, bytes):             # <<<<<<<<<<<<<<
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)
  */
   __pyx_t_1 = PyBytes_Check(__pyx_v_idata); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":325
+    /* "borg/compress.pyx":326
  *         """
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview             # <<<<<<<<<<<<<<
  *         cdef int isize = len(idata)
  *         cdef int osize
  */
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_idata); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 325, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_idata); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 326, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF_SET(__pyx_v_idata, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "borg/compress.pyx":324
+    /* "borg/compress.pyx":325
  *         *zstd_data* is the ZSTD result if *compressor* is ZSTD as well, otherwise it is None.
  *         """
  *         if not isinstance(idata, bytes):             # <<<<<<<<<<<<<<
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)
  */
   }
 
-  /* "borg/compress.pyx":326
+  /* "borg/compress.pyx":327
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)             # <<<<<<<<<<<<<<
  *         cdef int osize
  *         cdef char *source = idata
  */
-  __pyx_t_4 = PyObject_Length(__pyx_v_idata); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 326, __pyx_L1_error)
+  __pyx_t_4 = PyObject_Length(__pyx_v_idata); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 327, __pyx_L1_error)
   __pyx_v_isize = __pyx_t_4;
 
-  /* "borg/compress.pyx":328
+  /* "borg/compress.pyx":329
  *         cdef int isize = len(idata)
  *         cdef int osize
  *         cdef char *source = idata             # <<<<<<<<<<<<<<
  *         cdef char *dest
  *         cdef int level = self.level
  */
-  __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_idata); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 328, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_idata); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 329, __pyx_L1_error)
   __pyx_v_source = __pyx_t_5;
 
-  /* "borg/compress.pyx":330
+  /* "borg/compress.pyx":331
  *         cdef char *source = idata
  *         cdef char *dest
  *         cdef int level = self.level             # <<<<<<<<<<<<<<
  *         osize = ZSTD_compressBound(isize)
  *         buf = buffer.get(osize)
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 330, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 331, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 330, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 331, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_level = __pyx_t_6;
 
-  /* "borg/compress.pyx":331
+  /* "borg/compress.pyx":332
  *         cdef char *dest
  *         cdef int level = self.level
  *         osize = ZSTD_compressBound(isize)             # <<<<<<<<<<<<<<
  *         buf = buffer.get(osize)
  *         dest = <char *> buf
  */
   __pyx_v_osize = ZSTD_compressBound(__pyx_v_isize);
 
-  /* "borg/compress.pyx":332
+  /* "borg/compress.pyx":333
  *         cdef int level = self.level
  *         osize = ZSTD_compressBound(isize)
  *         buf = buffer.get(osize)             # <<<<<<<<<<<<<<
  *         dest = <char *> buf
  *         with nogil:
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_buffer); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 332, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_buffer); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 333, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_get); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 332, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_get); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 333, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_osize); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 332, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_osize); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 333, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __pyx_t_9 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
     __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
     if (likely(__pyx_t_9)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
       __Pyx_INCREF(__pyx_t_9);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_8, function);
     }
   }
   __pyx_t_3 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_9, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_7);
   __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 332, __pyx_L1_error)
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 333, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __pyx_v_buf = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":333
+  /* "borg/compress.pyx":334
  *         osize = ZSTD_compressBound(isize)
  *         buf = buffer.get(osize)
  *         dest = <char *> buf             # <<<<<<<<<<<<<<
  *         with nogil:
  *             osize = ZSTD_compress(dest, osize, source, isize, level)
  */
-  __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 333, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 334, __pyx_L1_error)
   __pyx_v_dest = ((char *)__pyx_t_5);
 
-  /* "borg/compress.pyx":334
+  /* "borg/compress.pyx":335
  *         buf = buffer.get(osize)
  *         dest = <char *> buf
  *         with nogil:             # <<<<<<<<<<<<<<
  *             osize = ZSTD_compress(dest, osize, source, isize, level)
  *         if ZSTD_isError(osize):
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "borg/compress.pyx":335
+        /* "borg/compress.pyx":336
  *         dest = <char *> buf
  *         with nogil:
  *             osize = ZSTD_compress(dest, osize, source, isize, level)             # <<<<<<<<<<<<<<
  *         if ZSTD_isError(osize):
  *             raise Exception('zstd compress failed: %s' % ZSTD_getErrorName(osize))
  */
         __pyx_v_osize = ZSTD_compress(__pyx_v_dest, __pyx_v_osize, __pyx_v_source, __pyx_v_isize, __pyx_v_level);
       }
 
-      /* "borg/compress.pyx":334
+      /* "borg/compress.pyx":335
  *         buf = buffer.get(osize)
  *         dest = <char *> buf
  *         with nogil:             # <<<<<<<<<<<<<<
  *             osize = ZSTD_compress(dest, osize, source, isize, level)
  *         if ZSTD_isError(osize):
  */
       /*finally:*/ {
@@ -8501,134 +8523,134 @@
           #endif
           goto __pyx_L6;
         }
         __pyx_L6:;
       }
   }
 
-  /* "borg/compress.pyx":336
+  /* "borg/compress.pyx":337
  *         with nogil:
  *             osize = ZSTD_compress(dest, osize, source, isize, level)
  *         if ZSTD_isError(osize):             # <<<<<<<<<<<<<<
  *             raise Exception('zstd compress failed: %s' % ZSTD_getErrorName(osize))
  *         # only compress if the result actually is smaller
  */
   __pyx_t_2 = (ZSTD_isError(__pyx_v_osize) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "borg/compress.pyx":337
+    /* "borg/compress.pyx":338
  *             osize = ZSTD_compress(dest, osize, source, isize, level)
  *         if ZSTD_isError(osize):
  *             raise Exception('zstd compress failed: %s' % ZSTD_getErrorName(osize))             # <<<<<<<<<<<<<<
  *         # only compress if the result actually is smaller
  *         if osize < isize:
  */
-    __pyx_t_3 = __Pyx_PyBytes_FromString(ZSTD_getErrorName(__pyx_v_osize)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 337, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromString(ZSTD_getErrorName(__pyx_v_osize)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 338, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_8 = __Pyx_PyString_Format(__pyx_kp_s_zstd_compress_failed_s, __pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 337, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyString_Format(__pyx_kp_s_zstd_compress_failed_s, __pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 338, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 337, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 338, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 337, __pyx_L1_error)
+    __PYX_ERR(0, 338, __pyx_L1_error)
 
-    /* "borg/compress.pyx":336
+    /* "borg/compress.pyx":337
  *         with nogil:
  *             osize = ZSTD_compress(dest, osize, source, isize, level)
  *         if ZSTD_isError(osize):             # <<<<<<<<<<<<<<
  *             raise Exception('zstd compress failed: %s' % ZSTD_getErrorName(osize))
  *         # only compress if the result actually is smaller
  */
   }
 
-  /* "borg/compress.pyx":339
+  /* "borg/compress.pyx":340
  *             raise Exception('zstd compress failed: %s' % ZSTD_getErrorName(osize))
  *         # only compress if the result actually is smaller
  *         if osize < isize:             # <<<<<<<<<<<<<<
  *             return self, (meta, dest[:osize])
  *         else:
  */
   __pyx_t_2 = ((__pyx_v_osize < __pyx_v_isize) != 0);
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":340
+    /* "borg/compress.pyx":341
  *         # only compress if the result actually is smaller
  *         if osize < isize:
  *             return self, (meta, dest[:osize])             # <<<<<<<<<<<<<<
  *         else:
  *             return NONE_COMPRESSOR, (meta, None)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_dest + 0, __pyx_v_osize - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 340, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_dest + 0, __pyx_v_osize - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 341, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_8 = PyTuple_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 340, __pyx_L1_error)
+    __pyx_t_8 = PyTuple_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 341, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_v_meta);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 340, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 341, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_self);
     __Pyx_GIVEREF(__pyx_v_self);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_self);
     __Pyx_GIVEREF(__pyx_t_8);
     PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_8);
     __pyx_t_8 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":339
+    /* "borg/compress.pyx":340
  *             raise Exception('zstd compress failed: %s' % ZSTD_getErrorName(osize))
  *         # only compress if the result actually is smaller
  *         if osize < isize:             # <<<<<<<<<<<<<<
  *             return self, (meta, dest[:osize])
  *         else:
  */
   }
 
-  /* "borg/compress.pyx":342
+  /* "borg/compress.pyx":343
  *             return self, (meta, dest[:osize])
  *         else:
  *             return NONE_COMPRESSOR, (meta, None)             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, meta, data):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 342, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 343, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_8 = PyTuple_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 342, __pyx_L1_error)
+    __pyx_t_8 = PyTuple_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 343, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_v_meta);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     PyTuple_SET_ITEM(__pyx_t_8, 1, Py_None);
-    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 342, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 343, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_8);
     PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_8);
     __pyx_t_3 = 0;
     __pyx_t_8 = 0;
     __pyx_r = __pyx_t_7;
     __pyx_t_7 = 0;
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":318
+  /* "borg/compress.pyx":319
  *         self.level = level
  * 
  *     def _decide(self, meta, idata):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, zstd_data).
  */
 
@@ -8644,15 +8666,15 @@
   __Pyx_XDECREF(__pyx_v_buf);
   __Pyx_XDECREF(__pyx_v_idata);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":344
+/* "borg/compress.pyx":345
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  */
 
@@ -8690,40 +8712,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 344, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 345, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 344, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 345, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 344, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 345, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 344, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 345, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ZSTD.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4ZSTD_4decompress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -8760,36 +8782,36 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_INCREF(__pyx_v_data);
 
-  /* "borg/compress.pyx":345
+  /* "borg/compress.pyx":346
  * 
  *     def decompress(self, meta, data):
  *         meta, idata = super().decompress(meta, data)             # <<<<<<<<<<<<<<
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview
  */
   __pyx_t_2 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 345, __pyx_L1_error) }
+  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 346, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 345, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 346, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 345, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 346, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 345, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 346, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -8799,251 +8821,251 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 345, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 346, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 345, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 346, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 345, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 346, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 345, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 346, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 345, __pyx_L1_error)
+      __PYX_ERR(0, 346, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 345, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 346, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 345, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 346, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 345, __pyx_L1_error)
+    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 346, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_6 = Py_TYPE(__pyx_t_2)->tp_iternext;
     index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
     index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_5);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 345, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 346, __pyx_L1_error)
     __pyx_t_6 = NULL;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 345, __pyx_L1_error)
+    __PYX_ERR(0, 346, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_3);
   __pyx_t_3 = 0;
   __pyx_v_idata = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "borg/compress.pyx":346
+  /* "borg/compress.pyx":347
  *     def decompress(self, meta, data):
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):             # <<<<<<<<<<<<<<
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)
  */
   __pyx_t_7 = PyBytes_Check(__pyx_v_idata); 
   __pyx_t_8 = ((!(__pyx_t_7 != 0)) != 0);
   if (__pyx_t_8) {
 
-    /* "borg/compress.pyx":347
+    /* "borg/compress.pyx":348
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview             # <<<<<<<<<<<<<<
  *         cdef int isize = len(idata)
  *         cdef unsigned long long osize
  */
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_idata); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 347, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_idata); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 348, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF_SET(__pyx_v_idata, __pyx_t_1);
     __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":346
+    /* "borg/compress.pyx":347
  *     def decompress(self, meta, data):
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):             # <<<<<<<<<<<<<<
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)
  */
   }
 
-  /* "borg/compress.pyx":348
+  /* "borg/compress.pyx":349
  *         if not isinstance(idata, bytes):
  *             idata = bytes(idata)  # code below does not work with memoryview
  *         cdef int isize = len(idata)             # <<<<<<<<<<<<<<
  *         cdef unsigned long long osize
  *         cdef unsigned long long rsize
  */
-  __pyx_t_9 = PyObject_Length(__pyx_v_idata); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 348, __pyx_L1_error)
+  __pyx_t_9 = PyObject_Length(__pyx_v_idata); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 349, __pyx_L1_error)
   __pyx_v_isize = __pyx_t_9;
 
-  /* "borg/compress.pyx":351
+  /* "borg/compress.pyx":352
  *         cdef unsigned long long osize
  *         cdef unsigned long long rsize
  *         cdef char *source = idata             # <<<<<<<<<<<<<<
  *         cdef char *dest
  *         osize = ZSTD_getFrameContentSize(source, isize)
  */
-  __pyx_t_10 = __Pyx_PyObject_AsWritableString(__pyx_v_idata); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 351, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_PyObject_AsWritableString(__pyx_v_idata); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 352, __pyx_L1_error)
   __pyx_v_source = __pyx_t_10;
 
-  /* "borg/compress.pyx":353
+  /* "borg/compress.pyx":354
  *         cdef char *source = idata
  *         cdef char *dest
  *         osize = ZSTD_getFrameContentSize(source, isize)             # <<<<<<<<<<<<<<
  *         if osize == ZSTD_CONTENTSIZE_ERROR:
  *             raise DecompressionError('zstd get size failed: data was not compressed by zstd')
  */
   __pyx_v_osize = ZSTD_getFrameContentSize(__pyx_v_source, __pyx_v_isize);
 
-  /* "borg/compress.pyx":354
+  /* "borg/compress.pyx":355
  *         cdef char *dest
  *         osize = ZSTD_getFrameContentSize(source, isize)
  *         if osize == ZSTD_CONTENTSIZE_ERROR:             # <<<<<<<<<<<<<<
  *             raise DecompressionError('zstd get size failed: data was not compressed by zstd')
  *         if osize == ZSTD_CONTENTSIZE_UNKNOWN:
  */
   __pyx_t_8 = ((__pyx_v_osize == ZSTD_CONTENTSIZE_ERROR) != 0);
   if (unlikely(__pyx_t_8)) {
 
-    /* "borg/compress.pyx":355
+    /* "borg/compress.pyx":356
  *         osize = ZSTD_getFrameContentSize(source, isize)
  *         if osize == ZSTD_CONTENTSIZE_ERROR:
  *             raise DecompressionError('zstd get size failed: data was not compressed by zstd')             # <<<<<<<<<<<<<<
  *         if osize == ZSTD_CONTENTSIZE_UNKNOWN:
  *             raise DecompressionError('zstd get size failed: original size unknown')
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 355, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 356, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_3 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_3, __pyx_kp_s_zstd_get_size_failed_data_was_no) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_zstd_get_size_failed_data_was_no);
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 355, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 356, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_Raise(__pyx_t_1, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 355, __pyx_L1_error)
+    __PYX_ERR(0, 356, __pyx_L1_error)
 
-    /* "borg/compress.pyx":354
+    /* "borg/compress.pyx":355
  *         cdef char *dest
  *         osize = ZSTD_getFrameContentSize(source, isize)
  *         if osize == ZSTD_CONTENTSIZE_ERROR:             # <<<<<<<<<<<<<<
  *             raise DecompressionError('zstd get size failed: data was not compressed by zstd')
  *         if osize == ZSTD_CONTENTSIZE_UNKNOWN:
  */
   }
 
-  /* "borg/compress.pyx":356
+  /* "borg/compress.pyx":357
  *         if osize == ZSTD_CONTENTSIZE_ERROR:
  *             raise DecompressionError('zstd get size failed: data was not compressed by zstd')
  *         if osize == ZSTD_CONTENTSIZE_UNKNOWN:             # <<<<<<<<<<<<<<
  *             raise DecompressionError('zstd get size failed: original size unknown')
  *         try:
  */
   __pyx_t_8 = ((__pyx_v_osize == ZSTD_CONTENTSIZE_UNKNOWN) != 0);
   if (unlikely(__pyx_t_8)) {
 
-    /* "borg/compress.pyx":357
+    /* "borg/compress.pyx":358
  *             raise DecompressionError('zstd get size failed: data was not compressed by zstd')
  *         if osize == ZSTD_CONTENTSIZE_UNKNOWN:
  *             raise DecompressionError('zstd get size failed: original size unknown')             # <<<<<<<<<<<<<<
  *         try:
  *             buf = buffer.get(osize)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 357, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 358, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_3 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_3, __pyx_kp_s_zstd_get_size_failed_original_si) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_zstd_get_size_failed_original_si);
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 357, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 358, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_Raise(__pyx_t_1, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 357, __pyx_L1_error)
+    __PYX_ERR(0, 358, __pyx_L1_error)
 
-    /* "borg/compress.pyx":356
+    /* "borg/compress.pyx":357
  *         if osize == ZSTD_CONTENTSIZE_ERROR:
  *             raise DecompressionError('zstd get size failed: data was not compressed by zstd')
  *         if osize == ZSTD_CONTENTSIZE_UNKNOWN:             # <<<<<<<<<<<<<<
  *             raise DecompressionError('zstd get size failed: original size unknown')
  *         try:
  */
   }
 
-  /* "borg/compress.pyx":358
+  /* "borg/compress.pyx":359
  *         if osize == ZSTD_CONTENTSIZE_UNKNOWN:
  *             raise DecompressionError('zstd get size failed: original size unknown')
  *         try:             # <<<<<<<<<<<<<<
  *             buf = buffer.get(osize)
  *         except MemoryError:
  */
   {
@@ -9051,48 +9073,48 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);
     __Pyx_XGOTREF(__pyx_t_11);
     __Pyx_XGOTREF(__pyx_t_12);
     __Pyx_XGOTREF(__pyx_t_13);
     /*try:*/ {
 
-      /* "borg/compress.pyx":359
+      /* "borg/compress.pyx":360
  *             raise DecompressionError('zstd get size failed: original size unknown')
  *         try:
  *             buf = buffer.get(osize)             # <<<<<<<<<<<<<<
  *         except MemoryError:
  *             raise DecompressionError('MemoryError')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_buffer); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 359, __pyx_L8_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_buffer); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 360, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 359, __pyx_L8_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 360, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_5 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_osize); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 359, __pyx_L8_error)
+      __pyx_t_5 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_osize); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 360, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_2 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_2)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_2);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5);
       __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 359, __pyx_L8_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 360, __pyx_L8_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __pyx_v_buf = __pyx_t_1;
       __pyx_t_1 = 0;
 
-      /* "borg/compress.pyx":358
+      /* "borg/compress.pyx":359
  *         if osize == ZSTD_CONTENTSIZE_UNKNOWN:
  *             raise DecompressionError('zstd get size failed: original size unknown')
  *         try:             # <<<<<<<<<<<<<<
  *             buf = buffer.get(osize)
  *         except MemoryError:
  */
     }
@@ -9102,111 +9124,111 @@
     goto __pyx_L13_try_end;
     __pyx_L8_error:;
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "borg/compress.pyx":360
+    /* "borg/compress.pyx":361
  *         try:
  *             buf = buffer.get(osize)
  *         except MemoryError:             # <<<<<<<<<<<<<<
  *             raise DecompressionError('MemoryError')
  *         dest = <char *> buf
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_MemoryError);
     if (__pyx_t_4) {
       __Pyx_AddTraceback("borg.compress.ZSTD.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_3, &__pyx_t_5) < 0) __PYX_ERR(0, 360, __pyx_L10_except_error)
+      if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_3, &__pyx_t_5) < 0) __PYX_ERR(0, 361, __pyx_L10_except_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_GOTREF(__pyx_t_5);
 
-      /* "borg/compress.pyx":361
+      /* "borg/compress.pyx":362
  *             buf = buffer.get(osize)
  *         except MemoryError:
  *             raise DecompressionError('MemoryError')             # <<<<<<<<<<<<<<
  *         dest = <char *> buf
  *         with nogil:
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_14, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 361, __pyx_L10_except_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_14, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 362, __pyx_L10_except_error)
       __Pyx_GOTREF(__pyx_t_14);
       __pyx_t_15 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_14))) {
         __pyx_t_15 = PyMethod_GET_SELF(__pyx_t_14);
         if (likely(__pyx_t_15)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_14);
           __Pyx_INCREF(__pyx_t_15);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_14, function);
         }
       }
       __pyx_t_2 = (__pyx_t_15) ? __Pyx_PyObject_Call2Args(__pyx_t_14, __pyx_t_15, __pyx_n_s_MemoryError) : __Pyx_PyObject_CallOneArg(__pyx_t_14, __pyx_n_s_MemoryError);
       __Pyx_XDECREF(__pyx_t_15); __pyx_t_15 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 361, __pyx_L10_except_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 362, __pyx_L10_except_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
       __Pyx_Raise(__pyx_t_2, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __PYX_ERR(0, 361, __pyx_L10_except_error)
+      __PYX_ERR(0, 362, __pyx_L10_except_error)
     }
     goto __pyx_L10_except_error;
     __pyx_L10_except_error:;
 
-    /* "borg/compress.pyx":358
+    /* "borg/compress.pyx":359
  *         if osize == ZSTD_CONTENTSIZE_UNKNOWN:
  *             raise DecompressionError('zstd get size failed: original size unknown')
  *         try:             # <<<<<<<<<<<<<<
  *             buf = buffer.get(osize)
  *         except MemoryError:
  */
     __Pyx_XGIVEREF(__pyx_t_11);
     __Pyx_XGIVEREF(__pyx_t_12);
     __Pyx_XGIVEREF(__pyx_t_13);
     __Pyx_ExceptionReset(__pyx_t_11, __pyx_t_12, __pyx_t_13);
     goto __pyx_L1_error;
     __pyx_L13_try_end:;
   }
 
-  /* "borg/compress.pyx":362
+  /* "borg/compress.pyx":363
  *         except MemoryError:
  *             raise DecompressionError('MemoryError')
  *         dest = <char *> buf             # <<<<<<<<<<<<<<
  *         with nogil:
  *             rsize = ZSTD_decompress(dest, osize, source, isize)
  */
-  __pyx_t_10 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 362, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 363, __pyx_L1_error)
   __pyx_v_dest = ((char *)__pyx_t_10);
 
-  /* "borg/compress.pyx":363
+  /* "borg/compress.pyx":364
  *             raise DecompressionError('MemoryError')
  *         dest = <char *> buf
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rsize = ZSTD_decompress(dest, osize, source, isize)
  *         if ZSTD_isError(rsize):
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "borg/compress.pyx":364
+        /* "borg/compress.pyx":365
  *         dest = <char *> buf
  *         with nogil:
  *             rsize = ZSTD_decompress(dest, osize, source, isize)             # <<<<<<<<<<<<<<
  *         if ZSTD_isError(rsize):
  *             raise DecompressionError('zstd decompress failed: %s' % ZSTD_getErrorName(rsize))
  */
         __pyx_v_rsize = ZSTD_decompress(__pyx_v_dest, __pyx_v_osize, __pyx_v_source, __pyx_v_isize);
       }
 
-      /* "borg/compress.pyx":363
+      /* "borg/compress.pyx":364
  *             raise DecompressionError('MemoryError')
  *         dest = <char *> buf
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rsize = ZSTD_decompress(dest, osize, source, isize)
  *         if ZSTD_isError(rsize):
  */
       /*finally:*/ {
@@ -9217,36 +9239,36 @@
           #endif
           goto __pyx_L18;
         }
         __pyx_L18:;
       }
   }
 
-  /* "borg/compress.pyx":365
+  /* "borg/compress.pyx":366
  *         with nogil:
  *             rsize = ZSTD_decompress(dest, osize, source, isize)
  *         if ZSTD_isError(rsize):             # <<<<<<<<<<<<<<
  *             raise DecompressionError('zstd decompress failed: %s' % ZSTD_getErrorName(rsize))
  *         if rsize != osize:
  */
   __pyx_t_8 = (ZSTD_isError(__pyx_v_rsize) != 0);
   if (unlikely(__pyx_t_8)) {
 
-    /* "borg/compress.pyx":366
+    /* "borg/compress.pyx":367
  *             rsize = ZSTD_decompress(dest, osize, source, isize)
  *         if ZSTD_isError(rsize):
  *             raise DecompressionError('zstd decompress failed: %s' % ZSTD_getErrorName(rsize))             # <<<<<<<<<<<<<<
  *         if rsize != osize:
  *             raise DecompressionError('zstd decompress failed: size mismatch')
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 366, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 367, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 = __Pyx_PyBytes_FromString(ZSTD_getErrorName(__pyx_v_rsize)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 366, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyBytes_FromString(ZSTD_getErrorName(__pyx_v_rsize)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 367, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_zstd_decompress_failed_s, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 366, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_zstd_decompress_failed_s, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 367, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_1 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_1)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -9254,97 +9276,97 @@
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_5 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_1, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2);
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 366, __pyx_L1_error)
+    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 367, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_5, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __PYX_ERR(0, 366, __pyx_L1_error)
+    __PYX_ERR(0, 367, __pyx_L1_error)
 
-    /* "borg/compress.pyx":365
+    /* "borg/compress.pyx":366
  *         with nogil:
  *             rsize = ZSTD_decompress(dest, osize, source, isize)
  *         if ZSTD_isError(rsize):             # <<<<<<<<<<<<<<
  *             raise DecompressionError('zstd decompress failed: %s' % ZSTD_getErrorName(rsize))
  *         if rsize != osize:
  */
   }
 
-  /* "borg/compress.pyx":367
+  /* "borg/compress.pyx":368
  *         if ZSTD_isError(rsize):
  *             raise DecompressionError('zstd decompress failed: %s' % ZSTD_getErrorName(rsize))
  *         if rsize != osize:             # <<<<<<<<<<<<<<
  *             raise DecompressionError('zstd decompress failed: size mismatch')
  *         data = dest[:osize]
  */
   __pyx_t_8 = ((__pyx_v_rsize != __pyx_v_osize) != 0);
   if (unlikely(__pyx_t_8)) {
 
-    /* "borg/compress.pyx":368
+    /* "borg/compress.pyx":369
  *             raise DecompressionError('zstd decompress failed: %s' % ZSTD_getErrorName(rsize))
  *         if rsize != osize:
  *             raise DecompressionError('zstd decompress failed: size mismatch')             # <<<<<<<<<<<<<<
  *         data = dest[:osize]
  *         self.check_fix_size(meta, data)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 368, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 369, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_2 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_2)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_2);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_5 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_kp_s_zstd_decompress_failed_size_mism) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_zstd_decompress_failed_size_mism);
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 368, __pyx_L1_error)
+    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 369, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_5, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __PYX_ERR(0, 368, __pyx_L1_error)
+    __PYX_ERR(0, 369, __pyx_L1_error)
 
-    /* "borg/compress.pyx":367
+    /* "borg/compress.pyx":368
  *         if ZSTD_isError(rsize):
  *             raise DecompressionError('zstd decompress failed: %s' % ZSTD_getErrorName(rsize))
  *         if rsize != osize:             # <<<<<<<<<<<<<<
  *             raise DecompressionError('zstd decompress failed: size mismatch')
  *         data = dest[:osize]
  */
   }
 
-  /* "borg/compress.pyx":369
+  /* "borg/compress.pyx":370
  *         if rsize != osize:
  *             raise DecompressionError('zstd decompress failed: size mismatch')
  *         data = dest[:osize]             # <<<<<<<<<<<<<<
  *         self.check_fix_size(meta, data)
  *         return meta, data
  */
-  __pyx_t_5 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_dest + 0, __pyx_v_osize - 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 369, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_dest + 0, __pyx_v_osize - 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 370, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_5);
   __pyx_t_5 = 0;
 
-  /* "borg/compress.pyx":370
+  /* "borg/compress.pyx":371
  *             raise DecompressionError('zstd decompress failed: size mismatch')
  *         data = dest[:osize]
  *         self.check_fix_size(meta, data)             # <<<<<<<<<<<<<<
  *         return meta, data
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 370, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 371, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -9353,67 +9375,67 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 370, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 371, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_5);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 370, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 371, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_5);
   } else
   #endif
   {
-    __pyx_t_1 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 370, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 371, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_1, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_1, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_1, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 370, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_1, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 371, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-  /* "borg/compress.pyx":371
+  /* "borg/compress.pyx":372
  *         data = dest[:osize]
  *         self.check_fix_size(meta, data)
  *         return meta, data             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 371, __pyx_L1_error)
+  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 372, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_GIVEREF(__pyx_v_meta);
   PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_meta);
   __Pyx_INCREF(__pyx_v_data);
   __Pyx_GIVEREF(__pyx_v_data);
   PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_data);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":344
+  /* "borg/compress.pyx":345
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  */
 
@@ -9433,15 +9455,15 @@
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":381
+/* "borg/compress.pyx":382
  *     name = 'zlib'
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
 
@@ -9494,15 +9516,15 @@
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_legacy_mode);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 381, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 382, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
@@ -9513,15 +9535,15 @@
     }
     __pyx_v_self = values[0];
     __pyx_v_level = values[1];
     __pyx_v_legacy_mode = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 381, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 382, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.ZLIB.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4ZLIB___init__(__pyx_self, __pyx_v_self, __pyx_v_level, __pyx_v_legacy_mode, __pyx_v_kwargs);
@@ -9539,61 +9561,61 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":382
+  /* "borg/compress.pyx":383
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)             # <<<<<<<<<<<<<<
  *         self.level = level
  * 
  */
   __pyx_t_1 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 382, __pyx_L1_error) }
+  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 383, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 383, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 383, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 383, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 383, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 382, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 382, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 383, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 383, __pyx_L1_error)
   __pyx_t_1 = __pyx_t_3;
   __pyx_t_3 = 0;
-  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 382, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 382, __pyx_L1_error)
+  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 383, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 383, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":383
+  /* "borg/compress.pyx":384
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level             # <<<<<<<<<<<<<<
  * 
  *     def _decide(self, meta, data):
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 383, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 384, __pyx_L1_error)
 
-  /* "borg/compress.pyx":381
+  /* "borg/compress.pyx":382
  *     name = 'zlib'
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
 
@@ -9608,15 +9630,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":385
+/* "borg/compress.pyx":386
  *         self.level = level
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, zlib_data).
  */
 
@@ -9655,40 +9677,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 385, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 386, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 385, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 386, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 385, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 386, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 385, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 386, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ZLIB._decide", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4ZLIB_2_decide(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -9711,27 +9733,27 @@
   Py_ssize_t __pyx_t_8;
   int __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decide", 0);
 
-  /* "borg/compress.pyx":391
+  /* "borg/compress.pyx":392
  *         *zlib_data* is the ZLIB result if *compressor* is ZLIB as well, otherwise it is None.
  *         """
  *         zlib_data = zlib.compress(data, self.level)             # <<<<<<<<<<<<<<
  *         if len(zlib_data) < len(data):
  *             return self, (meta, zlib_data)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_zlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 391, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_zlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 392, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 391, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 392, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 391, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 392, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -9740,131 +9762,131 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_data, __pyx_t_2};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 391, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 392, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_data, __pyx_t_2};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 391, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 392, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 391, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 392, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_data);
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_2);
     __pyx_t_2 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 391, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 392, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_zlib_data = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":392
+  /* "borg/compress.pyx":393
  *         """
  *         zlib_data = zlib.compress(data, self.level)
  *         if len(zlib_data) < len(data):             # <<<<<<<<<<<<<<
  *             return self, (meta, zlib_data)
  *         else:
  */
-  __pyx_t_7 = PyObject_Length(__pyx_v_zlib_data); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 392, __pyx_L1_error)
-  __pyx_t_8 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 392, __pyx_L1_error)
+  __pyx_t_7 = PyObject_Length(__pyx_v_zlib_data); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 393, __pyx_L1_error)
+  __pyx_t_8 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 393, __pyx_L1_error)
   __pyx_t_9 = ((__pyx_t_7 < __pyx_t_8) != 0);
   if (__pyx_t_9) {
 
-    /* "borg/compress.pyx":393
+    /* "borg/compress.pyx":394
  *         zlib_data = zlib.compress(data, self.level)
  *         if len(zlib_data) < len(data):
  *             return self, (meta, zlib_data)             # <<<<<<<<<<<<<<
  *         else:
  *             return NONE_COMPRESSOR, (meta, None)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 393, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 394, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_zlib_data);
     __Pyx_GIVEREF(__pyx_v_zlib_data);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_zlib_data);
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 393, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 394, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_self);
     __Pyx_GIVEREF(__pyx_v_self);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_self);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
     __pyx_t_1 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":392
+    /* "borg/compress.pyx":393
  *         """
  *         zlib_data = zlib.compress(data, self.level)
  *         if len(zlib_data) < len(data):             # <<<<<<<<<<<<<<
  *             return self, (meta, zlib_data)
  *         else:
  */
   }
 
-  /* "borg/compress.pyx":395
+  /* "borg/compress.pyx":396
  *             return self, (meta, zlib_data)
  *         else:
  *             return NONE_COMPRESSOR, (meta, None)             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, meta, data):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 395, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 396, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 395, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 396, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_meta);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     PyTuple_SET_ITEM(__pyx_t_1, 1, Py_None);
-    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 395, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 396, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_1);
     __pyx_t_3 = 0;
     __pyx_t_1 = 0;
     __pyx_r = __pyx_t_6;
     __pyx_t_6 = 0;
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":385
+  /* "borg/compress.pyx":386
  *         self.level = level
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, zlib_data).
  */
 
@@ -9880,15 +9902,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_zlib_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":397
+/* "borg/compress.pyx":398
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         try:
  */
 
@@ -9926,40 +9948,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 397, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 398, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 397, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 398, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 397, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 398, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 397, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 398, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ZLIB.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4ZLIB_4decompress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -9995,36 +10017,36 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_INCREF(__pyx_v_data);
 
-  /* "borg/compress.pyx":398
+  /* "borg/compress.pyx":399
  * 
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)             # <<<<<<<<<<<<<<
  *         try:
  *             data = zlib.decompress(data)
  */
   __pyx_t_2 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 398, __pyx_L1_error) }
+  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 399, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 398, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 399, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 398, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 399, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 398, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 399, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -10034,96 +10056,96 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 399, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 399, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 399, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 399, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 398, __pyx_L1_error)
+      __PYX_ERR(0, 399, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 399, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 399, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 399, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_6 = Py_TYPE(__pyx_t_2)->tp_iternext;
     index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
     index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_5);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 398, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 399, __pyx_L1_error)
     __pyx_t_6 = NULL;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 398, __pyx_L1_error)
+    __PYX_ERR(0, 399, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_3);
   __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_5);
   __pyx_t_5 = 0;
 
-  /* "borg/compress.pyx":399
+  /* "borg/compress.pyx":400
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)
  *         try:             # <<<<<<<<<<<<<<
  *             data = zlib.decompress(data)
  *             self.check_fix_size(meta, data)
  */
   {
@@ -10131,52 +10153,52 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
     __Pyx_XGOTREF(__pyx_t_7);
     __Pyx_XGOTREF(__pyx_t_8);
     __Pyx_XGOTREF(__pyx_t_9);
     /*try:*/ {
 
-      /* "borg/compress.pyx":400
+      /* "borg/compress.pyx":401
  *         meta, data = super().decompress(meta, data)
  *         try:
  *             data = zlib.decompress(data)             # <<<<<<<<<<<<<<
  *             self.check_fix_size(meta, data)
  *             return meta, data
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_zlib); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 400, __pyx_L5_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_zlib); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 401, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 400, __pyx_L5_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 401, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_data);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 400, __pyx_L5_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 401, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_1);
       __pyx_t_1 = 0;
 
-      /* "borg/compress.pyx":401
+      /* "borg/compress.pyx":402
  *         try:
  *             data = zlib.decompress(data)
  *             self.check_fix_size(meta, data)             # <<<<<<<<<<<<<<
  *             return meta, data
  *         except zlib.error as e:
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 401, __pyx_L5_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_fix_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 402, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_5 = NULL;
       __pyx_t_4 = 0;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -10185,140 +10207,140 @@
           __Pyx_DECREF_SET(__pyx_t_3, function);
           __pyx_t_4 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_3)) {
         PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_meta, __pyx_v_data};
-        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 401, __pyx_L5_error)
+        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 402, __pyx_L5_error)
         __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
         __Pyx_GOTREF(__pyx_t_1);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
         PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_meta, __pyx_v_data};
-        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 401, __pyx_L5_error)
+        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 402, __pyx_L5_error)
         __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
         __Pyx_GOTREF(__pyx_t_1);
       } else
       #endif
       {
-        __pyx_t_2 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 401, __pyx_L5_error)
+        __pyx_t_2 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 402, __pyx_L5_error)
         __Pyx_GOTREF(__pyx_t_2);
         if (__pyx_t_5) {
           __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_5); __pyx_t_5 = NULL;
         }
         __Pyx_INCREF(__pyx_v_meta);
         __Pyx_GIVEREF(__pyx_v_meta);
         PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_4, __pyx_v_meta);
         __Pyx_INCREF(__pyx_v_data);
         __Pyx_GIVEREF(__pyx_v_data);
         PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_4, __pyx_v_data);
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 401, __pyx_L5_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 402, __pyx_L5_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       }
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "borg/compress.pyx":402
+      /* "borg/compress.pyx":403
  *             data = zlib.decompress(data)
  *             self.check_fix_size(meta, data)
  *             return meta, data             # <<<<<<<<<<<<<<
  *         except zlib.error as e:
  *             raise DecompressionError(str(e)) from None
  */
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 402, __pyx_L5_error)
+      __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 403, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_INCREF(__pyx_v_meta);
       __Pyx_GIVEREF(__pyx_v_meta);
       PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_meta);
       __Pyx_INCREF(__pyx_v_data);
       __Pyx_GIVEREF(__pyx_v_data);
       PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_data);
       __pyx_r = __pyx_t_1;
       __pyx_t_1 = 0;
       goto __pyx_L9_try_return;
 
-      /* "borg/compress.pyx":399
+      /* "borg/compress.pyx":400
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)
  *         try:             # <<<<<<<<<<<<<<
  *             data = zlib.decompress(data)
  *             self.check_fix_size(meta, data)
  */
     }
     __pyx_L5_error:;
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "borg/compress.pyx":403
+    /* "borg/compress.pyx":404
  *             self.check_fix_size(meta, data)
  *             return meta, data
  *         except zlib.error as e:             # <<<<<<<<<<<<<<
  *             raise DecompressionError(str(e)) from None
  * 
  */
     __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_3, &__pyx_t_2);
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_zlib); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 403, __pyx_L7_except_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_zlib); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 404, __pyx_L7_except_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_error); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 403, __pyx_L7_except_error)
+    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_error); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 404, __pyx_L7_except_error)
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_4 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_10);
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
     __Pyx_ErrRestore(__pyx_t_1, __pyx_t_3, __pyx_t_2);
     __pyx_t_1 = 0; __pyx_t_3 = 0; __pyx_t_2 = 0;
     if (__pyx_t_4) {
       __Pyx_AddTraceback("borg.compress.ZLIB.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_3, &__pyx_t_1) < 0) __PYX_ERR(0, 403, __pyx_L7_except_error)
+      if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_3, &__pyx_t_1) < 0) __PYX_ERR(0, 404, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_INCREF(__pyx_t_3);
       __pyx_v_e = __pyx_t_3;
       /*try:*/ {
 
-        /* "borg/compress.pyx":404
+        /* "borg/compress.pyx":405
  *             return meta, data
  *         except zlib.error as e:
  *             raise DecompressionError(str(e)) from None             # <<<<<<<<<<<<<<
  * 
  * 
  */
-        __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 404, __pyx_L16_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 405, __pyx_L16_error)
         __Pyx_GOTREF(__pyx_t_5);
-        __pyx_t_11 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_e); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 404, __pyx_L16_error)
+        __pyx_t_11 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_e); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 405, __pyx_L16_error)
         __Pyx_GOTREF(__pyx_t_11);
         __pyx_t_12 = NULL;
         if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
           __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_5);
           if (likely(__pyx_t_12)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
             __Pyx_INCREF(__pyx_t_12);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_5, function);
           }
         }
         __pyx_t_10 = (__pyx_t_12) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_12, __pyx_t_11) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_11);
         __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
         __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 404, __pyx_L16_error)
+        if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 405, __pyx_L16_error)
         __Pyx_GOTREF(__pyx_t_10);
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
         __Pyx_Raise(__pyx_t_10, 0, 0, Py_None);
         __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-        __PYX_ERR(0, 404, __pyx_L16_error)
+        __PYX_ERR(0, 405, __pyx_L16_error)
       }
 
-      /* "borg/compress.pyx":403
+      /* "borg/compress.pyx":404
  *             self.check_fix_size(meta, data)
  *             return meta, data
  *         except zlib.error as e:             # <<<<<<<<<<<<<<
  *             raise DecompressionError(str(e)) from None
  * 
  */
       /*finally:*/ {
@@ -10359,15 +10381,15 @@
           goto __pyx_L7_except_error;
         }
       }
     }
     goto __pyx_L7_except_error;
     __pyx_L7_except_error:;
 
-    /* "borg/compress.pyx":399
+    /* "borg/compress.pyx":400
  *     def decompress(self, meta, data):
  *         meta, data = super().decompress(meta, data)
  *         try:             # <<<<<<<<<<<<<<
  *             data = zlib.decompress(data)
  *             self.check_fix_size(meta, data)
  */
     __Pyx_XGIVEREF(__pyx_t_7);
@@ -10379,15 +10401,15 @@
     __Pyx_XGIVEREF(__pyx_t_7);
     __Pyx_XGIVEREF(__pyx_t_8);
     __Pyx_XGIVEREF(__pyx_t_9);
     __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":397
+  /* "borg/compress.pyx":398
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         try:
  */
 
@@ -10407,15 +10429,15 @@
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":423
+/* "borg/compress.pyx":424
  * 
  *     @classmethod
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         # matches misc. patterns 0x.8.. used by zlib
  *         cmf, flg = data[:2]
  */
 
@@ -10450,32 +10472,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("detect", 1, 2, 2, 1); __PYX_ERR(0, 423, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("detect", 1, 2, 2, 1); __PYX_ERR(0, 424, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "detect") < 0)) __PYX_ERR(0, 423, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "detect") < 0)) __PYX_ERR(0, 424, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_cls = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("detect", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 423, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("detect", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 424, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ZLIB_legacy.detect", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_11ZLIB_legacy_detect(__pyx_self, __pyx_v_cls, __pyx_v_data);
 
@@ -10498,133 +10520,133 @@
   PyObject *(*__pyx_t_5)(PyObject *);
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("detect", 0);
 
-  /* "borg/compress.pyx":425
+  /* "borg/compress.pyx":426
  *     def detect(cls, data):
  *         # matches misc. patterns 0x.8.. used by zlib
  *         cmf, flg = data[:2]             # <<<<<<<<<<<<<<
  *         is_deflate = cmf & 0x0f == 8
  *         check_ok = (cmf * 256 + flg) % 31 == 0
  */
-  __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_data, 0, 2, NULL, NULL, &__pyx_slice__4, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 425, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_data, 0, 2, NULL, NULL, &__pyx_slice__4, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 426, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 425, __pyx_L1_error)
+      __PYX_ERR(0, 426, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_t_3);
     #else
-    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 425, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 426, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 425, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 426, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_4 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 425, __pyx_L1_error)
+    __pyx_t_4 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 426, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_5 = Py_TYPE(__pyx_t_4)->tp_iternext;
     index = 0; __pyx_t_2 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_2);
     index = 1; __pyx_t_3 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_4), 2) < 0) __PYX_ERR(0, 425, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_4), 2) < 0) __PYX_ERR(0, 426, __pyx_L1_error)
     __pyx_t_5 = NULL;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_5 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 425, __pyx_L1_error)
+    __PYX_ERR(0, 426, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __pyx_v_cmf = __pyx_t_2;
   __pyx_t_2 = 0;
   __pyx_v_flg = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":426
+  /* "borg/compress.pyx":427
  *         # matches misc. patterns 0x.8.. used by zlib
  *         cmf, flg = data[:2]
  *         is_deflate = cmf & 0x0f == 8             # <<<<<<<<<<<<<<
  *         check_ok = (cmf * 256 + flg) % 31 == 0
  *         return check_ok and is_deflate
  */
-  __pyx_t_1 = __Pyx_PyInt_AndObjC(__pyx_v_cmf, __pyx_int_15, 0x0f, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 426, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_AndObjC(__pyx_v_cmf, __pyx_int_15, 0x0f, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 427, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_t_1, __pyx_int_8, 8, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 426, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_t_1, __pyx_int_8, 8, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 427, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_is_deflate = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":427
+  /* "borg/compress.pyx":428
  *         cmf, flg = data[:2]
  *         is_deflate = cmf & 0x0f == 8
  *         check_ok = (cmf * 256 + flg) % 31 == 0             # <<<<<<<<<<<<<<
  *         return check_ok and is_deflate
  * 
  */
-  __pyx_t_3 = PyNumber_Multiply(__pyx_v_cmf, __pyx_int_256); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 427, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Multiply(__pyx_v_cmf, __pyx_int_256); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 428, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = PyNumber_Add(__pyx_t_3, __pyx_v_flg); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 427, __pyx_L1_error)
+  __pyx_t_1 = PyNumber_Add(__pyx_t_3, __pyx_v_flg); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 428, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyInt_RemainderObjC(__pyx_t_1, __pyx_int_31, 31, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 427, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_RemainderObjC(__pyx_t_1, __pyx_int_31, 31, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 428, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_EqObjC(__pyx_t_3, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 427, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_EqObjC(__pyx_t_3, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 428, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_check_ok = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":428
+  /* "borg/compress.pyx":429
  *         is_deflate = cmf & 0x0f == 8
  *         check_ok = (cmf * 256 + flg) % 31 == 0
  *         return check_ok and is_deflate             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, level=6, **kwargs):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_check_ok); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 428, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_check_ok); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 429, __pyx_L1_error)
   if (__pyx_t_6) {
   } else {
     __Pyx_INCREF(__pyx_v_check_ok);
     __pyx_t_1 = __pyx_v_check_ok;
     goto __pyx_L5_bool_binop_done;
   }
   __Pyx_INCREF(__pyx_v_is_deflate);
   __pyx_t_1 = __pyx_v_is_deflate;
   __pyx_L5_bool_binop_done:;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":423
+  /* "borg/compress.pyx":424
  * 
  *     @classmethod
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         # matches misc. patterns 0x.8.. used by zlib
  *         cmf, flg = data[:2]
  */
 
@@ -10642,15 +10664,15 @@
   __Pyx_XDECREF(__pyx_v_is_deflate);
   __Pyx_XDECREF(__pyx_v_check_ok);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":430
+/* "borg/compress.pyx":431
  *         return check_ok and is_deflate
  * 
  *     def __init__(self, level=6, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, **kwargs)
  *         self.level = level
  */
 
@@ -10693,15 +10715,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_level);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 430, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 431, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -10709,15 +10731,15 @@
       }
     }
     __pyx_v_self = values[0];
     __pyx_v_level = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 430, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 431, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.ZLIB_legacy.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_11ZLIB_legacy_2__init__(__pyx_self, __pyx_v_self, __pyx_v_level, __pyx_v_kwargs);
@@ -10735,60 +10757,60 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":431
+  /* "borg/compress.pyx":432
  * 
  *     def __init__(self, level=6, **kwargs):
  *         super().__init__(level=level, **kwargs)             # <<<<<<<<<<<<<<
  *         self.level = level
  * 
  */
   __pyx_t_1 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 431, __pyx_L1_error) }
+  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 432, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 431, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 432, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 431, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 432, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 431, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 432, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 431, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 432, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 431, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 432, __pyx_L1_error)
   __pyx_t_1 = __pyx_t_3;
   __pyx_t_3 = 0;
-  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 431, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 431, __pyx_L1_error)
+  if (__Pyx_MergeKeywords(__pyx_t_1, __pyx_v_kwargs) < 0) __PYX_ERR(0, 432, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 432, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":432
+  /* "borg/compress.pyx":433
  *     def __init__(self, level=6, **kwargs):
  *         super().__init__(level=level, **kwargs)
  *         self.level = level             # <<<<<<<<<<<<<<
  * 
  *     def compress(self, meta, data):
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 432, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 433, __pyx_L1_error)
 
-  /* "borg/compress.pyx":430
+  /* "borg/compress.pyx":431
  *         return check_ok and is_deflate
  * 
  *     def __init__(self, level=6, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, **kwargs)
  *         self.level = level
  */
 
@@ -10803,15 +10825,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":434
+/* "borg/compress.pyx":435
  *         self.level = level
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         # note: for compatibility no super call, do not add ID bytes
  *         return None, zlib.compress(data, self.level)
  */
 
@@ -10849,40 +10871,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 434, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 435, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 434, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 435, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 434, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 435, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 434, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 435, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ZLIB_legacy.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_11ZLIB_legacy_4compress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -10901,28 +10923,28 @@
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
 
-  /* "borg/compress.pyx":436
+  /* "borg/compress.pyx":437
  *     def compress(self, meta, data):
  *         # note: for compatibility no super call, do not add ID bytes
  *         return None, zlib.compress(data, self.level)             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, meta, data):
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_zlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 436, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_zlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 437, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 436, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 437, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 436, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 437, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -10931,59 +10953,59 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_data, __pyx_t_2};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 436, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 437, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_data, __pyx_t_2};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 436, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 437, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 436, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 437, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_data);
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_2);
     __pyx_t_2 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 436, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 437, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 436, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 437, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(Py_None);
   PyTuple_SET_ITEM(__pyx_t_3, 0, Py_None);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __pyx_t_1 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":434
+  /* "borg/compress.pyx":435
  *         self.level = level
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         # note: for compatibility no super call, do not add ID bytes
  *         return None, zlib.compress(data, self.level)
  */
 
@@ -10998,15 +11020,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":438
+/* "borg/compress.pyx":439
  *         return None, zlib.compress(data, self.level)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         # note: for compatibility no super call, do not strip ID bytes
  *         try:
  */
 
@@ -11044,40 +11066,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 438, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 439, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 438, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 439, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 438, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 439, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 438, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 439, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ZLIB_legacy.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_11ZLIB_legacy_6decompress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -11110,15 +11132,15 @@
   PyObject *__pyx_t_18 = NULL;
   PyObject *__pyx_t_19 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
 
-  /* "borg/compress.pyx":440
+  /* "borg/compress.pyx":441
  *     def decompress(self, meta, data):
  *         # note: for compatibility no super call, do not strip ID bytes
  *         try:             # <<<<<<<<<<<<<<
  *             return meta, zlib.decompress(data)
  *         except zlib.error as e:
  */
   {
@@ -11126,127 +11148,127 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "borg/compress.pyx":441
+      /* "borg/compress.pyx":442
  *         # note: for compatibility no super call, do not strip ID bytes
  *         try:
  *             return meta, zlib.decompress(data)             # <<<<<<<<<<<<<<
  *         except zlib.error as e:
  *             raise DecompressionError(str(e)) from None
  */
       __Pyx_XDECREF(__pyx_r);
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_zlib); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 441, __pyx_L3_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_zlib); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 442, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_decompress); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 441, __pyx_L3_error)
+      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_decompress); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 442, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_6, function);
         }
       }
       __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_5, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_data);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 441, __pyx_L3_error)
+      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 442, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 441, __pyx_L3_error)
+      __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 442, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_INCREF(__pyx_v_meta);
       __Pyx_GIVEREF(__pyx_v_meta);
       PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_meta);
       __Pyx_GIVEREF(__pyx_t_4);
       PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_4);
       __pyx_t_4 = 0;
       __pyx_r = __pyx_t_6;
       __pyx_t_6 = 0;
       goto __pyx_L7_try_return;
 
-      /* "borg/compress.pyx":440
+      /* "borg/compress.pyx":441
  *     def decompress(self, meta, data):
  *         # note: for compatibility no super call, do not strip ID bytes
  *         try:             # <<<<<<<<<<<<<<
  *             return meta, zlib.decompress(data)
  *         except zlib.error as e:
  */
     }
     __pyx_L3_error:;
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-    /* "borg/compress.pyx":442
+    /* "borg/compress.pyx":443
  *         try:
  *             return meta, zlib.decompress(data)
  *         except zlib.error as e:             # <<<<<<<<<<<<<<
  *             raise DecompressionError(str(e)) from None
  * 
  */
     __Pyx_ErrFetch(&__pyx_t_6, &__pyx_t_4, &__pyx_t_5);
-    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_zlib); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 442, __pyx_L5_except_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_zlib); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 443, __pyx_L5_except_error)
     __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_error); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 442, __pyx_L5_except_error)
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_error); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 443, __pyx_L5_except_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __pyx_t_9 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_6, __pyx_t_8);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_ErrRestore(__pyx_t_6, __pyx_t_4, __pyx_t_5);
     __pyx_t_6 = 0; __pyx_t_4 = 0; __pyx_t_5 = 0;
     if (__pyx_t_9) {
       __Pyx_AddTraceback("borg.compress.ZLIB_legacy.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_4, &__pyx_t_6) < 0) __PYX_ERR(0, 442, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_4, &__pyx_t_6) < 0) __PYX_ERR(0, 443, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_INCREF(__pyx_t_4);
       __pyx_v_e = __pyx_t_4;
       /*try:*/ {
 
-        /* "borg/compress.pyx":443
+        /* "borg/compress.pyx":444
  *             return meta, zlib.decompress(data)
  *         except zlib.error as e:
  *             raise DecompressionError(str(e)) from None             # <<<<<<<<<<<<<<
  * 
  * 
  */
-        __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 443, __pyx_L14_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 444, __pyx_L14_error)
         __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_10 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_e); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 443, __pyx_L14_error)
+        __pyx_t_10 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyString_Type)), __pyx_v_e); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 444, __pyx_L14_error)
         __Pyx_GOTREF(__pyx_t_10);
         __pyx_t_11 = NULL;
         if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
           __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_7);
           if (likely(__pyx_t_11)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
             __Pyx_INCREF(__pyx_t_11);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_7, function);
           }
         }
         __pyx_t_8 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_11, __pyx_t_10) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_10);
         __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
         __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-        if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 443, __pyx_L14_error)
+        if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 444, __pyx_L14_error)
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_Raise(__pyx_t_8, 0, 0, Py_None);
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-        __PYX_ERR(0, 443, __pyx_L14_error)
+        __PYX_ERR(0, 444, __pyx_L14_error)
       }
 
-      /* "borg/compress.pyx":442
+      /* "borg/compress.pyx":443
  *         try:
  *             return meta, zlib.decompress(data)
  *         except zlib.error as e:             # <<<<<<<<<<<<<<
  *             raise DecompressionError(str(e)) from None
  * 
  */
       /*finally:*/ {
@@ -11287,15 +11309,15 @@
           goto __pyx_L5_except_error;
         }
       }
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "borg/compress.pyx":440
+    /* "borg/compress.pyx":441
  *     def decompress(self, meta, data):
  *         # note: for compatibility no super call, do not strip ID bytes
  *         try:             # <<<<<<<<<<<<<<
  *             return meta, zlib.decompress(data)
  *         except zlib.error as e:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
@@ -11307,15 +11329,15 @@
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":438
+  /* "borg/compress.pyx":439
  *         return None, zlib.compress(data, self.level)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         # note: for compatibility no super call, do not strip ID bytes
  *         try:
  */
 
@@ -11333,15 +11355,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_e);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":457
+/* "borg/compress.pyx":458
  *     name = 'auto'
  * 
  *     def __init__(self, compressor):             # <<<<<<<<<<<<<<
  *         super().__init__()
  *         self.compressor = compressor
  */
 
@@ -11376,32 +11398,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_compressor)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 457, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 458, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 457, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 458, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_compressor = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 457, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 458, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.Auto.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4Auto___init__(__pyx_self, __pyx_v_self, __pyx_v_compressor);
 
@@ -11417,65 +11439,65 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":458
+  /* "borg/compress.pyx":459
  * 
  *     def __init__(self, compressor):
  *         super().__init__()             # <<<<<<<<<<<<<<
  *         self.compressor = compressor
  * 
  */
   __pyx_t_2 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 458, __pyx_L1_error) }
+  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 459, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 458, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 459, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 458, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 459, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 458, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 459, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 458, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 459, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":459
+  /* "borg/compress.pyx":460
  *     def __init__(self, compressor):
  *         super().__init__()
  *         self.compressor = compressor             # <<<<<<<<<<<<<<
  * 
  *     def _decide(self, meta, data):
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_compressor, __pyx_v_compressor) < 0) __PYX_ERR(0, 459, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_compressor, __pyx_v_compressor) < 0) __PYX_ERR(0, 460, __pyx_L1_error)
 
-  /* "borg/compress.pyx":457
+  /* "borg/compress.pyx":458
  *     name = 'auto'
  * 
  *     def __init__(self, compressor):             # <<<<<<<<<<<<<<
  *         super().__init__()
  *         self.compressor = compressor
  */
 
@@ -11490,15 +11512,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":461
+/* "borg/compress.pyx":462
  *         self.compressor = compressor
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, compressed_data).
  */
 
@@ -11537,40 +11559,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 461, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 1); __PYX_ERR(0, 462, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 461, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, 2); __PYX_ERR(0, 462, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 461, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_decide") < 0)) __PYX_ERR(0, 462, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 461, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 462, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.Auto._decide", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4Auto_2_decide(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -11599,24 +11621,24 @@
   int __pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decide", 0);
   __Pyx_INCREF(__pyx_v_meta);
 
-  /* "borg/compress.pyx":484
+  /* "borg/compress.pyx":485
  *         to the LZ4 compressor.
  *         """
  *         compressor, (meta, compressed_data) = LZ4_COMPRESSOR.decide_compress(meta, data)             # <<<<<<<<<<<<<<
  *         # compressed_data includes the compression type header, while data does not yet
  *         ratio = len(compressed_data) / (len(data) + 2)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_LZ4_COMPRESSOR); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 484, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_LZ4_COMPRESSOR); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 485, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decide_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 484, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_decide_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 485, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -11626,239 +11648,239 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 484, __pyx_L1_error)
+      __PYX_ERR(0, 485, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_6 = Py_TYPE(__pyx_t_2)->tp_iternext;
     index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
     index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_5);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 484, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 485, __pyx_L1_error)
     __pyx_t_6 = NULL;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 484, __pyx_L1_error)
+    __PYX_ERR(0, 485, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __pyx_v_compressor = __pyx_t_3;
   __pyx_t_3 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
     PyObject* sequence = __pyx_t_5;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 484, __pyx_L1_error)
+      __PYX_ERR(0, 485, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_t_7);
     #else
-    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     #endif
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_8 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_8 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 485, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_6 = Py_TYPE(__pyx_t_8)->tp_iternext;
     index = 0; __pyx_t_2 = __pyx_t_6(__pyx_t_8); if (unlikely(!__pyx_t_2)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_2);
     index = 1; __pyx_t_7 = __pyx_t_6(__pyx_t_8); if (unlikely(!__pyx_t_7)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_7);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_8), 2) < 0) __PYX_ERR(0, 484, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_8), 2) < 0) __PYX_ERR(0, 485, __pyx_L1_error)
     __pyx_t_6 = NULL;
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     goto __pyx_L6_unpacking_done;
     __pyx_L5_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 484, __pyx_L1_error)
+    __PYX_ERR(0, 485, __pyx_L1_error)
     __pyx_L6_unpacking_done:;
   }
   __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_2);
   __pyx_t_2 = 0;
   __pyx_v_compressed_data = __pyx_t_7;
   __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":486
+  /* "borg/compress.pyx":487
  *         compressor, (meta, compressed_data) = LZ4_COMPRESSOR.decide_compress(meta, data)
  *         # compressed_data includes the compression type header, while data does not yet
  *         ratio = len(compressed_data) / (len(data) + 2)             # <<<<<<<<<<<<<<
  *         if ratio < 0.97:
  *             return self.compressor, (meta, compressed_data)
  */
-  __pyx_t_9 = PyObject_Length(__pyx_v_compressed_data); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 486, __pyx_L1_error)
-  __pyx_t_10 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_10 == ((Py_ssize_t)-1))) __PYX_ERR(0, 486, __pyx_L1_error)
+  __pyx_t_9 = PyObject_Length(__pyx_v_compressed_data); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 487, __pyx_L1_error)
+  __pyx_t_10 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_10 == ((Py_ssize_t)-1))) __PYX_ERR(0, 487, __pyx_L1_error)
   __pyx_t_11 = (__pyx_t_10 + 2);
   if (unlikely(__pyx_t_11 == 0)) {
     PyErr_SetString(PyExc_ZeroDivisionError, "float division");
-    __PYX_ERR(0, 486, __pyx_L1_error)
+    __PYX_ERR(0, 487, __pyx_L1_error)
   }
   __pyx_v_ratio = (((double)__pyx_t_9) / ((double)__pyx_t_11));
 
-  /* "borg/compress.pyx":487
+  /* "borg/compress.pyx":488
  *         # compressed_data includes the compression type header, while data does not yet
  *         ratio = len(compressed_data) / (len(data) + 2)
  *         if ratio < 0.97:             # <<<<<<<<<<<<<<
  *             return self.compressor, (meta, compressed_data)
  *         else:
  */
   __pyx_t_12 = ((__pyx_v_ratio < 0.97) != 0);
   if (__pyx_t_12) {
 
-    /* "borg/compress.pyx":488
+    /* "borg/compress.pyx":489
  *         ratio = len(compressed_data) / (len(data) + 2)
  *         if ratio < 0.97:
  *             return self.compressor, (meta, compressed_data)             # <<<<<<<<<<<<<<
  *         else:
  *             return compressor, (meta, compressed_data)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 488, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 489, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 488, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 489, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_compressed_data);
     __Pyx_GIVEREF(__pyx_v_compressed_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_compressed_data);
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 488, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 489, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_5);
     __pyx_t_1 = 0;
     __pyx_t_5 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":487
+    /* "borg/compress.pyx":488
  *         # compressed_data includes the compression type header, while data does not yet
  *         ratio = len(compressed_data) / (len(data) + 2)
  *         if ratio < 0.97:             # <<<<<<<<<<<<<<
  *             return self.compressor, (meta, compressed_data)
  *         else:
  */
   }
 
-  /* "borg/compress.pyx":490
+  /* "borg/compress.pyx":491
  *             return self.compressor, (meta, compressed_data)
  *         else:
  *             return compressor, (meta, compressed_data)             # <<<<<<<<<<<<<<
  * 
  *     def decide(self, meta, data):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 490, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 491, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_compressed_data);
     __Pyx_GIVEREF(__pyx_v_compressed_data);
     PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_compressed_data);
-    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 490, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 491, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_compressor);
     __Pyx_GIVEREF(__pyx_v_compressor);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_compressor);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_3);
     __pyx_t_3 = 0;
     __pyx_r = __pyx_t_5;
     __pyx_t_5 = 0;
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":461
+  /* "borg/compress.pyx":462
  *         self.compressor = compressor
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, compressed_data).
  */
 
@@ -11877,15 +11899,15 @@
   __Pyx_XDECREF(__pyx_v_compressed_data);
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":492
+/* "borg/compress.pyx":493
  *             return compressor, (meta, compressed_data)
  * 
  *     def decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self._decide(meta, data)[0]
  * 
  */
 
@@ -11923,40 +11945,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decide", 1, 3, 3, 1); __PYX_ERR(0, 492, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decide", 1, 3, 3, 1); __PYX_ERR(0, 493, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decide", 1, 3, 3, 2); __PYX_ERR(0, 492, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decide", 1, 3, 3, 2); __PYX_ERR(0, 493, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decide") < 0)) __PYX_ERR(0, 492, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decide") < 0)) __PYX_ERR(0, 493, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 492, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decide", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 493, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.Auto.decide", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4Auto_4decide(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -11974,23 +11996,23 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decide", 0);
 
-  /* "borg/compress.pyx":493
+  /* "borg/compress.pyx":494
  * 
  *     def decide(self, meta, data):
  *         return self._decide(meta, data)[0]             # <<<<<<<<<<<<<<
  * 
  *     def compress(self, meta, data):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_decide); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 493, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_decide); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 494, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -11999,52 +12021,52 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 493, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 494, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 493, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 494, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 493, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 494, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_3) {
       __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 493, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 494, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 493, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 494, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":492
+  /* "borg/compress.pyx":493
  *             return compressor, (meta, compressed_data)
  * 
  *     def decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self._decide(meta, data)[0]
  * 
  */
 
@@ -12058,15 +12080,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":495
+/* "borg/compress.pyx":496
  *         return self._decide(meta, data)[0]
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":
  */
 
@@ -12104,53 +12126,53 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 495, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 496, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 495, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 496, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 495, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 496, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 495, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 496, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.Auto.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4Auto_6compress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":496
+/* "borg/compress.pyx":497
  * 
  *     def compress(self, meta, data):
  *         def get_meta(from_meta, to_meta):             # <<<<<<<<<<<<<<
  *             for key in "ctype", "clevel", "csize":
  *                 if key in from_meta:
  */
 
@@ -12185,32 +12207,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_from_meta)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_to_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("get_meta", 1, 2, 2, 1); __PYX_ERR(0, 496, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("get_meta", 1, 2, 2, 1); __PYX_ERR(0, 497, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_meta") < 0)) __PYX_ERR(0, 496, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_meta") < 0)) __PYX_ERR(0, 497, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_from_meta = values[0];
     __pyx_v_to_meta = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("get_meta", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 496, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("get_meta", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 497, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.Auto.compress.get_meta", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4Auto_8compress_get_meta(__pyx_self, __pyx_v_from_meta, __pyx_v_to_meta);
 
@@ -12229,76 +12251,76 @@
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_meta", 0);
 
-  /* "borg/compress.pyx":497
+  /* "borg/compress.pyx":498
  *     def compress(self, meta, data):
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":             # <<<<<<<<<<<<<<
  *                 if key in from_meta:
  *                     to_meta[key] = from_meta[key]
  */
   __pyx_t_1 = __pyx_tuple__5; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_2 >= 3) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 497, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 498, __pyx_L1_error)
     #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 497, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 498, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     __Pyx_XDECREF_SET(__pyx_v_key, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "borg/compress.pyx":498
+    /* "borg/compress.pyx":499
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":
  *                 if key in from_meta:             # <<<<<<<<<<<<<<
  *                     to_meta[key] = from_meta[key]
  * 
  */
-    __pyx_t_4 = (__Pyx_PySequence_ContainsTF(__pyx_v_key, __pyx_v_from_meta, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 498, __pyx_L1_error)
+    __pyx_t_4 = (__Pyx_PySequence_ContainsTF(__pyx_v_key, __pyx_v_from_meta, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 499, __pyx_L1_error)
     __pyx_t_5 = (__pyx_t_4 != 0);
     if (__pyx_t_5) {
 
-      /* "borg/compress.pyx":499
+      /* "borg/compress.pyx":500
  *             for key in "ctype", "clevel", "csize":
  *                 if key in from_meta:
  *                     to_meta[key] = from_meta[key]             # <<<<<<<<<<<<<<
  * 
  *         compressor, (cheap_meta, cheap_compressed_data) = self._decide(dict(meta), data)
  */
-      __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_from_meta, __pyx_v_key); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 499, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_from_meta, __pyx_v_key); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 500, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      if (unlikely(PyObject_SetItem(__pyx_v_to_meta, __pyx_v_key, __pyx_t_3) < 0)) __PYX_ERR(0, 499, __pyx_L1_error)
+      if (unlikely(PyObject_SetItem(__pyx_v_to_meta, __pyx_v_key, __pyx_t_3) < 0)) __PYX_ERR(0, 500, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-      /* "borg/compress.pyx":498
+      /* "borg/compress.pyx":499
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":
  *                 if key in from_meta:             # <<<<<<<<<<<<<<
  *                     to_meta[key] = from_meta[key]
  * 
  */
     }
 
-    /* "borg/compress.pyx":497
+    /* "borg/compress.pyx":498
  *     def compress(self, meta, data):
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":             # <<<<<<<<<<<<<<
  *                 if key in from_meta:
  *                     to_meta[key] = from_meta[key]
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":496
+  /* "borg/compress.pyx":497
  * 
  *     def compress(self, meta, data):
  *         def get_meta(from_meta, to_meta):             # <<<<<<<<<<<<<<
  *             for key in "ctype", "clevel", "csize":
  *                 if key in from_meta:
  */
 
@@ -12313,15 +12335,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_key);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":495
+/* "borg/compress.pyx":496
  *         return self._decide(meta, data)[0]
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":
  */
 
@@ -12348,36 +12370,36 @@
   Py_ssize_t __pyx_t_11;
   Py_ssize_t __pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
 
-  /* "borg/compress.pyx":496
+  /* "borg/compress.pyx":497
  * 
  *     def compress(self, meta, data):
  *         def get_meta(from_meta, to_meta):             # <<<<<<<<<<<<<<
  *             for key in "ctype", "clevel", "csize":
  *                 if key in from_meta:
  */
-  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_8compress_1get_meta, 0, __pyx_n_s_Auto_compress_locals_get_meta, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__7)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 496, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_8compress_1get_meta, 0, __pyx_n_s_Auto_compress_locals_get_meta, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__7)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 497, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_get_meta = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":501
+  /* "borg/compress.pyx":502
  *                     to_meta[key] = from_meta[key]
  * 
  *         compressor, (cheap_meta, cheap_compressed_data) = self._decide(dict(meta), data)             # <<<<<<<<<<<<<<
  *         if compressor in (LZ4_COMPRESSOR, NONE_COMPRESSOR):
  *             # we know that trying to compress with expensive compressor is likely pointless,
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_decide); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 501, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_decide); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyDict_Type)), __pyx_v_meta); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 501, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyDict_Type)), __pyx_v_meta); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 502, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -12386,227 +12408,227 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_3, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_3, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_t_3);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_data);
     __pyx_t_3 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 501, __pyx_L1_error)
+      __PYX_ERR(0, 502, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_t_6);
     #else
-    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_7 = Py_TYPE(__pyx_t_3)->tp_iternext;
     index = 0; __pyx_t_2 = __pyx_t_7(__pyx_t_3); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_2);
     index = 1; __pyx_t_6 = __pyx_t_7(__pyx_t_3); if (unlikely(!__pyx_t_6)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_6);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_3), 2) < 0) __PYX_ERR(0, 501, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_3), 2) < 0) __PYX_ERR(0, 502, __pyx_L1_error)
     __pyx_t_7 = NULL;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_7 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 501, __pyx_L1_error)
+    __PYX_ERR(0, 502, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __pyx_v_compressor = __pyx_t_2;
   __pyx_t_2 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_6))) || (PyList_CheckExact(__pyx_t_6))) {
     PyObject* sequence = __pyx_t_6;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 501, __pyx_L1_error)
+      __PYX_ERR(0, 502, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_4 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_t_4);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     #endif
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_8 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 501, __pyx_L1_error)
+    __pyx_t_8 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 502, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __pyx_t_7 = Py_TYPE(__pyx_t_8)->tp_iternext;
     index = 0; __pyx_t_3 = __pyx_t_7(__pyx_t_8); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
     index = 1; __pyx_t_4 = __pyx_t_7(__pyx_t_8); if (unlikely(!__pyx_t_4)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_4);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_8), 2) < 0) __PYX_ERR(0, 501, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_8), 2) < 0) __PYX_ERR(0, 502, __pyx_L1_error)
     __pyx_t_7 = NULL;
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     goto __pyx_L6_unpacking_done;
     __pyx_L5_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __pyx_t_7 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 501, __pyx_L1_error)
+    __PYX_ERR(0, 502, __pyx_L1_error)
     __pyx_L6_unpacking_done:;
   }
   __pyx_v_cheap_meta = __pyx_t_3;
   __pyx_t_3 = 0;
   __pyx_v_cheap_compressed_data = __pyx_t_4;
   __pyx_t_4 = 0;
 
-  /* "borg/compress.pyx":502
+  /* "borg/compress.pyx":503
  * 
  *         compressor, (cheap_meta, cheap_compressed_data) = self._decide(dict(meta), data)
  *         if compressor in (LZ4_COMPRESSOR, NONE_COMPRESSOR):             # <<<<<<<<<<<<<<
  *             # we know that trying to compress with expensive compressor is likely pointless,
  *             # so we fallback to return the cheap compressed data.
  */
   __Pyx_INCREF(__pyx_v_compressor);
   __pyx_t_1 = __pyx_v_compressor;
-  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_LZ4_COMPRESSOR); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 502, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_LZ4_COMPRESSOR); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 503, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_2 = PyObject_RichCompare(__pyx_t_1, __pyx_t_6, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
+  __pyx_t_2 = PyObject_RichCompare(__pyx_t_1, __pyx_t_6, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 503, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 502, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 503, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (!__pyx_t_10) {
   } else {
     __pyx_t_9 = __pyx_t_10;
     goto __pyx_L8_bool_binop_done;
   }
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_NONE_COMPRESSOR); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 503, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_6 = PyObject_RichCompare(__pyx_t_1, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 502, __pyx_L1_error)
+  __pyx_t_6 = PyObject_RichCompare(__pyx_t_1, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 503, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 502, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 503, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __pyx_t_9 = __pyx_t_10;
   __pyx_L8_bool_binop_done:;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_10 = (__pyx_t_9 != 0);
   if (__pyx_t_10) {
 
-    /* "borg/compress.pyx":505
+    /* "borg/compress.pyx":506
  *             # we know that trying to compress with expensive compressor is likely pointless,
  *             # so we fallback to return the cheap compressed data.
  *             get_meta(cheap_meta, meta)             # <<<<<<<<<<<<<<
  *             return meta, cheap_compressed_data
  *         # if we get here, the decider decided to try the expensive compressor.
  */
-    __pyx_t_1 = __pyx_pf_4borg_8compress_4Auto_8compress_get_meta(__pyx_v_get_meta, __pyx_v_cheap_meta, __pyx_v_meta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 505, __pyx_L1_error)
+    __pyx_t_1 = __pyx_pf_4borg_8compress_4Auto_8compress_get_meta(__pyx_v_get_meta, __pyx_v_cheap_meta, __pyx_v_meta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 506, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":506
+    /* "borg/compress.pyx":507
  *             # so we fallback to return the cheap compressed data.
  *             get_meta(cheap_meta, meta)
  *             return meta, cheap_compressed_data             # <<<<<<<<<<<<<<
  *         # if we get here, the decider decided to try the expensive compressor.
  *         # we also know that the compressed data returned by the decider is lz4 compressed.
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 506, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 507, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_cheap_compressed_data);
     __Pyx_GIVEREF(__pyx_v_cheap_compressed_data);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_cheap_compressed_data);
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":502
+    /* "borg/compress.pyx":503
  * 
  *         compressor, (cheap_meta, cheap_compressed_data) = self._decide(dict(meta), data)
  *         if compressor in (LZ4_COMPRESSOR, NONE_COMPRESSOR):             # <<<<<<<<<<<<<<
  *             # we know that trying to compress with expensive compressor is likely pointless,
  *             # so we fallback to return the cheap compressed data.
  */
   }
 
-  /* "borg/compress.pyx":509
+  /* "borg/compress.pyx":510
  *         # if we get here, the decider decided to try the expensive compressor.
  *         # we also know that the compressed data returned by the decider is lz4 compressed.
  *         expensive_meta, expensive_compressed_data = compressor.compress(dict(meta), data)             # <<<<<<<<<<<<<<
  *         ratio = len(expensive_compressed_data) / len(cheap_compressed_data)
  *         if ratio < 0.99:
  */
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_compressor, __pyx_n_s_compress); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 509, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_compressor, __pyx_n_s_compress); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 510, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyDict_Type)), __pyx_v_meta); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 509, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyDict_Type)), __pyx_v_meta); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 510, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_6);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
@@ -12615,196 +12637,196 @@
       __Pyx_DECREF_SET(__pyx_t_6, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_6)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_2, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 509, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_2, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 509, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   {
-    __pyx_t_3 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 509, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_5, __pyx_t_2);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_5, __pyx_v_data);
     __pyx_t_2 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 509, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 509, __pyx_L1_error)
+      __PYX_ERR(0, 510, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_6 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_6 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_6);
     __Pyx_INCREF(__pyx_t_3);
     #else
-    __pyx_t_6 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 509, __pyx_L1_error)
+    __pyx_t_6 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 509, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 509, __pyx_L1_error)
+    __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 510, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_7 = Py_TYPE(__pyx_t_2)->tp_iternext;
     index = 0; __pyx_t_6 = __pyx_t_7(__pyx_t_2); if (unlikely(!__pyx_t_6)) goto __pyx_L10_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_6);
     index = 1; __pyx_t_3 = __pyx_t_7(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L10_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_2), 2) < 0) __PYX_ERR(0, 509, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_2), 2) < 0) __PYX_ERR(0, 510, __pyx_L1_error)
     __pyx_t_7 = NULL;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     goto __pyx_L11_unpacking_done;
     __pyx_L10_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_7 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 509, __pyx_L1_error)
+    __PYX_ERR(0, 510, __pyx_L1_error)
     __pyx_L11_unpacking_done:;
   }
   __pyx_v_expensive_meta = __pyx_t_6;
   __pyx_t_6 = 0;
   __pyx_v_expensive_compressed_data = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":510
+  /* "borg/compress.pyx":511
  *         # we also know that the compressed data returned by the decider is lz4 compressed.
  *         expensive_meta, expensive_compressed_data = compressor.compress(dict(meta), data)
  *         ratio = len(expensive_compressed_data) / len(cheap_compressed_data)             # <<<<<<<<<<<<<<
  *         if ratio < 0.99:
  *             # the expensive compressor managed to squeeze the data significantly better than lz4.
  */
-  __pyx_t_11 = PyObject_Length(__pyx_v_expensive_compressed_data); if (unlikely(__pyx_t_11 == ((Py_ssize_t)-1))) __PYX_ERR(0, 510, __pyx_L1_error)
-  __pyx_t_12 = PyObject_Length(__pyx_v_cheap_compressed_data); if (unlikely(__pyx_t_12 == ((Py_ssize_t)-1))) __PYX_ERR(0, 510, __pyx_L1_error)
+  __pyx_t_11 = PyObject_Length(__pyx_v_expensive_compressed_data); if (unlikely(__pyx_t_11 == ((Py_ssize_t)-1))) __PYX_ERR(0, 511, __pyx_L1_error)
+  __pyx_t_12 = PyObject_Length(__pyx_v_cheap_compressed_data); if (unlikely(__pyx_t_12 == ((Py_ssize_t)-1))) __PYX_ERR(0, 511, __pyx_L1_error)
   if (unlikely(__pyx_t_12 == 0)) {
     PyErr_SetString(PyExc_ZeroDivisionError, "float division");
-    __PYX_ERR(0, 510, __pyx_L1_error)
+    __PYX_ERR(0, 511, __pyx_L1_error)
   }
   __pyx_v_ratio = (((double)__pyx_t_11) / ((double)__pyx_t_12));
 
-  /* "borg/compress.pyx":511
+  /* "borg/compress.pyx":512
  *         expensive_meta, expensive_compressed_data = compressor.compress(dict(meta), data)
  *         ratio = len(expensive_compressed_data) / len(cheap_compressed_data)
  *         if ratio < 0.99:             # <<<<<<<<<<<<<<
  *             # the expensive compressor managed to squeeze the data significantly better than lz4.
  *             get_meta(expensive_meta, meta)
  */
   __pyx_t_10 = ((__pyx_v_ratio < 0.99) != 0);
   if (__pyx_t_10) {
 
-    /* "borg/compress.pyx":513
+    /* "borg/compress.pyx":514
  *         if ratio < 0.99:
  *             # the expensive compressor managed to squeeze the data significantly better than lz4.
  *             get_meta(expensive_meta, meta)             # <<<<<<<<<<<<<<
  *             return meta, expensive_compressed_data
  *         else:
  */
-    __pyx_t_1 = __pyx_pf_4borg_8compress_4Auto_8compress_get_meta(__pyx_v_get_meta, __pyx_v_expensive_meta, __pyx_v_meta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 513, __pyx_L1_error)
+    __pyx_t_1 = __pyx_pf_4borg_8compress_4Auto_8compress_get_meta(__pyx_v_get_meta, __pyx_v_expensive_meta, __pyx_v_meta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 514, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":514
+    /* "borg/compress.pyx":515
  *             # the expensive compressor managed to squeeze the data significantly better than lz4.
  *             get_meta(expensive_meta, meta)
  *             return meta, expensive_compressed_data             # <<<<<<<<<<<<<<
  *         else:
  *             # otherwise let's just store the lz4 data, which decompresses extremely fast.
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 514, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 515, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_expensive_compressed_data);
     __Pyx_GIVEREF(__pyx_v_expensive_compressed_data);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_expensive_compressed_data);
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":511
+    /* "borg/compress.pyx":512
  *         expensive_meta, expensive_compressed_data = compressor.compress(dict(meta), data)
  *         ratio = len(expensive_compressed_data) / len(cheap_compressed_data)
  *         if ratio < 0.99:             # <<<<<<<<<<<<<<
  *             # the expensive compressor managed to squeeze the data significantly better than lz4.
  *             get_meta(expensive_meta, meta)
  */
   }
 
-  /* "borg/compress.pyx":517
+  /* "borg/compress.pyx":518
  *         else:
  *             # otherwise let's just store the lz4 data, which decompresses extremely fast.
  *             get_meta(cheap_meta, meta)             # <<<<<<<<<<<<<<
  *             return meta, cheap_compressed_data
  * 
  */
   /*else*/ {
-    __pyx_t_1 = __pyx_pf_4borg_8compress_4Auto_8compress_get_meta(__pyx_v_get_meta, __pyx_v_cheap_meta, __pyx_v_meta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 517, __pyx_L1_error)
+    __pyx_t_1 = __pyx_pf_4borg_8compress_4Auto_8compress_get_meta(__pyx_v_get_meta, __pyx_v_cheap_meta, __pyx_v_meta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 518, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":518
+    /* "borg/compress.pyx":519
  *             # otherwise let's just store the lz4 data, which decompresses extremely fast.
  *             get_meta(cheap_meta, meta)
  *             return meta, cheap_compressed_data             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, data):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 518, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 519, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_cheap_compressed_data);
     __Pyx_GIVEREF(__pyx_v_cheap_compressed_data);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_cheap_compressed_data);
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
   }
 
-  /* "borg/compress.pyx":495
+  /* "borg/compress.pyx":496
  *         return self._decide(meta, data)[0]
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":
  */
 
@@ -12826,15 +12848,15 @@
   __Pyx_XDECREF(__pyx_v_expensive_meta);
   __Pyx_XDECREF(__pyx_v_expensive_compressed_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":520
+/* "borg/compress.pyx":521
  *             return meta, cheap_compressed_data
  * 
  *     def decompress(self, data):             # <<<<<<<<<<<<<<
  *         raise NotImplementedError
  * 
  */
 
@@ -12869,32 +12891,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 2, 2, 1); __PYX_ERR(0, 520, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 2, 2, 1); __PYX_ERR(0, 521, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 520, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 521, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 520, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 521, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.Auto.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4Auto_8decompress(__pyx_self, __pyx_v_self, __pyx_v_data);
 
@@ -12907,25 +12929,25 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
 
-  /* "borg/compress.pyx":521
+  /* "borg/compress.pyx":522
  * 
  *     def decompress(self, data):
  *         raise NotImplementedError             # <<<<<<<<<<<<<<
  * 
  *     def detect(cls, data):
  */
   __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
-  __PYX_ERR(0, 521, __pyx_L1_error)
+  __PYX_ERR(0, 522, __pyx_L1_error)
 
-  /* "borg/compress.pyx":520
+  /* "borg/compress.pyx":521
  *             return meta, cheap_compressed_data
  * 
  *     def decompress(self, data):             # <<<<<<<<<<<<<<
  *         raise NotImplementedError
  * 
  */
 
@@ -12934,15 +12956,15 @@
   __Pyx_AddTraceback("borg.compress.Auto.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":523
+/* "borg/compress.pyx":524
  *         raise NotImplementedError
  * 
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         raise NotImplementedError
  * 
  */
 
@@ -12977,32 +12999,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("detect", 1, 2, 2, 1); __PYX_ERR(0, 523, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("detect", 1, 2, 2, 1); __PYX_ERR(0, 524, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "detect") < 0)) __PYX_ERR(0, 523, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "detect") < 0)) __PYX_ERR(0, 524, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_cls = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("detect", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 523, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("detect", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 524, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.Auto.detect", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_4Auto_10detect(__pyx_self, __pyx_v_cls, __pyx_v_data);
 
@@ -13015,25 +13037,25 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("detect", 0);
 
-  /* "borg/compress.pyx":524
+  /* "borg/compress.pyx":525
  * 
  *     def detect(cls, data):
  *         raise NotImplementedError             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
-  __PYX_ERR(0, 524, __pyx_L1_error)
+  __PYX_ERR(0, 525, __pyx_L1_error)
 
-  /* "borg/compress.pyx":523
+  /* "borg/compress.pyx":524
  *         raise NotImplementedError
  * 
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         raise NotImplementedError
  * 
  */
 
@@ -13042,15 +13064,15 @@
   __Pyx_AddTraceback("borg.compress.Auto.detect", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":537
+/* "borg/compress.pyx":538
  *     header_len = len(header_fmt.pack(0))
  * 
  *     def __init__(self, level=None, compressor=None, legacy_mode=False):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode)  # data will be encrypted, so we can tell the level
  *         self.compressor = compressor
  */
 
@@ -13110,15 +13132,15 @@
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_legacy_mode);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 537, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 538, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -13132,15 +13154,15 @@
     __pyx_v_self = values[0];
     __pyx_v_level = values[1];
     __pyx_v_compressor = values[2];
     __pyx_v_legacy_mode = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 537, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 538, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ObfuscateSize.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_13ObfuscateSize___init__(__pyx_self, __pyx_v_self, __pyx_v_level, __pyx_v_compressor, __pyx_v_legacy_mode);
 
@@ -13158,195 +13180,195 @@
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":538
+  /* "borg/compress.pyx":539
  * 
  *     def __init__(self, level=None, compressor=None, legacy_mode=False):
  *         super().__init__(level=level, legacy_mode=legacy_mode)  # data will be encrypted, so we can tell the level             # <<<<<<<<<<<<<<
  *         self.compressor = compressor
  *         self.level = level
  */
   __pyx_t_1 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 538, __pyx_L1_error) }
+  if (!__pyx_t_1) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 539, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 538, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 539, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 538, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 539, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 538, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 539, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 538, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 539, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 538, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 538, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 538, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 539, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_legacy_mode, __pyx_v_legacy_mode) < 0) __PYX_ERR(0, 539, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 539, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/compress.pyx":539
+  /* "borg/compress.pyx":540
  *     def __init__(self, level=None, compressor=None, legacy_mode=False):
  *         super().__init__(level=level, legacy_mode=legacy_mode)  # data will be encrypted, so we can tell the level
  *         self.compressor = compressor             # <<<<<<<<<<<<<<
  *         self.level = level
  *         if level is None:
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_compressor, __pyx_v_compressor) < 0) __PYX_ERR(0, 539, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_compressor, __pyx_v_compressor) < 0) __PYX_ERR(0, 540, __pyx_L1_error)
 
-  /* "borg/compress.pyx":540
+  /* "borg/compress.pyx":541
  *         super().__init__(level=level, legacy_mode=legacy_mode)  # data will be encrypted, so we can tell the level
  *         self.compressor = compressor
  *         self.level = level             # <<<<<<<<<<<<<<
  *         if level is None:
  *             pass  # decompression
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 540, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 541, __pyx_L1_error)
 
-  /* "borg/compress.pyx":541
+  /* "borg/compress.pyx":542
  *         self.compressor = compressor
  *         self.level = level
  *         if level is None:             # <<<<<<<<<<<<<<
  *             pass  # decompression
  *         elif 1 <= level <= 6:
  */
   __pyx_t_4 = (__pyx_v_level == Py_None);
   __pyx_t_5 = (__pyx_t_4 != 0);
   if (__pyx_t_5) {
     goto __pyx_L3;
   }
 
-  /* "borg/compress.pyx":543
+  /* "borg/compress.pyx":544
  *         if level is None:
  *             pass  # decompression
  *         elif 1 <= level <= 6:             # <<<<<<<<<<<<<<
  *             self._obfuscate = self._relative_random_reciprocal_obfuscate
  *             self.factor = 0.001 * 10 ** level
  */
-  __pyx_t_3 = PyObject_RichCompare(__pyx_int_1, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 543, __pyx_L1_error)
+  __pyx_t_3 = PyObject_RichCompare(__pyx_int_1, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 544, __pyx_L1_error)
   if (__Pyx_PyObject_IsTrue(__pyx_t_3)) {
     __Pyx_DECREF(__pyx_t_3);
-    __pyx_t_3 = PyObject_RichCompare(__pyx_v_level, __pyx_int_6, Py_LE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 543, __pyx_L1_error)
+    __pyx_t_3 = PyObject_RichCompare(__pyx_v_level, __pyx_int_6, Py_LE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 544, __pyx_L1_error)
   }
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 543, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 544, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__pyx_t_5) {
 
-    /* "borg/compress.pyx":544
+    /* "borg/compress.pyx":545
  *             pass  # decompression
  *         elif 1 <= level <= 6:
  *             self._obfuscate = self._relative_random_reciprocal_obfuscate             # <<<<<<<<<<<<<<
  *             self.factor = 0.001 * 10 ** level
  *             self.min_r = 0.0001
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_relative_random_reciprocal_obfu); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 544, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_relative_random_reciprocal_obfu); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 545, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_obfuscate, __pyx_t_3) < 0) __PYX_ERR(0, 544, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_obfuscate, __pyx_t_3) < 0) __PYX_ERR(0, 545, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/compress.pyx":545
+    /* "borg/compress.pyx":546
  *         elif 1 <= level <= 6:
  *             self._obfuscate = self._relative_random_reciprocal_obfuscate
  *             self.factor = 0.001 * 10 ** level             # <<<<<<<<<<<<<<
  *             self.min_r = 0.0001
  *         elif 110 <= level <= 123:
  */
-    __pyx_t_3 = PyNumber_Power(__pyx_int_10, __pyx_v_level, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 545, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Power(__pyx_int_10, __pyx_v_level, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 546, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 = PyNumber_Multiply(__pyx_float_0_001, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 545, __pyx_L1_error)
+    __pyx_t_1 = PyNumber_Multiply(__pyx_float_0_001, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 546, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_factor, __pyx_t_1) < 0) __PYX_ERR(0, 545, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_factor, __pyx_t_1) < 0) __PYX_ERR(0, 546, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":546
+    /* "borg/compress.pyx":547
  *             self._obfuscate = self._relative_random_reciprocal_obfuscate
  *             self.factor = 0.001 * 10 ** level
  *             self.min_r = 0.0001             # <<<<<<<<<<<<<<
  *         elif 110 <= level <= 123:
  *             self._obfuscate = self._random_padding_obfuscate
  */
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_min_r, __pyx_float_0_0001) < 0) __PYX_ERR(0, 546, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_min_r, __pyx_float_0_0001) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
 
-    /* "borg/compress.pyx":543
+    /* "borg/compress.pyx":544
  *         if level is None:
  *             pass  # decompression
  *         elif 1 <= level <= 6:             # <<<<<<<<<<<<<<
  *             self._obfuscate = self._relative_random_reciprocal_obfuscate
  *             self.factor = 0.001 * 10 ** level
  */
     goto __pyx_L3;
   }
 
-  /* "borg/compress.pyx":547
+  /* "borg/compress.pyx":548
  *             self.factor = 0.001 * 10 ** level
  *             self.min_r = 0.0001
  *         elif 110 <= level <= 123:             # <<<<<<<<<<<<<<
  *             self._obfuscate = self._random_padding_obfuscate
  *             self.max_padding_size = 2 ** (level - 100)  # 1kiB .. 8MiB
  */
-  __pyx_t_1 = PyObject_RichCompare(__pyx_int_110, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 547, __pyx_L1_error)
+  __pyx_t_1 = PyObject_RichCompare(__pyx_int_110, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 548, __pyx_L1_error)
   if (__Pyx_PyObject_IsTrue(__pyx_t_1)) {
     __Pyx_DECREF(__pyx_t_1);
-    __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_123, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 547, __pyx_L1_error)
+    __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_123, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 548, __pyx_L1_error)
   }
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 547, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 548, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if (__pyx_t_5) {
 
-    /* "borg/compress.pyx":548
+    /* "borg/compress.pyx":549
  *             self.min_r = 0.0001
  *         elif 110 <= level <= 123:
  *             self._obfuscate = self._random_padding_obfuscate             # <<<<<<<<<<<<<<
  *             self.max_padding_size = 2 ** (level - 100)  # 1kiB .. 8MiB
  * 
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_random_padding_obfuscate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 548, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_random_padding_obfuscate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 549, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_obfuscate, __pyx_t_1) < 0) __PYX_ERR(0, 548, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_obfuscate, __pyx_t_1) < 0) __PYX_ERR(0, 549, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/compress.pyx":549
+    /* "borg/compress.pyx":550
  *         elif 110 <= level <= 123:
  *             self._obfuscate = self._random_padding_obfuscate
  *             self.max_padding_size = 2 ** (level - 100)  # 1kiB .. 8MiB             # <<<<<<<<<<<<<<
  * 
  *     def _obfuscate(self, compr_size):
  */
-    __pyx_t_1 = __Pyx_PyInt_SubtractObjC(__pyx_v_level, __pyx_int_100, 0x64, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 549, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyInt_SubtractObjC(__pyx_v_level, __pyx_int_100, 0x64, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 550, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyNumber_PowerOf2(__pyx_int_2, __pyx_t_1, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 549, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyNumber_PowerOf2(__pyx_int_2, __pyx_t_1, Py_None); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 550, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_max_padding_size, __pyx_t_3) < 0) __PYX_ERR(0, 549, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_max_padding_size, __pyx_t_3) < 0) __PYX_ERR(0, 550, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/compress.pyx":547
+    /* "borg/compress.pyx":548
  *             self.factor = 0.001 * 10 ** level
  *             self.min_r = 0.0001
  *         elif 110 <= level <= 123:             # <<<<<<<<<<<<<<
  *             self._obfuscate = self._random_padding_obfuscate
  *             self.max_padding_size = 2 ** (level - 100)  # 1kiB .. 8MiB
  */
   }
   __pyx_L3:;
 
-  /* "borg/compress.pyx":537
+  /* "borg/compress.pyx":538
  *     header_len = len(header_fmt.pack(0))
  * 
  *     def __init__(self, level=None, compressor=None, legacy_mode=False):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode)  # data will be encrypted, so we can tell the level
  *         self.compressor = compressor
  */
 
@@ -13361,15 +13383,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":551
+/* "borg/compress.pyx":552
  *             self.max_padding_size = 2 ** (level - 100)  # 1kiB .. 8MiB
  * 
  *     def _obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         # implementations need to return the size of obfuscation data,
  *         # that the caller shall add.
  */
 
@@ -13404,32 +13426,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_compr_size)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_obfuscate", 1, 2, 2, 1); __PYX_ERR(0, 551, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_obfuscate", 1, 2, 2, 1); __PYX_ERR(0, 552, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_obfuscate") < 0)) __PYX_ERR(0, 551, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_obfuscate") < 0)) __PYX_ERR(0, 552, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_compr_size = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_obfuscate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 551, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_obfuscate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 552, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ObfuscateSize._obfuscate", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_13ObfuscateSize_2_obfuscate(__pyx_self, __pyx_v_self, __pyx_v_compr_size);
 
@@ -13442,25 +13464,25 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_obfuscate", 0);
 
-  /* "borg/compress.pyx":554
+  /* "borg/compress.pyx":555
  *         # implementations need to return the size of obfuscation data,
  *         # that the caller shall add.
  *         raise NotImplemented             # <<<<<<<<<<<<<<
  * 
  *     def _relative_random_reciprocal_obfuscate(self, compr_size):
  */
   __Pyx_Raise(__pyx_builtin_NotImplemented, 0, 0, 0);
-  __PYX_ERR(0, 554, __pyx_L1_error)
+  __PYX_ERR(0, 555, __pyx_L1_error)
 
-  /* "borg/compress.pyx":551
+  /* "borg/compress.pyx":552
  *             self.max_padding_size = 2 ** (level - 100)  # 1kiB .. 8MiB
  * 
  *     def _obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         # implementations need to return the size of obfuscation data,
  *         # that the caller shall add.
  */
 
@@ -13469,15 +13491,15 @@
   __Pyx_AddTraceback("borg.compress.ObfuscateSize._obfuscate", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":556
+/* "borg/compress.pyx":557
  *         raise NotImplemented
  * 
  *     def _relative_random_reciprocal_obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         # effect for SPEC 1:
  *         # f = 0.01 .. 0.1 for r in 1.0 .. 0.1 == in 90% of cases
  */
 
@@ -13512,32 +13534,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_compr_size)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_relative_random_reciprocal_obfuscate", 1, 2, 2, 1); __PYX_ERR(0, 556, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_relative_random_reciprocal_obfuscate", 1, 2, 2, 1); __PYX_ERR(0, 557, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_relative_random_reciprocal_obfuscate") < 0)) __PYX_ERR(0, 556, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_relative_random_reciprocal_obfuscate") < 0)) __PYX_ERR(0, 557, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_compr_size = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_relative_random_reciprocal_obfuscate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 556, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_relative_random_reciprocal_obfuscate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 557, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ObfuscateSize._relative_random_reciprocal_obfuscate", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_13ObfuscateSize_4_relative_random_reciprocal_obfuscate(__pyx_self, __pyx_v_self, __pyx_v_compr_size);
 
@@ -13557,45 +13579,45 @@
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_relative_random_reciprocal_obfuscate", 0);
 
-  /* "borg/compress.pyx":562
+  /* "borg/compress.pyx":563
  *         # f = 1.0 .. 10.0 for r in 0.01 .. 0.001 = in 0.9% of cases
  *         # f = 10.0 .. 100.0 for r in 0.001 .. 0.0001 == in 0.09% of cases
  *         r = max(self.min_r, random.random())  # 0..1, but don't get too close to 0             # <<<<<<<<<<<<<<
  *         f = self.factor / r
  *         return int(compr_size * f)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_random); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 562, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_random); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 563, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_random); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 562, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_random); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 563, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 562, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 563, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_min_r); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 562, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_min_r); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 563, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyObject_RichCompare(__pyx_t_1, __pyx_t_3, Py_GT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 562, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 562, __pyx_L1_error)
+  __pyx_t_4 = PyObject_RichCompare(__pyx_t_1, __pyx_t_3, Py_GT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 563, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 563, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   if (__pyx_t_5) {
     __Pyx_INCREF(__pyx_t_1);
     __pyx_t_2 = __pyx_t_1;
   } else {
     __Pyx_INCREF(__pyx_t_3);
     __pyx_t_2 = __pyx_t_3;
@@ -13604,47 +13626,47 @@
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __pyx_t_2;
   __Pyx_INCREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_r = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":563
+  /* "borg/compress.pyx":564
  *         # f = 10.0 .. 100.0 for r in 0.001 .. 0.0001 == in 0.09% of cases
  *         r = max(self.min_r, random.random())  # 0..1, but don't get too close to 0
  *         f = self.factor / r             # <<<<<<<<<<<<<<
  *         return int(compr_size * f)
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_factor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 563, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_factor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyNumber_Divide(__pyx_t_1, __pyx_v_r); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 563, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyNumber_Divide(__pyx_t_1, __pyx_v_r); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 564, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_f = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/compress.pyx":564
+  /* "borg/compress.pyx":565
  *         r = max(self.min_r, random.random())  # 0..1, but don't get too close to 0
  *         f = self.factor / r
  *         return int(compr_size * f)             # <<<<<<<<<<<<<<
  * 
  *     def _random_padding_obfuscate(self, compr_size):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = PyNumber_Multiply(__pyx_v_compr_size, __pyx_v_f); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 564, __pyx_L1_error)
+  __pyx_t_2 = PyNumber_Multiply(__pyx_v_compr_size, __pyx_v_f); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 565, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 564, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 565, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":556
+  /* "borg/compress.pyx":557
  *         raise NotImplemented
  * 
  *     def _relative_random_reciprocal_obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         # effect for SPEC 1:
  *         # f = 0.01 .. 0.1 for r in 1.0 .. 0.1 == in 90% of cases
  */
 
@@ -13660,15 +13682,15 @@
   __Pyx_XDECREF(__pyx_v_r);
   __Pyx_XDECREF(__pyx_v_f);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":566
+/* "borg/compress.pyx":567
  *         return int(compr_size * f)
  * 
  *     def _random_padding_obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         return int(self.max_padding_size * random.random())
  * 
  */
 
@@ -13703,32 +13725,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_compr_size)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_random_padding_obfuscate", 1, 2, 2, 1); __PYX_ERR(0, 566, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_random_padding_obfuscate", 1, 2, 2, 1); __PYX_ERR(0, 567, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_random_padding_obfuscate") < 0)) __PYX_ERR(0, 566, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_random_padding_obfuscate") < 0)) __PYX_ERR(0, 567, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_compr_size = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_random_padding_obfuscate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 566, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_random_padding_obfuscate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 567, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ObfuscateSize._random_padding_obfuscate", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_13ObfuscateSize_6_random_padding_obfuscate(__pyx_self, __pyx_v_self, __pyx_v_compr_size);
 
@@ -13745,56 +13767,56 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_random_padding_obfuscate", 0);
 
-  /* "borg/compress.pyx":567
+  /* "borg/compress.pyx":568
  * 
  *     def _random_padding_obfuscate(self, compr_size):
  *         return int(self.max_padding_size * random.random())             # <<<<<<<<<<<<<<
  * 
  *     def compress(self, meta, data):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_max_padding_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 567, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_max_padding_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 568, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_random); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 567, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_random); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 568, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_random); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 567, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_random); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 568, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 567, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 568, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 567, __pyx_L1_error)
+  __pyx_t_4 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 568, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 567, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 568, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":566
+  /* "borg/compress.pyx":567
  *         return int(compr_size * f)
  * 
  *     def _random_padding_obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         return int(self.max_padding_size * random.random())
  * 
  */
 
@@ -13808,15 +13830,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":569
+/* "borg/compress.pyx":570
  *         return int(self.max_padding_size * random.random())
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         assert not self.legacy_mode  # we never call this in legacy mode
  *         meta, compressed_data = self.compressor.compress(meta, data)  # compress data
  */
 
@@ -13854,40 +13876,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 569, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 570, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 569, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 570, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 569, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 570, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 569, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 570, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ObfuscateSize.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_13ObfuscateSize_8compress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -13915,44 +13937,44 @@
   long __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
   __Pyx_INCREF(__pyx_v_meta);
 
-  /* "borg/compress.pyx":570
+  /* "borg/compress.pyx":571
  * 
  *     def compress(self, meta, data):
  *         assert not self.legacy_mode  # we never call this in legacy mode             # <<<<<<<<<<<<<<
  *         meta, compressed_data = self.compressor.compress(meta, data)  # compress data
  *         compr_size = len(compressed_data)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 570, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 571, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 570, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 571, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     if (unlikely(!((!__pyx_t_2) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 570, __pyx_L1_error)
+      __PYX_ERR(0, 571, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/compress.pyx":571
+  /* "borg/compress.pyx":572
  *     def compress(self, meta, data):
  *         assert not self.legacy_mode  # we never call this in legacy mode
  *         meta, compressed_data = self.compressor.compress(meta, data)  # compress data             # <<<<<<<<<<<<<<
  *         compr_size = len(compressed_data)
  *         assert "csize" in meta, repr(meta)
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 571, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_compress); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 571, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_compress); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 572, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_3)) {
@@ -13962,221 +13984,221 @@
       __Pyx_DECREF_SET(__pyx_t_4, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 571, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 572, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 571, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 572, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 571, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_3) {
       __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 571, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 571, __pyx_L1_error)
+      __PYX_ERR(0, 572, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_4 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_t_6);
     #else
-    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 571, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 571, __pyx_L1_error)
+    __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 571, __pyx_L1_error)
+    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 572, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_7 = Py_TYPE(__pyx_t_3)->tp_iternext;
     index = 0; __pyx_t_4 = __pyx_t_7(__pyx_t_3); if (unlikely(!__pyx_t_4)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_4);
     index = 1; __pyx_t_6 = __pyx_t_7(__pyx_t_3); if (unlikely(!__pyx_t_6)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_6);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_3), 2) < 0) __PYX_ERR(0, 571, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_3), 2) < 0) __PYX_ERR(0, 572, __pyx_L1_error)
     __pyx_t_7 = NULL;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_7 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 571, __pyx_L1_error)
+    __PYX_ERR(0, 572, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_4);
   __pyx_t_4 = 0;
   __pyx_v_compressed_data = __pyx_t_6;
   __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":572
+  /* "borg/compress.pyx":573
  *         assert not self.legacy_mode  # we never call this in legacy mode
  *         meta, compressed_data = self.compressor.compress(meta, data)  # compress data
  *         compr_size = len(compressed_data)             # <<<<<<<<<<<<<<
  *         assert "csize" in meta, repr(meta)
  *         meta["psize"] = meta["csize"]  # psize (payload size) is the csize (compressed size) of the inner compressor
  */
-  __pyx_t_8 = PyObject_Length(__pyx_v_compressed_data); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 572, __pyx_L1_error)
-  __pyx_t_1 = PyInt_FromSsize_t(__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 572, __pyx_L1_error)
+  __pyx_t_8 = PyObject_Length(__pyx_v_compressed_data); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 573, __pyx_L1_error)
+  __pyx_t_1 = PyInt_FromSsize_t(__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 573, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_compr_size = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":573
+  /* "borg/compress.pyx":574
  *         meta, compressed_data = self.compressor.compress(meta, data)  # compress data
  *         compr_size = len(compressed_data)
  *         assert "csize" in meta, repr(meta)             # <<<<<<<<<<<<<<
  *         meta["psize"] = meta["csize"]  # psize (payload size) is the csize (compressed size) of the inner compressor
  *         addtl_size = self._obfuscate(compr_size)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
-    __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_csize, __pyx_v_meta, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 573, __pyx_L1_error)
+    __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_csize, __pyx_v_meta, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 574, __pyx_L1_error)
     if (unlikely(!(__pyx_t_2 != 0))) {
-      __pyx_t_1 = PyObject_Repr(__pyx_v_meta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 573, __pyx_L1_error)
+      __pyx_t_1 = PyObject_Repr(__pyx_v_meta); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 574, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_6 = PyTuple_Pack(1, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 573, __pyx_L1_error)
+      __pyx_t_6 = PyTuple_Pack(1, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 574, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       PyErr_SetObject(PyExc_AssertionError, __pyx_t_6);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __PYX_ERR(0, 573, __pyx_L1_error)
+      __PYX_ERR(0, 574, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/compress.pyx":574
+  /* "borg/compress.pyx":575
  *         compr_size = len(compressed_data)
  *         assert "csize" in meta, repr(meta)
  *         meta["psize"] = meta["csize"]  # psize (payload size) is the csize (compressed size) of the inner compressor             # <<<<<<<<<<<<<<
  *         addtl_size = self._obfuscate(compr_size)
  *         addtl_size = max(0, addtl_size)  # we can only make it longer, not shorter!
  */
-  __pyx_t_6 = __Pyx_PyObject_Dict_GetItem(__pyx_v_meta, __pyx_n_s_csize); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 574, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_Dict_GetItem(__pyx_v_meta, __pyx_n_s_csize); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 575, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_psize, __pyx_t_6) < 0)) __PYX_ERR(0, 574, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_psize, __pyx_t_6) < 0)) __PYX_ERR(0, 575, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":575
+  /* "borg/compress.pyx":576
  *         assert "csize" in meta, repr(meta)
  *         meta["psize"] = meta["csize"]  # psize (payload size) is the csize (compressed size) of the inner compressor
  *         addtl_size = self._obfuscate(compr_size)             # <<<<<<<<<<<<<<
  *         addtl_size = max(0, addtl_size)  # we can only make it longer, not shorter!
  *         addtl_size = min(MAX_DATA_SIZE - 1024 - compr_size, addtl_size)  # stay away from MAX_DATA_SIZE
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_obfuscate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 575, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_obfuscate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 576, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_1);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_1, function);
     }
   }
   __pyx_t_6 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_4, __pyx_v_compr_size) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_compr_size);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 575, __pyx_L1_error)
+  if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 576, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_addtl_size = __pyx_t_6;
   __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":576
+  /* "borg/compress.pyx":577
  *         meta["psize"] = meta["csize"]  # psize (payload size) is the csize (compressed size) of the inner compressor
  *         addtl_size = self._obfuscate(compr_size)
  *         addtl_size = max(0, addtl_size)  # we can only make it longer, not shorter!             # <<<<<<<<<<<<<<
  *         addtl_size = min(MAX_DATA_SIZE - 1024 - compr_size, addtl_size)  # stay away from MAX_DATA_SIZE
  *         trailer = bytes(addtl_size)
  */
   __Pyx_INCREF(__pyx_v_addtl_size);
   __pyx_t_6 = __pyx_v_addtl_size;
   __pyx_t_9 = 0;
-  __pyx_t_4 = __Pyx_PyInt_From_long(__pyx_t_9); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 576, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_From_long(__pyx_t_9); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 577, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_3 = PyObject_RichCompare(__pyx_t_6, __pyx_t_4, Py_GT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 576, __pyx_L1_error)
+  __pyx_t_3 = PyObject_RichCompare(__pyx_t_6, __pyx_t_4, Py_GT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 577, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 576, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 577, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__pyx_t_2) {
     __Pyx_INCREF(__pyx_t_6);
     __pyx_t_1 = __pyx_t_6;
   } else {
-    __pyx_t_3 = __Pyx_PyInt_From_long(__pyx_t_9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 576, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_From_long(__pyx_t_9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 577, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_1 = __pyx_t_3;
     __pyx_t_3 = 0;
   }
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __pyx_t_6 = __pyx_t_1;
   __Pyx_INCREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF_SET(__pyx_v_addtl_size, __pyx_t_6);
   __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":577
+  /* "borg/compress.pyx":578
  *         addtl_size = self._obfuscate(compr_size)
  *         addtl_size = max(0, addtl_size)  # we can only make it longer, not shorter!
  *         addtl_size = min(MAX_DATA_SIZE - 1024 - compr_size, addtl_size)  # stay away from MAX_DATA_SIZE             # <<<<<<<<<<<<<<
  *         trailer = bytes(addtl_size)
  *         obfuscated_data = compressed_data + trailer
  */
   __Pyx_INCREF(__pyx_v_addtl_size);
   __pyx_t_6 = __pyx_v_addtl_size;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_MAX_DATA_SIZE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 577, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_MAX_DATA_SIZE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 578, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyInt_SubtractObjC(__pyx_t_1, __pyx_int_1024, 0x400, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 577, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_SubtractObjC(__pyx_t_1, __pyx_int_1024, 0x400, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 578, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyNumber_Subtract(__pyx_t_3, __pyx_v_compr_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 577, __pyx_L1_error)
+  __pyx_t_1 = PyNumber_Subtract(__pyx_t_3, __pyx_v_compr_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 578, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_4 = PyObject_RichCompare(__pyx_t_6, __pyx_t_1, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 577, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 577, __pyx_L1_error)
+  __pyx_t_4 = PyObject_RichCompare(__pyx_t_6, __pyx_t_1, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 578, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 578, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   if (__pyx_t_2) {
     __Pyx_INCREF(__pyx_t_6);
     __pyx_t_3 = __pyx_t_6;
   } else {
     __Pyx_INCREF(__pyx_t_1);
     __pyx_t_3 = __pyx_t_1;
@@ -14185,84 +14207,84 @@
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __pyx_t_6 = __pyx_t_3;
   __Pyx_INCREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_addtl_size, __pyx_t_6);
   __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":578
+  /* "borg/compress.pyx":579
  *         addtl_size = max(0, addtl_size)  # we can only make it longer, not shorter!
  *         addtl_size = min(MAX_DATA_SIZE - 1024 - compr_size, addtl_size)  # stay away from MAX_DATA_SIZE
  *         trailer = bytes(addtl_size)             # <<<<<<<<<<<<<<
  *         obfuscated_data = compressed_data + trailer
  *         meta["csize"] = len(obfuscated_data)  # csize is the overall output size of this "obfuscation compressor"
  */
-  __pyx_t_6 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_addtl_size); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 578, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_addtl_size); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __pyx_v_trailer = ((PyObject*)__pyx_t_6);
   __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":579
+  /* "borg/compress.pyx":580
  *         addtl_size = min(MAX_DATA_SIZE - 1024 - compr_size, addtl_size)  # stay away from MAX_DATA_SIZE
  *         trailer = bytes(addtl_size)
  *         obfuscated_data = compressed_data + trailer             # <<<<<<<<<<<<<<
  *         meta["csize"] = len(obfuscated_data)  # csize is the overall output size of this "obfuscation compressor"
  *         meta["olevel"] = self.level  # remember the obfuscation level, useful for rcompress
  */
-  __pyx_t_6 = PyNumber_Add(__pyx_v_compressed_data, __pyx_v_trailer); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 579, __pyx_L1_error)
+  __pyx_t_6 = PyNumber_Add(__pyx_v_compressed_data, __pyx_v_trailer); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 580, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __pyx_v_obfuscated_data = __pyx_t_6;
   __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":580
+  /* "borg/compress.pyx":581
  *         trailer = bytes(addtl_size)
  *         obfuscated_data = compressed_data + trailer
  *         meta["csize"] = len(obfuscated_data)  # csize is the overall output size of this "obfuscation compressor"             # <<<<<<<<<<<<<<
  *         meta["olevel"] = self.level  # remember the obfuscation level, useful for rcompress
  *         return meta, obfuscated_data  # for borg2 it is enough that we have the payload size in meta["psize"]
  */
-  __pyx_t_8 = PyObject_Length(__pyx_v_obfuscated_data); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 580, __pyx_L1_error)
-  __pyx_t_6 = PyInt_FromSsize_t(__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 580, __pyx_L1_error)
+  __pyx_t_8 = PyObject_Length(__pyx_v_obfuscated_data); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 581, __pyx_L1_error)
+  __pyx_t_6 = PyInt_FromSsize_t(__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 581, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_csize, __pyx_t_6) < 0)) __PYX_ERR(0, 580, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_csize, __pyx_t_6) < 0)) __PYX_ERR(0, 581, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":581
+  /* "borg/compress.pyx":582
  *         obfuscated_data = compressed_data + trailer
  *         meta["csize"] = len(obfuscated_data)  # csize is the overall output size of this "obfuscation compressor"
  *         meta["olevel"] = self.level  # remember the obfuscation level, useful for rcompress             # <<<<<<<<<<<<<<
  *         return meta, obfuscated_data  # for borg2 it is enough that we have the payload size in meta["psize"]
  * 
  */
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 581, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 582, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_olevel, __pyx_t_6) < 0)) __PYX_ERR(0, 581, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_v_meta, __pyx_n_s_olevel, __pyx_t_6) < 0)) __PYX_ERR(0, 582, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":582
+  /* "borg/compress.pyx":583
  *         meta["csize"] = len(obfuscated_data)  # csize is the overall output size of this "obfuscation compressor"
  *         meta["olevel"] = self.level  # remember the obfuscation level, useful for rcompress
  *         return meta, obfuscated_data  # for borg2 it is enough that we have the payload size in meta["psize"]             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, meta, data):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 582, __pyx_L1_error)
+  __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 583, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_INCREF(__pyx_v_meta);
   __Pyx_GIVEREF(__pyx_v_meta);
   PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_meta);
   __Pyx_INCREF(__pyx_v_obfuscated_data);
   __Pyx_GIVEREF(__pyx_v_obfuscated_data);
   PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_v_obfuscated_data);
   __pyx_r = __pyx_t_6;
   __pyx_t_6 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":569
+  /* "borg/compress.pyx":570
  *         return int(self.max_padding_size * random.random())
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         assert not self.legacy_mode  # we never call this in legacy mode
  *         meta, compressed_data = self.compressor.compress(meta, data)  # compress data
  */
 
@@ -14282,15 +14304,15 @@
   __Pyx_XDECREF(__pyx_v_obfuscated_data);
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":584
+/* "borg/compress.pyx":585
  *         return meta, obfuscated_data  # for borg2 it is enough that we have the payload size in meta["psize"]
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         assert self.legacy_mode  # borg2 never dispatches to this, only used for legacy mode
  *         meta, obfuscated_data = super().decompress(meta, data)  # remove obfuscator ID header
  */
 
@@ -14328,40 +14350,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 584, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 585, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 584, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 585, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 584, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 585, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 584, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 585, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.ObfuscateSize.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_13ObfuscateSize_10decompress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -14387,56 +14409,56 @@
   int __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
   __Pyx_INCREF(__pyx_v_meta);
 
-  /* "borg/compress.pyx":585
+  /* "borg/compress.pyx":586
  * 
  *     def decompress(self, meta, data):
  *         assert self.legacy_mode  # borg2 never dispatches to this, only used for legacy mode             # <<<<<<<<<<<<<<
  *         meta, obfuscated_data = super().decompress(meta, data)  # remove obfuscator ID header
  *         compr_size = self.header_fmt.unpack(obfuscated_data[0:self.header_len])[0]
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 585, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 586, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 585, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 586, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     if (unlikely(!__pyx_t_2)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 585, __pyx_L1_error)
+      __PYX_ERR(0, 586, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/compress.pyx":586
+  /* "borg/compress.pyx":587
  *     def decompress(self, meta, data):
  *         assert self.legacy_mode  # borg2 never dispatches to this, only used for legacy mode
  *         meta, obfuscated_data = super().decompress(meta, data)  # remove obfuscator ID header             # <<<<<<<<<<<<<<
  *         compr_size = self.header_fmt.unpack(obfuscated_data[0:self.header_len])[0]
  *         compressed_data = obfuscated_data[self.header_len:self.header_len+compr_size]
  */
   __pyx_t_3 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_3) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 586, __pyx_L1_error) }
+  if (!__pyx_t_3) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 587, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_3);
-  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 586, __pyx_L1_error)
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
   PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_self);
   __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 586, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_decompress); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 586, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_decompress); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_3)) {
@@ -14446,110 +14468,110 @@
       __Pyx_DECREF_SET(__pyx_t_4, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 587, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 587, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 587, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_3) {
       __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 587, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 586, __pyx_L1_error)
+      __PYX_ERR(0, 587, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
       __pyx_t_4 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
     }
     __Pyx_INCREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_t_6);
     #else
-    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 587, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 587, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 587, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_7 = Py_TYPE(__pyx_t_3)->tp_iternext;
     index = 0; __pyx_t_4 = __pyx_t_7(__pyx_t_3); if (unlikely(!__pyx_t_4)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_4);
     index = 1; __pyx_t_6 = __pyx_t_7(__pyx_t_3); if (unlikely(!__pyx_t_6)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_6);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_3), 2) < 0) __PYX_ERR(0, 586, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_3), 2) < 0) __PYX_ERR(0, 587, __pyx_L1_error)
     __pyx_t_7 = NULL;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_7 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 586, __pyx_L1_error)
+    __PYX_ERR(0, 587, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
   __Pyx_DECREF_SET(__pyx_v_meta, __pyx_t_4);
   __pyx_t_4 = 0;
   __pyx_v_obfuscated_data = __pyx_t_6;
   __pyx_t_6 = 0;
 
-  /* "borg/compress.pyx":587
+  /* "borg/compress.pyx":588
  *         assert self.legacy_mode  # borg2 never dispatches to this, only used for legacy mode
  *         meta, obfuscated_data = super().decompress(meta, data)  # remove obfuscator ID header
  *         compr_size = self.header_fmt.unpack(obfuscated_data[0:self.header_len])[0]             # <<<<<<<<<<<<<<
  *         compressed_data = obfuscated_data[self.header_len:self.header_len+compr_size]
  *         if self.compressor is None:
  */
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_fmt); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 587, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_fmt); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 588, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_unpack); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 587, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_unpack); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 588, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_len); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 587, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_len); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 588, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_3 = __Pyx_PyObject_GetSlice(__pyx_v_obfuscated_data, 0, 0, NULL, &__pyx_t_6, NULL, 1, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 587, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetSlice(__pyx_v_obfuscated_data, 0, 0, NULL, &__pyx_t_6, NULL, 1, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 588, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __pyx_t_6 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_6)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
@@ -14557,92 +14579,92 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_6, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
   __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 587, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 588, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 587, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 588, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_compr_size = __pyx_t_4;
   __pyx_t_4 = 0;
 
-  /* "borg/compress.pyx":588
+  /* "borg/compress.pyx":589
  *         meta, obfuscated_data = super().decompress(meta, data)  # remove obfuscator ID header
  *         compr_size = self.header_fmt.unpack(obfuscated_data[0:self.header_len])[0]
  *         compressed_data = obfuscated_data[self.header_len:self.header_len+compr_size]             # <<<<<<<<<<<<<<
  *         if self.compressor is None:
  *             compressor_cls = Compressor.detect(compressed_data)[0]
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_len); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 588, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_len); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 589, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_len); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 588, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_len); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 589, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_v_compr_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 588, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_v_compr_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 589, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_obfuscated_data, 0, 0, &__pyx_t_4, &__pyx_t_3, NULL, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 588, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_obfuscated_data, 0, 0, &__pyx_t_4, &__pyx_t_3, NULL, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 589, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_compressed_data = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":589
+  /* "borg/compress.pyx":590
  *         compr_size = self.header_fmt.unpack(obfuscated_data[0:self.header_len])[0]
  *         compressed_data = obfuscated_data[self.header_len:self.header_len+compr_size]
  *         if self.compressor is None:             # <<<<<<<<<<<<<<
  *             compressor_cls = Compressor.detect(compressed_data)[0]
  *             self.compressor = compressor_cls()
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 589, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 590, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_2 = (__pyx_t_1 == Py_None);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_8 = (__pyx_t_2 != 0);
   if (__pyx_t_8) {
 
-    /* "borg/compress.pyx":590
+    /* "borg/compress.pyx":591
  *         compressed_data = obfuscated_data[self.header_len:self.header_len+compr_size]
  *         if self.compressor is None:
  *             compressor_cls = Compressor.detect(compressed_data)[0]             # <<<<<<<<<<<<<<
  *             self.compressor = compressor_cls()
  *         return self.compressor.decompress(meta, compressed_data)  # decompress data
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Compressor); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 590, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Compressor); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 591, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_detect); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 590, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_detect); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 591, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_3 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_compressed_data) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_compressed_data);
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 590, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 591, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 590, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 591, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_v_compressor_cls = __pyx_t_4;
     __pyx_t_4 = 0;
 
-    /* "borg/compress.pyx":591
+    /* "borg/compress.pyx":592
  *         if self.compressor is None:
  *             compressor_cls = Compressor.detect(compressed_data)[0]
  *             self.compressor = compressor_cls()             # <<<<<<<<<<<<<<
  *         return self.compressor.decompress(meta, compressed_data)  # decompress data
  * 
  */
     __Pyx_INCREF(__pyx_v_compressor_cls);
@@ -14654,40 +14676,40 @@
         __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_1, function);
       }
     }
     __pyx_t_4 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 591, __pyx_L1_error)
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 592, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_compressor, __pyx_t_4) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_compressor, __pyx_t_4) < 0) __PYX_ERR(0, 592, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "borg/compress.pyx":589
+    /* "borg/compress.pyx":590
  *         compr_size = self.header_fmt.unpack(obfuscated_data[0:self.header_len])[0]
  *         compressed_data = obfuscated_data[self.header_len:self.header_len+compr_size]
  *         if self.compressor is None:             # <<<<<<<<<<<<<<
  *             compressor_cls = Compressor.detect(compressed_data)[0]
  *             self.compressor = compressor_cls()
  */
   }
 
-  /* "borg/compress.pyx":592
+  /* "borg/compress.pyx":593
  *             compressor_cls = Compressor.detect(compressed_data)[0]
  *             self.compressor = compressor_cls()
  *         return self.compressor.decompress(meta, compressed_data)  # decompress data             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 592, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 593, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 592, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_decompress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 593, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_1)) {
@@ -14697,49 +14719,49 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_meta, __pyx_v_compressed_data};
-    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 592, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 593, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_GOTREF(__pyx_t_4);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_meta, __pyx_v_compressed_data};
-    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 592, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 593, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_GOTREF(__pyx_t_4);
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 592, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 593, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_1) {
       __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1); __pyx_t_1 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_compressed_data);
     __Pyx_GIVEREF(__pyx_v_compressed_data);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_compressed_data);
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 592, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 593, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_4;
   __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":584
+  /* "borg/compress.pyx":585
  *         return meta, obfuscated_data  # for borg2 it is enough that we have the payload size in meta["psize"]
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         assert self.legacy_mode  # borg2 never dispatches to this, only used for legacy mode
  *         meta, obfuscated_data = super().decompress(meta, data)  # remove obfuscator ID header
  */
 
@@ -14758,15 +14780,15 @@
   __Pyx_XDECREF(__pyx_v_compressor_cls);
   __Pyx_XDECREF(__pyx_v_meta);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":609
+/* "borg/compress.pyx":610
  * COMPRESSOR_LIST = [LZ4, ZSTD, CNONE, ZLIB, ZLIB_legacy, LZMA, ObfuscateSize, ]  # check fast stuff first
  * 
  * def get_compressor(name, **kwargs):             # <<<<<<<<<<<<<<
  *     cls = COMPRESSOR_TABLE[name]
  *     return cls(**kwargs)
  */
 
@@ -14799,26 +14821,26 @@
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "get_compressor") < 0)) __PYX_ERR(0, 609, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "get_compressor") < 0)) __PYX_ERR(0, 610, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_name = values[0];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("get_compressor", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 609, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("get_compressor", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 610, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.get_compressor", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_get_compressor(__pyx_self, __pyx_v_name, __pyx_v_kwargs);
@@ -14836,47 +14858,47 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_compressor", 0);
 
-  /* "borg/compress.pyx":610
+  /* "borg/compress.pyx":611
  * 
  * def get_compressor(name, **kwargs):
  *     cls = COMPRESSOR_TABLE[name]             # <<<<<<<<<<<<<<
  *     return cls(**kwargs)
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_COMPRESSOR_TABLE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 610, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_COMPRESSOR_TABLE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 611, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 610, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 611, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_cls = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/compress.pyx":611
+  /* "borg/compress.pyx":612
  * def get_compressor(name, **kwargs):
  *     cls = COMPRESSOR_TABLE[name]
  *     return cls(**kwargs)             # <<<<<<<<<<<<<<
  * 
  * # compressor instances to be used by all other compressors
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = PyDict_Copy(__pyx_v_kwargs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 611, __pyx_L1_error)
+  __pyx_t_2 = PyDict_Copy(__pyx_v_kwargs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_v_cls, __pyx_empty_tuple, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 611, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_v_cls, __pyx_empty_tuple, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":609
+  /* "borg/compress.pyx":610
  * COMPRESSOR_LIST = [LZ4, ZSTD, CNONE, ZLIB, ZLIB_legacy, LZMA, ObfuscateSize, ]  # check fast stuff first
  * 
  * def get_compressor(name, **kwargs):             # <<<<<<<<<<<<<<
  *     cls = COMPRESSOR_TABLE[name]
  *     return cls(**kwargs)
  */
 
@@ -14889,15 +14911,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_cls);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":622
+/* "borg/compress.pyx":623
  *     decompresses everything we can handle (autodetect)
  *     """
  *     def __init__(self, name='null', **kwargs):             # <<<<<<<<<<<<<<
  *         self.params = kwargs
  *         self.compressor = get_compressor(name, **self.params)
  */
 
@@ -14940,15 +14962,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 622, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 623, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -14956,15 +14978,15 @@
       }
     }
     __pyx_v_self = values[0];
     __pyx_v_name = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 622, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 623, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
   __Pyx_AddTraceback("borg.compress.Compressor.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_10Compressor___init__(__pyx_self, __pyx_v_self, __pyx_v_name, __pyx_v_kwargs);
@@ -14983,61 +15005,61 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":623
+  /* "borg/compress.pyx":624
  *     """
  *     def __init__(self, name='null', **kwargs):
  *         self.params = kwargs             # <<<<<<<<<<<<<<
  *         self.compressor = get_compressor(name, **self.params)
  * 
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_params, __pyx_v_kwargs) < 0) __PYX_ERR(0, 623, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_params, __pyx_v_kwargs) < 0) __PYX_ERR(0, 624, __pyx_L1_error)
 
-  /* "borg/compress.pyx":624
+  /* "borg/compress.pyx":625
  *     def __init__(self, name='null', **kwargs):
  *         self.params = kwargs
  *         self.compressor = get_compressor(name, **self.params)             # <<<<<<<<<<<<<<
  * 
  *     def compress(self, meta, data):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 624, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 625, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 624, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 625, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_v_name);
   __Pyx_GIVEREF(__pyx_v_name);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_name);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_params); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 624, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_params); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 625, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   if (unlikely(__pyx_t_4 == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "argument after ** must be a mapping, not NoneType");
-    __PYX_ERR(0, 624, __pyx_L1_error)
+    __PYX_ERR(0, 625, __pyx_L1_error)
   }
   if (likely(PyDict_CheckExact(__pyx_t_4))) {
-    __pyx_t_3 = PyDict_Copy(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 624, __pyx_L1_error)
+    __pyx_t_3 = PyDict_Copy(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 625, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   } else {
-    __pyx_t_3 = PyObject_CallFunctionObjArgs((PyObject*)&PyDict_Type, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 624, __pyx_L1_error)
+    __pyx_t_3 = PyObject_CallFunctionObjArgs((PyObject*)&PyDict_Type, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 625, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 624, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 625, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_compressor, __pyx_t_4) < 0) __PYX_ERR(0, 624, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_compressor, __pyx_t_4) < 0) __PYX_ERR(0, 625, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "borg/compress.pyx":622
+  /* "borg/compress.pyx":623
  *     decompresses everything we can handle (autodetect)
  *     """
  *     def __init__(self, name='null', **kwargs):             # <<<<<<<<<<<<<<
  *         self.params = kwargs
  *         self.compressor = get_compressor(name, **self.params)
  */
 
@@ -15053,15 +15075,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":626
+/* "borg/compress.pyx":627
  *         self.compressor = get_compressor(name, **self.params)
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self.compressor.compress(meta, data)
  * 
  */
 
@@ -15099,40 +15121,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 626, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 1); __PYX_ERR(0, 627, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 626, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, 2); __PYX_ERR(0, 627, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 626, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 627, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 626, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("compress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 627, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.Compressor.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_10Compressor_2compress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -15150,25 +15172,25 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compress", 0);
 
-  /* "borg/compress.pyx":627
+  /* "borg/compress.pyx":628
  * 
  *     def compress(self, meta, data):
  *         return self.compressor.compress(meta, data)             # <<<<<<<<<<<<<<
  * 
  *     def decompress(self, meta, data):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 627, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 628, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 627, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_compress); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 628, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -15178,49 +15200,49 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 628, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 628, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 627, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 628, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 628, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":626
+  /* "borg/compress.pyx":627
  *         self.compressor = get_compressor(name, **self.params)
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self.compressor.compress(meta, data)
  * 
  */
 
@@ -15234,15 +15256,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":629
+/* "borg/compress.pyx":630
  *         return self.compressor.compress(meta, data)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         if self.compressor.legacy_mode:
  *             hdr = data[:2]
  */
 
@@ -15280,40 +15302,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_meta)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 629, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 1); __PYX_ERR(0, 630, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 629, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, 2); __PYX_ERR(0, 630, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 629, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decompress") < 0)) __PYX_ERR(0, 630, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_self = values[0];
     __pyx_v_meta = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 629, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decompress", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 630, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.Compressor.decompress", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_10Compressor_4decompress(__pyx_self, __pyx_v_self, __pyx_v_meta, __pyx_v_data);
 
@@ -15336,157 +15358,157 @@
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decompress", 0);
 
-  /* "borg/compress.pyx":630
+  /* "borg/compress.pyx":631
  * 
  *     def decompress(self, meta, data):
  *         if self.compressor.legacy_mode:             # <<<<<<<<<<<<<<
  *             hdr = data[:2]
  *         else:
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 630, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 631, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 630, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_legacy_mode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 631, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 630, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 631, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (__pyx_t_3) {
 
-    /* "borg/compress.pyx":631
+    /* "borg/compress.pyx":632
  *     def decompress(self, meta, data):
  *         if self.compressor.legacy_mode:
  *             hdr = data[:2]             # <<<<<<<<<<<<<<
  *         else:
  *             ctype = meta["ctype"]
  */
-    __pyx_t_2 = __Pyx_PyObject_GetSlice(__pyx_v_data, 0, 2, NULL, NULL, &__pyx_slice__4, 0, 1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 631, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetSlice(__pyx_v_data, 0, 2, NULL, NULL, &__pyx_slice__4, 0, 1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 632, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_v_hdr = __pyx_t_2;
     __pyx_t_2 = 0;
 
-    /* "borg/compress.pyx":630
+    /* "borg/compress.pyx":631
  * 
  *     def decompress(self, meta, data):
  *         if self.compressor.legacy_mode:             # <<<<<<<<<<<<<<
  *             hdr = data[:2]
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "borg/compress.pyx":633
+  /* "borg/compress.pyx":634
  *             hdr = data[:2]
  *         else:
  *             ctype = meta["ctype"]             # <<<<<<<<<<<<<<
  *             clevel = meta["clevel"]
  *             hdr = bytes((ctype, clevel))
  */
   /*else*/ {
-    __pyx_t_2 = __Pyx_PyObject_Dict_GetItem(__pyx_v_meta, __pyx_n_s_ctype); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 633, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Dict_GetItem(__pyx_v_meta, __pyx_n_s_ctype); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 634, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_v_ctype = __pyx_t_2;
     __pyx_t_2 = 0;
 
-    /* "borg/compress.pyx":634
+    /* "borg/compress.pyx":635
  *         else:
  *             ctype = meta["ctype"]
  *             clevel = meta["clevel"]             # <<<<<<<<<<<<<<
  *             hdr = bytes((ctype, clevel))
  *         compressor_cls = self.detect(hdr)[0]
  */
-    __pyx_t_2 = __Pyx_PyObject_Dict_GetItem(__pyx_v_meta, __pyx_n_s_clevel); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 634, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Dict_GetItem(__pyx_v_meta, __pyx_n_s_clevel); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 635, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_v_clevel = __pyx_t_2;
     __pyx_t_2 = 0;
 
-    /* "borg/compress.pyx":635
+    /* "borg/compress.pyx":636
  *             ctype = meta["ctype"]
  *             clevel = meta["clevel"]
  *             hdr = bytes((ctype, clevel))             # <<<<<<<<<<<<<<
  *         compressor_cls = self.detect(hdr)[0]
  *         return compressor_cls(**self.params).decompress(meta, data)
  */
-    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 635, __pyx_L1_error)
+    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 636, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_v_ctype);
     __Pyx_GIVEREF(__pyx_v_ctype);
     PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_ctype);
     __Pyx_INCREF(__pyx_v_clevel);
     __Pyx_GIVEREF(__pyx_v_clevel);
     PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_clevel);
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 635, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 636, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_v_hdr = __pyx_t_1;
     __pyx_t_1 = 0;
   }
   __pyx_L3:;
 
-  /* "borg/compress.pyx":636
+  /* "borg/compress.pyx":637
  *             clevel = meta["clevel"]
  *             hdr = bytes((ctype, clevel))
  *         compressor_cls = self.detect(hdr)[0]             # <<<<<<<<<<<<<<
  *         return compressor_cls(**self.params).decompress(meta, data)
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_detect); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 636, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_detect); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v_hdr) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_hdr);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 636, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 636, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_compressor_cls = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/compress.pyx":637
+  /* "borg/compress.pyx":638
  *             hdr = bytes((ctype, clevel))
  *         compressor_cls = self.detect(hdr)[0]
  *         return compressor_cls(**self.params).decompress(meta, data)             # <<<<<<<<<<<<<<
  * 
  *     @staticmethod
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_params); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 637, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_params); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 638, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   if (unlikely(__pyx_t_4 == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "argument after ** must be a mapping, not NoneType");
-    __PYX_ERR(0, 637, __pyx_L1_error)
+    __PYX_ERR(0, 638, __pyx_L1_error)
   }
   if (likely(PyDict_CheckExact(__pyx_t_4))) {
-    __pyx_t_1 = PyDict_Copy(__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
+    __pyx_t_1 = PyDict_Copy(__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   } else {
-    __pyx_t_1 = PyObject_CallFunctionObjArgs((PyObject*)&PyDict_Type, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
+    __pyx_t_1 = PyObject_CallFunctionObjArgs((PyObject*)&PyDict_Type, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_v_compressor_cls, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 637, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_v_compressor_cls, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 638, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_decompress); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_decompress); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_1);
     if (likely(__pyx_t_4)) {
@@ -15496,49 +15518,49 @@
       __Pyx_DECREF_SET(__pyx_t_1, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_1)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 638, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_meta, __pyx_v_data};
-    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 638, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 637, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 638, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_v_meta);
     __Pyx_GIVEREF(__pyx_v_meta);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_meta);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_data);
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 638, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/compress.pyx":629
+  /* "borg/compress.pyx":630
  *         return self.compressor.compress(meta, data)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         if self.compressor.legacy_mode:
  *             hdr = data[:2]
  */
 
@@ -15556,15 +15578,15 @@
   __Pyx_XDECREF(__pyx_v_clevel);
   __Pyx_XDECREF(__pyx_v_compressor_cls);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":640
+/* "borg/compress.pyx":641
  * 
  *     @staticmethod
  *     def detect(data):             # <<<<<<<<<<<<<<
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  */
 
@@ -15596,207 +15618,207 @@
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("detect", 0);
 
-  /* "borg/compress.pyx":641
+  /* "borg/compress.pyx":642
  *     @staticmethod
  *     def detect(data):
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview             # <<<<<<<<<<<<<<
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  *         for cls in COMPRESSOR_LIST:
  */
-  __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_data, 0, 2, NULL, NULL, &__pyx_slice__4, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 641, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_data, 0, 2, NULL, NULL, &__pyx_slice__4, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 642, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 641, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 642, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_hdr = ((PyObject*)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "borg/compress.pyx":642
+  /* "borg/compress.pyx":643
  *     def detect(data):
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview
  *         level = hdr[1]  # usually the level, but not for zlib_legacy             # <<<<<<<<<<<<<<
  *         for cls in COMPRESSOR_LIST:
  *             if cls.detect(hdr):
  */
-  __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_hdr, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 642, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_hdr, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 643, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_v_level = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/compress.pyx":643
+  /* "borg/compress.pyx":644
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  *         for cls in COMPRESSOR_LIST:             # <<<<<<<<<<<<<<
  *             if cls.detect(hdr):
  *                 return cls, (255 if cls.name == 'zlib_legacy' else level)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_COMPRESSOR_LIST); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 643, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_COMPRESSOR_LIST); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 644, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
     __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_3 = 0;
     __pyx_t_4 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 643, __pyx_L1_error)
+    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 644, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 643, __pyx_L1_error)
+    __pyx_t_4 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 644, __pyx_L1_error)
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   for (;;) {
     if (likely(!__pyx_t_4)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_2); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 643, __pyx_L1_error)
+        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_2); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 644, __pyx_L1_error)
         #else
-        __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 643, __pyx_L1_error)
+        __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 644, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_2); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 643, __pyx_L1_error)
+        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_2); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 644, __pyx_L1_error)
         #else
-        __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 643, __pyx_L1_error)
+        __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 644, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         #endif
       }
     } else {
       __pyx_t_2 = __pyx_t_4(__pyx_t_1);
       if (unlikely(!__pyx_t_2)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 643, __pyx_L1_error)
+          else __PYX_ERR(0, 644, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_2);
     }
     __Pyx_XDECREF_SET(__pyx_v_cls, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "borg/compress.pyx":644
+    /* "borg/compress.pyx":645
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  *         for cls in COMPRESSOR_LIST:
  *             if cls.detect(hdr):             # <<<<<<<<<<<<<<
  *                 return cls, (255 if cls.name == 'zlib_legacy' else level)
  *         else:
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_detect); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 644, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_detect); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 645, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_hdr) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_hdr);
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 644, __pyx_L1_error)
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 645, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 644, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 645, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     if (__pyx_t_7) {
 
-      /* "borg/compress.pyx":645
+      /* "borg/compress.pyx":646
  *         for cls in COMPRESSOR_LIST:
  *             if cls.detect(hdr):
  *                 return cls, (255 if cls.name == 'zlib_legacy' else level)             # <<<<<<<<<<<<<<
  *         else:
  *             raise ValueError('No decompressor for this data found: %r.', data[:2])
  */
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 645, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 646, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_7 = (__Pyx_PyString_Equals(__pyx_t_5, __pyx_n_s_zlib_legacy, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 645, __pyx_L1_error)
+      __pyx_t_7 = (__Pyx_PyString_Equals(__pyx_t_5, __pyx_n_s_zlib_legacy, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 646, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (__pyx_t_7) {
         __Pyx_INCREF(__pyx_int_255);
         __pyx_t_2 = __pyx_int_255;
       } else {
         __Pyx_INCREF(__pyx_v_level);
         __pyx_t_2 = __pyx_v_level;
       }
-      __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 645, __pyx_L1_error)
+      __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 646, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_INCREF(__pyx_v_cls);
       __Pyx_GIVEREF(__pyx_v_cls);
       PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_cls);
       __Pyx_GIVEREF(__pyx_t_2);
       PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
       __pyx_t_2 = 0;
       __pyx_r = __pyx_t_5;
       __pyx_t_5 = 0;
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       goto __pyx_L0;
 
-      /* "borg/compress.pyx":644
+      /* "borg/compress.pyx":645
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  *         for cls in COMPRESSOR_LIST:
  *             if cls.detect(hdr):             # <<<<<<<<<<<<<<
  *                 return cls, (255 if cls.name == 'zlib_legacy' else level)
  *         else:
  */
     }
 
-    /* "borg/compress.pyx":643
+    /* "borg/compress.pyx":644
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  *         for cls in COMPRESSOR_LIST:             # <<<<<<<<<<<<<<
  *             if cls.detect(hdr):
  *                 return cls, (255 if cls.name == 'zlib_legacy' else level)
  */
   }
   /*else*/ {
 
-    /* "borg/compress.pyx":647
+    /* "borg/compress.pyx":648
  *                 return cls, (255 if cls.name == 'zlib_legacy' else level)
  *         else:
  *             raise ValueError('No decompressor for this data found: %r.', data[:2])             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_5 = __Pyx_PyObject_GetSlice(__pyx_v_data, 0, 2, NULL, NULL, &__pyx_slice__4, 0, 1, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 647, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetSlice(__pyx_v_data, 0, 2, NULL, NULL, &__pyx_slice__4, 0, 1, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 648, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 647, __pyx_L1_error)
+    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 648, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_kp_s_No_decompressor_for_this_data_fo);
     __Pyx_GIVEREF(__pyx_kp_s_No_decompressor_for_this_data_fo);
     PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_s_No_decompressor_for_this_data_fo);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_5);
     __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_2, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 647, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_2, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 648, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_Raise(__pyx_t_5, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __PYX_ERR(0, 647, __pyx_L1_error)
+    __PYX_ERR(0, 648, __pyx_L1_error)
   }
 
-  /* "borg/compress.pyx":643
+  /* "borg/compress.pyx":644
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  *         for cls in COMPRESSOR_LIST:             # <<<<<<<<<<<<<<
  *             if cls.detect(hdr):
  *                 return cls, (255 if cls.name == 'zlib_legacy' else level)
  */
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":640
+  /* "borg/compress.pyx":641
  * 
  *     @staticmethod
  *     def detect(data):             # <<<<<<<<<<<<<<
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  */
 
@@ -15813,15 +15835,15 @@
   __Pyx_XDECREF(__pyx_v_level);
   __Pyx_XDECREF(__pyx_v_cls);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":651
+/* "borg/compress.pyx":652
  * 
  * class CompressionSpec:
  *     def __init__(self, s):             # <<<<<<<<<<<<<<
  *         values = s.split(',')
  *         count = len(values)
  */
 
@@ -15856,32 +15878,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_s)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 651, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 652, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 651, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 652, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_s = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 651, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 652, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.compress.CompressionSpec.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8compress_15CompressionSpec___init__(__pyx_self, __pyx_v_self, __pyx_v_s);
 
@@ -15904,734 +15926,896 @@
   int __pyx_t_5;
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/compress.pyx":652
+  /* "borg/compress.pyx":653
  * class CompressionSpec:
  *     def __init__(self, s):
  *         values = s.split(',')             # <<<<<<<<<<<<<<
  *         count = len(values)
  *         if count < 1:
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_split); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 652, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_split); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 653, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_kp_s__8) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s__8);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 652, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 653, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_values = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":653
+  /* "borg/compress.pyx":654
  *     def __init__(self, s):
  *         values = s.split(',')
  *         count = len(values)             # <<<<<<<<<<<<<<
  *         if count < 1:
- *             raise ValueError
+ *             raise ArgumentTypeError("not enough arguments")
  */
-  __pyx_t_4 = PyObject_Length(__pyx_v_values); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 653, __pyx_L1_error)
+  __pyx_t_4 = PyObject_Length(__pyx_v_values); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 654, __pyx_L1_error)
   __pyx_v_count = __pyx_t_4;
 
-  /* "borg/compress.pyx":654
+  /* "borg/compress.pyx":655
  *         values = s.split(',')
  *         count = len(values)
  *         if count < 1:             # <<<<<<<<<<<<<<
- *             raise ValueError
+ *             raise ArgumentTypeError("not enough arguments")
  *         # --compression algo[,level]
  */
   __pyx_t_5 = ((__pyx_v_count < 1) != 0);
   if (unlikely(__pyx_t_5)) {
 
-    /* "borg/compress.pyx":655
+    /* "borg/compress.pyx":656
  *         count = len(values)
  *         if count < 1:
- *             raise ValueError             # <<<<<<<<<<<<<<
+ *             raise ArgumentTypeError("not enough arguments")             # <<<<<<<<<<<<<<
  *         # --compression algo[,level]
  *         self.name = values[0]
  */
-    __Pyx_Raise(__pyx_builtin_ValueError, 0, 0, 0);
-    __PYX_ERR(0, 655, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 656, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_3)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_3);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
+      }
+    }
+    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_kp_s_not_enough_arguments) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_not_enough_arguments);
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 656, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __PYX_ERR(0, 656, __pyx_L1_error)
 
-    /* "borg/compress.pyx":654
+    /* "borg/compress.pyx":655
  *         values = s.split(',')
  *         count = len(values)
  *         if count < 1:             # <<<<<<<<<<<<<<
- *             raise ValueError
+ *             raise ArgumentTypeError("not enough arguments")
  *         # --compression algo[,level]
  */
   }
 
-  /* "borg/compress.pyx":657
- *             raise ValueError
+  /* "borg/compress.pyx":658
+ *             raise ArgumentTypeError("not enough arguments")
  *         # --compression algo[,level]
  *         self.name = values[0]             # <<<<<<<<<<<<<<
  *         if self.name in ('none', 'lz4', ):
  *             return
  */
-  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_values, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 657, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_values, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 658, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_name, __pyx_t_1) < 0) __PYX_ERR(0, 657, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_name, __pyx_t_1) < 0) __PYX_ERR(0, 658, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":658
+  /* "borg/compress.pyx":659
  *         # --compression algo[,level]
  *         self.name = values[0]
  *         if self.name in ('none', 'lz4', ):             # <<<<<<<<<<<<<<
  *             return
  *         elif self.name in ('zlib', 'lzma', 'zlib_legacy'):  # zlib_legacy just for testing
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 658, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 659, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_6 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_none, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 658, __pyx_L1_error)
+  __pyx_t_6 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_none, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 659, __pyx_L1_error)
   if (!__pyx_t_6) {
   } else {
     __pyx_t_5 = __pyx_t_6;
     goto __pyx_L5_bool_binop_done;
   }
-  __pyx_t_6 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_lz4, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 658, __pyx_L1_error)
+  __pyx_t_6 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_lz4, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 659, __pyx_L1_error)
   __pyx_t_5 = __pyx_t_6;
   __pyx_L5_bool_binop_done:;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_6 = (__pyx_t_5 != 0);
   if (__pyx_t_6) {
 
-    /* "borg/compress.pyx":659
+    /* "borg/compress.pyx":660
  *         self.name = values[0]
  *         if self.name in ('none', 'lz4', ):
  *             return             # <<<<<<<<<<<<<<
  *         elif self.name in ('zlib', 'lzma', 'zlib_legacy'):  # zlib_legacy just for testing
  *             if count < 2:
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":658
+    /* "borg/compress.pyx":659
  *         # --compression algo[,level]
  *         self.name = values[0]
  *         if self.name in ('none', 'lz4', ):             # <<<<<<<<<<<<<<
  *             return
  *         elif self.name in ('zlib', 'lzma', 'zlib_legacy'):  # zlib_legacy just for testing
  */
   }
 
-  /* "borg/compress.pyx":660
+  /* "borg/compress.pyx":661
  *         if self.name in ('none', 'lz4', ):
  *             return
  *         elif self.name in ('zlib', 'lzma', 'zlib_legacy'):  # zlib_legacy just for testing             # <<<<<<<<<<<<<<
  *             if count < 2:
  *                 level = 6  # default compression level in py stdlib
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 661, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zlib, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 660, __pyx_L1_error)
+  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zlib, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 661, __pyx_L1_error)
   if (!__pyx_t_5) {
   } else {
     __pyx_t_6 = __pyx_t_5;
     goto __pyx_L7_bool_binop_done;
   }
-  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_lzma, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 660, __pyx_L1_error)
+  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_lzma, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 661, __pyx_L1_error)
   if (!__pyx_t_5) {
   } else {
     __pyx_t_6 = __pyx_t_5;
     goto __pyx_L7_bool_binop_done;
   }
-  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zlib_legacy, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 660, __pyx_L1_error)
+  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zlib_legacy, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 661, __pyx_L1_error)
   __pyx_t_6 = __pyx_t_5;
   __pyx_L7_bool_binop_done:;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_5 = (__pyx_t_6 != 0);
   if (__pyx_t_5) {
 
-    /* "borg/compress.pyx":661
+    /* "borg/compress.pyx":662
  *             return
  *         elif self.name in ('zlib', 'lzma', 'zlib_legacy'):  # zlib_legacy just for testing
  *             if count < 2:             # <<<<<<<<<<<<<<
  *                 level = 6  # default compression level in py stdlib
  *             elif count == 2:
  */
     __pyx_t_5 = ((__pyx_v_count < 2) != 0);
     if (__pyx_t_5) {
 
-      /* "borg/compress.pyx":662
+      /* "borg/compress.pyx":663
  *         elif self.name in ('zlib', 'lzma', 'zlib_legacy'):  # zlib_legacy just for testing
  *             if count < 2:
  *                 level = 6  # default compression level in py stdlib             # <<<<<<<<<<<<<<
  *             elif count == 2:
  *                 level = int(values[1])
  */
       __Pyx_INCREF(__pyx_int_6);
       __pyx_v_level = __pyx_int_6;
 
-      /* "borg/compress.pyx":661
+      /* "borg/compress.pyx":662
  *             return
  *         elif self.name in ('zlib', 'lzma', 'zlib_legacy'):  # zlib_legacy just for testing
  *             if count < 2:             # <<<<<<<<<<<<<<
  *                 level = 6  # default compression level in py stdlib
  *             elif count == 2:
  */
       goto __pyx_L10;
     }
 
-    /* "borg/compress.pyx":663
+    /* "borg/compress.pyx":664
  *             if count < 2:
  *                 level = 6  # default compression level in py stdlib
  *             elif count == 2:             # <<<<<<<<<<<<<<
  *                 level = int(values[1])
  *                 if not 0 <= level <= 9:
  */
     __pyx_t_5 = ((__pyx_v_count == 2) != 0);
     if (likely(__pyx_t_5)) {
 
-      /* "borg/compress.pyx":664
+      /* "borg/compress.pyx":665
  *                 level = 6  # default compression level in py stdlib
  *             elif count == 2:
  *                 level = int(values[1])             # <<<<<<<<<<<<<<
  *                 if not 0 <= level <= 9:
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 0 and <= 9")
  */
-      __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_values, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 664, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_values, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 665, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 664, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 665, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __pyx_v_level = __pyx_t_2;
       __pyx_t_2 = 0;
 
-      /* "borg/compress.pyx":665
+      /* "borg/compress.pyx":666
  *             elif count == 2:
  *                 level = int(values[1])
  *                 if not 0 <= level <= 9:             # <<<<<<<<<<<<<<
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 0 and <= 9")
  *             else:
  */
-      __pyx_t_2 = PyObject_RichCompare(__pyx_int_0, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 665, __pyx_L1_error)
+      __pyx_t_2 = PyObject_RichCompare(__pyx_int_0, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 666, __pyx_L1_error)
       if (__Pyx_PyObject_IsTrue(__pyx_t_2)) {
         __Pyx_DECREF(__pyx_t_2);
-        __pyx_t_2 = PyObject_RichCompare(__pyx_v_level, __pyx_int_9, Py_LE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 665, __pyx_L1_error)
+        __pyx_t_2 = PyObject_RichCompare(__pyx_v_level, __pyx_int_9, Py_LE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 666, __pyx_L1_error)
       }
-      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 665, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 666, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_6 = ((!__pyx_t_5) != 0);
       if (unlikely(__pyx_t_6)) {
 
-        /* "borg/compress.pyx":666
+        /* "borg/compress.pyx":667
  *                 level = int(values[1])
  *                 if not 0 <= level <= 9:
- *                     raise ValueError             # <<<<<<<<<<<<<<
+ *                     raise ArgumentTypeError("level must be >= 0 and <= 9")             # <<<<<<<<<<<<<<
  *             else:
- *                 raise ValueError
+ *                 raise ArgumentTypeError("too many arguments")
  */
-        __Pyx_Raise(__pyx_builtin_ValueError, 0, 0, 0);
-        __PYX_ERR(0, 666, __pyx_L1_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 667, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_1);
+        __pyx_t_3 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+          __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
+          if (likely(__pyx_t_3)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+            __Pyx_INCREF(__pyx_t_3);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_1, function);
+          }
+        }
+        __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_kp_s_level_must_be_0_and_9) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_kp_s_level_must_be_0_and_9);
+        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 667, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __PYX_ERR(0, 667, __pyx_L1_error)
 
-        /* "borg/compress.pyx":665
+        /* "borg/compress.pyx":666
  *             elif count == 2:
  *                 level = int(values[1])
  *                 if not 0 <= level <= 9:             # <<<<<<<<<<<<<<
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 0 and <= 9")
  *             else:
  */
       }
 
-      /* "borg/compress.pyx":663
+      /* "borg/compress.pyx":664
  *             if count < 2:
  *                 level = 6  # default compression level in py stdlib
  *             elif count == 2:             # <<<<<<<<<<<<<<
  *                 level = int(values[1])
  *                 if not 0 <= level <= 9:
  */
       goto __pyx_L10;
     }
 
-    /* "borg/compress.pyx":668
- *                     raise ValueError
+    /* "borg/compress.pyx":669
+ *                     raise ArgumentTypeError("level must be >= 0 and <= 9")
  *             else:
- *                 raise ValueError             # <<<<<<<<<<<<<<
+ *                 raise ArgumentTypeError("too many arguments")             # <<<<<<<<<<<<<<
  *             self.level = level
  *         elif self.name in ('zstd', ):
  */
     /*else*/ {
-      __Pyx_Raise(__pyx_builtin_ValueError, 0, 0, 0);
-      __PYX_ERR(0, 668, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 669, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_3 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
+        if (likely(__pyx_t_3)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+          __Pyx_INCREF(__pyx_t_3);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_1, function);
+        }
+      }
+      __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_kp_s_too_many_arguments) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_kp_s_too_many_arguments);
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 669, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __PYX_ERR(0, 669, __pyx_L1_error)
     }
     __pyx_L10:;
 
-    /* "borg/compress.pyx":669
+    /* "borg/compress.pyx":670
  *             else:
- *                 raise ValueError
+ *                 raise ArgumentTypeError("too many arguments")
  *             self.level = level             # <<<<<<<<<<<<<<
  *         elif self.name in ('zstd', ):
  *             if count < 2:
  */
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 669, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 670, __pyx_L1_error)
 
-    /* "borg/compress.pyx":660
+    /* "borg/compress.pyx":661
  *         if self.name in ('none', 'lz4', ):
  *             return
  *         elif self.name in ('zlib', 'lzma', 'zlib_legacy'):  # zlib_legacy just for testing             # <<<<<<<<<<<<<<
  *             if count < 2:
  *                 level = 6  # default compression level in py stdlib
  */
     goto __pyx_L4;
   }
 
-  /* "borg/compress.pyx":670
- *                 raise ValueError
+  /* "borg/compress.pyx":671
+ *                 raise ArgumentTypeError("too many arguments")
  *             self.level = level
  *         elif self.name in ('zstd', ):             # <<<<<<<<<<<<<<
  *             if count < 2:
  *                 level = 3  # default compression level in zstd
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 670, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 671, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_6 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_zstd, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 670, __pyx_L1_error)
+  __pyx_t_6 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_zstd, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 671, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_5 = (__pyx_t_6 != 0);
   if (__pyx_t_5) {
 
-    /* "borg/compress.pyx":671
+    /* "borg/compress.pyx":672
  *             self.level = level
  *         elif self.name in ('zstd', ):
  *             if count < 2:             # <<<<<<<<<<<<<<
  *                 level = 3  # default compression level in zstd
  *             elif count == 2:
  */
     __pyx_t_5 = ((__pyx_v_count < 2) != 0);
     if (__pyx_t_5) {
 
-      /* "borg/compress.pyx":672
+      /* "borg/compress.pyx":673
  *         elif self.name in ('zstd', ):
  *             if count < 2:
  *                 level = 3  # default compression level in zstd             # <<<<<<<<<<<<<<
  *             elif count == 2:
  *                 level = int(values[1])
  */
       __Pyx_INCREF(__pyx_int_3);
       __pyx_v_level = __pyx_int_3;
 
-      /* "borg/compress.pyx":671
+      /* "borg/compress.pyx":672
  *             self.level = level
  *         elif self.name in ('zstd', ):
  *             if count < 2:             # <<<<<<<<<<<<<<
  *                 level = 3  # default compression level in zstd
  *             elif count == 2:
  */
       goto __pyx_L12;
     }
 
-    /* "borg/compress.pyx":673
+    /* "borg/compress.pyx":674
  *             if count < 2:
  *                 level = 3  # default compression level in zstd
  *             elif count == 2:             # <<<<<<<<<<<<<<
  *                 level = int(values[1])
  *                 if not 1 <= level <= 22:
  */
     __pyx_t_5 = ((__pyx_v_count == 2) != 0);
     if (likely(__pyx_t_5)) {
 
-      /* "borg/compress.pyx":674
+      /* "borg/compress.pyx":675
  *                 level = 3  # default compression level in zstd
  *             elif count == 2:
  *                 level = int(values[1])             # <<<<<<<<<<<<<<
  *                 if not 1 <= level <= 22:
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 22")
  */
-      __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_values, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 674, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_values, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 675, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 674, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 675, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_v_level = __pyx_t_1;
       __pyx_t_1 = 0;
 
-      /* "borg/compress.pyx":675
+      /* "borg/compress.pyx":676
  *             elif count == 2:
  *                 level = int(values[1])
  *                 if not 1 <= level <= 22:             # <<<<<<<<<<<<<<
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 22")
  *             else:
  */
-      __pyx_t_1 = PyObject_RichCompare(__pyx_int_1, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 675, __pyx_L1_error)
+      __pyx_t_1 = PyObject_RichCompare(__pyx_int_1, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 676, __pyx_L1_error)
       if (__Pyx_PyObject_IsTrue(__pyx_t_1)) {
         __Pyx_DECREF(__pyx_t_1);
-        __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_22, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 675, __pyx_L1_error)
+        __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_22, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 676, __pyx_L1_error)
       }
-      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 675, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 676, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __pyx_t_6 = ((!__pyx_t_5) != 0);
       if (unlikely(__pyx_t_6)) {
 
-        /* "borg/compress.pyx":676
+        /* "borg/compress.pyx":677
  *                 level = int(values[1])
  *                 if not 1 <= level <= 22:
- *                     raise ValueError             # <<<<<<<<<<<<<<
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 22")             # <<<<<<<<<<<<<<
  *             else:
- *                 raise ValueError
+ *                 raise ArgumentTypeError("too many arguments")
  */
-        __Pyx_Raise(__pyx_builtin_ValueError, 0, 0, 0);
-        __PYX_ERR(0, 676, __pyx_L1_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 677, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __pyx_t_3 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+          __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+          if (likely(__pyx_t_3)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+            __Pyx_INCREF(__pyx_t_3);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_2, function);
+          }
+        }
+        __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_kp_s_level_must_be_1_and_22) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_level_must_be_1_and_22);
+        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 677, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        __PYX_ERR(0, 677, __pyx_L1_error)
 
-        /* "borg/compress.pyx":675
+        /* "borg/compress.pyx":676
  *             elif count == 2:
  *                 level = int(values[1])
  *                 if not 1 <= level <= 22:             # <<<<<<<<<<<<<<
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 22")
  *             else:
  */
       }
 
-      /* "borg/compress.pyx":673
+      /* "borg/compress.pyx":674
  *             if count < 2:
  *                 level = 3  # default compression level in zstd
  *             elif count == 2:             # <<<<<<<<<<<<<<
  *                 level = int(values[1])
  *                 if not 1 <= level <= 22:
  */
       goto __pyx_L12;
     }
 
-    /* "borg/compress.pyx":678
- *                     raise ValueError
+    /* "borg/compress.pyx":679
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 22")
  *             else:
- *                 raise ValueError             # <<<<<<<<<<<<<<
+ *                 raise ArgumentTypeError("too many arguments")             # <<<<<<<<<<<<<<
  *             self.level = level
  *         elif self.name == 'auto':
  */
     /*else*/ {
-      __Pyx_Raise(__pyx_builtin_ValueError, 0, 0, 0);
-      __PYX_ERR(0, 678, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 679, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+        if (likely(__pyx_t_3)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+          __Pyx_INCREF(__pyx_t_3);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_2, function);
+        }
+      }
+      __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_kp_s_too_many_arguments) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_too_many_arguments);
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 679, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __PYX_ERR(0, 679, __pyx_L1_error)
     }
     __pyx_L12:;
 
-    /* "borg/compress.pyx":679
+    /* "borg/compress.pyx":680
  *             else:
- *                 raise ValueError
+ *                 raise ArgumentTypeError("too many arguments")
  *             self.level = level             # <<<<<<<<<<<<<<
  *         elif self.name == 'auto':
  *             if 2 <= count <= 3:
  */
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 679, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 680, __pyx_L1_error)
 
-    /* "borg/compress.pyx":670
- *                 raise ValueError
+    /* "borg/compress.pyx":671
+ *                 raise ArgumentTypeError("too many arguments")
  *             self.level = level
  *         elif self.name in ('zstd', ):             # <<<<<<<<<<<<<<
  *             if count < 2:
  *                 level = 3  # default compression level in zstd
  */
     goto __pyx_L4;
   }
 
-  /* "borg/compress.pyx":680
- *                 raise ValueError
+  /* "borg/compress.pyx":681
+ *                 raise ArgumentTypeError("too many arguments")
  *             self.level = level
  *         elif self.name == 'auto':             # <<<<<<<<<<<<<<
  *             if 2 <= count <= 3:
  *                 compression = ','.join(values[1:])
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 680, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 681, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_6 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_auto, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 680, __pyx_L1_error)
+  __pyx_t_6 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_auto, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 681, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if (__pyx_t_6) {
 
-    /* "borg/compress.pyx":681
+    /* "borg/compress.pyx":682
  *             self.level = level
  *         elif self.name == 'auto':
  *             if 2 <= count <= 3:             # <<<<<<<<<<<<<<
  *                 compression = ','.join(values[1:])
  *             else:
  */
     __pyx_t_6 = (2 <= __pyx_v_count);
     if (__pyx_t_6) {
       __pyx_t_6 = (__pyx_v_count <= 3);
     }
     __pyx_t_5 = (__pyx_t_6 != 0);
     if (likely(__pyx_t_5)) {
 
-      /* "borg/compress.pyx":682
+      /* "borg/compress.pyx":683
  *         elif self.name == 'auto':
  *             if 2 <= count <= 3:
  *                 compression = ','.join(values[1:])             # <<<<<<<<<<<<<<
  *             else:
- *                 raise ValueError
+ *                 raise ArgumentTypeError("bad arguments")
  */
-      __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_values, 1, 0, NULL, NULL, &__pyx_slice__9, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 682, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_values, 1, 0, NULL, NULL, &__pyx_slice__9, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 683, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_2 = __Pyx_PyString_Join(__pyx_kp_s__8, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 682, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyString_Join(__pyx_kp_s__8, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 683, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __pyx_v_compression = ((PyObject*)__pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/compress.pyx":681
+      /* "borg/compress.pyx":682
  *             self.level = level
  *         elif self.name == 'auto':
  *             if 2 <= count <= 3:             # <<<<<<<<<<<<<<
  *                 compression = ','.join(values[1:])
  *             else:
  */
       goto __pyx_L14;
     }
 
-    /* "borg/compress.pyx":684
+    /* "borg/compress.pyx":685
  *                 compression = ','.join(values[1:])
  *             else:
- *                 raise ValueError             # <<<<<<<<<<<<<<
+ *                 raise ArgumentTypeError("bad arguments")             # <<<<<<<<<<<<<<
  *             self.inner = CompressionSpec(compression)
  *         elif self.name == 'obfuscate':
  */
     /*else*/ {
-      __Pyx_Raise(__pyx_builtin_ValueError, 0, 0, 0);
-      __PYX_ERR(0, 684, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 685, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_3 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
+        if (likely(__pyx_t_3)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+          __Pyx_INCREF(__pyx_t_3);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_1, function);
+        }
+      }
+      __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_kp_s_bad_arguments) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_kp_s_bad_arguments);
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 685, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __PYX_ERR(0, 685, __pyx_L1_error)
     }
     __pyx_L14:;
 
-    /* "borg/compress.pyx":685
+    /* "borg/compress.pyx":686
  *             else:
- *                 raise ValueError
+ *                 raise ArgumentTypeError("bad arguments")
  *             self.inner = CompressionSpec(compression)             # <<<<<<<<<<<<<<
  *         elif self.name == 'obfuscate':
  *             if 3 <= count <= 5:
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_CompressionSpec); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 685, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_CompressionSpec); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 686, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_3 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
         __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_1, function);
       }
     }
     __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_compression) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_compression);
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 685, __pyx_L1_error)
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 686, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_inner, __pyx_t_2) < 0) __PYX_ERR(0, 685, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_inner, __pyx_t_2) < 0) __PYX_ERR(0, 686, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-    /* "borg/compress.pyx":680
- *                 raise ValueError
+    /* "borg/compress.pyx":681
+ *                 raise ArgumentTypeError("too many arguments")
  *             self.level = level
  *         elif self.name == 'auto':             # <<<<<<<<<<<<<<
  *             if 2 <= count <= 3:
  *                 compression = ','.join(values[1:])
  */
     goto __pyx_L4;
   }
 
-  /* "borg/compress.pyx":686
- *                 raise ValueError
+  /* "borg/compress.pyx":687
+ *                 raise ArgumentTypeError("bad arguments")
  *             self.inner = CompressionSpec(compression)
  *         elif self.name == 'obfuscate':             # <<<<<<<<<<<<<<
  *             if 3 <= count <= 5:
  *                 level = int(values[1])
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 686, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 687, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_obfuscate_2, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 686, __pyx_L1_error)
+  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_obfuscate_2, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 687, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (likely(__pyx_t_5)) {
 
-    /* "borg/compress.pyx":687
+    /* "borg/compress.pyx":688
  *             self.inner = CompressionSpec(compression)
  *         elif self.name == 'obfuscate':
  *             if 3 <= count <= 5:             # <<<<<<<<<<<<<<
  *                 level = int(values[1])
  *                 if not ((1 <= level <= 6) or (110 <= level <= 123)):
  */
     __pyx_t_5 = (3 <= __pyx_v_count);
     if (__pyx_t_5) {
       __pyx_t_5 = (__pyx_v_count <= 5);
     }
     __pyx_t_6 = (__pyx_t_5 != 0);
     if (likely(__pyx_t_6)) {
 
-      /* "borg/compress.pyx":688
+      /* "borg/compress.pyx":689
  *         elif self.name == 'obfuscate':
  *             if 3 <= count <= 5:
  *                 level = int(values[1])             # <<<<<<<<<<<<<<
  *                 if not ((1 <= level <= 6) or (110 <= level <= 123)):
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 6 or >= 110 and <= 123")
  */
-      __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_values, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 688, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_values, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 689, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 688, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 689, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_v_level = __pyx_t_1;
       __pyx_t_1 = 0;
 
-      /* "borg/compress.pyx":689
+      /* "borg/compress.pyx":690
  *             if 3 <= count <= 5:
  *                 level = int(values[1])
  *                 if not ((1 <= level <= 6) or (110 <= level <= 123)):             # <<<<<<<<<<<<<<
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 6 or >= 110 and <= 123")
  *                 self.level = level
  */
-      __pyx_t_1 = PyObject_RichCompare(__pyx_int_1, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 689, __pyx_L1_error)
+      __pyx_t_1 = PyObject_RichCompare(__pyx_int_1, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 690, __pyx_L1_error)
       if (__Pyx_PyObject_IsTrue(__pyx_t_1)) {
         __Pyx_DECREF(__pyx_t_1);
-        __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_6, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 689, __pyx_L1_error)
+        __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_6, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 690, __pyx_L1_error)
       }
-      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 689, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 690, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       if (!__pyx_t_5) {
       } else {
         __pyx_t_6 = __pyx_t_5;
         goto __pyx_L17_bool_binop_done;
       }
-      __pyx_t_1 = PyObject_RichCompare(__pyx_int_110, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 689, __pyx_L1_error)
+      __pyx_t_1 = PyObject_RichCompare(__pyx_int_110, __pyx_v_level, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 690, __pyx_L1_error)
       if (__Pyx_PyObject_IsTrue(__pyx_t_1)) {
         __Pyx_DECREF(__pyx_t_1);
-        __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_123, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 689, __pyx_L1_error)
+        __pyx_t_1 = PyObject_RichCompare(__pyx_v_level, __pyx_int_123, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 690, __pyx_L1_error)
       }
-      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 689, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 690, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __pyx_t_6 = __pyx_t_5;
       __pyx_L17_bool_binop_done:;
       __pyx_t_5 = ((!__pyx_t_6) != 0);
       if (unlikely(__pyx_t_5)) {
 
-        /* "borg/compress.pyx":690
+        /* "borg/compress.pyx":691
  *                 level = int(values[1])
  *                 if not ((1 <= level <= 6) or (110 <= level <= 123)):
- *                     raise ValueError             # <<<<<<<<<<<<<<
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 6 or >= 110 and <= 123")             # <<<<<<<<<<<<<<
  *                 self.level = level
  *                 compression = ','.join(values[2:])
  */
-        __Pyx_Raise(__pyx_builtin_ValueError, 0, 0, 0);
-        __PYX_ERR(0, 690, __pyx_L1_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 691, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __pyx_t_3 = NULL;
+        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+          __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+          if (likely(__pyx_t_3)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+            __Pyx_INCREF(__pyx_t_3);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_2, function);
+          }
+        }
+        __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_kp_s_level_must_be_1_and_6_or_110_and) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_level_must_be_1_and_6_or_110_and);
+        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 691, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        __PYX_ERR(0, 691, __pyx_L1_error)
 
-        /* "borg/compress.pyx":689
+        /* "borg/compress.pyx":690
  *             if 3 <= count <= 5:
  *                 level = int(values[1])
  *                 if not ((1 <= level <= 6) or (110 <= level <= 123)):             # <<<<<<<<<<<<<<
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 6 or >= 110 and <= 123")
  *                 self.level = level
  */
       }
 
-      /* "borg/compress.pyx":691
+      /* "borg/compress.pyx":692
  *                 if not ((1 <= level <= 6) or (110 <= level <= 123)):
- *                     raise ValueError
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 6 or >= 110 and <= 123")
  *                 self.level = level             # <<<<<<<<<<<<<<
  *                 compression = ','.join(values[2:])
  *             else:
  */
-      if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 691, __pyx_L1_error)
+      if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_level, __pyx_v_level) < 0) __PYX_ERR(0, 692, __pyx_L1_error)
 
-      /* "borg/compress.pyx":692
- *                     raise ValueError
+      /* "borg/compress.pyx":693
+ *                     raise ArgumentTypeError("level must be >= 1 and <= 6 or >= 110 and <= 123")
  *                 self.level = level
  *                 compression = ','.join(values[2:])             # <<<<<<<<<<<<<<
  *             else:
- *                 raise ValueError
+ *                 raise ArgumentTypeError("bad arguments")
  */
-      __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_values, 2, 0, NULL, NULL, &__pyx_slice_, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 692, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetSlice(__pyx_v_values, 2, 0, NULL, NULL, &__pyx_slice_, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 693, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_2 = __Pyx_PyString_Join(__pyx_kp_s__8, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 692, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyString_Join(__pyx_kp_s__8, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 693, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __pyx_v_compression = ((PyObject*)__pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/compress.pyx":687
+      /* "borg/compress.pyx":688
  *             self.inner = CompressionSpec(compression)
  *         elif self.name == 'obfuscate':
  *             if 3 <= count <= 5:             # <<<<<<<<<<<<<<
  *                 level = int(values[1])
  *                 if not ((1 <= level <= 6) or (110 <= level <= 123)):
  */
       goto __pyx_L15;
     }
 
-    /* "borg/compress.pyx":694
+    /* "borg/compress.pyx":695
  *                 compression = ','.join(values[2:])
  *             else:
- *                 raise ValueError             # <<<<<<<<<<<<<<
+ *                 raise ArgumentTypeError("bad arguments")             # <<<<<<<<<<<<<<
  *             self.inner = CompressionSpec(compression)
  *         else:
  */
     /*else*/ {
-      __Pyx_Raise(__pyx_builtin_ValueError, 0, 0, 0);
-      __PYX_ERR(0, 694, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 695, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_3 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
+        if (likely(__pyx_t_3)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+          __Pyx_INCREF(__pyx_t_3);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_1, function);
+        }
+      }
+      __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_kp_s_bad_arguments) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_kp_s_bad_arguments);
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 695, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __PYX_ERR(0, 695, __pyx_L1_error)
     }
     __pyx_L15:;
 
-    /* "borg/compress.pyx":695
+    /* "borg/compress.pyx":696
  *             else:
- *                 raise ValueError
+ *                 raise ArgumentTypeError("bad arguments")
  *             self.inner = CompressionSpec(compression)             # <<<<<<<<<<<<<<
  *         else:
- *             raise ValueError
+ *             raise ArgumentTypeError("unsupported compression type")
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_CompressionSpec); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 695, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_CompressionSpec); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_3 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
         __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_1, function);
       }
     }
     __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_compression) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_compression);
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 695, __pyx_L1_error)
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_inner, __pyx_t_2) < 0) __PYX_ERR(0, 695, __pyx_L1_error)
+    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_inner, __pyx_t_2) < 0) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-    /* "borg/compress.pyx":686
- *                 raise ValueError
+    /* "borg/compress.pyx":687
+ *                 raise ArgumentTypeError("bad arguments")
  *             self.inner = CompressionSpec(compression)
  *         elif self.name == 'obfuscate':             # <<<<<<<<<<<<<<
  *             if 3 <= count <= 5:
  *                 level = int(values[1])
  */
     goto __pyx_L4;
   }
 
-  /* "borg/compress.pyx":697
+  /* "borg/compress.pyx":698
  *             self.inner = CompressionSpec(compression)
  *         else:
- *             raise ValueError             # <<<<<<<<<<<<<<
+ *             raise ArgumentTypeError("unsupported compression type")             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   /*else*/ {
-    __Pyx_Raise(__pyx_builtin_ValueError, 0, 0, 0);
-    __PYX_ERR(0, 697, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 698, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
+      if (likely(__pyx_t_3)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+        __Pyx_INCREF(__pyx_t_3);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_1, function);
+      }
+    }
+    __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_kp_s_unsupported_compression_type) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_kp_s_unsupported_compression_type);
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 698, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(0, 698, __pyx_L1_error)
   }
   __pyx_L4:;
 
-  /* "borg/compress.pyx":651
+  /* "borg/compress.pyx":652
  * 
  * class CompressionSpec:
  *     def __init__(self, s):             # <<<<<<<<<<<<<<
  *         values = s.split(',')
  *         count = len(values)
  */
 
@@ -16649,15 +16833,15 @@
   __Pyx_XDECREF(__pyx_v_level);
   __Pyx_XDECREF(__pyx_v_compression);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/compress.pyx":700
+/* "borg/compress.pyx":701
  * 
  *     @property
  *     def compressor(self):             # <<<<<<<<<<<<<<
  *         if self.name in ('none', 'lz4', ):
  *             return get_compressor(self.name)
  */
 
@@ -16686,267 +16870,267 @@
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("compressor", 0);
 
-  /* "borg/compress.pyx":701
+  /* "borg/compress.pyx":702
  *     @property
  *     def compressor(self):
  *         if self.name in ('none', 'lz4', ):             # <<<<<<<<<<<<<<
  *             return get_compressor(self.name)
  *         elif self.name in ('zlib', 'lzma', 'zstd', 'zlib_legacy'):
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 701, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 702, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_none, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 701, __pyx_L1_error)
+  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_none, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 702, __pyx_L1_error)
   if (!__pyx_t_3) {
   } else {
     __pyx_t_2 = __pyx_t_3;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_lz4, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 701, __pyx_L1_error)
+  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_lz4, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 702, __pyx_L1_error)
   __pyx_t_2 = __pyx_t_3;
   __pyx_L4_bool_binop_done:;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
-    /* "borg/compress.pyx":702
+    /* "borg/compress.pyx":703
  *     def compressor(self):
  *         if self.name in ('none', 'lz4', ):
  *             return get_compressor(self.name)             # <<<<<<<<<<<<<<
  *         elif self.name in ('zlib', 'lzma', 'zstd', 'zlib_legacy'):
  *             return get_compressor(self.name, level=self.level)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 702, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 703, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 702, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 703, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5);
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 702, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 703, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":701
+    /* "borg/compress.pyx":702
  *     @property
  *     def compressor(self):
  *         if self.name in ('none', 'lz4', ):             # <<<<<<<<<<<<<<
  *             return get_compressor(self.name)
  *         elif self.name in ('zlib', 'lzma', 'zstd', 'zlib_legacy'):
  */
   }
 
-  /* "borg/compress.pyx":703
+  /* "borg/compress.pyx":704
  *         if self.name in ('none', 'lz4', ):
  *             return get_compressor(self.name)
  *         elif self.name in ('zlib', 'lzma', 'zstd', 'zlib_legacy'):             # <<<<<<<<<<<<<<
  *             return get_compressor(self.name, level=self.level)
  *         elif self.name == 'auto':
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zlib, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zlib, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 704, __pyx_L1_error)
   if (!__pyx_t_2) {
   } else {
     __pyx_t_3 = __pyx_t_2;
     goto __pyx_L6_bool_binop_done;
   }
-  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_lzma, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_lzma, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 704, __pyx_L1_error)
   if (!__pyx_t_2) {
   } else {
     __pyx_t_3 = __pyx_t_2;
     goto __pyx_L6_bool_binop_done;
   }
-  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zstd, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zstd, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 704, __pyx_L1_error)
   if (!__pyx_t_2) {
   } else {
     __pyx_t_3 = __pyx_t_2;
     goto __pyx_L6_bool_binop_done;
   }
-  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zlib_legacy, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_zlib_legacy, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 704, __pyx_L1_error)
   __pyx_t_3 = __pyx_t_2;
   __pyx_L6_bool_binop_done:;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_2 = (__pyx_t_3 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":704
+    /* "borg/compress.pyx":705
  *             return get_compressor(self.name)
  *         elif self.name in ('zlib', 'lzma', 'zstd', 'zlib_legacy'):
  *             return get_compressor(self.name, level=self.level)             # <<<<<<<<<<<<<<
  *         elif self.name == 'auto':
  *             return get_compressor(self.name, compressor=self.inner.compressor)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 705, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 704, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 705, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 704, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 705, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 704, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 705, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 704, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 705, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_level, __pyx_t_6) < 0) __PYX_ERR(0, 704, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_level, __pyx_t_6) < 0) __PYX_ERR(0, 705, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 704, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 705, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_r = __pyx_t_6;
     __pyx_t_6 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":703
+    /* "borg/compress.pyx":704
  *         if self.name in ('none', 'lz4', ):
  *             return get_compressor(self.name)
  *         elif self.name in ('zlib', 'lzma', 'zstd', 'zlib_legacy'):             # <<<<<<<<<<<<<<
  *             return get_compressor(self.name, level=self.level)
  *         elif self.name == 'auto':
  */
   }
 
-  /* "borg/compress.pyx":705
+  /* "borg/compress.pyx":706
  *         elif self.name in ('zlib', 'lzma', 'zstd', 'zlib_legacy'):
  *             return get_compressor(self.name, level=self.level)
  *         elif self.name == 'auto':             # <<<<<<<<<<<<<<
  *             return get_compressor(self.name, compressor=self.inner.compressor)
  *         elif self.name == 'obfuscate':
  */
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 705, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 706, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_6, __pyx_n_s_auto, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 705, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_6, __pyx_n_s_auto, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 706, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":706
+    /* "borg/compress.pyx":707
  *             return get_compressor(self.name, level=self.level)
  *         elif self.name == 'auto':
  *             return get_compressor(self.name, compressor=self.inner.compressor)             # <<<<<<<<<<<<<<
  *         elif self.name == 'obfuscate':
  *             return get_compressor(self.name, level=self.level, compressor=self.inner.compressor)
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 706, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 707, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 706, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 707, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 706, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 707, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 706, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 707, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_inner); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 706, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_inner); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 707, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_compressor); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 706, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_compressor); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 707, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_compressor, __pyx_t_7) < 0) __PYX_ERR(0, 706, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_compressor, __pyx_t_7) < 0) __PYX_ERR(0, 707, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 706, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 707, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_r = __pyx_t_7;
     __pyx_t_7 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":705
+    /* "borg/compress.pyx":706
  *         elif self.name in ('zlib', 'lzma', 'zstd', 'zlib_legacy'):
  *             return get_compressor(self.name, level=self.level)
  *         elif self.name == 'auto':             # <<<<<<<<<<<<<<
  *             return get_compressor(self.name, compressor=self.inner.compressor)
  *         elif self.name == 'obfuscate':
  */
   }
 
-  /* "borg/compress.pyx":707
+  /* "borg/compress.pyx":708
  *         elif self.name == 'auto':
  *             return get_compressor(self.name, compressor=self.inner.compressor)
  *         elif self.name == 'obfuscate':             # <<<<<<<<<<<<<<
  *             return get_compressor(self.name, level=self.level, compressor=self.inner.compressor)
  */
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 707, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 708, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_7, __pyx_n_s_obfuscate_2, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 707, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_7, __pyx_n_s_obfuscate_2, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 708, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   if (__pyx_t_2) {
 
-    /* "borg/compress.pyx":708
+    /* "borg/compress.pyx":709
  *             return get_compressor(self.name, compressor=self.inner.compressor)
  *         elif self.name == 'obfuscate':
  *             return get_compressor(self.name, level=self.level, compressor=self.inner.compressor)             # <<<<<<<<<<<<<<
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_level); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_level, __pyx_t_6) < 0) __PYX_ERR(0, 708, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_level, __pyx_t_6) < 0) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_inner); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_inner); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_compressor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_compressor, __pyx_t_1) < 0) __PYX_ERR(0, 708, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_compressor, __pyx_t_1) < 0) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 709, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
 
-    /* "borg/compress.pyx":707
+    /* "borg/compress.pyx":708
  *         elif self.name == 'auto':
  *             return get_compressor(self.name, compressor=self.inner.compressor)
  *         elif self.name == 'obfuscate':             # <<<<<<<<<<<<<<
  *             return get_compressor(self.name, level=self.level, compressor=self.inner.compressor)
  */
   }
 
-  /* "borg/compress.pyx":700
+  /* "borg/compress.pyx":701
  * 
  *     @property
  *     def compressor(self):             # <<<<<<<<<<<<<<
  *         if self.name in ('none', 'lz4', ):
  *             return get_compressor(self.name)
  */
 
@@ -17825,15 +18009,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_8compress_DecidingCompressor(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_8compress_CompressorBase(t, a, k);
   if (unlikely(!o)) return 0;
@@ -17913,15 +18097,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
@@ -17966,14 +18150,15 @@
     #define CYTHON_SMALL_CODE
 #endif
 #endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
   {&__pyx_kp_s_1_2_02, __pyx_k_1_2_02, sizeof(__pyx_k_1_2_02), 0, 0, 1, 0},
   {&__pyx_n_s_API_VERSION, __pyx_k_API_VERSION, sizeof(__pyx_k_API_VERSION), 0, 0, 1, 1},
+  {&__pyx_n_s_ArgumentTypeError, __pyx_k_ArgumentTypeError, sizeof(__pyx_k_ArgumentTypeError), 0, 0, 1, 1},
   {&__pyx_n_s_Auto, __pyx_k_Auto, sizeof(__pyx_k_Auto), 0, 0, 1, 1},
   {&__pyx_n_s_Auto___init, __pyx_k_Auto___init, sizeof(__pyx_k_Auto___init), 0, 0, 1, 1},
   {&__pyx_n_s_Auto__decide, __pyx_k_Auto__decide, sizeof(__pyx_k_Auto__decide), 0, 0, 1, 1},
   {&__pyx_n_s_Auto_compress, __pyx_k_Auto_compress, sizeof(__pyx_k_Auto_compress), 0, 0, 1, 1},
   {&__pyx_n_s_Auto_compress_locals_get_meta, __pyx_k_Auto_compress_locals_get_meta, sizeof(__pyx_k_Auto_compress_locals_get_meta), 0, 0, 1, 1},
   {&__pyx_n_s_Auto_decide, __pyx_k_Auto_decide, sizeof(__pyx_k_Auto_decide), 0, 0, 1, 1},
   {&__pyx_n_s_Auto_decompress, __pyx_k_Auto_decompress, sizeof(__pyx_k_Auto_decompress), 0, 0, 1, 1},
@@ -18041,15 +18226,17 @@
   {&__pyx_n_s_ZLIB_legacy_detect, __pyx_k_ZLIB_legacy_detect, sizeof(__pyx_k_ZLIB_legacy_detect), 0, 0, 1, 1},
   {&__pyx_n_s_ZSTD, __pyx_k_ZSTD, sizeof(__pyx_k_ZSTD), 0, 0, 1, 1},
   {&__pyx_n_s_ZSTD___init, __pyx_k_ZSTD___init, sizeof(__pyx_k_ZSTD___init), 0, 0, 1, 1},
   {&__pyx_n_s_ZSTD__decide, __pyx_k_ZSTD__decide, sizeof(__pyx_k_ZSTD__decide), 0, 0, 1, 1},
   {&__pyx_n_s_ZSTD_decompress, __pyx_k_ZSTD_decompress, sizeof(__pyx_k_ZSTD_decompress), 0, 0, 1, 1},
   {&__pyx_kp_s__8, __pyx_k__8, sizeof(__pyx_k__8), 0, 0, 1, 0},
   {&__pyx_n_s_addtl_size, __pyx_k_addtl_size, sizeof(__pyx_k_addtl_size), 0, 0, 1, 1},
+  {&__pyx_n_s_argparse, __pyx_k_argparse, sizeof(__pyx_k_argparse), 0, 0, 1, 1},
   {&__pyx_n_s_auto, __pyx_k_auto, sizeof(__pyx_k_auto), 0, 0, 1, 1},
+  {&__pyx_kp_s_bad_arguments, __pyx_k_bad_arguments, sizeof(__pyx_k_bad_arguments), 0, 0, 1, 0},
   {&__pyx_n_s_baseclass, __pyx_k_baseclass, sizeof(__pyx_k_baseclass), 0, 0, 1, 1},
   {&__pyx_n_s_borg_compress, __pyx_k_borg_compress, sizeof(__pyx_k_borg_compress), 0, 0, 1, 1},
   {&__pyx_n_s_buf, __pyx_k_buf, sizeof(__pyx_k_buf), 0, 0, 1, 1},
   {&__pyx_n_s_buffer, __pyx_k_buffer, sizeof(__pyx_k_buffer), 0, 0, 1, 1},
   {&__pyx_n_s_cheap_compressed_data, __pyx_k_cheap_compressed_data, sizeof(__pyx_k_cheap_compressed_data), 0, 0, 1, 1},
   {&__pyx_n_s_cheap_meta, __pyx_k_cheap_meta, sizeof(__pyx_k_cheap_meta), 0, 0, 1, 1},
   {&__pyx_n_s_check, __pyx_k_check, sizeof(__pyx_k_check), 0, 0, 1, 1},
@@ -18104,14 +18291,17 @@
   {&__pyx_n_s_isize, __pyx_k_isize, sizeof(__pyx_k_isize), 0, 0, 1, 1},
   {&__pyx_n_s_items, __pyx_k_items, sizeof(__pyx_k_items), 0, 0, 1, 1},
   {&__pyx_n_s_join, __pyx_k_join, sizeof(__pyx_k_join), 0, 0, 1, 1},
   {&__pyx_n_s_key, __pyx_k_key, sizeof(__pyx_k_key), 0, 0, 1, 1},
   {&__pyx_n_s_kwargs, __pyx_k_kwargs, sizeof(__pyx_k_kwargs), 0, 0, 1, 1},
   {&__pyx_n_s_legacy_mode, __pyx_k_legacy_mode, sizeof(__pyx_k_legacy_mode), 0, 0, 1, 1},
   {&__pyx_n_s_level, __pyx_k_level, sizeof(__pyx_k_level), 0, 0, 1, 1},
+  {&__pyx_kp_s_level_must_be_0_and_9, __pyx_k_level_must_be_0_and_9, sizeof(__pyx_k_level_must_be_0_and_9), 0, 0, 1, 0},
+  {&__pyx_kp_s_level_must_be_1_and_22, __pyx_k_level_must_be_1_and_22, sizeof(__pyx_k_level_must_be_1_and_22), 0, 0, 1, 0},
+  {&__pyx_kp_s_level_must_be_1_and_6_or_110_and, __pyx_k_level_must_be_1_and_6_or_110_and, sizeof(__pyx_k_level_must_be_1_and_6_or_110_and), 0, 0, 1, 0},
   {&__pyx_n_s_lz4, __pyx_k_lz4, sizeof(__pyx_k_lz4), 0, 0, 1, 1},
   {&__pyx_kp_s_lz4_compress_failed, __pyx_k_lz4_compress_failed, sizeof(__pyx_k_lz4_compress_failed), 0, 0, 1, 0},
   {&__pyx_kp_s_lz4_decompress_failed, __pyx_k_lz4_decompress_failed, sizeof(__pyx_k_lz4_decompress_failed), 0, 0, 1, 0},
   {&__pyx_n_s_lzma, __pyx_k_lzma, sizeof(__pyx_k_lzma), 0, 0, 1, 1},
   {&__pyx_kp_s_lzma_compression_decompression, __pyx_k_lzma_compression_decompression, sizeof(__pyx_k_lzma_compression_decompression), 0, 0, 1, 0},
   {&__pyx_n_s_lzma_data, __pyx_k_lzma_data, sizeof(__pyx_k_lzma_data), 0, 0, 1, 1},
   {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
@@ -18121,14 +18311,15 @@
   {&__pyx_n_s_min_r, __pyx_k_min_r, sizeof(__pyx_k_min_r), 0, 0, 1, 1},
   {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
   {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
   {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
   {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
   {&__pyx_n_s_none, __pyx_k_none, sizeof(__pyx_k_none), 0, 0, 1, 1},
   {&__pyx_kp_s_none_no_compression_just_pass_t, __pyx_k_none_no_compression_just_pass_t, sizeof(__pyx_k_none_no_compression_just_pass_t), 0, 0, 1, 0},
+  {&__pyx_kp_s_not_enough_arguments, __pyx_k_not_enough_arguments, sizeof(__pyx_k_not_enough_arguments), 0, 0, 1, 0},
   {&__pyx_n_s_null, __pyx_k_null, sizeof(__pyx_k_null), 0, 0, 1, 1},
   {&__pyx_n_s_obfuscate, __pyx_k_obfuscate, sizeof(__pyx_k_obfuscate), 0, 0, 1, 1},
   {&__pyx_n_s_obfuscate_2, __pyx_k_obfuscate_2, sizeof(__pyx_k_obfuscate_2), 0, 0, 1, 1},
   {&__pyx_n_s_obfuscated_data, __pyx_k_obfuscated_data, sizeof(__pyx_k_obfuscated_data), 0, 0, 1, 1},
   {&__pyx_n_s_olevel, __pyx_k_olevel, sizeof(__pyx_k_olevel), 0, 0, 1, 1},
   {&__pyx_n_s_osize, __pyx_k_osize, sizeof(__pyx_k_osize), 0, 0, 1, 1},
   {&__pyx_n_s_pack, __pyx_k_pack, sizeof(__pyx_k_pack), 0, 0, 1, 1},
@@ -18166,16 +18357,18 @@
   {&__pyx_kp_s_src_borg_compress_pyx, __pyx_k_src_borg_compress_pyx, sizeof(__pyx_k_src_borg_compress_pyx), 0, 0, 1, 0},
   {&__pyx_n_s_staticmethod, __pyx_k_staticmethod, sizeof(__pyx_k_staticmethod), 0, 0, 1, 1},
   {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
   {&__pyx_n_s_struct, __pyx_k_struct, sizeof(__pyx_k_struct), 0, 0, 1, 1},
   {&__pyx_n_s_super, __pyx_k_super, sizeof(__pyx_k_super), 0, 0, 1, 1},
   {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
   {&__pyx_n_s_to_meta, __pyx_k_to_meta, sizeof(__pyx_k_to_meta), 0, 0, 1, 1},
+  {&__pyx_kp_s_too_many_arguments, __pyx_k_too_many_arguments, sizeof(__pyx_k_too_many_arguments), 0, 0, 1, 0},
   {&__pyx_n_s_trailer, __pyx_k_trailer, sizeof(__pyx_k_trailer), 0, 0, 1, 1},
   {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
+  {&__pyx_kp_s_unsupported_compression_type, __pyx_k_unsupported_compression_type, sizeof(__pyx_k_unsupported_compression_type), 0, 0, 1, 0},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
   {&__pyx_n_s_values, __pyx_k_values, sizeof(__pyx_k_values), 0, 0, 1, 1},
   {&__pyx_n_s_zlib, __pyx_k_zlib, sizeof(__pyx_k_zlib), 0, 0, 1, 1},
   {&__pyx_kp_s_zlib_compression_decompression, __pyx_k_zlib_compression_decompression, sizeof(__pyx_k_zlib_compression_decompression), 0, 0, 1, 0},
   {&__pyx_kp_s_zlib_compression_decompression_2, __pyx_k_zlib_compression_decompression_2, sizeof(__pyx_k_zlib_compression_decompression_2), 0, 0, 1, 0},
   {&__pyx_n_s_zlib_data, __pyx_k_zlib_data, sizeof(__pyx_k_zlib_data), 0, 0, 1, 1},
   {&__pyx_n_s_zlib_legacy, __pyx_k_zlib_legacy, sizeof(__pyx_k_zlib_legacy), 0, 0, 1, 1},
@@ -18185,621 +18378,621 @@
   {&__pyx_kp_s_zstd_decompress_failed_s, __pyx_k_zstd_decompress_failed_s, sizeof(__pyx_k_zstd_decompress_failed_s), 0, 0, 1, 0},
   {&__pyx_kp_s_zstd_decompress_failed_size_mism, __pyx_k_zstd_decompress_failed_size_mism, sizeof(__pyx_k_zstd_decompress_failed_size_mism), 0, 0, 1, 0},
   {&__pyx_kp_s_zstd_get_size_failed_data_was_no, __pyx_k_zstd_get_size_failed_data_was_no, sizeof(__pyx_k_zstd_get_size_failed_data_was_no), 0, 0, 1, 0},
   {&__pyx_kp_s_zstd_get_size_failed_original_si, __pyx_k_zstd_get_size_failed_original_si, sizeof(__pyx_k_zstd_get_size_failed_original_si), 0, 0, 1, 0},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(0, 24, __pyx_L1_error)
-  __pyx_builtin_staticmethod = __Pyx_GetBuiltinName(__pyx_n_s_staticmethod); if (!__pyx_builtin_staticmethod) __PYX_ERR(0, 639, __pyx_L1_error)
-  __pyx_builtin_property = __Pyx_GetBuiltinName(__pyx_n_s_property); if (!__pyx_builtin_property) __PYX_ERR(0, 699, __pyx_L1_error)
-  __pyx_builtin_super = __Pyx_GetBuiltinName(__pyx_n_s_super); if (!__pyx_builtin_super) __PYX_ERR(0, 138, __pyx_L1_error)
-  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 150, __pyx_L1_error)
-  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 253, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 281, __pyx_L1_error)
-  __pyx_builtin_NotImplemented = __Pyx_GetBuiltinName(__pyx_n_s_NotImplemented); if (!__pyx_builtin_NotImplemented) __PYX_ERR(0, 554, __pyx_L1_error)
+  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(0, 25, __pyx_L1_error)
+  __pyx_builtin_staticmethod = __Pyx_GetBuiltinName(__pyx_n_s_staticmethod); if (!__pyx_builtin_staticmethod) __PYX_ERR(0, 640, __pyx_L1_error)
+  __pyx_builtin_property = __Pyx_GetBuiltinName(__pyx_n_s_property); if (!__pyx_builtin_property) __PYX_ERR(0, 700, __pyx_L1_error)
+  __pyx_builtin_super = __Pyx_GetBuiltinName(__pyx_n_s_super); if (!__pyx_builtin_super) __PYX_ERR(0, 139, __pyx_L1_error)
+  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 151, __pyx_L1_error)
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 254, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 282, __pyx_L1_error)
+  __pyx_builtin_NotImplemented = __Pyx_GetBuiltinName(__pyx_n_s_NotImplemented); if (!__pyx_builtin_NotImplemented) __PYX_ERR(0, 555, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "borg/compress.pyx":114
+  /* "borg/compress.pyx":115
  *             meta["clevel"] = data[1]
  *             meta["csize"] = len(data)
  *             return meta, data[2:]             # <<<<<<<<<<<<<<
  *         else:
  *             assert isinstance(meta, dict)
  */
-  __pyx_slice_ = PySlice_New(__pyx_int_2, Py_None, Py_None); if (unlikely(!__pyx_slice_)) __PYX_ERR(0, 114, __pyx_L1_error)
+  __pyx_slice_ = PySlice_New(__pyx_int_2, Py_None, Py_None); if (unlikely(!__pyx_slice_)) __PYX_ERR(0, 115, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_slice_);
   __Pyx_GIVEREF(__pyx_slice_);
 
-  /* "borg/compress.pyx":231
+  /* "borg/compress.pyx":232
  *             osize = LZ4_compress_default(source, dest, isize, osize)
  *         if not osize:
  *             raise Exception('lz4 compress failed')             # <<<<<<<<<<<<<<
  *         # only compress if the result actually is smaller
  *         if osize < isize:
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_lz4_compress_failed); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 231, __pyx_L1_error)
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_lz4_compress_failed); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 232, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__2);
   __Pyx_GIVEREF(__pyx_tuple__2);
 
-  /* "borg/compress.pyx":281
+  /* "borg/compress.pyx":282
  *         self.level = level
  *         if lzma is None:
  *             raise ValueError('No lzma support found.')             # <<<<<<<<<<<<<<
  * 
  *     def _decide(self, meta, data):
  */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_No_lzma_support_found); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 281, __pyx_L1_error)
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_No_lzma_support_found); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 282, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__3);
   __Pyx_GIVEREF(__pyx_tuple__3);
 
-  /* "borg/compress.pyx":425
+  /* "borg/compress.pyx":426
  *     def detect(cls, data):
  *         # matches misc. patterns 0x.8.. used by zlib
  *         cmf, flg = data[:2]             # <<<<<<<<<<<<<<
  *         is_deflate = cmf & 0x0f == 8
  *         check_ok = (cmf * 256 + flg) % 31 == 0
  */
-  __pyx_slice__4 = PySlice_New(Py_None, __pyx_int_2, Py_None); if (unlikely(!__pyx_slice__4)) __PYX_ERR(0, 425, __pyx_L1_error)
+  __pyx_slice__4 = PySlice_New(Py_None, __pyx_int_2, Py_None); if (unlikely(!__pyx_slice__4)) __PYX_ERR(0, 426, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_slice__4);
   __Pyx_GIVEREF(__pyx_slice__4);
 
-  /* "borg/compress.pyx":497
+  /* "borg/compress.pyx":498
  *     def compress(self, meta, data):
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":             # <<<<<<<<<<<<<<
  *                 if key in from_meta:
  *                     to_meta[key] = from_meta[key]
  */
-  __pyx_tuple__5 = PyTuple_Pack(3, __pyx_n_s_ctype, __pyx_n_s_clevel, __pyx_n_s_csize); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 497, __pyx_L1_error)
+  __pyx_tuple__5 = PyTuple_Pack(3, __pyx_n_s_ctype, __pyx_n_s_clevel, __pyx_n_s_csize); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 498, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__5);
   __Pyx_GIVEREF(__pyx_tuple__5);
 
-  /* "borg/compress.pyx":496
+  /* "borg/compress.pyx":497
  * 
  *     def compress(self, meta, data):
  *         def get_meta(from_meta, to_meta):             # <<<<<<<<<<<<<<
  *             for key in "ctype", "clevel", "csize":
  *                 if key in from_meta:
  */
-  __pyx_tuple__6 = PyTuple_Pack(3, __pyx_n_s_from_meta, __pyx_n_s_to_meta, __pyx_n_s_key); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 496, __pyx_L1_error)
+  __pyx_tuple__6 = PyTuple_Pack(3, __pyx_n_s_from_meta, __pyx_n_s_to_meta, __pyx_n_s_key); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 497, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__6);
   __Pyx_GIVEREF(__pyx_tuple__6);
-  __pyx_codeobj__7 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__6, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_get_meta, 496, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__7)) __PYX_ERR(0, 496, __pyx_L1_error)
+  __pyx_codeobj__7 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__6, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_get_meta, 497, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__7)) __PYX_ERR(0, 497, __pyx_L1_error)
 
-  /* "borg/compress.pyx":682
+  /* "borg/compress.pyx":683
  *         elif self.name == 'auto':
  *             if 2 <= count <= 3:
  *                 compression = ','.join(values[1:])             # <<<<<<<<<<<<<<
  *             else:
- *                 raise ValueError
+ *                 raise ArgumentTypeError("bad arguments")
  */
-  __pyx_slice__9 = PySlice_New(__pyx_int_1, Py_None, Py_None); if (unlikely(!__pyx_slice__9)) __PYX_ERR(0, 682, __pyx_L1_error)
+  __pyx_slice__9 = PySlice_New(__pyx_int_1, Py_None, Py_None); if (unlikely(!__pyx_slice__9)) __PYX_ERR(0, 683, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_slice__9);
   __Pyx_GIVEREF(__pyx_slice__9);
 
   /* "(tree fragment)":4
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  *     if __pyx_checksum not in (0xd41d8cd, 0xe3b0c44, 0xda39a3e):             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError("Incompatible checksums (0x%x vs (0xd41d8cd, 0xe3b0c44, 0xda39a3e) = ())" % __pyx_checksum)
  */
   __pyx_tuple__10 = PyTuple_Pack(3, __pyx_int_222419149, __pyx_int_238750788, __pyx_int_228825662); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__10);
   __Pyx_GIVEREF(__pyx_tuple__10);
 
-  /* "borg/compress.pyx":183
+  /* "borg/compress.pyx":184
  *     name = 'none'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for CNONE, so just say "unknown"
  * 
  */
-  __pyx_tuple__11 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 183, __pyx_L1_error)
+  __pyx_tuple__11 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 184, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__11);
   __Pyx_GIVEREF(__pyx_tuple__11);
-  __pyx_codeobj__12 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__11, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 183, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__12)) __PYX_ERR(0, 183, __pyx_L1_error)
-  __pyx_tuple__13 = PyTuple_Pack(2, ((PyObject *)__pyx_int_255), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 183, __pyx_L1_error)
+  __pyx_codeobj__12 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__11, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 184, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__12)) __PYX_ERR(0, 184, __pyx_L1_error)
+  __pyx_tuple__13 = PyTuple_Pack(2, ((PyObject *)__pyx_int_255), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 184, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__13);
   __Pyx_GIVEREF(__pyx_tuple__13);
 
-  /* "borg/compress.pyx":186
+  /* "borg/compress.pyx":187
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for CNONE, so just say "unknown"
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta["size"] = len(data)
  *         return super().compress(meta, data)
  */
-  __pyx_tuple__14 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 186, __pyx_L1_error)
+  __pyx_tuple__14 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 187, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__14);
   __Pyx_GIVEREF(__pyx_tuple__14);
-  __pyx_codeobj__15 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 186, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__15)) __PYX_ERR(0, 186, __pyx_L1_error)
+  __pyx_codeobj__15 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 187, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__15)) __PYX_ERR(0, 187, __pyx_L1_error)
 
-  /* "borg/compress.pyx":190
+  /* "borg/compress.pyx":191
  *         return super().compress(meta, data)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         if not isinstance(data, bytes):
  */
-  __pyx_tuple__16 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __pyx_tuple__16 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 191, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__16);
   __Pyx_GIVEREF(__pyx_tuple__16);
-  __pyx_codeobj__17 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 190, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__17)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __pyx_codeobj__17 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 191, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__17)) __PYX_ERR(0, 191, __pyx_L1_error)
 
-  /* "borg/compress.pyx":210
+  /* "borg/compress.pyx":211
  *     name = 'lz4'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for LZ4, so just say "unknown"
  * 
  */
-  __pyx_tuple__18 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 210, __pyx_L1_error)
+  __pyx_tuple__18 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 211, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__18);
   __Pyx_GIVEREF(__pyx_tuple__18);
-  __pyx_codeobj__19 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 210, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__19)) __PYX_ERR(0, 210, __pyx_L1_error)
-  __pyx_tuple__20 = PyTuple_Pack(2, ((PyObject *)__pyx_int_255), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 210, __pyx_L1_error)
+  __pyx_codeobj__19 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 211, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__19)) __PYX_ERR(0, 211, __pyx_L1_error)
+  __pyx_tuple__20 = PyTuple_Pack(2, ((PyObject *)__pyx_int_255), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 211, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__20);
   __Pyx_GIVEREF(__pyx_tuple__20);
 
-  /* "borg/compress.pyx":213
+  /* "borg/compress.pyx":214
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for LZ4, so just say "unknown"
  * 
  *     def _decide(self, meta, idata):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, lz4_data).
  */
-  __pyx_tuple__21 = PyTuple_Pack(8, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_idata, __pyx_n_s_isize, __pyx_n_s_osize, __pyx_n_s_source, __pyx_n_s_dest, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 213, __pyx_L1_error)
+  __pyx_tuple__21 = PyTuple_Pack(8, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_idata, __pyx_n_s_isize, __pyx_n_s_osize, __pyx_n_s_source, __pyx_n_s_dest, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 214, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__21);
   __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_codeobj__22 = (PyObject*)__Pyx_PyCode_New(3, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 213, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__22)) __PYX_ERR(0, 213, __pyx_L1_error)
+  __pyx_codeobj__22 = (PyObject*)__Pyx_PyCode_New(3, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 214, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__22)) __PYX_ERR(0, 214, __pyx_L1_error)
 
-  /* "borg/compress.pyx":238
+  /* "borg/compress.pyx":239
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  */
-  __pyx_tuple__23 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_idata, __pyx_n_s_isize, __pyx_n_s_osize, __pyx_n_s_rsize, __pyx_n_s_source, __pyx_n_s_dest, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __pyx_tuple__23 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_idata, __pyx_n_s_isize, __pyx_n_s_osize, __pyx_n_s_rsize, __pyx_n_s_source, __pyx_n_s_dest, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 239, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__23);
   __Pyx_GIVEREF(__pyx_tuple__23);
-  __pyx_codeobj__24 = (PyObject*)__Pyx_PyCode_New(3, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 238, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__24)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __pyx_codeobj__24 = (PyObject*)__Pyx_PyCode_New(3, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 239, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__24)) __PYX_ERR(0, 239, __pyx_L1_error)
 
-  /* "borg/compress.pyx":277
+  /* "borg/compress.pyx":278
  *     name = 'lzma'
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
-  __pyx_tuple__25 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 277, __pyx_L1_error)
+  __pyx_tuple__25 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 278, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__25);
   __Pyx_GIVEREF(__pyx_tuple__25);
-  __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 277, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) __PYX_ERR(0, 277, __pyx_L1_error)
-  __pyx_tuple__27 = PyTuple_Pack(2, ((PyObject *)__pyx_int_6), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 277, __pyx_L1_error)
+  __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 278, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) __PYX_ERR(0, 278, __pyx_L1_error)
+  __pyx_tuple__27 = PyTuple_Pack(2, ((PyObject *)__pyx_int_6), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 278, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__27);
   __Pyx_GIVEREF(__pyx_tuple__27);
 
-  /* "borg/compress.pyx":283
+  /* "borg/compress.pyx":284
  *             raise ValueError('No lzma support found.')
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, lzma_data).
  */
-  __pyx_tuple__28 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_lzma_data); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 283, __pyx_L1_error)
+  __pyx_tuple__28 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_lzma_data); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 284, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__28);
   __Pyx_GIVEREF(__pyx_tuple__28);
-  __pyx_codeobj__29 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__28, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 283, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__29)) __PYX_ERR(0, 283, __pyx_L1_error)
+  __pyx_codeobj__29 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__28, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 284, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__29)) __PYX_ERR(0, 284, __pyx_L1_error)
 
-  /* "borg/compress.pyx":296
+  /* "borg/compress.pyx":297
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         try:
  */
-  __pyx_tuple__30 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_e); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 296, __pyx_L1_error)
+  __pyx_tuple__30 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_e); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 297, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__30);
   __Pyx_GIVEREF(__pyx_tuple__30);
-  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__30, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 296, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(0, 296, __pyx_L1_error)
+  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__30, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 297, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(0, 297, __pyx_L1_error)
 
-  /* "borg/compress.pyx":314
+  /* "borg/compress.pyx":315
  *     name = 'zstd'
  * 
  *     def __init__(self, level=3, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
-  __pyx_tuple__32 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 314, __pyx_L1_error)
+  __pyx_tuple__32 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 315, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__32);
   __Pyx_GIVEREF(__pyx_tuple__32);
-  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 314, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(0, 314, __pyx_L1_error)
-  __pyx_tuple__34 = PyTuple_Pack(2, ((PyObject *)__pyx_int_3), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 314, __pyx_L1_error)
+  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 315, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(0, 315, __pyx_L1_error)
+  __pyx_tuple__34 = PyTuple_Pack(2, ((PyObject *)__pyx_int_3), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 315, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__34);
   __Pyx_GIVEREF(__pyx_tuple__34);
 
-  /* "borg/compress.pyx":318
+  /* "borg/compress.pyx":319
  *         self.level = level
  * 
  *     def _decide(self, meta, idata):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, zstd_data).
  */
-  __pyx_tuple__35 = PyTuple_Pack(9, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_idata, __pyx_n_s_isize, __pyx_n_s_osize, __pyx_n_s_source, __pyx_n_s_dest, __pyx_n_s_level, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 318, __pyx_L1_error)
+  __pyx_tuple__35 = PyTuple_Pack(9, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_idata, __pyx_n_s_isize, __pyx_n_s_osize, __pyx_n_s_source, __pyx_n_s_dest, __pyx_n_s_level, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 319, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__35);
   __Pyx_GIVEREF(__pyx_tuple__35);
-  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(3, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 318, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 318, __pyx_L1_error)
+  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(3, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 319, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 319, __pyx_L1_error)
 
-  /* "borg/compress.pyx":344
+  /* "borg/compress.pyx":345
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  */
-  __pyx_tuple__37 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_idata, __pyx_n_s_isize, __pyx_n_s_osize, __pyx_n_s_rsize, __pyx_n_s_source, __pyx_n_s_dest, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 344, __pyx_L1_error)
+  __pyx_tuple__37 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_idata, __pyx_n_s_isize, __pyx_n_s_osize, __pyx_n_s_rsize, __pyx_n_s_source, __pyx_n_s_dest, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 345, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__37);
   __Pyx_GIVEREF(__pyx_tuple__37);
-  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(3, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 344, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 344, __pyx_L1_error)
+  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(3, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 345, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 345, __pyx_L1_error)
 
-  /* "borg/compress.pyx":381
+  /* "borg/compress.pyx":382
  *     name = 'zlib'
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
-  __pyx_tuple__39 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 381, __pyx_L1_error)
+  __pyx_tuple__39 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_legacy_mode, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 382, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__39);
   __Pyx_GIVEREF(__pyx_tuple__39);
-  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 381, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(0, 381, __pyx_L1_error)
-  __pyx_tuple__41 = PyTuple_Pack(2, ((PyObject *)__pyx_int_6), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 381, __pyx_L1_error)
+  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 382, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_tuple__41 = PyTuple_Pack(2, ((PyObject *)__pyx_int_6), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 382, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__41);
   __Pyx_GIVEREF(__pyx_tuple__41);
 
-  /* "borg/compress.pyx":385
+  /* "borg/compress.pyx":386
  *         self.level = level
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, zlib_data).
  */
-  __pyx_tuple__42 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_zlib_data); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(0, 385, __pyx_L1_error)
+  __pyx_tuple__42 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_zlib_data); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(0, 386, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__42);
   __Pyx_GIVEREF(__pyx_tuple__42);
-  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__42, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 385, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) __PYX_ERR(0, 385, __pyx_L1_error)
+  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__42, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 386, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) __PYX_ERR(0, 386, __pyx_L1_error)
 
-  /* "borg/compress.pyx":397
+  /* "borg/compress.pyx":398
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         try:
  */
-  __pyx_tuple__44 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_e); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 397, __pyx_L1_error)
+  __pyx_tuple__44 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_e); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 398, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__44);
   __Pyx_GIVEREF(__pyx_tuple__44);
-  __pyx_codeobj__45 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__44, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 397, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__45)) __PYX_ERR(0, 397, __pyx_L1_error)
+  __pyx_codeobj__45 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__44, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 398, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__45)) __PYX_ERR(0, 398, __pyx_L1_error)
 
-  /* "borg/compress.pyx":423
+  /* "borg/compress.pyx":424
  * 
  *     @classmethod
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         # matches misc. patterns 0x.8.. used by zlib
  *         cmf, flg = data[:2]
  */
-  __pyx_tuple__46 = PyTuple_Pack(6, __pyx_n_s_cls, __pyx_n_s_data, __pyx_n_s_cmf, __pyx_n_s_flg, __pyx_n_s_is_deflate, __pyx_n_s_check_ok); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 423, __pyx_L1_error)
+  __pyx_tuple__46 = PyTuple_Pack(6, __pyx_n_s_cls, __pyx_n_s_data, __pyx_n_s_cmf, __pyx_n_s_flg, __pyx_n_s_is_deflate, __pyx_n_s_check_ok); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 424, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__46);
   __Pyx_GIVEREF(__pyx_tuple__46);
-  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(2, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__46, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_detect, 423, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(0, 423, __pyx_L1_error)
+  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(2, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__46, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_detect, 424, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(0, 424, __pyx_L1_error)
 
-  /* "borg/compress.pyx":430
+  /* "borg/compress.pyx":431
  *         return check_ok and is_deflate
  * 
  *     def __init__(self, level=6, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, **kwargs)
  *         self.level = level
  */
-  __pyx_tuple__48 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 430, __pyx_L1_error)
+  __pyx_tuple__48 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 431, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__48);
   __Pyx_GIVEREF(__pyx_tuple__48);
-  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__48, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 430, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) __PYX_ERR(0, 430, __pyx_L1_error)
-  __pyx_tuple__50 = PyTuple_Pack(1, ((PyObject *)__pyx_int_6)); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 430, __pyx_L1_error)
+  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__48, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 431, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) __PYX_ERR(0, 431, __pyx_L1_error)
+  __pyx_tuple__50 = PyTuple_Pack(1, ((PyObject *)__pyx_int_6)); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 431, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__50);
   __Pyx_GIVEREF(__pyx_tuple__50);
 
-  /* "borg/compress.pyx":434
+  /* "borg/compress.pyx":435
  *         self.level = level
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         # note: for compatibility no super call, do not add ID bytes
  *         return None, zlib.compress(data, self.level)
  */
-  __pyx_tuple__51 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 434, __pyx_L1_error)
+  __pyx_tuple__51 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 435, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__51);
   __Pyx_GIVEREF(__pyx_tuple__51);
-  __pyx_codeobj__52 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__51, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 434, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__52)) __PYX_ERR(0, 434, __pyx_L1_error)
+  __pyx_codeobj__52 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__51, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 435, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__52)) __PYX_ERR(0, 435, __pyx_L1_error)
 
-  /* "borg/compress.pyx":438
+  /* "borg/compress.pyx":439
  *         return None, zlib.compress(data, self.level)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         # note: for compatibility no super call, do not strip ID bytes
  *         try:
  */
-  __pyx_tuple__53 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_e); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 438, __pyx_L1_error)
+  __pyx_tuple__53 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_e); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 439, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__53);
   __Pyx_GIVEREF(__pyx_tuple__53);
-  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 438, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) __PYX_ERR(0, 438, __pyx_L1_error)
+  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 439, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) __PYX_ERR(0, 439, __pyx_L1_error)
 
-  /* "borg/compress.pyx":457
+  /* "borg/compress.pyx":458
  *     name = 'auto'
  * 
  *     def __init__(self, compressor):             # <<<<<<<<<<<<<<
  *         super().__init__()
  *         self.compressor = compressor
  */
-  __pyx_tuple__55 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_compressor); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 457, __pyx_L1_error)
+  __pyx_tuple__55 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_compressor); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 458, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__55);
   __Pyx_GIVEREF(__pyx_tuple__55);
-  __pyx_codeobj__56 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__55, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 457, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__56)) __PYX_ERR(0, 457, __pyx_L1_error)
+  __pyx_codeobj__56 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__55, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 458, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__56)) __PYX_ERR(0, 458, __pyx_L1_error)
 
-  /* "borg/compress.pyx":461
+  /* "borg/compress.pyx":462
  *         self.compressor = compressor
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, compressed_data).
  */
-  __pyx_tuple__57 = PyTuple_Pack(6, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_compressor, __pyx_n_s_compressed_data, __pyx_n_s_ratio); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(0, 461, __pyx_L1_error)
+  __pyx_tuple__57 = PyTuple_Pack(6, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_compressor, __pyx_n_s_compressed_data, __pyx_n_s_ratio); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(0, 462, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__57);
   __Pyx_GIVEREF(__pyx_tuple__57);
-  __pyx_codeobj__58 = (PyObject*)__Pyx_PyCode_New(3, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__57, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 461, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__58)) __PYX_ERR(0, 461, __pyx_L1_error)
+  __pyx_codeobj__58 = (PyObject*)__Pyx_PyCode_New(3, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__57, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide, 462, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__58)) __PYX_ERR(0, 462, __pyx_L1_error)
 
-  /* "borg/compress.pyx":492
+  /* "borg/compress.pyx":493
  *             return compressor, (meta, compressed_data)
  * 
  *     def decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self._decide(meta, data)[0]
  * 
  */
-  __pyx_tuple__59 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 492, __pyx_L1_error)
+  __pyx_tuple__59 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 493, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__59);
   __Pyx_GIVEREF(__pyx_tuple__59);
-  __pyx_codeobj__60 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__59, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide_2, 492, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__60)) __PYX_ERR(0, 492, __pyx_L1_error)
+  __pyx_codeobj__60 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__59, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decide_2, 493, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__60)) __PYX_ERR(0, 493, __pyx_L1_error)
 
-  /* "borg/compress.pyx":495
+  /* "borg/compress.pyx":496
  *         return self._decide(meta, data)[0]
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":
  */
-  __pyx_tuple__61 = PyTuple_Pack(11, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_get_meta, __pyx_n_s_get_meta, __pyx_n_s_compressor, __pyx_n_s_cheap_meta, __pyx_n_s_cheap_compressed_data, __pyx_n_s_expensive_meta, __pyx_n_s_expensive_compressed_data, __pyx_n_s_ratio); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(0, 495, __pyx_L1_error)
+  __pyx_tuple__61 = PyTuple_Pack(11, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_get_meta, __pyx_n_s_get_meta, __pyx_n_s_compressor, __pyx_n_s_cheap_meta, __pyx_n_s_cheap_compressed_data, __pyx_n_s_expensive_meta, __pyx_n_s_expensive_compressed_data, __pyx_n_s_ratio); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(0, 496, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__61);
   __Pyx_GIVEREF(__pyx_tuple__61);
-  __pyx_codeobj__62 = (PyObject*)__Pyx_PyCode_New(3, 0, 11, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__61, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 495, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__62)) __PYX_ERR(0, 495, __pyx_L1_error)
+  __pyx_codeobj__62 = (PyObject*)__Pyx_PyCode_New(3, 0, 11, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__61, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 496, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__62)) __PYX_ERR(0, 496, __pyx_L1_error)
 
-  /* "borg/compress.pyx":520
+  /* "borg/compress.pyx":521
  *             return meta, cheap_compressed_data
  * 
  *     def decompress(self, data):             # <<<<<<<<<<<<<<
  *         raise NotImplementedError
  * 
  */
-  __pyx_tuple__63 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_data); if (unlikely(!__pyx_tuple__63)) __PYX_ERR(0, 520, __pyx_L1_error)
+  __pyx_tuple__63 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_data); if (unlikely(!__pyx_tuple__63)) __PYX_ERR(0, 521, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__63);
   __Pyx_GIVEREF(__pyx_tuple__63);
-  __pyx_codeobj__64 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__63, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 520, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__64)) __PYX_ERR(0, 520, __pyx_L1_error)
+  __pyx_codeobj__64 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__63, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 521, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__64)) __PYX_ERR(0, 521, __pyx_L1_error)
 
-  /* "borg/compress.pyx":523
+  /* "borg/compress.pyx":524
  *         raise NotImplementedError
  * 
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         raise NotImplementedError
  * 
  */
-  __pyx_tuple__65 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_data); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 523, __pyx_L1_error)
+  __pyx_tuple__65 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_data); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 524, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__65);
   __Pyx_GIVEREF(__pyx_tuple__65);
-  __pyx_codeobj__66 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__65, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_detect, 523, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__66)) __PYX_ERR(0, 523, __pyx_L1_error)
+  __pyx_codeobj__66 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__65, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_detect, 524, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__66)) __PYX_ERR(0, 524, __pyx_L1_error)
 
-  /* "borg/compress.pyx":537
+  /* "borg/compress.pyx":538
  *     header_len = len(header_fmt.pack(0))
  * 
  *     def __init__(self, level=None, compressor=None, legacy_mode=False):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode)  # data will be encrypted, so we can tell the level
  *         self.compressor = compressor
  */
-  __pyx_tuple__67 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_compressor, __pyx_n_s_legacy_mode); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 537, __pyx_L1_error)
+  __pyx_tuple__67 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_level, __pyx_n_s_compressor, __pyx_n_s_legacy_mode); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 538, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__67);
   __Pyx_GIVEREF(__pyx_tuple__67);
-  __pyx_codeobj__68 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__67, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 537, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__68)) __PYX_ERR(0, 537, __pyx_L1_error)
-  __pyx_tuple__69 = PyTuple_Pack(3, ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__69)) __PYX_ERR(0, 537, __pyx_L1_error)
+  __pyx_codeobj__68 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__67, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 538, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__68)) __PYX_ERR(0, 538, __pyx_L1_error)
+  __pyx_tuple__69 = PyTuple_Pack(3, ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__69)) __PYX_ERR(0, 538, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__69);
   __Pyx_GIVEREF(__pyx_tuple__69);
 
-  /* "borg/compress.pyx":551
+  /* "borg/compress.pyx":552
  *             self.max_padding_size = 2 ** (level - 100)  # 1kiB .. 8MiB
  * 
  *     def _obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         # implementations need to return the size of obfuscation data,
  *         # that the caller shall add.
  */
-  __pyx_tuple__70 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_compr_size); if (unlikely(!__pyx_tuple__70)) __PYX_ERR(0, 551, __pyx_L1_error)
+  __pyx_tuple__70 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_compr_size); if (unlikely(!__pyx_tuple__70)) __PYX_ERR(0, 552, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__70);
   __Pyx_GIVEREF(__pyx_tuple__70);
-  __pyx_codeobj__71 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__70, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_obfuscate, 551, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__71)) __PYX_ERR(0, 551, __pyx_L1_error)
+  __pyx_codeobj__71 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__70, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_obfuscate, 552, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__71)) __PYX_ERR(0, 552, __pyx_L1_error)
 
-  /* "borg/compress.pyx":556
+  /* "borg/compress.pyx":557
  *         raise NotImplemented
  * 
  *     def _relative_random_reciprocal_obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         # effect for SPEC 1:
  *         # f = 0.01 .. 0.1 for r in 1.0 .. 0.1 == in 90% of cases
  */
-  __pyx_tuple__72 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_compr_size, __pyx_n_s_r, __pyx_n_s_f); if (unlikely(!__pyx_tuple__72)) __PYX_ERR(0, 556, __pyx_L1_error)
+  __pyx_tuple__72 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_compr_size, __pyx_n_s_r, __pyx_n_s_f); if (unlikely(!__pyx_tuple__72)) __PYX_ERR(0, 557, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__72);
   __Pyx_GIVEREF(__pyx_tuple__72);
-  __pyx_codeobj__73 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__72, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_relative_random_reciprocal_obfu, 556, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__73)) __PYX_ERR(0, 556, __pyx_L1_error)
+  __pyx_codeobj__73 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__72, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_relative_random_reciprocal_obfu, 557, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__73)) __PYX_ERR(0, 557, __pyx_L1_error)
 
-  /* "borg/compress.pyx":566
+  /* "borg/compress.pyx":567
  *         return int(compr_size * f)
  * 
  *     def _random_padding_obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         return int(self.max_padding_size * random.random())
  * 
  */
-  __pyx_tuple__74 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_compr_size); if (unlikely(!__pyx_tuple__74)) __PYX_ERR(0, 566, __pyx_L1_error)
+  __pyx_tuple__74 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_compr_size); if (unlikely(!__pyx_tuple__74)) __PYX_ERR(0, 567, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__74);
   __Pyx_GIVEREF(__pyx_tuple__74);
-  __pyx_codeobj__75 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__74, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_random_padding_obfuscate, 566, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__75)) __PYX_ERR(0, 566, __pyx_L1_error)
+  __pyx_codeobj__75 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__74, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_random_padding_obfuscate, 567, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__75)) __PYX_ERR(0, 567, __pyx_L1_error)
 
-  /* "borg/compress.pyx":569
+  /* "borg/compress.pyx":570
  *         return int(self.max_padding_size * random.random())
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         assert not self.legacy_mode  # we never call this in legacy mode
  *         meta, compressed_data = self.compressor.compress(meta, data)  # compress data
  */
-  __pyx_tuple__76 = PyTuple_Pack(8, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_compressed_data, __pyx_n_s_compr_size, __pyx_n_s_addtl_size, __pyx_n_s_trailer, __pyx_n_s_obfuscated_data); if (unlikely(!__pyx_tuple__76)) __PYX_ERR(0, 569, __pyx_L1_error)
+  __pyx_tuple__76 = PyTuple_Pack(8, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_compressed_data, __pyx_n_s_compr_size, __pyx_n_s_addtl_size, __pyx_n_s_trailer, __pyx_n_s_obfuscated_data); if (unlikely(!__pyx_tuple__76)) __PYX_ERR(0, 570, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__76);
   __Pyx_GIVEREF(__pyx_tuple__76);
-  __pyx_codeobj__77 = (PyObject*)__Pyx_PyCode_New(3, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__76, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 569, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__77)) __PYX_ERR(0, 569, __pyx_L1_error)
+  __pyx_codeobj__77 = (PyObject*)__Pyx_PyCode_New(3, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__76, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 570, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__77)) __PYX_ERR(0, 570, __pyx_L1_error)
 
-  /* "borg/compress.pyx":584
+  /* "borg/compress.pyx":585
  *         return meta, obfuscated_data  # for borg2 it is enough that we have the payload size in meta["psize"]
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         assert self.legacy_mode  # borg2 never dispatches to this, only used for legacy mode
  *         meta, obfuscated_data = super().decompress(meta, data)  # remove obfuscator ID header
  */
-  __pyx_tuple__78 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_obfuscated_data, __pyx_n_s_compr_size, __pyx_n_s_compressed_data, __pyx_n_s_compressor_cls); if (unlikely(!__pyx_tuple__78)) __PYX_ERR(0, 584, __pyx_L1_error)
+  __pyx_tuple__78 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_obfuscated_data, __pyx_n_s_compr_size, __pyx_n_s_compressed_data, __pyx_n_s_compressor_cls); if (unlikely(!__pyx_tuple__78)) __PYX_ERR(0, 585, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__78);
   __Pyx_GIVEREF(__pyx_tuple__78);
-  __pyx_codeobj__79 = (PyObject*)__Pyx_PyCode_New(3, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__78, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 584, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__79)) __PYX_ERR(0, 584, __pyx_L1_error)
+  __pyx_codeobj__79 = (PyObject*)__Pyx_PyCode_New(3, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__78, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 585, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__79)) __PYX_ERR(0, 585, __pyx_L1_error)
 
-  /* "borg/compress.pyx":609
+  /* "borg/compress.pyx":610
  * COMPRESSOR_LIST = [LZ4, ZSTD, CNONE, ZLIB, ZLIB_legacy, LZMA, ObfuscateSize, ]  # check fast stuff first
  * 
  * def get_compressor(name, **kwargs):             # <<<<<<<<<<<<<<
  *     cls = COMPRESSOR_TABLE[name]
  *     return cls(**kwargs)
  */
-  __pyx_tuple__80 = PyTuple_Pack(3, __pyx_n_s_name, __pyx_n_s_kwargs, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__80)) __PYX_ERR(0, 609, __pyx_L1_error)
+  __pyx_tuple__80 = PyTuple_Pack(3, __pyx_n_s_name, __pyx_n_s_kwargs, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__80)) __PYX_ERR(0, 610, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__80);
   __Pyx_GIVEREF(__pyx_tuple__80);
-  __pyx_codeobj__81 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__80, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_get_compressor, 609, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__81)) __PYX_ERR(0, 609, __pyx_L1_error)
+  __pyx_codeobj__81 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__80, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_get_compressor, 610, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__81)) __PYX_ERR(0, 610, __pyx_L1_error)
 
-  /* "borg/compress.pyx":614
+  /* "borg/compress.pyx":615
  * 
  * # compressor instances to be used by all other compressors
  * NONE_COMPRESSOR = get_compressor('none')             # <<<<<<<<<<<<<<
  * LZ4_COMPRESSOR = get_compressor('lz4')
  * 
  */
-  __pyx_tuple__82 = PyTuple_Pack(1, __pyx_n_s_none); if (unlikely(!__pyx_tuple__82)) __PYX_ERR(0, 614, __pyx_L1_error)
+  __pyx_tuple__82 = PyTuple_Pack(1, __pyx_n_s_none); if (unlikely(!__pyx_tuple__82)) __PYX_ERR(0, 615, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__82);
   __Pyx_GIVEREF(__pyx_tuple__82);
 
-  /* "borg/compress.pyx":615
+  /* "borg/compress.pyx":616
  * # compressor instances to be used by all other compressors
  * NONE_COMPRESSOR = get_compressor('none')
  * LZ4_COMPRESSOR = get_compressor('lz4')             # <<<<<<<<<<<<<<
  * 
  * class Compressor:
  */
-  __pyx_tuple__83 = PyTuple_Pack(1, __pyx_n_s_lz4); if (unlikely(!__pyx_tuple__83)) __PYX_ERR(0, 615, __pyx_L1_error)
+  __pyx_tuple__83 = PyTuple_Pack(1, __pyx_n_s_lz4); if (unlikely(!__pyx_tuple__83)) __PYX_ERR(0, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__83);
   __Pyx_GIVEREF(__pyx_tuple__83);
 
-  /* "borg/compress.pyx":622
+  /* "borg/compress.pyx":623
  *     decompresses everything we can handle (autodetect)
  *     """
  *     def __init__(self, name='null', **kwargs):             # <<<<<<<<<<<<<<
  *         self.params = kwargs
  *         self.compressor = get_compressor(name, **self.params)
  */
-  __pyx_tuple__84 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_name, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__84)) __PYX_ERR(0, 622, __pyx_L1_error)
+  __pyx_tuple__84 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_name, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__84)) __PYX_ERR(0, 623, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__84);
   __Pyx_GIVEREF(__pyx_tuple__84);
-  __pyx_codeobj__85 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__84, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 622, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__85)) __PYX_ERR(0, 622, __pyx_L1_error)
-  __pyx_tuple__86 = PyTuple_Pack(1, ((PyObject*)__pyx_n_s_null)); if (unlikely(!__pyx_tuple__86)) __PYX_ERR(0, 622, __pyx_L1_error)
+  __pyx_codeobj__85 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__84, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 623, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__85)) __PYX_ERR(0, 623, __pyx_L1_error)
+  __pyx_tuple__86 = PyTuple_Pack(1, ((PyObject*)__pyx_n_s_null)); if (unlikely(!__pyx_tuple__86)) __PYX_ERR(0, 623, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__86);
   __Pyx_GIVEREF(__pyx_tuple__86);
 
-  /* "borg/compress.pyx":626
+  /* "borg/compress.pyx":627
  *         self.compressor = get_compressor(name, **self.params)
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self.compressor.compress(meta, data)
  * 
  */
-  __pyx_tuple__87 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__87)) __PYX_ERR(0, 626, __pyx_L1_error)
+  __pyx_tuple__87 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data); if (unlikely(!__pyx_tuple__87)) __PYX_ERR(0, 627, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__87);
   __Pyx_GIVEREF(__pyx_tuple__87);
-  __pyx_codeobj__88 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__87, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 626, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__88)) __PYX_ERR(0, 626, __pyx_L1_error)
+  __pyx_codeobj__88 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__87, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compress, 627, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__88)) __PYX_ERR(0, 627, __pyx_L1_error)
 
-  /* "borg/compress.pyx":629
+  /* "borg/compress.pyx":630
  *         return self.compressor.compress(meta, data)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         if self.compressor.legacy_mode:
  *             hdr = data[:2]
  */
-  __pyx_tuple__89 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_hdr, __pyx_n_s_ctype, __pyx_n_s_clevel, __pyx_n_s_compressor_cls); if (unlikely(!__pyx_tuple__89)) __PYX_ERR(0, 629, __pyx_L1_error)
+  __pyx_tuple__89 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_meta, __pyx_n_s_data, __pyx_n_s_hdr, __pyx_n_s_ctype, __pyx_n_s_clevel, __pyx_n_s_compressor_cls); if (unlikely(!__pyx_tuple__89)) __PYX_ERR(0, 630, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__89);
   __Pyx_GIVEREF(__pyx_tuple__89);
-  __pyx_codeobj__90 = (PyObject*)__Pyx_PyCode_New(3, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__89, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 629, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__90)) __PYX_ERR(0, 629, __pyx_L1_error)
+  __pyx_codeobj__90 = (PyObject*)__Pyx_PyCode_New(3, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__89, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_decompress, 630, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__90)) __PYX_ERR(0, 630, __pyx_L1_error)
 
-  /* "borg/compress.pyx":640
+  /* "borg/compress.pyx":641
  * 
  *     @staticmethod
  *     def detect(data):             # <<<<<<<<<<<<<<
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  */
-  __pyx_tuple__91 = PyTuple_Pack(4, __pyx_n_s_data, __pyx_n_s_hdr, __pyx_n_s_level, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__91)) __PYX_ERR(0, 640, __pyx_L1_error)
+  __pyx_tuple__91 = PyTuple_Pack(4, __pyx_n_s_data, __pyx_n_s_hdr, __pyx_n_s_level, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__91)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__91);
   __Pyx_GIVEREF(__pyx_tuple__91);
-  __pyx_codeobj__92 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__91, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_detect, 640, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__92)) __PYX_ERR(0, 640, __pyx_L1_error)
+  __pyx_codeobj__92 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__91, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_detect, 641, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__92)) __PYX_ERR(0, 641, __pyx_L1_error)
 
-  /* "borg/compress.pyx":651
+  /* "borg/compress.pyx":652
  * 
  * class CompressionSpec:
  *     def __init__(self, s):             # <<<<<<<<<<<<<<
  *         values = s.split(',')
  *         count = len(values)
  */
-  __pyx_tuple__93 = PyTuple_Pack(6, __pyx_n_s_self, __pyx_n_s_s, __pyx_n_s_values, __pyx_n_s_count, __pyx_n_s_level, __pyx_n_s_compression); if (unlikely(!__pyx_tuple__93)) __PYX_ERR(0, 651, __pyx_L1_error)
+  __pyx_tuple__93 = PyTuple_Pack(6, __pyx_n_s_self, __pyx_n_s_s, __pyx_n_s_values, __pyx_n_s_count, __pyx_n_s_level, __pyx_n_s_compression); if (unlikely(!__pyx_tuple__93)) __PYX_ERR(0, 652, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__93);
   __Pyx_GIVEREF(__pyx_tuple__93);
-  __pyx_codeobj__94 = (PyObject*)__Pyx_PyCode_New(2, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__93, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 651, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__94)) __PYX_ERR(0, 651, __pyx_L1_error)
+  __pyx_codeobj__94 = (PyObject*)__Pyx_PyCode_New(2, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__93, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_init, 652, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__94)) __PYX_ERR(0, 652, __pyx_L1_error)
 
-  /* "borg/compress.pyx":700
+  /* "borg/compress.pyx":701
  * 
  *     @property
  *     def compressor(self):             # <<<<<<<<<<<<<<
  *         if self.name in ('none', 'lz4', ):
  *             return get_compressor(self.name)
  */
-  __pyx_tuple__95 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__95)) __PYX_ERR(0, 700, __pyx_L1_error)
+  __pyx_tuple__95 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__95)) __PYX_ERR(0, 701, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__95);
   __Pyx_GIVEREF(__pyx_tuple__95);
-  __pyx_codeobj__96 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__95, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compressor, 700, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__96)) __PYX_ERR(0, 700, __pyx_L1_error)
+  __pyx_codeobj__96 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__95, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_compress_pyx, __pyx_n_s_compressor, 701, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__96)) __PYX_ERR(0, 701, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_CompressorBase(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
   __pyx_tuple__97 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__97)) __PYX_ERR(1, 1, __pyx_L1_error)
@@ -18883,34 +19076,34 @@
 static int __Pyx_modinit_type_init_code(void) {
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
-  if (PyType_Ready(&__pyx_type_4borg_8compress_CompressorBase) < 0) __PYX_ERR(0, 53, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_8compress_CompressorBase) < 0) __PYX_ERR(0, 54, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_8compress_CompressorBase.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_8compress_CompressorBase.tp_dictoffset && __pyx_type_4borg_8compress_CompressorBase.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_8compress_CompressorBase.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_CompressorBase, (PyObject *)&__pyx_type_4borg_8compress_CompressorBase) < 0) __PYX_ERR(0, 53, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_8compress_CompressorBase) < 0) __PYX_ERR(0, 53, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_CompressorBase, (PyObject *)&__pyx_type_4borg_8compress_CompressorBase) < 0) __PYX_ERR(0, 54, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_8compress_CompressorBase) < 0) __PYX_ERR(0, 54, __pyx_L1_error)
   __pyx_ptype_4borg_8compress_CompressorBase = &__pyx_type_4borg_8compress_CompressorBase;
   __pyx_type_4borg_8compress_DecidingCompressor.tp_base = __pyx_ptype_4borg_8compress_CompressorBase;
-  if (PyType_Ready(&__pyx_type_4borg_8compress_DecidingCompressor) < 0) __PYX_ERR(0, 130, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_8compress_DecidingCompressor) < 0) __PYX_ERR(0, 131, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_8compress_DecidingCompressor.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_8compress_DecidingCompressor.tp_dictoffset && __pyx_type_4borg_8compress_DecidingCompressor.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_8compress_DecidingCompressor.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_DecidingCompressor, (PyObject *)&__pyx_type_4borg_8compress_DecidingCompressor) < 0) __PYX_ERR(0, 130, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_8compress_DecidingCompressor) < 0) __PYX_ERR(0, 130, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_DecidingCompressor, (PyObject *)&__pyx_type_4borg_8compress_DecidingCompressor) < 0) __PYX_ERR(0, 131, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_8compress_DecidingCompressor) < 0) __PYX_ERR(0, 131, __pyx_L1_error)
   __pyx_ptype_4borg_8compress_DecidingCompressor = &__pyx_type_4borg_8compress_DecidingCompressor;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
@@ -19150,57 +19343,78 @@
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
 
   /* "borg/compress.pyx":18
  * """
  * 
- * import random             # <<<<<<<<<<<<<<
+ * from argparse import ArgumentTypeError             # <<<<<<<<<<<<<<
+ * import random
  * from struct import Struct
- * import zlib
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_random, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_n_s_ArgumentTypeError);
+  __Pyx_GIVEREF(__pyx_n_s_ArgumentTypeError);
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_ArgumentTypeError);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_argparse, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_ArgumentTypeError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_random, __pyx_t_1) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ArgumentTypeError, __pyx_t_1) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "borg/compress.pyx":19
  * 
+ * from argparse import ArgumentTypeError
+ * import random             # <<<<<<<<<<<<<<
+ * from struct import Struct
+ * import zlib
+ */
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_random, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 19, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_random, __pyx_t_2) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "borg/compress.pyx":20
+ * from argparse import ArgumentTypeError
  * import random
  * from struct import Struct             # <<<<<<<<<<<<<<
  * import zlib
  * 
  */
-  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 19, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_Struct);
   __Pyx_GIVEREF(__pyx_n_s_Struct);
-  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Struct);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_struct, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 19, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Struct); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 19, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_Struct);
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, __pyx_t_2, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 20, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Struct, __pyx_t_1) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Struct); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Struct, __pyx_t_2) < 0) __PYX_ERR(0, 20, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":20
+  /* "borg/compress.pyx":21
  * import random
  * from struct import Struct
  * import zlib             # <<<<<<<<<<<<<<
  * 
  * try:
  */
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_zlib, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_zlib, __pyx_t_2) < 0) __PYX_ERR(0, 20, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_zlib, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 21, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_zlib, __pyx_t_1) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":22
+  /* "borg/compress.pyx":23
  * import zlib
  * 
  * try:             # <<<<<<<<<<<<<<
  *     import lzma
  * except ImportError:
  */
   {
@@ -19208,27 +19422,27 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
     __Pyx_XGOTREF(__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_4);
     __Pyx_XGOTREF(__pyx_t_5);
     /*try:*/ {
 
-      /* "borg/compress.pyx":23
+      /* "borg/compress.pyx":24
  * 
  * try:
  *     import lzma             # <<<<<<<<<<<<<<
  * except ImportError:
  *     lzma = None
  */
-      __pyx_t_2 = __Pyx_Import(__pyx_n_s_lzma, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 23, __pyx_L2_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      if (PyDict_SetItem(__pyx_d, __pyx_n_s_lzma, __pyx_t_2) < 0) __PYX_ERR(0, 23, __pyx_L2_error)
-      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_t_1 = __Pyx_Import(__pyx_n_s_lzma, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 24, __pyx_L2_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (PyDict_SetItem(__pyx_d, __pyx_n_s_lzma, __pyx_t_1) < 0) __PYX_ERR(0, 24, __pyx_L2_error)
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-      /* "borg/compress.pyx":22
+      /* "borg/compress.pyx":23
  * import zlib
  * 
  * try:             # <<<<<<<<<<<<<<
  *     import lzma
  * except ImportError:
  */
     }
@@ -19236,46 +19450,46 @@
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     goto __pyx_L7_try_end;
     __pyx_L2_error:;
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-    /* "borg/compress.pyx":24
+    /* "borg/compress.pyx":25
  * try:
  *     import lzma
  * except ImportError:             # <<<<<<<<<<<<<<
  *     lzma = None
  * 
  */
     __pyx_t_6 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ImportError);
     if (__pyx_t_6) {
       __Pyx_AddTraceback("borg.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_1, &__pyx_t_7) < 0) __PYX_ERR(0, 24, __pyx_L4_except_error)
-      __Pyx_GOTREF(__pyx_t_2);
+      if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_2, &__pyx_t_7) < 0) __PYX_ERR(0, 25, __pyx_L4_except_error)
       __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_GOTREF(__pyx_t_2);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "borg/compress.pyx":25
+      /* "borg/compress.pyx":26
  *     import lzma
  * except ImportError:
  *     lzma = None             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      if (PyDict_SetItem(__pyx_d, __pyx_n_s_lzma, Py_None) < 0) __PYX_ERR(0, 25, __pyx_L4_except_error)
-      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+      if (PyDict_SetItem(__pyx_d, __pyx_n_s_lzma, Py_None) < 0) __PYX_ERR(0, 26, __pyx_L4_except_error)
       __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
       goto __pyx_L3_exception_handled;
     }
     goto __pyx_L4_except_error;
     __pyx_L4_except_error:;
 
-    /* "borg/compress.pyx":22
+    /* "borg/compress.pyx":23
  * import zlib
  * 
  * try:             # <<<<<<<<<<<<<<
  *     import lzma
  * except ImportError:
  */
     __Pyx_XGIVEREF(__pyx_t_3);
@@ -19287,1459 +19501,1459 @@
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_XGIVEREF(__pyx_t_5);
     __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
     __pyx_L7_try_end:;
   }
 
-  /* "borg/compress.pyx":28
+  /* "borg/compress.pyx":29
  * 
  * 
  * from .constants import MAX_DATA_SIZE             # <<<<<<<<<<<<<<
  * from .helpers import Buffer, DecompressionError
  * 
  */
-  __pyx_t_7 = PyList_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 28, __pyx_L1_error)
+  __pyx_t_7 = PyList_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 29, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_n_s_MAX_DATA_SIZE);
   __Pyx_GIVEREF(__pyx_n_s_MAX_DATA_SIZE);
   PyList_SET_ITEM(__pyx_t_7, 0, __pyx_n_s_MAX_DATA_SIZE);
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_constants, __pyx_t_7, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_constants, __pyx_t_7, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 29, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_MAX_DATA_SIZE); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 28, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_MAX_DATA_SIZE); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 29, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_MAX_DATA_SIZE, __pyx_t_7) < 0) __PYX_ERR(0, 28, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_MAX_DATA_SIZE, __pyx_t_7) < 0) __PYX_ERR(0, 29, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/compress.pyx":29
+  /* "borg/compress.pyx":30
  * 
  * from .constants import MAX_DATA_SIZE
  * from .helpers import Buffer, DecompressionError             # <<<<<<<<<<<<<<
  * 
  * API_VERSION = '1.2_02'
  */
-  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_Buffer);
   __Pyx_GIVEREF(__pyx_n_s_Buffer);
-  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Buffer);
+  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_Buffer);
   __Pyx_INCREF(__pyx_n_s_DecompressionError);
   __Pyx_GIVEREF(__pyx_n_s_DecompressionError);
-  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_DecompressionError);
-  __pyx_t_7 = __Pyx_Import(__pyx_n_s_helpers, __pyx_t_1, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 29, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_DecompressionError);
+  __pyx_t_7 = __Pyx_Import(__pyx_n_s_helpers, __pyx_t_2, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_7, __pyx_n_s_Buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Buffer, __pyx_t_1) < 0) __PYX_ERR(0, 29, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_7, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DecompressionError, __pyx_t_1) < 0) __PYX_ERR(0, 29, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_7, __pyx_n_s_Buffer); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Buffer, __pyx_t_2) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_7, __pyx_n_s_DecompressionError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DecompressionError, __pyx_t_2) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":31
+  /* "borg/compress.pyx":32
  * from .helpers import Buffer, DecompressionError
  * 
  * API_VERSION = '1.2_02'             # <<<<<<<<<<<<<<
  * 
  * cdef extern from "lz4.h":
  */
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_API_VERSION, __pyx_kp_s_1_2_02) < 0) __PYX_ERR(0, 31, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_API_VERSION, __pyx_kp_s_1_2_02) < 0) __PYX_ERR(0, 32, __pyx_L1_error)
 
-  /* "borg/compress.pyx":50
+  /* "borg/compress.pyx":51
  * 
  * 
  * buffer = Buffer(bytearray, size=0)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_Buffer); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 50, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_Buffer); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 51, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 51, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(((PyObject *)(&PyByteArray_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyByteArray_Type)));
-  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyByteArray_Type)));
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_size, __pyx_int_0) < 0) __PYX_ERR(0, 50, __pyx_L1_error)
-  __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 50, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyByteArray_Type)));
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 51, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_size, __pyx_int_0) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 51, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_buffer, __pyx_t_8) < 0) __PYX_ERR(0, 50, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_buffer, __pyx_t_8) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-  /* "borg/compress.pyx":59
+  /* "borg/compress.pyx":60
  *     adding/stripping the ID header (which enable auto detection).
  *     """
  *     ID = 0xFF  # reserved and not used             # <<<<<<<<<<<<<<
  *                # overwrite with a unique 1-byte bytestring in child classes
  *     name = 'baseclass'
  */
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase->tp_dict, __pyx_n_s_ID, __pyx_int_255) < 0) __PYX_ERR(0, 59, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase->tp_dict, __pyx_n_s_ID, __pyx_int_255) < 0) __PYX_ERR(0, 60, __pyx_L1_error)
   PyType_Modified(__pyx_ptype_4borg_8compress_CompressorBase);
 
-  /* "borg/compress.pyx":61
+  /* "borg/compress.pyx":62
  *     ID = 0xFF  # reserved and not used
  *                # overwrite with a unique 1-byte bytestring in child classes
  *     name = 'baseclass'             # <<<<<<<<<<<<<<
  * 
  *     @classmethod
  */
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase->tp_dict, __pyx_n_s_name, __pyx_n_s_baseclass) < 0) __PYX_ERR(0, 61, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase->tp_dict, __pyx_n_s_name, __pyx_n_s_baseclass) < 0) __PYX_ERR(0, 62, __pyx_L1_error)
   PyType_Modified(__pyx_ptype_4borg_8compress_CompressorBase);
 
-  /* "borg/compress.pyx":64
+  /* "borg/compress.pyx":65
  * 
  *     @classmethod
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         return data and data[0] == cls.ID
  * 
  */
-  __Pyx_GetNameInClass(__pyx_t_8, (PyObject *)__pyx_ptype_4borg_8compress_CompressorBase, __pyx_n_s_detect); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __Pyx_GetNameInClass(__pyx_t_8, (PyObject *)__pyx_ptype_4borg_8compress_CompressorBase, __pyx_n_s_detect); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 65, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
 
-  /* "borg/compress.pyx":63
+  /* "borg/compress.pyx":64
  *     name = 'baseclass'
  * 
  *     @classmethod             # <<<<<<<<<<<<<<
  *     def detect(cls, data):
  *         return data and data[0] == cls.ID
  */
-  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 63, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase->tp_dict, __pyx_n_s_detect, __pyx_t_2) < 0) __PYX_ERR(0, 64, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase->tp_dict, __pyx_n_s_detect, __pyx_t_1) < 0) __PYX_ERR(0, 65, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_8compress_CompressorBase);
 
-  /* "borg/compress.pyx":135
+  /* "borg/compress.pyx":136
  *     method) decide whether and how to compress data.
  *     """
  *     name = 'decidebaseclass'             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):
  */
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor->tp_dict, __pyx_n_s_name, __pyx_n_s_decidebaseclass) < 0) __PYX_ERR(0, 135, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor->tp_dict, __pyx_n_s_name, __pyx_n_s_decidebaseclass) < 0) __PYX_ERR(0, 136, __pyx_L1_error)
   PyType_Modified(__pyx_ptype_4borg_8compress_DecidingCompressor);
 
-  /* "borg/compress.pyx":176
+  /* "borg/compress.pyx":177
  *         return self.decide_compress(meta, data)[1]
  * 
  * class CNONE(CompressorBase):             # <<<<<<<<<<<<<<
  *     """
  *     none - no compression, just pass through data
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 176, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 177, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
-  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 176, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
+  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 177, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_2, __pyx_n_s_CNONE, __pyx_n_s_CNONE, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_none_no_compression_just_pass_t); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 176, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = PyList_New(0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 176, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_1, __pyx_n_s_CNONE, __pyx_n_s_CNONE, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_none_no_compression_just_pass_t); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 177, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_7 = PyList_New(0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 177, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
 
-  /* "borg/compress.pyx":180
+  /* "borg/compress.pyx":181
  *     none - no compression, just pass through data
  *     """
  *     ID = 0x00             # <<<<<<<<<<<<<<
  *     name = 'none'
  * 
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_ID, __pyx_int_0) < 0) __PYX_ERR(0, 180, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_ID, __pyx_int_0) < 0) __PYX_ERR(0, 181, __pyx_L1_error)
 
-  /* "borg/compress.pyx":181
+  /* "borg/compress.pyx":182
  *     """
  *     ID = 0x00
  *     name = 'none'             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_name, __pyx_n_s_none) < 0) __PYX_ERR(0, 181, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_name, __pyx_n_s_none) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
 
-  /* "borg/compress.pyx":183
+  /* "borg/compress.pyx":184
  *     name = 'none'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for CNONE, so just say "unknown"
  * 
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_5CNONE_1__init__, 0, __pyx_n_s_CNONE___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__12)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 183, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_5CNONE_1__init__, 0, __pyx_n_s_CNONE___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__12)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 184, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_INCREF(__pyx_t_9);
   PyList_Append(__pyx_t_7, __pyx_t_9);
   __Pyx_GIVEREF(__pyx_t_9);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_9, __pyx_tuple__13);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_9) < 0) __PYX_ERR(0, 183, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_9) < 0) __PYX_ERR(0, 184, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":186
+  /* "borg/compress.pyx":187
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for CNONE, so just say "unknown"
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta["size"] = len(data)
  *         return super().compress(meta, data)
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_5CNONE_3compress, 0, __pyx_n_s_CNONE_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__15)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 186, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_5CNONE_3compress, 0, __pyx_n_s_CNONE_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__15)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 187, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_INCREF(__pyx_t_9);
   PyList_Append(__pyx_t_7, __pyx_t_9);
   __Pyx_GIVEREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_compress, __pyx_t_9) < 0) __PYX_ERR(0, 186, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_compress, __pyx_t_9) < 0) __PYX_ERR(0, 187, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":190
+  /* "borg/compress.pyx":191
  *         return super().compress(meta, data)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         if not isinstance(data, bytes):
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_5CNONE_5decompress, 0, __pyx_n_s_CNONE_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__17)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_5CNONE_5decompress, 0, __pyx_n_s_CNONE_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__17)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 191, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_INCREF(__pyx_t_9);
   PyList_Append(__pyx_t_7, __pyx_t_9);
   __Pyx_GIVEREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decompress, __pyx_t_9) < 0) __PYX_ERR(0, 190, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decompress, __pyx_t_9) < 0) __PYX_ERR(0, 191, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":176
+  /* "borg/compress.pyx":177
  *         return self.decide_compress(meta, data)[1]
  * 
  * class CNONE(CompressorBase):             # <<<<<<<<<<<<<<
  *     """
  *     none - no compression, just pass through data
  */
-  __pyx_t_9 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_CNONE, __pyx_t_2, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 176, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_CNONE, __pyx_t_1, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 177, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_7, __pyx_t_9) < 0) __PYX_ERR(0, 176, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_7, __pyx_t_9) < 0) __PYX_ERR(0, 177, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CNONE, __pyx_t_9) < 0) __PYX_ERR(0, 176, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CNONE, __pyx_t_9) < 0) __PYX_ERR(0, 177, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":198
+  /* "borg/compress.pyx":199
  * 
  * 
  * class LZ4(DecidingCompressor):             # <<<<<<<<<<<<<<
  *     """
  *     raw LZ4 compression / decompression (liblz4).
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 198, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 199, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
-  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 198, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
+  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 199, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_2, __pyx_n_s_LZ4, __pyx_n_s_LZ4, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_raw_LZ4_compression_decompressi); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 198, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 198, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_1, __pyx_n_s_LZ4, __pyx_n_s_LZ4, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_raw_LZ4_compression_decompressi); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 199, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 199, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
 
-  /* "borg/compress.pyx":207
+  /* "borg/compress.pyx":208
  *         - uses safe lz4 methods that never go beyond the end of the output buffer
  *     """
  *     ID = 0x01             # <<<<<<<<<<<<<<
  *     name = 'lz4'
  * 
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_ID, __pyx_int_1) < 0) __PYX_ERR(0, 207, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_ID, __pyx_int_1) < 0) __PYX_ERR(0, 208, __pyx_L1_error)
 
-  /* "borg/compress.pyx":208
+  /* "borg/compress.pyx":209
  *     """
  *     ID = 0x01
  *     name = 'lz4'             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_name, __pyx_n_s_lz4) < 0) __PYX_ERR(0, 208, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_name, __pyx_n_s_lz4) < 0) __PYX_ERR(0, 209, __pyx_L1_error)
 
-  /* "borg/compress.pyx":210
+  /* "borg/compress.pyx":211
  *     name = 'lz4'
  * 
  *     def __init__(self, level=255, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for LZ4, so just say "unknown"
  * 
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_3LZ4_1__init__, 0, __pyx_n_s_LZ4___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__19)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 210, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_3LZ4_1__init__, 0, __pyx_n_s_LZ4___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__19)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 211, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_t_7);
   PyList_Append(__pyx_t_9, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_7, __pyx_tuple__20);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_7) < 0) __PYX_ERR(0, 210, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_7) < 0) __PYX_ERR(0, 211, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":213
+  /* "borg/compress.pyx":214
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)  # no defined levels for LZ4, so just say "unknown"
  * 
  *     def _decide(self, meta, idata):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, lz4_data).
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_3LZ4_3_decide, 0, __pyx_n_s_LZ4__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__22)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 213, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_3LZ4_3_decide, 0, __pyx_n_s_LZ4__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__22)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 214, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decide, __pyx_t_7) < 0) __PYX_ERR(0, 213, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decide, __pyx_t_7) < 0) __PYX_ERR(0, 214, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":238
+  /* "borg/compress.pyx":239
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_3LZ4_5decompress, 0, __pyx_n_s_LZ4_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__24)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_3LZ4_5decompress, 0, __pyx_n_s_LZ4_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__24)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 239, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_t_7);
   PyList_Append(__pyx_t_9, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decompress, __pyx_t_7) < 0) __PYX_ERR(0, 238, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decompress, __pyx_t_7) < 0) __PYX_ERR(0, 239, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":198
+  /* "borg/compress.pyx":199
  * 
  * 
  * class LZ4(DecidingCompressor):             # <<<<<<<<<<<<<<
  *     """
  *     raw LZ4 compression / decompression (liblz4).
  */
-  __pyx_t_7 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_LZ4, __pyx_t_2, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 198, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_LZ4, __pyx_t_1, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 199, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_9, __pyx_t_7) < 0) __PYX_ERR(0, 198, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_9, __pyx_t_7) < 0) __PYX_ERR(0, 199, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LZ4, __pyx_t_7) < 0) __PYX_ERR(0, 198, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LZ4, __pyx_t_7) < 0) __PYX_ERR(0, 199, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":270
+  /* "borg/compress.pyx":271
  * 
  * 
  * class LZMA(DecidingCompressor):             # <<<<<<<<<<<<<<
  *     """
  *     lzma compression / decompression
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 270, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 271, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
-  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 270, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
+  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 271, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_2, __pyx_n_s_LZMA, __pyx_n_s_LZMA, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_lzma_compression_decompression); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 270, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = PyList_New(0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 270, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_1, __pyx_n_s_LZMA, __pyx_n_s_LZMA, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_lzma_compression_decompression); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 271, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_7 = PyList_New(0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 271, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
 
-  /* "borg/compress.pyx":274
+  /* "borg/compress.pyx":275
  *     lzma compression / decompression
  *     """
  *     ID = 0x02             # <<<<<<<<<<<<<<
  *     name = 'lzma'
  * 
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_ID, __pyx_int_2) < 0) __PYX_ERR(0, 274, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_ID, __pyx_int_2) < 0) __PYX_ERR(0, 275, __pyx_L1_error)
 
-  /* "borg/compress.pyx":275
+  /* "borg/compress.pyx":276
  *     """
  *     ID = 0x02
  *     name = 'lzma'             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_name, __pyx_n_s_lzma) < 0) __PYX_ERR(0, 275, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_name, __pyx_n_s_lzma) < 0) __PYX_ERR(0, 276, __pyx_L1_error)
 
-  /* "borg/compress.pyx":277
+  /* "borg/compress.pyx":278
  *     name = 'lzma'
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4LZMA_1__init__, 0, __pyx_n_s_LZMA___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__26)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 277, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4LZMA_1__init__, 0, __pyx_n_s_LZMA___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__26)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 278, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_INCREF(__pyx_t_9);
   PyList_Append(__pyx_t_7, __pyx_t_9);
   __Pyx_GIVEREF(__pyx_t_9);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_9, __pyx_tuple__27);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_9) < 0) __PYX_ERR(0, 277, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_9) < 0) __PYX_ERR(0, 278, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":283
+  /* "borg/compress.pyx":284
  *             raise ValueError('No lzma support found.')
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, lzma_data).
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4LZMA_3_decide, 0, __pyx_n_s_LZMA__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__29)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 283, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4LZMA_3_decide, 0, __pyx_n_s_LZMA__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__29)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 284, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decide, __pyx_t_9) < 0) __PYX_ERR(0, 283, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decide, __pyx_t_9) < 0) __PYX_ERR(0, 284, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":296
+  /* "borg/compress.pyx":297
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         try:
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4LZMA_5decompress, 0, __pyx_n_s_LZMA_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__31)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 296, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4LZMA_5decompress, 0, __pyx_n_s_LZMA_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__31)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 297, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_INCREF(__pyx_t_9);
   PyList_Append(__pyx_t_7, __pyx_t_9);
   __Pyx_GIVEREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decompress, __pyx_t_9) < 0) __PYX_ERR(0, 296, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decompress, __pyx_t_9) < 0) __PYX_ERR(0, 297, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":270
+  /* "borg/compress.pyx":271
  * 
  * 
  * class LZMA(DecidingCompressor):             # <<<<<<<<<<<<<<
  *     """
  *     lzma compression / decompression
  */
-  __pyx_t_9 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_LZMA, __pyx_t_2, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 270, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_LZMA, __pyx_t_1, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 271, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_7, __pyx_t_9) < 0) __PYX_ERR(0, 270, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_7, __pyx_t_9) < 0) __PYX_ERR(0, 271, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LZMA, __pyx_t_9) < 0) __PYX_ERR(0, 270, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LZMA, __pyx_t_9) < 0) __PYX_ERR(0, 271, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":306
+  /* "borg/compress.pyx":307
  * 
  * 
  * class ZSTD(DecidingCompressor):             # <<<<<<<<<<<<<<
  *     """zstd compression / decompression (pypi: zstandard, gh: python-zstandard)"""
  *     # This is a NOT THREAD SAFE implementation.
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 306, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 307, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
-  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 306, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
+  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 307, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_2, __pyx_n_s_ZSTD, __pyx_n_s_ZSTD, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_zstd_compression_decompression_p); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 306, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 306, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_1, __pyx_n_s_ZSTD, __pyx_n_s_ZSTD, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_zstd_compression_decompression_p); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 307, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 307, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
 
-  /* "borg/compress.pyx":311
+  /* "borg/compress.pyx":312
  *     # Only ONE python context must be created at a time.
  *     # It should work flawlessly as long as borg will call ONLY ONE compression job at time.
  *     ID = 0x03             # <<<<<<<<<<<<<<
  *     name = 'zstd'
  * 
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_ID, __pyx_int_3) < 0) __PYX_ERR(0, 311, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_ID, __pyx_int_3) < 0) __PYX_ERR(0, 312, __pyx_L1_error)
 
-  /* "borg/compress.pyx":312
+  /* "borg/compress.pyx":313
  *     # It should work flawlessly as long as borg will call ONLY ONE compression job at time.
  *     ID = 0x03
  *     name = 'zstd'             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, level=3, legacy_mode=False, **kwargs):
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_name, __pyx_n_s_zstd) < 0) __PYX_ERR(0, 312, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_name, __pyx_n_s_zstd) < 0) __PYX_ERR(0, 313, __pyx_L1_error)
 
-  /* "borg/compress.pyx":314
+  /* "borg/compress.pyx":315
  *     name = 'zstd'
  * 
  *     def __init__(self, level=3, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZSTD_1__init__, 0, __pyx_n_s_ZSTD___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__33)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 314, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZSTD_1__init__, 0, __pyx_n_s_ZSTD___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__33)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 315, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_t_7);
   PyList_Append(__pyx_t_9, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_7, __pyx_tuple__34);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_7) < 0) __PYX_ERR(0, 314, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_7) < 0) __PYX_ERR(0, 315, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":318
+  /* "borg/compress.pyx":319
  *         self.level = level
  * 
  *     def _decide(self, meta, idata):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, zstd_data).
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZSTD_3_decide, 0, __pyx_n_s_ZSTD__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 318, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZSTD_3_decide, 0, __pyx_n_s_ZSTD__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 319, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decide, __pyx_t_7) < 0) __PYX_ERR(0, 318, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decide, __pyx_t_7) < 0) __PYX_ERR(0, 319, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":344
+  /* "borg/compress.pyx":345
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, idata = super().decompress(meta, data)
  *         if not isinstance(idata, bytes):
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZSTD_5decompress, 0, __pyx_n_s_ZSTD_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__38)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 344, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZSTD_5decompress, 0, __pyx_n_s_ZSTD_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__38)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 345, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_t_7);
   PyList_Append(__pyx_t_9, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decompress, __pyx_t_7) < 0) __PYX_ERR(0, 344, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decompress, __pyx_t_7) < 0) __PYX_ERR(0, 345, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":306
+  /* "borg/compress.pyx":307
  * 
  * 
  * class ZSTD(DecidingCompressor):             # <<<<<<<<<<<<<<
  *     """zstd compression / decompression (pypi: zstandard, gh: python-zstandard)"""
  *     # This is a NOT THREAD SAFE implementation.
  */
-  __pyx_t_7 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_ZSTD, __pyx_t_2, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 306, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_ZSTD, __pyx_t_1, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 307, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_9, __pyx_t_7) < 0) __PYX_ERR(0, 306, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_9, __pyx_t_7) < 0) __PYX_ERR(0, 307, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ZSTD, __pyx_t_7) < 0) __PYX_ERR(0, 306, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ZSTD, __pyx_t_7) < 0) __PYX_ERR(0, 307, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":374
+  /* "borg/compress.pyx":375
  * 
  * 
  * class ZLIB(DecidingCompressor):             # <<<<<<<<<<<<<<
  *     """
  *     zlib compression / decompression (python stdlib)
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 374, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 375, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
-  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 374, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_8compress_DecidingCompressor));
+  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 375, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_2, __pyx_n_s_ZLIB, __pyx_n_s_ZLIB, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_zlib_compression_decompression); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 374, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = PyList_New(0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 374, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_1, __pyx_n_s_ZLIB, __pyx_n_s_ZLIB, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_zlib_compression_decompression); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 375, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_7 = PyList_New(0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 375, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
 
-  /* "borg/compress.pyx":378
+  /* "borg/compress.pyx":379
  *     zlib compression / decompression (python stdlib)
  *     """
  *     ID = 0x05             # <<<<<<<<<<<<<<
  *     name = 'zlib'
  * 
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_ID, __pyx_int_5) < 0) __PYX_ERR(0, 378, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_ID, __pyx_int_5) < 0) __PYX_ERR(0, 379, __pyx_L1_error)
 
-  /* "borg/compress.pyx":379
+  /* "borg/compress.pyx":380
  *     """
  *     ID = 0x05
  *     name = 'zlib'             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_name, __pyx_n_s_zlib) < 0) __PYX_ERR(0, 379, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_name, __pyx_n_s_zlib) < 0) __PYX_ERR(0, 380, __pyx_L1_error)
 
-  /* "borg/compress.pyx":381
+  /* "borg/compress.pyx":382
  *     name = 'zlib'
  * 
  *     def __init__(self, level=6, legacy_mode=False, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode, **kwargs)
  *         self.level = level
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZLIB_1__init__, 0, __pyx_n_s_ZLIB___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__40)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 381, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZLIB_1__init__, 0, __pyx_n_s_ZLIB___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__40)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 382, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_INCREF(__pyx_t_9);
   PyList_Append(__pyx_t_7, __pyx_t_9);
   __Pyx_GIVEREF(__pyx_t_9);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_9, __pyx_tuple__41);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_9) < 0) __PYX_ERR(0, 381, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_9) < 0) __PYX_ERR(0, 382, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":385
+  /* "borg/compress.pyx":386
  *         self.level = level
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, zlib_data).
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZLIB_3_decide, 0, __pyx_n_s_ZLIB__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__43)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 385, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZLIB_3_decide, 0, __pyx_n_s_ZLIB__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__43)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 386, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decide, __pyx_t_9) < 0) __PYX_ERR(0, 385, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decide, __pyx_t_9) < 0) __PYX_ERR(0, 386, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":397
+  /* "borg/compress.pyx":398
  *             return NONE_COMPRESSOR, (meta, None)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         meta, data = super().decompress(meta, data)
  *         try:
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZLIB_5decompress, 0, __pyx_n_s_ZLIB_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__45)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 397, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4ZLIB_5decompress, 0, __pyx_n_s_ZLIB_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__45)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 398, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_INCREF(__pyx_t_9);
   PyList_Append(__pyx_t_7, __pyx_t_9);
   __Pyx_GIVEREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decompress, __pyx_t_9) < 0) __PYX_ERR(0, 397, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decompress, __pyx_t_9) < 0) __PYX_ERR(0, 398, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":374
+  /* "borg/compress.pyx":375
  * 
  * 
  * class ZLIB(DecidingCompressor):             # <<<<<<<<<<<<<<
  *     """
  *     zlib compression / decompression (python stdlib)
  */
-  __pyx_t_9 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_ZLIB, __pyx_t_2, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 374, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_ZLIB, __pyx_t_1, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 375, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_7, __pyx_t_9) < 0) __PYX_ERR(0, 374, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_7, __pyx_t_9) < 0) __PYX_ERR(0, 375, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ZLIB, __pyx_t_9) < 0) __PYX_ERR(0, 374, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ZLIB, __pyx_t_9) < 0) __PYX_ERR(0, 375, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":407
+  /* "borg/compress.pyx":408
  * 
  * 
  * class ZLIB_legacy(CompressorBase):             # <<<<<<<<<<<<<<
  *     """
  *     zlib compression / decompression (python stdlib)
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 407, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 408, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
-  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 407, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
+  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 408, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_2, __pyx_n_s_ZLIB_legacy, __pyx_n_s_ZLIB_legacy, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_zlib_compression_decompression_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 407, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 407, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_1, __pyx_n_s_ZLIB_legacy, __pyx_n_s_ZLIB_legacy, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_zlib_compression_decompression_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 408, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 408, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
 
-  /* "borg/compress.pyx":418
+  /* "borg/compress.pyx":419
  *           compressors) and does not need this hack.
  *     """
  *     ID = 0x08  # not used here, see detect()             # <<<<<<<<<<<<<<
  *     # avoid all 0x.8 IDs elsewhere!
  *     name = 'zlib_legacy'
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_ID, __pyx_int_8) < 0) __PYX_ERR(0, 418, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_ID, __pyx_int_8) < 0) __PYX_ERR(0, 419, __pyx_L1_error)
 
-  /* "borg/compress.pyx":420
+  /* "borg/compress.pyx":421
  *     ID = 0x08  # not used here, see detect()
  *     # avoid all 0x.8 IDs elsewhere!
  *     name = 'zlib_legacy'             # <<<<<<<<<<<<<<
  * 
  *     @classmethod
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_name, __pyx_n_s_zlib_legacy) < 0) __PYX_ERR(0, 420, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_name, __pyx_n_s_zlib_legacy) < 0) __PYX_ERR(0, 421, __pyx_L1_error)
 
-  /* "borg/compress.pyx":423
+  /* "borg/compress.pyx":424
  * 
  *     @classmethod
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         # matches misc. patterns 0x.8.. used by zlib
  *         cmf, flg = data[:2]
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_11ZLIB_legacy_1detect, __Pyx_CYFUNCTION_CLASSMETHOD, __pyx_n_s_ZLIB_legacy_detect, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__47)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 423, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_11ZLIB_legacy_1detect, __Pyx_CYFUNCTION_CLASSMETHOD, __pyx_n_s_ZLIB_legacy_detect, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__47)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 424, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
 
-  /* "borg/compress.pyx":422
+  /* "borg/compress.pyx":423
  *     name = 'zlib_legacy'
  * 
  *     @classmethod             # <<<<<<<<<<<<<<
  *     def detect(cls, data):
  *         # matches misc. patterns 0x.8.. used by zlib
  */
-  __pyx_t_10 = __Pyx_Method_ClassMethod(__pyx_t_7); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 422, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_Method_ClassMethod(__pyx_t_7); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 423, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_detect, __pyx_t_10) < 0) __PYX_ERR(0, 423, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_detect, __pyx_t_10) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":430
+  /* "borg/compress.pyx":431
  *         return check_ok and is_deflate
  * 
  *     def __init__(self, level=6, **kwargs):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, **kwargs)
  *         self.level = level
  */
-  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_11ZLIB_legacy_3__init__, 0, __pyx_n_s_ZLIB_legacy___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__49)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 430, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_11ZLIB_legacy_3__init__, 0, __pyx_n_s_ZLIB_legacy___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__49)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 431, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
   __Pyx_INCREF(__pyx_t_10);
   PyList_Append(__pyx_t_9, __pyx_t_10);
   __Pyx_GIVEREF(__pyx_t_10);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_10, __pyx_tuple__50);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_10) < 0) __PYX_ERR(0, 430, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_10) < 0) __PYX_ERR(0, 431, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":434
+  /* "borg/compress.pyx":435
  *         self.level = level
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         # note: for compatibility no super call, do not add ID bytes
  *         return None, zlib.compress(data, self.level)
  */
-  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_11ZLIB_legacy_5compress, 0, __pyx_n_s_ZLIB_legacy_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__52)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 434, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_11ZLIB_legacy_5compress, 0, __pyx_n_s_ZLIB_legacy_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__52)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 435, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_compress, __pyx_t_10) < 0) __PYX_ERR(0, 434, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_compress, __pyx_t_10) < 0) __PYX_ERR(0, 435, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":438
+  /* "borg/compress.pyx":439
  *         return None, zlib.compress(data, self.level)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         # note: for compatibility no super call, do not strip ID bytes
  *         try:
  */
-  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_11ZLIB_legacy_7decompress, 0, __pyx_n_s_ZLIB_legacy_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__54)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 438, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_11ZLIB_legacy_7decompress, 0, __pyx_n_s_ZLIB_legacy_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__54)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 439, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decompress, __pyx_t_10) < 0) __PYX_ERR(0, 438, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decompress, __pyx_t_10) < 0) __PYX_ERR(0, 439, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":407
+  /* "borg/compress.pyx":408
  * 
  * 
  * class ZLIB_legacy(CompressorBase):             # <<<<<<<<<<<<<<
  *     """
  *     zlib compression / decompression (python stdlib)
  */
-  __pyx_t_10 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_ZLIB_legacy, __pyx_t_2, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 407, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_ZLIB_legacy, __pyx_t_1, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 408, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_9, __pyx_t_10) < 0) __PYX_ERR(0, 407, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_9, __pyx_t_10) < 0) __PYX_ERR(0, 408, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ZLIB_legacy, __pyx_t_10) < 0) __PYX_ERR(0, 407, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ZLIB_legacy, __pyx_t_10) < 0) __PYX_ERR(0, 408, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":446
+  /* "borg/compress.pyx":447
  * 
  * 
  * class Auto(CompressorBase):             # <<<<<<<<<<<<<<
  *     """
  *     Meta-Compressor that decides which compression to use based on LZ4's ratio.
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 446, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 447, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
-  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 446, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
+  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 447, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_2, __pyx_n_s_Auto, __pyx_n_s_Auto, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_Meta_Compressor_that_decides_wh); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 446, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_10 = PyList_New(0); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 446, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_1, __pyx_n_s_Auto, __pyx_n_s_Auto, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_Meta_Compressor_that_decides_wh); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 447, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_10 = PyList_New(0); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 447, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
 
-  /* "borg/compress.pyx":454
+  /* "borg/compress.pyx":455
  *     """
  * 
  *     ID = None             # <<<<<<<<<<<<<<
  *     name = 'auto'
  * 
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_ID, Py_None) < 0) __PYX_ERR(0, 454, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_ID, Py_None) < 0) __PYX_ERR(0, 455, __pyx_L1_error)
 
-  /* "borg/compress.pyx":455
+  /* "borg/compress.pyx":456
  * 
  *     ID = None
  *     name = 'auto'             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, compressor):
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_name, __pyx_n_s_auto) < 0) __PYX_ERR(0, 455, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_name, __pyx_n_s_auto) < 0) __PYX_ERR(0, 456, __pyx_L1_error)
 
-  /* "borg/compress.pyx":457
+  /* "borg/compress.pyx":458
  *     name = 'auto'
  * 
  *     def __init__(self, compressor):             # <<<<<<<<<<<<<<
  *         super().__init__()
  *         self.compressor = compressor
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_1__init__, 0, __pyx_n_s_Auto___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__56)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 457, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_1__init__, 0, __pyx_n_s_Auto___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__56)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 458, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_INCREF(__pyx_t_9);
   PyList_Append(__pyx_t_10, __pyx_t_9);
   __Pyx_GIVEREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_9) < 0) __PYX_ERR(0, 457, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_9) < 0) __PYX_ERR(0, 458, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":461
+  /* "borg/compress.pyx":462
  *         self.compressor = compressor
  * 
  *     def _decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         """
  *         Decides what to do with *data*. Returns (compressor, compressed_data).
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_3_decide, 0, __pyx_n_s_Auto__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__58)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 461, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_3_decide, 0, __pyx_n_s_Auto__decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__58)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 462, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decide, __pyx_t_9) < 0) __PYX_ERR(0, 461, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decide, __pyx_t_9) < 0) __PYX_ERR(0, 462, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":492
+  /* "borg/compress.pyx":493
  *             return compressor, (meta, compressed_data)
  * 
  *     def decide(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self._decide(meta, data)[0]
  * 
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_5decide, 0, __pyx_n_s_Auto_decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__60)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 492, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_5decide, 0, __pyx_n_s_Auto_decide, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__60)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 493, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decide_2, __pyx_t_9) < 0) __PYX_ERR(0, 492, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decide_2, __pyx_t_9) < 0) __PYX_ERR(0, 493, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":495
+  /* "borg/compress.pyx":496
  *         return self._decide(meta, data)[0]
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         def get_meta(from_meta, to_meta):
  *             for key in "ctype", "clevel", "csize":
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_7compress, 0, __pyx_n_s_Auto_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__62)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 495, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_7compress, 0, __pyx_n_s_Auto_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__62)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 496, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_compress, __pyx_t_9) < 0) __PYX_ERR(0, 495, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_compress, __pyx_t_9) < 0) __PYX_ERR(0, 496, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":520
+  /* "borg/compress.pyx":521
  *             return meta, cheap_compressed_data
  * 
  *     def decompress(self, data):             # <<<<<<<<<<<<<<
  *         raise NotImplementedError
  * 
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_9decompress, 0, __pyx_n_s_Auto_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__64)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 520, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_9decompress, 0, __pyx_n_s_Auto_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__64)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 521, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decompress, __pyx_t_9) < 0) __PYX_ERR(0, 520, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decompress, __pyx_t_9) < 0) __PYX_ERR(0, 521, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":523
+  /* "borg/compress.pyx":524
  *         raise NotImplementedError
  * 
  *     def detect(cls, data):             # <<<<<<<<<<<<<<
  *         raise NotImplementedError
  * 
  */
-  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_11detect, 0, __pyx_n_s_Auto_detect, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__66)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 523, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_4Auto_11detect, 0, __pyx_n_s_Auto_detect, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__66)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 524, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_detect, __pyx_t_9) < 0) __PYX_ERR(0, 523, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_detect, __pyx_t_9) < 0) __PYX_ERR(0, 524, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/compress.pyx":446
+  /* "borg/compress.pyx":447
  * 
  * 
  * class Auto(CompressorBase):             # <<<<<<<<<<<<<<
  *     """
  *     Meta-Compressor that decides which compression to use based on LZ4's ratio.
  */
-  __pyx_t_9 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_Auto, __pyx_t_2, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 446, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_Auto, __pyx_t_1, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 447, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_10, __pyx_t_9) < 0) __PYX_ERR(0, 446, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_10, __pyx_t_9) < 0) __PYX_ERR(0, 447, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Auto, __pyx_t_9) < 0) __PYX_ERR(0, 446, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Auto, __pyx_t_9) < 0) __PYX_ERR(0, 447, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":527
+  /* "borg/compress.pyx":528
  * 
  * 
  * class ObfuscateSize(CompressorBase):             # <<<<<<<<<<<<<<
  *     """
  *     Meta-Compressor that obfuscates the compressed data size.
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 527, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 528, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
-  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 527, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_8compress_CompressorBase));
+  __pyx_t_8 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 528, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_2, __pyx_n_s_ObfuscateSize, __pyx_n_s_ObfuscateSize, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_Meta_Compressor_that_obfuscates); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 527, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 527, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare(__pyx_t_8, __pyx_t_1, __pyx_n_s_ObfuscateSize, __pyx_n_s_ObfuscateSize, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_Meta_Compressor_that_obfuscates); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 528, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 528, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
 
-  /* "borg/compress.pyx":531
+  /* "borg/compress.pyx":532
  *     Meta-Compressor that obfuscates the compressed data size.
  *     """
  *     ID = 0x04             # <<<<<<<<<<<<<<
  *     name = 'obfuscate'
  * 
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_ID, __pyx_int_4) < 0) __PYX_ERR(0, 531, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_ID, __pyx_int_4) < 0) __PYX_ERR(0, 532, __pyx_L1_error)
 
-  /* "borg/compress.pyx":532
+  /* "borg/compress.pyx":533
  *     """
  *     ID = 0x04
  *     name = 'obfuscate'             # <<<<<<<<<<<<<<
  * 
  *     header_fmt = Struct('<I')
  */
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_name, __pyx_n_s_obfuscate_2) < 0) __PYX_ERR(0, 532, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_name, __pyx_n_s_obfuscate_2) < 0) __PYX_ERR(0, 533, __pyx_L1_error)
 
-  /* "borg/compress.pyx":534
+  /* "borg/compress.pyx":535
  *     name = 'obfuscate'
  * 
  *     header_fmt = Struct('<I')             # <<<<<<<<<<<<<<
  *     header_len = len(header_fmt.pack(0))
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_Struct); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 534, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_Struct); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 535, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __pyx_t_11 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
     __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_7);
     if (likely(__pyx_t_11)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
       __Pyx_INCREF(__pyx_t_11);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_7, function);
     }
   }
   __pyx_t_10 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_11, __pyx_kp_s_I) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_kp_s_I);
   __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-  if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 534, __pyx_L1_error)
+  if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 535, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_header_fmt, __pyx_t_10) < 0) __PYX_ERR(0, 534, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_header_fmt, __pyx_t_10) < 0) __PYX_ERR(0, 535, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":535
+  /* "borg/compress.pyx":536
  * 
  *     header_fmt = Struct('<I')
  *     header_len = len(header_fmt.pack(0))             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, level=None, compressor=None, legacy_mode=False):
  */
-  __pyx_t_7 = PyObject_GetItem(__pyx_t_1, __pyx_n_s_header_fmt);
+  __pyx_t_7 = PyObject_GetItem(__pyx_t_2, __pyx_n_s_header_fmt);
   if (unlikely(!__pyx_t_7)) {
     PyErr_Clear();
     __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_header_fmt);
   }
-  if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 535, __pyx_L1_error)
+  if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 536, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_pack); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 535, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_pack); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 536, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_t_7 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_11))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_11);
     if (likely(__pyx_t_7)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
       __Pyx_INCREF(__pyx_t_7);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_11, function);
     }
   }
   __pyx_t_10 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_11, __pyx_t_7, __pyx_int_0) : __Pyx_PyObject_CallOneArg(__pyx_t_11, __pyx_int_0);
   __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 535, __pyx_L1_error)
+  if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 536, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
   __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-  __pyx_t_12 = PyObject_Length(__pyx_t_10); if (unlikely(__pyx_t_12 == ((Py_ssize_t)-1))) __PYX_ERR(0, 535, __pyx_L1_error)
+  __pyx_t_12 = PyObject_Length(__pyx_t_10); if (unlikely(__pyx_t_12 == ((Py_ssize_t)-1))) __PYX_ERR(0, 536, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-  __pyx_t_10 = PyInt_FromSsize_t(__pyx_t_12); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 535, __pyx_L1_error)
+  __pyx_t_10 = PyInt_FromSsize_t(__pyx_t_12); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 536, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_header_len, __pyx_t_10) < 0) __PYX_ERR(0, 535, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_header_len, __pyx_t_10) < 0) __PYX_ERR(0, 536, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":537
+  /* "borg/compress.pyx":538
  *     header_len = len(header_fmt.pack(0))
  * 
  *     def __init__(self, level=None, compressor=None, legacy_mode=False):             # <<<<<<<<<<<<<<
  *         super().__init__(level=level, legacy_mode=legacy_mode)  # data will be encrypted, so we can tell the level
  *         self.compressor = compressor
  */
-  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_1__init__, 0, __pyx_n_s_ObfuscateSize___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__68)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 537, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_1__init__, 0, __pyx_n_s_ObfuscateSize___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__68)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 538, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
   __Pyx_INCREF(__pyx_t_10);
   PyList_Append(__pyx_t_9, __pyx_t_10);
   __Pyx_GIVEREF(__pyx_t_10);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_10, __pyx_tuple__69);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_10) < 0) __PYX_ERR(0, 537, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_10) < 0) __PYX_ERR(0, 538, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":551
+  /* "borg/compress.pyx":552
  *             self.max_padding_size = 2 ** (level - 100)  # 1kiB .. 8MiB
  * 
  *     def _obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         # implementations need to return the size of obfuscation data,
  *         # that the caller shall add.
  */
-  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_3_obfuscate, 0, __pyx_n_s_ObfuscateSize__obfuscate, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__71)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 551, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_3_obfuscate, 0, __pyx_n_s_ObfuscateSize__obfuscate, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__71)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 552, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_obfuscate, __pyx_t_10) < 0) __PYX_ERR(0, 551, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_obfuscate, __pyx_t_10) < 0) __PYX_ERR(0, 552, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":556
+  /* "borg/compress.pyx":557
  *         raise NotImplemented
  * 
  *     def _relative_random_reciprocal_obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         # effect for SPEC 1:
  *         # f = 0.01 .. 0.1 for r in 1.0 .. 0.1 == in 90% of cases
  */
-  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_5_relative_random_reciprocal_obfuscate, 0, __pyx_n_s_ObfuscateSize__relative_random_r, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__73)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 556, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_5_relative_random_reciprocal_obfuscate, 0, __pyx_n_s_ObfuscateSize__relative_random_r, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__73)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 557, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_relative_random_reciprocal_obfu, __pyx_t_10) < 0) __PYX_ERR(0, 556, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_relative_random_reciprocal_obfu, __pyx_t_10) < 0) __PYX_ERR(0, 557, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":566
+  /* "borg/compress.pyx":567
  *         return int(compr_size * f)
  * 
  *     def _random_padding_obfuscate(self, compr_size):             # <<<<<<<<<<<<<<
  *         return int(self.max_padding_size * random.random())
  * 
  */
-  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_7_random_padding_obfuscate, 0, __pyx_n_s_ObfuscateSize__random_padding_ob, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__75)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 566, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_7_random_padding_obfuscate, 0, __pyx_n_s_ObfuscateSize__random_padding_ob, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__75)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 567, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_random_padding_obfuscate, __pyx_t_10) < 0) __PYX_ERR(0, 566, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_random_padding_obfuscate, __pyx_t_10) < 0) __PYX_ERR(0, 567, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":569
+  /* "borg/compress.pyx":570
  *         return int(self.max_padding_size * random.random())
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         assert not self.legacy_mode  # we never call this in legacy mode
  *         meta, compressed_data = self.compressor.compress(meta, data)  # compress data
  */
-  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_9compress, 0, __pyx_n_s_ObfuscateSize_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__77)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 569, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_9compress, 0, __pyx_n_s_ObfuscateSize_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__77)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 570, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_compress, __pyx_t_10) < 0) __PYX_ERR(0, 569, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_compress, __pyx_t_10) < 0) __PYX_ERR(0, 570, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":584
+  /* "borg/compress.pyx":585
  *         return meta, obfuscated_data  # for borg2 it is enough that we have the payload size in meta["psize"]
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         assert self.legacy_mode  # borg2 never dispatches to this, only used for legacy mode
  *         meta, obfuscated_data = super().decompress(meta, data)  # remove obfuscator ID header
  */
-  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_11decompress, 0, __pyx_n_s_ObfuscateSize_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__79)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 584, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_13ObfuscateSize_11decompress, 0, __pyx_n_s_ObfuscateSize_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__79)); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 585, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
   __Pyx_INCREF(__pyx_t_10);
   PyList_Append(__pyx_t_9, __pyx_t_10);
   __Pyx_GIVEREF(__pyx_t_10);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decompress, __pyx_t_10) < 0) __PYX_ERR(0, 584, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_decompress, __pyx_t_10) < 0) __PYX_ERR(0, 585, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "borg/compress.pyx":527
+  /* "borg/compress.pyx":528
  * 
  * 
  * class ObfuscateSize(CompressorBase):             # <<<<<<<<<<<<<<
  *     """
  *     Meta-Compressor that obfuscates the compressed data size.
  */
-  __pyx_t_10 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_ObfuscateSize, __pyx_t_2, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 527, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_Py3ClassCreate(__pyx_t_8, __pyx_n_s_ObfuscateSize, __pyx_t_1, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 528, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_9, __pyx_t_10) < 0) __PYX_ERR(0, 527, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_9, __pyx_t_10) < 0) __PYX_ERR(0, 528, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ObfuscateSize, __pyx_t_10) < 0) __PYX_ERR(0, 527, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ObfuscateSize, __pyx_t_10) < 0) __PYX_ERR(0, 528, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":597
+  /* "borg/compress.pyx":598
  * # Maps valid compressor names to their class
  * COMPRESSOR_TABLE = {
  *     CNONE.name: CNONE,             # <<<<<<<<<<<<<<
  *     LZ4.name: LZ4,
  *     ZLIB.name: ZLIB,
  */
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_CNONE); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 597, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 598, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_CNONE); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_8);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_CNONE); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 597, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_CNONE); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 598, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_t_1, __pyx_t_8) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_t_8) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-  /* "borg/compress.pyx":598
+  /* "borg/compress.pyx":599
  * COMPRESSOR_TABLE = {
  *     CNONE.name: CNONE,
  *     LZ4.name: LZ4,             # <<<<<<<<<<<<<<
  *     ZLIB.name: ZLIB,
  *     ZLIB_legacy.name: ZLIB_legacy,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_LZ4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_LZ4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 599, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 598, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 599, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_LZ4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_LZ4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 599, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_t_1, __pyx_t_8) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_t_8) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-  /* "borg/compress.pyx":599
+  /* "borg/compress.pyx":600
  *     CNONE.name: CNONE,
  *     LZ4.name: LZ4,
  *     ZLIB.name: ZLIB,             # <<<<<<<<<<<<<<
  *     ZLIB_legacy.name: ZLIB_legacy,
  *     LZMA.name: LZMA,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZLIB); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 599, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZLIB); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 600, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 599, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZLIB); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 599, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZLIB); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 600, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_t_1, __pyx_t_8) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_t_8) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-  /* "borg/compress.pyx":600
+  /* "borg/compress.pyx":601
  *     LZ4.name: LZ4,
  *     ZLIB.name: ZLIB,
  *     ZLIB_legacy.name: ZLIB_legacy,             # <<<<<<<<<<<<<<
  *     LZMA.name: LZMA,
  *     Auto.name: Auto,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZLIB_legacy); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZLIB_legacy); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 601, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 600, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 601, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZLIB_legacy); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZLIB_legacy); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 601, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_t_1, __pyx_t_8) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_t_8) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-  /* "borg/compress.pyx":601
+  /* "borg/compress.pyx":602
  *     ZLIB.name: ZLIB,
  *     ZLIB_legacy.name: ZLIB_legacy,
  *     LZMA.name: LZMA,             # <<<<<<<<<<<<<<
  *     Auto.name: Auto,
  *     ZSTD.name: ZSTD,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_LZMA); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 601, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_LZMA); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 602, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 601, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 602, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_LZMA); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 601, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_LZMA); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 602, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_t_1, __pyx_t_8) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_t_8) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-  /* "borg/compress.pyx":602
+  /* "borg/compress.pyx":603
  *     ZLIB_legacy.name: ZLIB_legacy,
  *     LZMA.name: LZMA,
  *     Auto.name: Auto,             # <<<<<<<<<<<<<<
  *     ZSTD.name: ZSTD,
  *     ObfuscateSize.name: ObfuscateSize,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_Auto); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 602, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_Auto); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 603, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 602, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 603, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_Auto); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 602, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_Auto); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 603, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_t_1, __pyx_t_8) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_t_8) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-  /* "borg/compress.pyx":603
+  /* "borg/compress.pyx":604
  *     LZMA.name: LZMA,
  *     Auto.name: Auto,
  *     ZSTD.name: ZSTD,             # <<<<<<<<<<<<<<
  *     ObfuscateSize.name: ObfuscateSize,
  * }
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZSTD); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 603, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZSTD); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 604, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 603, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 604, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZSTD); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 603, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZSTD); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 604, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_t_1, __pyx_t_8) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_t_8) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-  /* "borg/compress.pyx":604
+  /* "borg/compress.pyx":605
  *     Auto.name: Auto,
  *     ZSTD.name: ZSTD,
  *     ObfuscateSize.name: ObfuscateSize,             # <<<<<<<<<<<<<<
  * }
  * # List of possible compression types. Does not include Auto, since it is a meta-Compressor.
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ObfuscateSize); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 604, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ObfuscateSize); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 605, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 604, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 605, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ObfuscateSize); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 604, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ObfuscateSize); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 605, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_t_1, __pyx_t_8) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_COMPRESSOR_TABLE, __pyx_t_2) < 0) __PYX_ERR(0, 596, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_t_8) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_COMPRESSOR_TABLE, __pyx_t_1) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/compress.pyx":607
+  /* "borg/compress.pyx":608
  * }
  * # List of possible compression types. Does not include Auto, since it is a meta-Compressor.
  * COMPRESSOR_LIST = [LZ4, ZSTD, CNONE, ZLIB, ZLIB_legacy, LZMA, ObfuscateSize, ]  # check fast stuff first             # <<<<<<<<<<<<<<
  * 
  * def get_compressor(name, **kwargs):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_LZ4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 607, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZSTD); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 607, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_8);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_CNONE); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 607, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_LZ4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 608, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_ZLIB); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 607, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_ZSTD); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 608, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_8);
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CNONE); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 608, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_ZLIB); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 608, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
-  __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_ZLIB_legacy); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 607, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_ZLIB_legacy); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 608, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_LZMA); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 607, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_LZMA); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 608, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_ObfuscateSize); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 607, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_ObfuscateSize); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 608, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_13 = PyList_New(7); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 607, __pyx_L1_error)
+  __pyx_t_13 = PyList_New(7); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 608, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_13);
-  __Pyx_GIVEREF(__pyx_t_2);
-  PyList_SET_ITEM(__pyx_t_13, 0, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_1);
+  PyList_SET_ITEM(__pyx_t_13, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_8);
   PyList_SET_ITEM(__pyx_t_13, 1, __pyx_t_8);
-  __Pyx_GIVEREF(__pyx_t_1);
-  PyList_SET_ITEM(__pyx_t_13, 2, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyList_SET_ITEM(__pyx_t_13, 2, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_10);
   PyList_SET_ITEM(__pyx_t_13, 3, __pyx_t_10);
   __Pyx_GIVEREF(__pyx_t_9);
   PyList_SET_ITEM(__pyx_t_13, 4, __pyx_t_9);
   __Pyx_GIVEREF(__pyx_t_11);
   PyList_SET_ITEM(__pyx_t_13, 5, __pyx_t_11);
   __Pyx_GIVEREF(__pyx_t_7);
   PyList_SET_ITEM(__pyx_t_13, 6, __pyx_t_7);
-  __pyx_t_2 = 0;
-  __pyx_t_8 = 0;
   __pyx_t_1 = 0;
+  __pyx_t_8 = 0;
+  __pyx_t_2 = 0;
   __pyx_t_10 = 0;
   __pyx_t_9 = 0;
   __pyx_t_11 = 0;
   __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_COMPRESSOR_LIST, __pyx_t_13) < 0) __PYX_ERR(0, 607, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_COMPRESSOR_LIST, __pyx_t_13) < 0) __PYX_ERR(0, 608, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
 
-  /* "borg/compress.pyx":609
+  /* "borg/compress.pyx":610
  * COMPRESSOR_LIST = [LZ4, ZSTD, CNONE, ZLIB, ZLIB_legacy, LZMA, ObfuscateSize, ]  # check fast stuff first
  * 
  * def get_compressor(name, **kwargs):             # <<<<<<<<<<<<<<
  *     cls = COMPRESSOR_TABLE[name]
  *     return cls(**kwargs)
  */
-  __pyx_t_13 = PyCFunction_NewEx(&__pyx_mdef_4borg_8compress_1get_compressor, NULL, __pyx_n_s_borg_compress); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 609, __pyx_L1_error)
+  __pyx_t_13 = PyCFunction_NewEx(&__pyx_mdef_4borg_8compress_1get_compressor, NULL, __pyx_n_s_borg_compress); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 610, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_13);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_compressor, __pyx_t_13) < 0) __PYX_ERR(0, 609, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_compressor, __pyx_t_13) < 0) __PYX_ERR(0, 610, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
 
-  /* "borg/compress.pyx":614
+  /* "borg/compress.pyx":615
  * 
  * # compressor instances to be used by all other compressors
  * NONE_COMPRESSOR = get_compressor('none')             # <<<<<<<<<<<<<<
  * LZ4_COMPRESSOR = get_compressor('lz4')
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_13, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 614, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_13, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 615, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_13);
-  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_tuple__82, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 614, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_tuple__82, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 615, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NONE_COMPRESSOR, __pyx_t_7) < 0) __PYX_ERR(0, 614, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NONE_COMPRESSOR, __pyx_t_7) < 0) __PYX_ERR(0, 615, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":615
+  /* "borg/compress.pyx":616
  * # compressor instances to be used by all other compressors
  * NONE_COMPRESSOR = get_compressor('none')
  * LZ4_COMPRESSOR = get_compressor('lz4')             # <<<<<<<<<<<<<<
  * 
  * class Compressor:
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 615, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_get_compressor); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_13 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_tuple__83, NULL); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 615, __pyx_L1_error)
+  __pyx_t_13 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_tuple__83, NULL); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 616, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_13);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LZ4_COMPRESSOR, __pyx_t_13) < 0) __PYX_ERR(0, 615, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LZ4_COMPRESSOR, __pyx_t_13) < 0) __PYX_ERR(0, 616, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
 
-  /* "borg/compress.pyx":617
+  /* "borg/compress.pyx":618
  * LZ4_COMPRESSOR = get_compressor('lz4')
  * 
  * class Compressor:             # <<<<<<<<<<<<<<
  *     """
  *     compresses using a compressor with given name and parameters
  */
-  __pyx_t_13 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_Compressor, __pyx_n_s_Compressor, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_compresses_using_a_compressor_w); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 617, __pyx_L1_error)
+  __pyx_t_13 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_Compressor, __pyx_n_s_Compressor, (PyObject *) NULL, __pyx_n_s_borg_compress, __pyx_kp_s_compresses_using_a_compressor_w); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 618, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_13);
 
-  /* "borg/compress.pyx":622
+  /* "borg/compress.pyx":623
  *     decompresses everything we can handle (autodetect)
  *     """
  *     def __init__(self, name='null', **kwargs):             # <<<<<<<<<<<<<<
  *         self.params = kwargs
  *         self.compressor = get_compressor(name, **self.params)
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_10Compressor_1__init__, 0, __pyx_n_s_Compressor___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__85)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 622, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_10Compressor_1__init__, 0, __pyx_n_s_Compressor___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__85)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 623, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_7, __pyx_tuple__86);
-  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_init, __pyx_t_7) < 0) __PYX_ERR(0, 622, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_init, __pyx_t_7) < 0) __PYX_ERR(0, 623, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":626
+  /* "borg/compress.pyx":627
  *         self.compressor = get_compressor(name, **self.params)
  * 
  *     def compress(self, meta, data):             # <<<<<<<<<<<<<<
  *         return self.compressor.compress(meta, data)
  * 
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_10Compressor_3compress, 0, __pyx_n_s_Compressor_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__88)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 626, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_10Compressor_3compress, 0, __pyx_n_s_Compressor_compress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__88)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 627, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_compress, __pyx_t_7) < 0) __PYX_ERR(0, 626, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_compress, __pyx_t_7) < 0) __PYX_ERR(0, 627, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":629
+  /* "borg/compress.pyx":630
  *         return self.compressor.compress(meta, data)
  * 
  *     def decompress(self, meta, data):             # <<<<<<<<<<<<<<
  *         if self.compressor.legacy_mode:
  *             hdr = data[:2]
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_10Compressor_5decompress, 0, __pyx_n_s_Compressor_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__90)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 629, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_10Compressor_5decompress, 0, __pyx_n_s_Compressor_decompress, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__90)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 630, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_decompress, __pyx_t_7) < 0) __PYX_ERR(0, 629, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_decompress, __pyx_t_7) < 0) __PYX_ERR(0, 630, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":640
+  /* "borg/compress.pyx":641
  * 
  *     @staticmethod
  *     def detect(data):             # <<<<<<<<<<<<<<
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview
  *         level = hdr[1]  # usually the level, but not for zlib_legacy
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_10Compressor_7detect, __Pyx_CYFUNCTION_STATICMETHOD, __pyx_n_s_Compressor_detect, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__92)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 640, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_10Compressor_7detect, __Pyx_CYFUNCTION_STATICMETHOD, __pyx_n_s_Compressor_detect, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__92)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
 
-  /* "borg/compress.pyx":639
+  /* "borg/compress.pyx":640
  *         return compressor_cls(**self.params).decompress(meta, data)
  * 
  *     @staticmethod             # <<<<<<<<<<<<<<
  *     def detect(data):
  *         hdr = bytes(data[:2])  # detect() does not work with memoryview
  */
-  __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 639, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 640, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_detect, __pyx_t_11) < 0) __PYX_ERR(0, 640, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_detect, __pyx_t_11) < 0) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
 
-  /* "borg/compress.pyx":617
+  /* "borg/compress.pyx":618
  * LZ4_COMPRESSOR = get_compressor('lz4')
  * 
  * class Compressor:             # <<<<<<<<<<<<<<
  *     """
  *     compresses using a compressor with given name and parameters
  */
-  __pyx_t_11 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_Compressor, __pyx_empty_tuple, __pyx_t_13, NULL, 0, 0); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 617, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_Compressor, __pyx_empty_tuple, __pyx_t_13, NULL, 0, 0); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 618, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Compressor, __pyx_t_11) < 0) __PYX_ERR(0, 617, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Compressor, __pyx_t_11) < 0) __PYX_ERR(0, 618, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
 
-  /* "borg/compress.pyx":650
+  /* "borg/compress.pyx":651
  * 
  * 
  * class CompressionSpec:             # <<<<<<<<<<<<<<
  *     def __init__(self, s):
  *         values = s.split(',')
  */
-  __pyx_t_13 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_CompressionSpec, __pyx_n_s_CompressionSpec, (PyObject *) NULL, __pyx_n_s_borg_compress, (PyObject *) NULL); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 650, __pyx_L1_error)
+  __pyx_t_13 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_CompressionSpec, __pyx_n_s_CompressionSpec, (PyObject *) NULL, __pyx_n_s_borg_compress, (PyObject *) NULL); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 651, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_13);
 
-  /* "borg/compress.pyx":651
+  /* "borg/compress.pyx":652
  * 
  * class CompressionSpec:
  *     def __init__(self, s):             # <<<<<<<<<<<<<<
  *         values = s.split(',')
  *         count = len(values)
  */
-  __pyx_t_11 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_15CompressionSpec_1__init__, 0, __pyx_n_s_CompressionSpec___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__94)); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 651, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_15CompressionSpec_1__init__, 0, __pyx_n_s_CompressionSpec___init, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__94)); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 652, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
-  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_init, __pyx_t_11) < 0) __PYX_ERR(0, 651, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_init, __pyx_t_11) < 0) __PYX_ERR(0, 652, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
 
-  /* "borg/compress.pyx":700
+  /* "borg/compress.pyx":701
  * 
  *     @property
  *     def compressor(self):             # <<<<<<<<<<<<<<
  *         if self.name in ('none', 'lz4', ):
  *             return get_compressor(self.name)
  */
-  __pyx_t_11 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_15CompressionSpec_3compressor, 0, __pyx_n_s_CompressionSpec_compressor, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__96)); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 700, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8compress_15CompressionSpec_3compressor, 0, __pyx_n_s_CompressionSpec_compressor, NULL, __pyx_n_s_borg_compress, __pyx_d, ((PyObject *)__pyx_codeobj__96)); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 701, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
 
-  /* "borg/compress.pyx":699
- *             raise ValueError
+  /* "borg/compress.pyx":700
+ *             raise ArgumentTypeError("unsupported compression type")
  * 
  *     @property             # <<<<<<<<<<<<<<
  *     def compressor(self):
  *         if self.name in ('none', 'lz4', ):
  */
-  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_property, __pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 699, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_property, __pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 700, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_compressor, __pyx_t_7) < 0) __PYX_ERR(0, 700, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_13, __pyx_n_s_compressor, __pyx_t_7) < 0) __PYX_ERR(0, 701, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "borg/compress.pyx":650
+  /* "borg/compress.pyx":651
  * 
  * 
  * class CompressionSpec:             # <<<<<<<<<<<<<<
  *     def __init__(self, s):
  *         values = s.split(',')
  */
-  __pyx_t_7 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_CompressionSpec, __pyx_empty_tuple, __pyx_t_13, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 650, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_CompressionSpec, __pyx_empty_tuple, __pyx_t_13, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 651, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CompressionSpec, __pyx_t_7) < 0) __PYX_ERR(0, 650, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CompressionSpec, __pyx_t_7) < 0) __PYX_ERR(0, 651, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_CompressorBase(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
@@ -22120,28 +22334,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -23396,15 +23610,18 @@
 #endif
 #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
     0,
 #endif
 };
 static int __pyx_CyFunction_init(void) {
     __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
     if (unlikely(__pyx_CyFunctionType == NULL)) {
         return -1;
@@ -24549,15 +24766,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -24821,15 +25038,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/compress.pyi` & `borgbackup-2.0.0b6/src/borg/compress.pyi`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/compress.pyx` & `borgbackup-2.0.0b6/src/borg/compress.pyx`

 * *Files 3% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 for the actual compression).
 
 Decompression is normally handled through Compressor.decompress which will detect
 which compressor has been used to compress the data and dispatch to the correct
 decompressor.
 """
 
+from argparse import ArgumentTypeError
 import random
 from struct import Struct
 import zlib
 
 try:
     import lzma
 except ImportError:
@@ -648,57 +649,57 @@
 
 
 class CompressionSpec:
     def __init__(self, s):
         values = s.split(',')
         count = len(values)
         if count < 1:
-            raise ValueError
+            raise ArgumentTypeError("not enough arguments")
         # --compression algo[,level]
         self.name = values[0]
         if self.name in ('none', 'lz4', ):
             return
         elif self.name in ('zlib', 'lzma', 'zlib_legacy'):  # zlib_legacy just for testing
             if count < 2:
                 level = 6  # default compression level in py stdlib
             elif count == 2:
                 level = int(values[1])
                 if not 0 <= level <= 9:
-                    raise ValueError
+                    raise ArgumentTypeError("level must be >= 0 and <= 9")
             else:
-                raise ValueError
+                raise ArgumentTypeError("too many arguments")
             self.level = level
         elif self.name in ('zstd', ):
             if count < 2:
                 level = 3  # default compression level in zstd
             elif count == 2:
                 level = int(values[1])
                 if not 1 <= level <= 22:
-                    raise ValueError
+                    raise ArgumentTypeError("level must be >= 1 and <= 22")
             else:
-                raise ValueError
+                raise ArgumentTypeError("too many arguments")
             self.level = level
         elif self.name == 'auto':
             if 2 <= count <= 3:
                 compression = ','.join(values[1:])
             else:
-                raise ValueError
+                raise ArgumentTypeError("bad arguments")
             self.inner = CompressionSpec(compression)
         elif self.name == 'obfuscate':
             if 3 <= count <= 5:
                 level = int(values[1])
                 if not ((1 <= level <= 6) or (110 <= level <= 123)):
-                    raise ValueError
+                    raise ArgumentTypeError("level must be >= 1 and <= 6 or >= 110 and <= 123")
                 self.level = level
                 compression = ','.join(values[2:])
             else:
-                raise ValueError
+                raise ArgumentTypeError("bad arguments")
             self.inner = CompressionSpec(compression)
         else:
-            raise ValueError
+            raise ArgumentTypeError("unsupported compression type")
 
     @property
     def compressor(self):
         if self.name in ('none', 'lz4', ):
             return get_compressor(self.name)
         elif self.name in ('zlib', 'lzma', 'zstd', 'zlib_legacy'):
             return get_compressor(self.name, level=self.level)
```

### Comparing `borgbackup-2.0.0b5/src/borg/constants.py` & `borgbackup-2.0.0b6/src/borg/constants.py`

 * *Files 3% similar despite different names*

```diff
@@ -71,14 +71,20 @@
 MAX_ARCHIVES = 400000
 
 # repo.list() / .scan() result count limit the borg client uses
 LIST_SCAN_LIMIT = 100000
 
 FD_MAX_AGE = 4 * 60  # 4 minutes
 
+# Some bounds on segment / segment_dir indexes
+MIN_SEGMENT_INDEX = 0
+MAX_SEGMENT_INDEX = 2**32 - 1
+MIN_SEGMENT_DIR_INDEX = 0
+MAX_SEGMENT_DIR_INDEX = 2**32 - 1
+
 # chunker algorithms
 CH_BUZHASH = "buzhash"
 CH_FIXED = "fixed"
 CH_FAIL = "fail"
 
 # buzhash chunker params
 CHUNK_MIN_EXP = 19  # 2**19 == 512kiB
```

### Comparing `borgbackup-2.0.0b5/src/borg/crypto/file_integrity.py` & `borgbackup-2.0.0b6/src/borg/crypto/file_integrity.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/crypto/key.py` & `borgbackup-2.0.0b6/src/borg/crypto/key.py`

 * *Files 1% similar despite different names*

```diff
@@ -21,15 +21,14 @@
 from ..helpers import msgpack
 from ..item import Key, EncryptedKey, want_bytes
 from ..manifest import Manifest
 from ..platform import SaveFile
 from ..repoobj import RepoObj
 
 
-from .nonces import NonceManager
 from .low_level import AES, bytes_to_int, num_cipher_blocks, hmac_sha256, blake2b_256, hkdf_hmac_sha512
 from .low_level import AES256_CTR_HMAC_SHA256, AES256_CTR_BLAKE2b, AES256_OCB, CHACHA20_POLY1305
 from . import low_level
 
 
 class UnsupportedPayloadError(Error):
     """Unsupported payload type {}. A newer version is required to access this repository."""
@@ -111,15 +110,15 @@
 def key_factory(repository, manifest_chunk, *, ro_cls=RepoObj):
     manifest_data = ro_cls.extract_crypted_data(manifest_chunk)
     assert manifest_data, "manifest data must not be zero bytes long"
     return identify_key(manifest_data).detect(repository, manifest_data)
 
 
 def tam_required_file(repository):
-    security_dir = get_security_dir(bin_to_hex(repository.id))
+    security_dir = get_security_dir(bin_to_hex(repository.id), legacy=(repository.version == 1))
     return os.path.join(security_dir, "tam_required")
 
 
 def tam_required(repository):
     file = tam_required_file(repository)
     return os.path.isfile(file)
 
@@ -368,15 +367,16 @@
     PAYLOAD_OVERHEAD = 1 + 32 + 8  # TYPE + HMAC + NONCE
 
     CIPHERSUITE: Callable = None  # override in derived class
 
     logically_encrypted = True
 
     def encrypt(self, id, data):
-        next_iv = self.nonce_manager.ensure_reservation(self.cipher.next_iv(), self.cipher.block_count(len(data)))
+        # legacy, this is only used by the tests.
+        next_iv = self.cipher.next_iv()
         return self.cipher.encrypt(data, header=self.TYPE_STR, iv=next_iv)
 
     def decrypt(self, id, data):
         self.assert_type(data[0], id)
         try:
             return self.cipher.decrypt(data)
         except IntegrityError as e:
@@ -407,15 +407,14 @@
             self.assert_type(manifest_data[0])
             # manifest_blocks is a safe upper bound on the amount of cipher blocks needed
             # to encrypt the manifest. depending on the ciphersuite and overhead, it might
             # be a bit too high, but that does not matter.
             manifest_blocks = num_cipher_blocks(len(manifest_data))
             nonce = self.cipher.extract_iv(manifest_data) + manifest_blocks
         self.cipher.set_iv(nonce)
-        self.nonce_manager = NonceManager(self.repository, nonce)
 
 
 class FlexiKey:
     FILE_ID = "BORG_KEY"
     STORAGE: ClassVar[str] = KeyBlobStorage.NO_STORAGE  # override in subclass
 
     @classmethod
```

### Comparing `borgbackup-2.0.0b5/src/borg/crypto/keymanager.py` & `borgbackup-2.0.0b6/src/borg/crypto/keymanager.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/crypto/low_level.c` & `borgbackup-2.0.0b6/src/borg/crypto/low_level.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,16 +1,15 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
             "/opt/homebrew/opt/openssl@1.1/include/openssl/crypto.h",
             "/opt/homebrew/opt/openssl@1.1/include/openssl/evp.h",
-            "/opt/homebrew/opt/openssl@1.1/include/openssl/hmac.h",
             "/opt/homebrew/opt/openssl@1.1/include/openssl/opensslv.h"
         ],
         "extra_compile_args": [
             "-Wall",
             "-Wextra",
             "-Wpointer-arith"
         ],
@@ -37,16 +36,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -106,16 +105,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -231,15 +234,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -270,15 +273,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -775,15 +778,14 @@
 /* Early includes */
 #include <string.h>
 #include <stdio.h>
 #include "pythread.h"
 #include "openssl/crypto.h"
 #include "openssl/opensslv.h"
 #include "openssl/evp.h"
-#include "openssl/hmac.h"
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
 
 #if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
 #define CYTHON_WITHOUT_ASSERTIONS
 #endif
@@ -1001,28 +1003,28 @@
 struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256;
 struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b;
 struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE;
 struct __pyx_obj_4borg_6crypto_9low_level_AES256_OCB;
 struct __pyx_obj_4borg_6crypto_9low_level_CHACHA20_POLY1305;
 struct __pyx_obj_4borg_6crypto_9low_level_AES;
 
-/* "borg/crypto/low_level.pyx":406
+/* "borg/crypto/low_level.pyx":397
  * 
  * 
  * ctypedef const EVP_CIPHER * (* CIPHER)()             # <<<<<<<<<<<<<<
  * 
  * 
  */
 typedef EVP_CIPHER const *(*__pyx_t_4borg_6crypto_9low_level_CIPHER)(void);
 
-/* "borg/crypto/low_level.pyx":177
+/* "borg/crypto/low_level.pyx":168
  * 
  * 
  * cdef class AES256_CTR_BASE:             # <<<<<<<<<<<<<<
- *     # Layout: HEADER + MAC 32 + IV 8 + CT (same as attic / borg < 1.3 IF HEADER = TYPE_BYTE, no AAD)
+ *     # Layout: HEADER + MAC 32 + IV 8 + CT (same as attic / borg < 2.0 IF HEADER = TYPE_BYTE, no AAD)
  * 
  */
 struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE {
   PyObject_HEAD
   struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *__pyx_vtab;
   EVP_CIPHER_CTX *ctx;
   unsigned char enc_key[32];
@@ -1033,45 +1035,45 @@
   int header_len;
   int mac_len;
   unsigned char iv[16];
   PY_LONG_LONG blocks;
 };
 
 
-/* "borg/crypto/low_level.pyx":346
+/* "borg/crypto/low_level.pyx":337
  * 
  * 
  * cdef class AES256_CTR_HMAC_SHA256(AES256_CTR_BASE):             # <<<<<<<<<<<<<<
  *     cdef unsigned char mac_key[32]
  * 
  */
 struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 {
   struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE __pyx_base;
   unsigned char mac_key[32];
 };
 
 
-/* "borg/crypto/low_level.pyx":376
+/* "borg/crypto/low_level.pyx":367
  * 
  * 
  * cdef class AES256_CTR_BLAKE2b(AES256_CTR_BASE):             # <<<<<<<<<<<<<<
  *     cdef unsigned char mac_key[128]
  * 
  */
 struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b {
   struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE __pyx_base;
   unsigned char mac_key[0x80];
 };
 
 
-/* "borg/crypto/low_level.pyx":409
+/* "borg/crypto/low_level.pyx":400
  * 
  * 
  * cdef class _AEAD_BASE:             # <<<<<<<<<<<<<<
- *     # new crypto used in borg >= 1.3
+ *     # new crypto used in borg >= 2.0
  *     # Layout: HEADER + MAC 16 + CT
  */
 struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE {
   PyObject_HEAD
   __pyx_t_4borg_6crypto_9low_level_CIPHER cipher;
   EVP_CIPHER_CTX *ctx;
   unsigned char key[32];
@@ -1081,39 +1083,39 @@
   int header_len_expected;
   int mac_len;
   unsigned char iv[12];
   PY_LONG_LONG blocks;
 };
 
 
-/* "borg/crypto/low_level.pyx":591
+/* "borg/crypto/low_level.pyx":582
  * 
  * 
  * cdef class AES256_OCB(_AEAD_BASE):             # <<<<<<<<<<<<<<
  *     @classmethod
  *     def requirements_check(cls):
  */
 struct __pyx_obj_4borg_6crypto_9low_level_AES256_OCB {
   struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE __pyx_base;
 };
 
 
-/* "borg/crypto/low_level.pyx":603
+/* "borg/crypto/low_level.pyx":594
  * 
  * 
  * cdef class CHACHA20_POLY1305(_AEAD_BASE):             # <<<<<<<<<<<<<<
  *     @classmethod
  *     def requirements_check(cls):
  */
 struct __pyx_obj_4borg_6crypto_9low_level_CHACHA20_POLY1305 {
   struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE __pyx_base;
 };
 
 
-/* "borg/crypto/low_level.pyx":615
+/* "borg/crypto/low_level.pyx":606
  * 
  * 
  * cdef class AES:  # legacy             # <<<<<<<<<<<<<<
  *     """A thin wrapper around the OpenSSL EVP cipher API - for legacy code, like key file encryption"""
  *     cdef CIPHER cipher
  */
 struct __pyx_obj_4borg_6crypto_9low_level_AES {
@@ -1125,46 +1127,46 @@
   int iv_len;
   unsigned char iv[16];
   PY_LONG_LONG blocks;
 };
 
 
 
-/* "borg/crypto/low_level.pyx":177
+/* "borg/crypto/low_level.pyx":168
  * 
  * 
  * cdef class AES256_CTR_BASE:             # <<<<<<<<<<<<<<
- *     # Layout: HEADER + MAC 32 + IV 8 + CT (same as attic / borg < 1.3 IF HEADER = TYPE_BYTE, no AAD)
+ *     # Layout: HEADER + MAC 32 + IV 8 + CT (same as attic / borg < 2.0 IF HEADER = TYPE_BYTE, no AAD)
  * 
  */
 
 struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE {
   PyObject *(*mac_compute)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char const *, int, unsigned char const *, int, unsigned char *);
   PyObject *(*mac_verify)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char const *, int, unsigned char const *, int, unsigned char *, unsigned char const *);
   PyObject *(*fetch_iv)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char *);
   PyObject *(*store_iv)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char *, unsigned char *);
 };
 static struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *__pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_BASE;
 
 
-/* "borg/crypto/low_level.pyx":346
+/* "borg/crypto/low_level.pyx":337
  * 
  * 
  * cdef class AES256_CTR_HMAC_SHA256(AES256_CTR_BASE):             # <<<<<<<<<<<<<<
  *     cdef unsigned char mac_key[32]
  * 
  */
 
 struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 {
   struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE __pyx_base;
 };
 static struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 *__pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256;
 
 
-/* "borg/crypto/low_level.pyx":376
+/* "borg/crypto/low_level.pyx":367
  * 
  * 
  * cdef class AES256_CTR_BLAKE2b(AES256_CTR_BASE):             # <<<<<<<<<<<<<<
  *     cdef unsigned char mac_key[128]
  * 
  */
 
@@ -1531,22 +1533,30 @@
 /* PyObjectGetAttrStrNoError.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
 
 /* SetupReduce.proto */
 static int __Pyx_setup_reduce(PyObject* type_obj);
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto
-#define __PYX_HAVE_RT_ImportType_proto
-enum __Pyx_ImportType_CheckSize {
-   __Pyx_ImportType_CheckSize_Error = 0,
-   __Pyx_ImportType_CheckSize_Warn = 1,
-   __Pyx_ImportType_CheckSize_Ignore = 2
+#ifndef __PYX_HAVE_RT_ImportType_proto_0_29_35
+#define __PYX_HAVE_RT_ImportType_proto_0_29_35
+#if __STDC_VERSION__ >= 201112L
+#include <stdalign.h>
+#endif
+#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) alignof(s)
+#else
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) sizeof(void*)
+#endif
+enum __Pyx_ImportType_CheckSize_0_29_35 {
+   __Pyx_ImportType_CheckSize_Error_0_29_35 = 0,
+   __Pyx_ImportType_CheckSize_Warn_0_29_35 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_0_29_35 = 2
 };
-static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size);
 #endif
 
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
@@ -2233,15 +2243,15 @@
 static PyObject *__pyx_codeobj__48;
 static PyObject *__pyx_codeobj__50;
 static PyObject *__pyx_codeobj__52;
 static PyObject *__pyx_codeobj__54;
 static PyObject *__pyx_codeobj__56;
 /* Late includes */
 
-/* "borg/crypto/low_level.pyx":102
+/* "borg/crypto/low_level.pyx":93
  * _long = struct.Struct('>Q')
  * 
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]             # <<<<<<<<<<<<<<
  * bytes_to_long = lambda x, offset=0: _long.unpack_from(x, offset)[0]
  * long_to_bytes = lambda x: _long.pack(x)
  */
 
@@ -2281,15 +2291,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_offset);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lambda") < 0)) __PYX_ERR(0, 102, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lambda") < 0)) __PYX_ERR(0, 93, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -2297,15 +2307,15 @@
       }
     }
     __pyx_v_x = values[0];
     __pyx_v_offset = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("lambda", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 102, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("lambda", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 93, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.lambda", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_lambda_funcdef_4borg_6crypto_9low_level_lambda(__pyx_self, __pyx_v_x, __pyx_v_offset);
 
@@ -2323,17 +2333,17 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("lambda", 0);
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_int); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_int); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unpack_from); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unpack_from); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -2343,45 +2353,45 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_x, __pyx_v_offset};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 102, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_x, __pyx_v_offset};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 102, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 102, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_x);
     __Pyx_GIVEREF(__pyx_v_x);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_x);
     __Pyx_INCREF(__pyx_v_offset);
     __Pyx_GIVEREF(__pyx_v_offset);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_offset);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 102, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 93, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
   /* function exit code */
@@ -2394,15 +2404,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":103
+/* "borg/crypto/low_level.pyx":94
  * 
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]
  * bytes_to_long = lambda x, offset=0: _long.unpack_from(x, offset)[0]             # <<<<<<<<<<<<<<
  * long_to_bytes = lambda x: _long.pack(x)
  * 
  */
 
@@ -2442,15 +2452,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_offset);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lambda1") < 0)) __PYX_ERR(0, 103, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lambda1") < 0)) __PYX_ERR(0, 94, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -2458,15 +2468,15 @@
       }
     }
     __pyx_v_x = values[0];
     __pyx_v_offset = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("lambda1", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 103, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("lambda1", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 94, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.lambda1", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_lambda_funcdef_4borg_6crypto_9low_level_lambda1(__pyx_self, __pyx_v_x, __pyx_v_offset);
 
@@ -2484,17 +2494,17 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("lambda1", 0);
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_long); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 103, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_long); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unpack_from); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 103, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unpack_from); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -2504,45 +2514,45 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_x, __pyx_v_offset};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 94, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_x, __pyx_v_offset};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 94, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 94, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_x);
     __Pyx_GIVEREF(__pyx_v_x);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_x);
     __Pyx_INCREF(__pyx_v_offset);
     __Pyx_GIVEREF(__pyx_v_offset);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_offset);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 94, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 103, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
   /* function exit code */
@@ -2555,15 +2565,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":104
+/* "borg/crypto/low_level.pyx":95
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]
  * bytes_to_long = lambda x, offset=0: _long.unpack_from(x, offset)[0]
  * long_to_bytes = lambda x: _long.pack(x)             # <<<<<<<<<<<<<<
  * 
  * 
  */
 
@@ -2588,32 +2598,32 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("lambda2", 0);
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_long); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_long); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_pack); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_pack); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_x);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 104, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
@@ -2625,15 +2635,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":107
+/* "borg/crypto/low_level.pyx":98
  * 
  * 
  * def num_cipher_blocks(length, blocksize=16):             # <<<<<<<<<<<<<<
  *     """Return the number of cipher blocks required to encrypt/decrypt <length> bytes of data.
  * 
  */
 
@@ -2674,15 +2684,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_blocksize);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "num_cipher_blocks") < 0)) __PYX_ERR(0, 107, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "num_cipher_blocks") < 0)) __PYX_ERR(0, 98, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -2690,15 +2700,15 @@
       }
     }
     __pyx_v_length = values[0];
     __pyx_v_blocksize = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("num_cipher_blocks", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 107, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("num_cipher_blocks", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 98, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.num_cipher_blocks", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_num_cipher_blocks(__pyx_self, __pyx_v_length, __pyx_v_blocksize);
 
@@ -2713,35 +2723,35 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("num_cipher_blocks", 0);
 
-  /* "borg/crypto/low_level.pyx":120
+  /* "borg/crypto/low_level.pyx":111
  *     Padding cipher modes are not supported.
  *     """
  *     return (length + blocksize - 1) // blocksize             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyNumber_Add(__pyx_v_length, __pyx_v_blocksize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 120, __pyx_L1_error)
+  __pyx_t_1 = PyNumber_Add(__pyx_v_length, __pyx_v_blocksize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 111, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyInt_SubtractObjC(__pyx_t_1, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 120, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_SubtractObjC(__pyx_t_1, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 111, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyNumber_FloorDivide(__pyx_t_2, __pyx_v_blocksize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 120, __pyx_L1_error)
+  __pyx_t_1 = PyNumber_FloorDivide(__pyx_t_2, __pyx_v_blocksize); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 111, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":107
+  /* "borg/crypto/low_level.pyx":98
  * 
  * 
  * def num_cipher_blocks(length, blocksize=16):             # <<<<<<<<<<<<<<
  *     """Return the number of cipher blocks required to encrypt/decrypt <length> bytes of data.
  * 
  */
 
@@ -2753,15 +2763,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":131
+/* "borg/crypto/low_level.pyx":122
  * 
  * 
  * cdef Py_buffer ro_buffer(object data) except *:             # <<<<<<<<<<<<<<
  *     cdef Py_buffer view
  *     PyObject_GetBuffer(data, &view, PyBUF_SIMPLE)
  */
 
@@ -2771,34 +2781,34 @@
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("ro_buffer", 0);
 
-  /* "borg/crypto/low_level.pyx":133
+  /* "borg/crypto/low_level.pyx":124
  * cdef Py_buffer ro_buffer(object data) except *:
  *     cdef Py_buffer view
  *     PyObject_GetBuffer(data, &view, PyBUF_SIMPLE)             # <<<<<<<<<<<<<<
  *     return view
  * 
  */
-  __pyx_t_1 = PyObject_GetBuffer(__pyx_v_data, (&__pyx_v_view), PyBUF_SIMPLE); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 133, __pyx_L1_error)
+  __pyx_t_1 = PyObject_GetBuffer(__pyx_v_data, (&__pyx_v_view), PyBUF_SIMPLE); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 124, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":134
+  /* "borg/crypto/low_level.pyx":125
  *     cdef Py_buffer view
  *     PyObject_GetBuffer(data, &view, PyBUF_SIMPLE)
  *     return view             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_view;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":131
+  /* "borg/crypto/low_level.pyx":122
  * 
  * 
  * cdef Py_buffer ro_buffer(object data) except *:             # <<<<<<<<<<<<<<
  *     cdef Py_buffer view
  *     PyObject_GetBuffer(data, &view, PyBUF_SIMPLE)
  */
 
@@ -2807,15 +2817,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.ro_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":140
+/* "borg/crypto/low_level.pyx":131
  *     # Layout: HEADER + PlainText
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         assert mac_key is None
  *         assert enc_key is None
  */
 
@@ -2865,21 +2875,21 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mac_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 6, 1); __PYX_ERR(0, 140, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 6, 1); __PYX_ERR(0, 131, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_enc_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 6, 2); __PYX_ERR(0, 140, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 6, 2); __PYX_ERR(0, 131, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[3] = value; kw_args--; }
         }
@@ -2893,15 +2903,15 @@
         case  5:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[5] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 140, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 131, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
         CYTHON_FALLTHROUGH;
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
@@ -2919,15 +2929,15 @@
     __pyx_v_enc_key = values[2];
     __pyx_v_iv = values[3];
     __pyx_v_header_len = values[4];
     __pyx_v_aad_offset = values[5];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 140, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 131, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.UNENCRYPTED.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_11UNENCRYPTED___init__(__pyx_self, __pyx_v_self, __pyx_v_mac_key, __pyx_v_enc_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -2944,84 +2954,84 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/crypto/low_level.pyx":141
+  /* "borg/crypto/low_level.pyx":132
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  *         assert mac_key is None             # <<<<<<<<<<<<<<
  *         assert enc_key is None
  *         self.header_len = header_len
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_1 = (__pyx_v_mac_key == Py_None);
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 141, __pyx_L1_error)
+      __PYX_ERR(0, 132, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":142
+  /* "borg/crypto/low_level.pyx":133
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  *         assert mac_key is None
  *         assert enc_key is None             # <<<<<<<<<<<<<<
  *         self.header_len = header_len
  *         self.set_iv(iv)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_1 = (__pyx_v_enc_key == Py_None);
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 142, __pyx_L1_error)
+      __PYX_ERR(0, 133, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":143
+  /* "borg/crypto/low_level.pyx":134
  *         assert mac_key is None
  *         assert enc_key is None
  *         self.header_len = header_len             # <<<<<<<<<<<<<<
  *         self.set_iv(iv)
  * 
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 143, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":144
+  /* "borg/crypto/low_level.pyx":135
  *         assert enc_key is None
  *         self.header_len = header_len
  *         self.set_iv(iv)             # <<<<<<<<<<<<<<
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=None):
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_set_iv); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 144, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_set_iv); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 135, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_iv) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_iv);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 144, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":140
+  /* "borg/crypto/low_level.pyx":131
  *     # Layout: HEADER + PlainText
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         assert mac_key is None
  *         assert enc_key is None
  */
 
@@ -3036,15 +3046,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":146
+/* "borg/crypto/low_level.pyx":137
  *         self.set_iv(iv)
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         IMPORTANT: it is called encrypt to satisfy the crypto api naming convention,
  */
 
@@ -3092,15 +3102,15 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("encrypt", 0, 2, 5, 1); __PYX_ERR(0, 146, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("encrypt", 0, 2, 5, 1); __PYX_ERR(0, 137, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_header);
           if (value) { values[2] = value; kw_args--; }
         }
@@ -3114,15 +3124,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "encrypt") < 0)) __PYX_ERR(0, 146, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "encrypt") < 0)) __PYX_ERR(0, 137, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -3138,15 +3148,15 @@
     __pyx_v_data = values[1];
     __pyx_v_header = values[2];
     __pyx_v_iv = values[3];
     __pyx_v_aad = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("encrypt", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 146, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("encrypt", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 137, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.UNENCRYPTED.encrypt", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_11UNENCRYPTED_2encrypt(__pyx_self, __pyx_v_self, __pyx_v_data, __pyx_v_header, __pyx_v_iv, __pyx_v_aad);
 
@@ -3164,95 +3174,95 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encrypt", 0);
 
-  /* "borg/crypto/low_level.pyx":151
+  /* "borg/crypto/low_level.pyx":142
  *         but this does NOT encrypt and it does NOT compute and store a MAC either.
  *         """
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         assert self.iv is not None, 'iv needs to be set before encrypt is called'
  */
   __pyx_t_1 = (__pyx_v_iv != Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/crypto/low_level.pyx":152
+    /* "borg/crypto/low_level.pyx":143
  *         """
  *         if iv is not None:
  *             self.set_iv(iv)             # <<<<<<<<<<<<<<
  *         assert self.iv is not None, 'iv needs to be set before encrypt is called'
  *         return header + data
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_set_iv); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 152, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_set_iv); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 143, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_iv) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_iv);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 152, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 143, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/crypto/low_level.pyx":151
+    /* "borg/crypto/low_level.pyx":142
  *         but this does NOT encrypt and it does NOT compute and store a MAC either.
  *         """
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         assert self.iv is not None, 'iv needs to be set before encrypt is called'
  */
   }
 
-  /* "borg/crypto/low_level.pyx":153
+  /* "borg/crypto/low_level.pyx":144
  *         if iv is not None:
  *             self.set_iv(iv)
  *         assert self.iv is not None, 'iv needs to be set before encrypt is called'             # <<<<<<<<<<<<<<
  *         return header + data
  * 
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_iv); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 153, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_iv); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 144, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_2 = (__pyx_t_3 != Py_None);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     if (unlikely(!(__pyx_t_2 != 0))) {
       PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_iv_needs_to_be_set_before_encryp);
-      __PYX_ERR(0, 153, __pyx_L1_error)
+      __PYX_ERR(0, 144, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":154
+  /* "borg/crypto/low_level.pyx":145
  *             self.set_iv(iv)
  *         assert self.iv is not None, 'iv needs to be set before encrypt is called'
  *         return header + data             # <<<<<<<<<<<<<<
  * 
  *     def decrypt(self, envelope, aad=None):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = PyNumber_Add(__pyx_v_header, __pyx_v_data); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 154, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Add(__pyx_v_header, __pyx_v_data); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 145, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":146
+  /* "borg/crypto/low_level.pyx":137
  *         self.set_iv(iv)
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         IMPORTANT: it is called encrypt to satisfy the crypto api naming convention,
  */
 
@@ -3265,15 +3275,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":156
+/* "borg/crypto/low_level.pyx":147
  *         return header + data
  * 
  *     def decrypt(self, envelope, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         IMPORTANT: it is called decrypt to satisfy the crypto api naming convention,
  */
 
@@ -3313,25 +3323,25 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_envelope)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("decrypt", 0, 2, 3, 1); __PYX_ERR(0, 156, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decrypt", 0, 2, 3, 1); __PYX_ERR(0, 147, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decrypt") < 0)) __PYX_ERR(0, 156, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decrypt") < 0)) __PYX_ERR(0, 147, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
@@ -3341,15 +3351,15 @@
     }
     __pyx_v_self = values[0];
     __pyx_v_envelope = values[1];
     __pyx_v_aad = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decrypt", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 156, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decrypt", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 147, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.UNENCRYPTED.decrypt", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_11UNENCRYPTED_4decrypt(__pyx_self, __pyx_v_self, __pyx_v_envelope, __pyx_v_aad);
 
@@ -3365,38 +3375,38 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decrypt", 0);
 
-  /* "borg/crypto/low_level.pyx":162
+  /* "borg/crypto/low_level.pyx":153
  *         is not encrypted and there is no MAC.
  *         """
  *         return memoryview(envelope)[self.header_len:]             # <<<<<<<<<<<<<<
  * 
  *     def block_count(self, length):
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_memoryview); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_memoryview); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_envelope); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_envelope); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_len); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_header_len); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyObject_GetSlice(__pyx_t_2, 0, 0, &__pyx_t_1, NULL, NULL, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetSlice(__pyx_t_2, 0, 0, &__pyx_t_1, NULL, NULL, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":156
+  /* "borg/crypto/low_level.pyx":147
  *         return header + data
  * 
  *     def decrypt(self, envelope, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         IMPORTANT: it is called decrypt to satisfy the crypto api naming convention,
  */
 
@@ -3409,15 +3419,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":164
+/* "borg/crypto/low_level.pyx":155
  *         return memoryview(envelope)[self.header_len:]
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return 0
  * 
  */
 
@@ -3452,32 +3462,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_length)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("block_count", 1, 2, 2, 1); __PYX_ERR(0, 164, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("block_count", 1, 2, 2, 1); __PYX_ERR(0, 155, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "block_count") < 0)) __PYX_ERR(0, 164, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "block_count") < 0)) __PYX_ERR(0, 155, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_length = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("block_count", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 164, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("block_count", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 155, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.UNENCRYPTED.block_count", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_11UNENCRYPTED_6block_count(__pyx_self, __pyx_v_self, __pyx_v_length);
 
@@ -3487,42 +3497,42 @@
 }
 
 static PyObject *__pyx_pf_4borg_6crypto_9low_level_11UNENCRYPTED_6block_count(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_length) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("block_count", 0);
 
-  /* "borg/crypto/low_level.pyx":165
+  /* "borg/crypto/low_level.pyx":156
  * 
  *     def block_count(self, length):
  *         return 0             # <<<<<<<<<<<<<<
  * 
  *     def set_iv(self, iv):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_int_0);
   __pyx_r = __pyx_int_0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":164
+  /* "borg/crypto/low_level.pyx":155
  *         return memoryview(envelope)[self.header_len:]
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return 0
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":167
+/* "borg/crypto/low_level.pyx":158
  *         return 0
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         self.iv = iv
  * 
  */
 
@@ -3557,32 +3567,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("set_iv", 1, 2, 2, 1); __PYX_ERR(0, 167, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("set_iv", 1, 2, 2, 1); __PYX_ERR(0, 158, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_iv") < 0)) __PYX_ERR(0, 167, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_iv") < 0)) __PYX_ERR(0, 158, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_iv = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("set_iv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 167, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("set_iv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 158, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.UNENCRYPTED.set_iv", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_11UNENCRYPTED_8set_iv(__pyx_self, __pyx_v_self, __pyx_v_iv);
 
@@ -3595,24 +3605,24 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("set_iv", 0);
 
-  /* "borg/crypto/low_level.pyx":168
+  /* "borg/crypto/low_level.pyx":159
  * 
  *     def set_iv(self, iv):
  *         self.iv = iv             # <<<<<<<<<<<<<<
  * 
  *     def next_iv(self):
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 168, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 159, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":167
+  /* "borg/crypto/low_level.pyx":158
  *         return 0
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         self.iv = iv
  * 
  */
 
@@ -3624,15 +3634,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":170
+/* "borg/crypto/low_level.pyx":161
  *         self.iv = iv
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         return self.iv
  * 
  */
 
@@ -3655,29 +3665,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("next_iv", 0);
 
-  /* "borg/crypto/low_level.pyx":171
+  /* "borg/crypto/low_level.pyx":162
  * 
  *     def next_iv(self):
  *         return self.iv             # <<<<<<<<<<<<<<
  * 
  *     def extract_iv(self, envelope):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_iv); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_iv); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":170
+  /* "borg/crypto/low_level.pyx":161
  *         self.iv = iv
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         return self.iv
  * 
  */
 
@@ -3688,15 +3698,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":173
+/* "borg/crypto/low_level.pyx":164
  *         return self.iv
  * 
  *     def extract_iv(self, envelope):             # <<<<<<<<<<<<<<
  *         return 0
  * 
  */
 
@@ -3731,32 +3741,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_envelope)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("extract_iv", 1, 2, 2, 1); __PYX_ERR(0, 173, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("extract_iv", 1, 2, 2, 1); __PYX_ERR(0, 164, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "extract_iv") < 0)) __PYX_ERR(0, 173, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "extract_iv") < 0)) __PYX_ERR(0, 164, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_envelope = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("extract_iv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 173, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("extract_iv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 164, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.UNENCRYPTED.extract_iv", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_11UNENCRYPTED_12extract_iv(__pyx_self, __pyx_v_self, __pyx_v_envelope);
 
@@ -3766,42 +3776,42 @@
 }
 
 static PyObject *__pyx_pf_4borg_6crypto_9low_level_11UNENCRYPTED_12extract_iv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_envelope) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("extract_iv", 0);
 
-  /* "borg/crypto/low_level.pyx":174
+  /* "borg/crypto/low_level.pyx":165
  * 
  *     def extract_iv(self, envelope):
  *         return 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_int_0);
   __pyx_r = __pyx_int_0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":173
+  /* "borg/crypto/low_level.pyx":164
  *         return self.iv
  * 
  *     def extract_iv(self, envelope):             # <<<<<<<<<<<<<<
  *         return 0
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":191
+/* "borg/crypto/low_level.pyx":182
  * 
  *     @classmethod
  *     def requirements_check(cls):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
 
@@ -3826,15 +3836,15 @@
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":194
+/* "borg/crypto/low_level.pyx":185
  *         pass
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         self.requirements_check()
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32
  */
 
@@ -3880,15 +3890,15 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mac_key)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_enc_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, 1); __PYX_ERR(0, 194, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, 1); __PYX_ERR(0, 185, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[2] = value; kw_args--; }
         }
@@ -3902,15 +3912,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 194, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 185, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -3926,15 +3936,15 @@
     __pyx_v_enc_key = values[1];
     __pyx_v_iv = values[2];
     __pyx_v_header_len = values[3];
     __pyx_v_aad_offset = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 194, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 185, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BASE.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_15AES256_CTR_BASE_2__init__(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self), __pyx_v_mac_key, __pyx_v_enc_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -3956,41 +3966,41 @@
   int __pyx_t_8;
   unsigned char __pyx_t_9[32];
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/crypto/low_level.pyx":195
+  /* "borg/crypto/low_level.pyx":186
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  *         self.requirements_check()             # <<<<<<<<<<<<<<
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32
  *         self.cipher_blk_len = 16
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 195, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":196
+  /* "borg/crypto/low_level.pyx":187
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  *         self.requirements_check()
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32             # <<<<<<<<<<<<<<
  *         self.cipher_blk_len = 16
  *         self.iv_len = sizeof(self.iv)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -3998,170 +4008,170 @@
     __pyx_t_5 = PyBytes_Check(__pyx_v_enc_key); 
     __pyx_t_6 = (__pyx_t_5 != 0);
     if (__pyx_t_6) {
     } else {
       __pyx_t_4 = __pyx_t_6;
       goto __pyx_L3_bool_binop_done;
     }
-    __pyx_t_7 = PyObject_Length(__pyx_v_enc_key); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 196, __pyx_L1_error)
+    __pyx_t_7 = PyObject_Length(__pyx_v_enc_key); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 187, __pyx_L1_error)
     __pyx_t_6 = ((__pyx_t_7 == 32) != 0);
     __pyx_t_4 = __pyx_t_6;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!__pyx_t_4)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 196, __pyx_L1_error)
+      __PYX_ERR(0, 187, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":197
+  /* "borg/crypto/low_level.pyx":188
  *         self.requirements_check()
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32
  *         self.cipher_blk_len = 16             # <<<<<<<<<<<<<<
  *         self.iv_len = sizeof(self.iv)
  *         self.iv_len_short = 8
  */
   __pyx_v_self->cipher_blk_len = 16;
 
-  /* "borg/crypto/low_level.pyx":198
+  /* "borg/crypto/low_level.pyx":189
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32
  *         self.cipher_blk_len = 16
  *         self.iv_len = sizeof(self.iv)             # <<<<<<<<<<<<<<
  *         self.iv_len_short = 8
  *         assert aad_offset <= header_len
  */
   __pyx_v_self->iv_len = (sizeof(__pyx_v_self->iv));
 
-  /* "borg/crypto/low_level.pyx":199
+  /* "borg/crypto/low_level.pyx":190
  *         self.cipher_blk_len = 16
  *         self.iv_len = sizeof(self.iv)
  *         self.iv_len_short = 8             # <<<<<<<<<<<<<<
  *         assert aad_offset <= header_len
  *         self.aad_offset = aad_offset
  */
   __pyx_v_self->iv_len_short = 8;
 
-  /* "borg/crypto/low_level.pyx":200
+  /* "borg/crypto/low_level.pyx":191
  *         self.iv_len = sizeof(self.iv)
  *         self.iv_len_short = 8
  *         assert aad_offset <= header_len             # <<<<<<<<<<<<<<
  *         self.aad_offset = aad_offset
  *         self.header_len = header_len
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
-    __pyx_t_1 = PyObject_RichCompare(__pyx_v_aad_offset, __pyx_v_header_len, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 200, __pyx_L1_error)
-    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 200, __pyx_L1_error)
+    __pyx_t_1 = PyObject_RichCompare(__pyx_v_aad_offset, __pyx_v_header_len, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 191, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     if (unlikely(!__pyx_t_4)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 200, __pyx_L1_error)
+      __PYX_ERR(0, 191, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":201
+  /* "borg/crypto/low_level.pyx":192
  *         self.iv_len_short = 8
  *         assert aad_offset <= header_len
  *         self.aad_offset = aad_offset             # <<<<<<<<<<<<<<
  *         self.header_len = header_len
  *         self.mac_len = 32
  */
-  __pyx_t_8 = __Pyx_PyInt_As_int(__pyx_v_aad_offset); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 201, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyInt_As_int(__pyx_v_aad_offset); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 192, __pyx_L1_error)
   __pyx_v_self->aad_offset = __pyx_t_8;
 
-  /* "borg/crypto/low_level.pyx":202
+  /* "borg/crypto/low_level.pyx":193
  *         assert aad_offset <= header_len
  *         self.aad_offset = aad_offset
  *         self.header_len = header_len             # <<<<<<<<<<<<<<
  *         self.mac_len = 32
  *         self.enc_key = enc_key
  */
-  __pyx_t_8 = __Pyx_PyInt_As_int(__pyx_v_header_len); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 202, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyInt_As_int(__pyx_v_header_len); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 193, __pyx_L1_error)
   __pyx_v_self->header_len = __pyx_t_8;
 
-  /* "borg/crypto/low_level.pyx":203
+  /* "borg/crypto/low_level.pyx":194
  *         self.aad_offset = aad_offset
  *         self.header_len = header_len
  *         self.mac_len = 32             # <<<<<<<<<<<<<<
  *         self.enc_key = enc_key
  *         if iv is not None:
  */
   __pyx_v_self->mac_len = 32;
 
-  /* "borg/crypto/low_level.pyx":204
+  /* "borg/crypto/low_level.pyx":195
  *         self.header_len = header_len
  *         self.mac_len = 32
  *         self.enc_key = enc_key             # <<<<<<<<<<<<<<
  *         if iv is not None:
  *             self.set_iv(iv)
  */
-  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_enc_key, __pyx_t_9, 32) < 0)) __PYX_ERR(0, 204, __pyx_L1_error)
+  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_enc_key, __pyx_t_9, 32) < 0)) __PYX_ERR(0, 195, __pyx_L1_error)
   memcpy(&(__pyx_v_self->enc_key[0]), __pyx_t_9, sizeof(__pyx_v_self->enc_key[0]) * (32));
 
-  /* "borg/crypto/low_level.pyx":205
+  /* "borg/crypto/low_level.pyx":196
  *         self.mac_len = 32
  *         self.enc_key = enc_key
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         else:
  */
   __pyx_t_4 = (__pyx_v_iv != Py_None);
   __pyx_t_6 = (__pyx_t_4 != 0);
   if (__pyx_t_6) {
 
-    /* "borg/crypto/low_level.pyx":206
+    /* "borg/crypto/low_level.pyx":197
  *         self.enc_key = enc_key
  *         if iv is not None:
  *             self.set_iv(iv)             # <<<<<<<<<<<<<<
  *         else:
  *             self.blocks = -1  # make sure set_iv is called before encrypt
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 206, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 197, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_t_3 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
         __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_2, function);
       }
     }
     __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_iv) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_iv);
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 206, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 197, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/crypto/low_level.pyx":205
+    /* "borg/crypto/low_level.pyx":196
  *         self.mac_len = 32
  *         self.enc_key = enc_key
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         else:
  */
     goto __pyx_L5;
   }
 
-  /* "borg/crypto/low_level.pyx":208
+  /* "borg/crypto/low_level.pyx":199
  *             self.set_iv(iv)
  *         else:
  *             self.blocks = -1  # make sure set_iv is called before encrypt             # <<<<<<<<<<<<<<
  * 
  *     def __cinit__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  */
   /*else*/ {
     __pyx_v_self->blocks = -1LL;
   }
   __pyx_L5:;
 
-  /* "borg/crypto/low_level.pyx":194
+  /* "borg/crypto/low_level.pyx":185
  *         pass
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         self.requirements_check()
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32
  */
 
@@ -4175,15 +4185,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BASE.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":210
+/* "borg/crypto/low_level.pyx":201
  *             self.blocks = -1  # make sure set_iv is called before encrypt
  * 
  *     def __cinit__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  */
 
@@ -4229,15 +4239,15 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mac_key)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_enc_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, 1); __PYX_ERR(0, 210, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, 1); __PYX_ERR(0, 201, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[2] = value; kw_args--; }
         }
@@ -4251,15 +4261,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 210, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 201, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -4275,15 +4285,15 @@
     __pyx_v_enc_key = values[1];
     __pyx_v_iv = values[2];
     __pyx_v_header_len = values[3];
     __pyx_v_aad_offset = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 210, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 201, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BASE.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_15AES256_CTR_BASE_4__cinit__(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self), __pyx_v_mac_key, __pyx_v_enc_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -4293,38 +4303,38 @@
 }
 
 static int __pyx_pf_4borg_6crypto_9low_level_15AES256_CTR_BASE_4__cinit__(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_mac_key, CYTHON_UNUSED PyObject *__pyx_v_enc_key, CYTHON_UNUSED PyObject *__pyx_v_iv, CYTHON_UNUSED PyObject *__pyx_v_header_len, CYTHON_UNUSED PyObject *__pyx_v_aad_offset) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "borg/crypto/low_level.pyx":211
+  /* "borg/crypto/low_level.pyx":202
  * 
  *     def __cinit__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  *         self.ctx = EVP_CIPHER_CTX_new()             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(self):
  */
   __pyx_v_self->ctx = EVP_CIPHER_CTX_new();
 
-  /* "borg/crypto/low_level.pyx":210
+  /* "borg/crypto/low_level.pyx":201
  *             self.blocks = -1  # make sure set_iv is called before encrypt
  * 
  *     def __cinit__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":213
+/* "borg/crypto/low_level.pyx":204
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  */
 
@@ -4339,36 +4349,36 @@
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_pf_4borg_6crypto_9low_level_15AES256_CTR_BASE_6__dealloc__(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "borg/crypto/low_level.pyx":214
+  /* "borg/crypto/low_level.pyx":205
  * 
  *     def __dealloc__(self):
  *         EVP_CIPHER_CTX_free(self.ctx)             # <<<<<<<<<<<<<<
  * 
  *     cdef mac_compute(self, const unsigned char *data1, int data1_len,
  */
   EVP_CIPHER_CTX_free(__pyx_v_self->ctx);
 
-  /* "borg/crypto/low_level.pyx":213
+  /* "borg/crypto/low_level.pyx":204
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "borg/crypto/low_level.pyx":216
+/* "borg/crypto/low_level.pyx":207
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  *     cdef mac_compute(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                      const unsigned char *data2, int data2_len,
  *                      unsigned char *mac_buf):
  */
 
@@ -4376,25 +4386,25 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("mac_compute", 0);
 
-  /* "borg/crypto/low_level.pyx":219
+  /* "borg/crypto/low_level.pyx":210
  *                      const unsigned char *data2, int data2_len,
  *                      unsigned char *mac_buf):
  *         raise NotImplementedError             # <<<<<<<<<<<<<<
  * 
  *     cdef mac_verify(self, const unsigned char *data1, int data1_len,
  */
   __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
-  __PYX_ERR(0, 219, __pyx_L1_error)
+  __PYX_ERR(0, 210, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":216
+  /* "borg/crypto/low_level.pyx":207
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  *     cdef mac_compute(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                      const unsigned char *data2, int data2_len,
  *                      unsigned char *mac_buf):
  */
 
@@ -4403,15 +4413,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BASE.mac_compute", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":221
+/* "borg/crypto/low_level.pyx":212
  *         raise NotImplementedError
  * 
  *     cdef mac_verify(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                     const unsigned char *data2, int data2_len,
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  */
 
@@ -4419,25 +4429,25 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("mac_verify", 0);
 
-  /* "borg/crypto/low_level.pyx":227
+  /* "borg/crypto/low_level.pyx":218
  *         Calculate MAC of *data1*, *data2*, write result to *mac_buf*, and verify against *mac_wanted.*
  *         """
  *         raise NotImplementedError             # <<<<<<<<<<<<<<
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=None):
  */
   __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
-  __PYX_ERR(0, 227, __pyx_L1_error)
+  __PYX_ERR(0, 218, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":221
+  /* "borg/crypto/low_level.pyx":212
  *         raise NotImplementedError
  * 
  *     cdef mac_verify(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                     const unsigned char *data2, int data2_len,
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  */
 
@@ -4446,15 +4456,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BASE.mac_verify", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":229
+/* "borg/crypto/low_level.pyx":220
  *         raise NotImplementedError
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         encrypt data, compute mac over aad + iv + cdata, prepend header.
  */
 
@@ -4514,15 +4524,15 @@
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "encrypt") < 0)) __PYX_ERR(0, 229, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "encrypt") < 0)) __PYX_ERR(0, 220, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -4536,15 +4546,15 @@
     __pyx_v_data = values[0];
     __pyx_v_header = values[1];
     __pyx_v_iv = values[2];
     __pyx_v_aad = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("encrypt", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 229, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("encrypt", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 220, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BASE.encrypt", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_15AES256_CTR_BASE_8encrypt(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self), __pyx_v_data, __pyx_v_header, __pyx_v_iv, __pyx_v_aad);
 
@@ -4589,561 +4599,561 @@
   PyObject *__pyx_t_21 = NULL;
   PyObject *__pyx_t_22 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encrypt", 0);
 
-  /* "borg/crypto/low_level.pyx":234
+  /* "borg/crypto/low_level.pyx":225
  *         aad_offset is the offset into the header where aad starts.
  *         """
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  */
   __pyx_t_1 = (__pyx_v_iv != Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/crypto/low_level.pyx":235
+    /* "borg/crypto/low_level.pyx":226
  *         """
  *         if iv is not None:
  *             self.set_iv(iv)             # <<<<<<<<<<<<<<
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  *         cdef int ilen = len(data)
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 235, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 226, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_iv) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_iv);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 235, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 226, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/crypto/low_level.pyx":234
+    /* "borg/crypto/low_level.pyx":225
  *         aad_offset is the offset into the header where aad starts.
  *         """
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  */
   }
 
-  /* "borg/crypto/low_level.pyx":236
+  /* "borg/crypto/low_level.pyx":227
  *         if iv is not None:
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'             # <<<<<<<<<<<<<<
  *         cdef int ilen = len(data)
  *         cdef int hlen = len(header)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_self->blocks == 0) != 0))) {
       PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_iv_needs_to_be_set_before_encryp);
-      __PYX_ERR(0, 236, __pyx_L1_error)
+      __PYX_ERR(0, 227, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":237
+  /* "borg/crypto/low_level.pyx":228
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  *         cdef int ilen = len(data)             # <<<<<<<<<<<<<<
  *         cdef int hlen = len(header)
  *         assert hlen == self.header_len
  */
-  __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 237, __pyx_L1_error)
+  __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 228, __pyx_L1_error)
   __pyx_v_ilen = __pyx_t_6;
 
-  /* "borg/crypto/low_level.pyx":238
+  /* "borg/crypto/low_level.pyx":229
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  *         cdef int ilen = len(data)
  *         cdef int hlen = len(header)             # <<<<<<<<<<<<<<
  *         assert hlen == self.header_len
  *         cdef int aoffset = self.aad_offset
  */
-  __pyx_t_6 = PyObject_Length(__pyx_v_header); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 238, __pyx_L1_error)
+  __pyx_t_6 = PyObject_Length(__pyx_v_header); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 229, __pyx_L1_error)
   __pyx_v_hlen = __pyx_t_6;
 
-  /* "borg/crypto/low_level.pyx":239
+  /* "borg/crypto/low_level.pyx":230
  *         cdef int ilen = len(data)
  *         cdef int hlen = len(header)
  *         assert hlen == self.header_len             # <<<<<<<<<<<<<<
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_hlen == __pyx_v_self->header_len) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 239, __pyx_L1_error)
+      __PYX_ERR(0, 230, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":240
+  /* "borg/crypto/low_level.pyx":231
  *         cdef int hlen = len(header)
  *         assert hlen == self.header_len
  *         cdef int aoffset = self.aad_offset             # <<<<<<<<<<<<<<
  *         cdef int alen = hlen - aoffset
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len + self.iv_len_short +
  */
   __pyx_t_7 = __pyx_v_self->aad_offset;
   __pyx_v_aoffset = __pyx_t_7;
 
-  /* "borg/crypto/low_level.pyx":241
+  /* "borg/crypto/low_level.pyx":232
  *         assert hlen == self.header_len
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset             # <<<<<<<<<<<<<<
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len + self.iv_len_short +
  *                                                                   ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  */
   __pyx_v_alen = (__pyx_v_hlen - __pyx_v_aoffset);
 
-  /* "borg/crypto/low_level.pyx":242
+  /* "borg/crypto/low_level.pyx":233
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len + self.iv_len_short +             # <<<<<<<<<<<<<<
  *                                                                   ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  *         if not odata:
  */
   __pyx_v_odata = ((unsigned char *)PyMem_Malloc(((((__pyx_v_hlen + __pyx_v_self->mac_len) + __pyx_v_self->iv_len_short) + __pyx_v_ilen) + __pyx_v_self->cipher_blk_len)));
 
-  /* "borg/crypto/low_level.pyx":244
+  /* "borg/crypto/low_level.pyx":235
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len + self.iv_len_short +
  *                                                                   ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         cdef int olen = 0
  */
   __pyx_t_2 = ((!(__pyx_v_odata != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "borg/crypto/low_level.pyx":245
+    /* "borg/crypto/low_level.pyx":236
  *                                                                   ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  *         if not odata:
  *             raise MemoryError             # <<<<<<<<<<<<<<
  *         cdef int olen = 0
  *         cdef int offset
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 245, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 236, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":244
+    /* "borg/crypto/low_level.pyx":235
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len + self.iv_len_short +
  *                                                                   ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         cdef int olen = 0
  */
   }
 
-  /* "borg/crypto/low_level.pyx":246
+  /* "borg/crypto/low_level.pyx":237
  *         if not odata:
  *             raise MemoryError
  *         cdef int olen = 0             # <<<<<<<<<<<<<<
  *         cdef int offset
  *         cdef Py_buffer idata = ro_buffer(data)
  */
   __pyx_v_olen = 0;
 
-  /* "borg/crypto/low_level.pyx":248
+  /* "borg/crypto/low_level.pyx":239
  *         cdef int olen = 0
  *         cdef int offset
  *         cdef Py_buffer idata = ro_buffer(data)             # <<<<<<<<<<<<<<
  *         cdef Py_buffer hdata = ro_buffer(header)
  *         try:
  */
-  __pyx_t_8 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_data); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 248, __pyx_L1_error)
+  __pyx_t_8 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_data); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 239, __pyx_L1_error)
   __pyx_v_idata = __pyx_t_8;
 
-  /* "borg/crypto/low_level.pyx":249
+  /* "borg/crypto/low_level.pyx":240
  *         cdef int offset
  *         cdef Py_buffer idata = ro_buffer(data)
  *         cdef Py_buffer hdata = ro_buffer(header)             # <<<<<<<<<<<<<<
  *         try:
  *             offset = 0
  */
-  __pyx_t_8 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_header); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 249, __pyx_L1_error)
+  __pyx_t_8 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_header); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 240, __pyx_L1_error)
   __pyx_v_hdata = __pyx_t_8;
 
-  /* "borg/crypto/low_level.pyx":250
+  /* "borg/crypto/low_level.pyx":241
  *         cdef Py_buffer idata = ro_buffer(data)
  *         cdef Py_buffer hdata = ro_buffer(header)
  *         try:             # <<<<<<<<<<<<<<
  *             offset = 0
  *             for i in range(hlen):
  */
   /*try:*/ {
 
-    /* "borg/crypto/low_level.pyx":251
+    /* "borg/crypto/low_level.pyx":242
  *         cdef Py_buffer hdata = ro_buffer(header)
  *         try:
  *             offset = 0             # <<<<<<<<<<<<<<
  *             for i in range(hlen):
  *                 odata[offset+i] = header[i]
  */
     __pyx_v_offset = 0;
 
-    /* "borg/crypto/low_level.pyx":252
+    /* "borg/crypto/low_level.pyx":243
  *         try:
  *             offset = 0
  *             for i in range(hlen):             # <<<<<<<<<<<<<<
  *                 odata[offset+i] = header[i]
  *             offset += hlen
  */
-    __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_hlen); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L6_error)
+    __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_hlen); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 243, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 252, __pyx_L6_error)
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 243, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     if (likely(PyList_CheckExact(__pyx_t_4)) || PyTuple_CheckExact(__pyx_t_4)) {
       __pyx_t_3 = __pyx_t_4; __Pyx_INCREF(__pyx_t_3); __pyx_t_6 = 0;
       __pyx_t_9 = NULL;
     } else {
-      __pyx_t_6 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L6_error)
+      __pyx_t_6 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 243, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_9 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 252, __pyx_L6_error)
+      __pyx_t_9 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 243, __pyx_L6_error)
     }
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     for (;;) {
       if (likely(!__pyx_t_9)) {
         if (likely(PyList_CheckExact(__pyx_t_3))) {
           if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_3)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 252, __pyx_L6_error)
+          __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 243, __pyx_L6_error)
           #else
-          __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 252, __pyx_L6_error)
+          __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 243, __pyx_L6_error)
           __Pyx_GOTREF(__pyx_t_4);
           #endif
         } else {
           if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 252, __pyx_L6_error)
+          __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 243, __pyx_L6_error)
           #else
-          __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 252, __pyx_L6_error)
+          __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 243, __pyx_L6_error)
           __Pyx_GOTREF(__pyx_t_4);
           #endif
         }
       } else {
         __pyx_t_4 = __pyx_t_9(__pyx_t_3);
         if (unlikely(!__pyx_t_4)) {
           PyObject* exc_type = PyErr_Occurred();
           if (exc_type) {
             if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 252, __pyx_L6_error)
+            else __PYX_ERR(0, 243, __pyx_L6_error)
           }
           break;
         }
         __Pyx_GOTREF(__pyx_t_4);
       }
       __Pyx_XDECREF_SET(__pyx_v_i, __pyx_t_4);
       __pyx_t_4 = 0;
 
-      /* "borg/crypto/low_level.pyx":253
+      /* "borg/crypto/low_level.pyx":244
  *             offset = 0
  *             for i in range(hlen):
  *                 odata[offset+i] = header[i]             # <<<<<<<<<<<<<<
  *             offset += hlen
  *             offset += self.mac_len
  */
-      __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_header, __pyx_v_i); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 253, __pyx_L6_error)
+      __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_header, __pyx_v_i); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 244, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_10 = __Pyx_PyInt_As_unsigned_char(__pyx_t_4); if (unlikely((__pyx_t_10 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 253, __pyx_L6_error)
+      __pyx_t_10 = __Pyx_PyInt_As_unsigned_char(__pyx_t_4); if (unlikely((__pyx_t_10 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 244, __pyx_L6_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 253, __pyx_L6_error)
+      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 244, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = PyNumber_Add(__pyx_t_4, __pyx_v_i); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 253, __pyx_L6_error)
+      __pyx_t_5 = PyNumber_Add(__pyx_t_4, __pyx_v_i); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 244, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_11 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_11 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 253, __pyx_L6_error)
+      __pyx_t_11 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_11 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 244, __pyx_L6_error)
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       (__pyx_v_odata[__pyx_t_11]) = __pyx_t_10;
 
-      /* "borg/crypto/low_level.pyx":252
+      /* "borg/crypto/low_level.pyx":243
  *         try:
  *             offset = 0
  *             for i in range(hlen):             # <<<<<<<<<<<<<<
  *                 odata[offset+i] = header[i]
  *             offset += hlen
  */
     }
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/crypto/low_level.pyx":254
+    /* "borg/crypto/low_level.pyx":245
  *             for i in range(hlen):
  *                 odata[offset+i] = header[i]
  *             offset += hlen             # <<<<<<<<<<<<<<
  *             offset += self.mac_len
  *             self.store_iv(odata+offset, self.iv)
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_hlen);
 
-    /* "borg/crypto/low_level.pyx":255
+    /* "borg/crypto/low_level.pyx":246
  *                 odata[offset+i] = header[i]
  *             offset += hlen
  *             offset += self.mac_len             # <<<<<<<<<<<<<<
  *             self.store_iv(odata+offset, self.iv)
  *             offset += self.iv_len_short
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_self->mac_len);
 
-    /* "borg/crypto/low_level.pyx":256
+    /* "borg/crypto/low_level.pyx":247
  *             offset += hlen
  *             offset += self.mac_len
  *             self.store_iv(odata+offset, self.iv)             # <<<<<<<<<<<<<<
  *             offset += self.iv_len_short
  *             if not EVP_EncryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, self.iv):
  */
-    __pyx_t_3 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self->__pyx_vtab)->store_iv(__pyx_v_self, (__pyx_v_odata + __pyx_v_offset), __pyx_v_self->iv); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 256, __pyx_L6_error)
+    __pyx_t_3 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self->__pyx_vtab)->store_iv(__pyx_v_self, (__pyx_v_odata + __pyx_v_offset), __pyx_v_self->iv); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 247, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/crypto/low_level.pyx":257
+    /* "borg/crypto/low_level.pyx":248
  *             offset += self.mac_len
  *             self.store_iv(odata+offset, self.iv)
  *             offset += self.iv_len_short             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, self.iv):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_self->iv_len_short);
 
-    /* "borg/crypto/low_level.pyx":258
+    /* "borg/crypto/low_level.pyx":249
  *             self.store_iv(odata+offset, self.iv)
  *             offset += self.iv_len_short
  *             if not EVP_EncryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  */
     __pyx_t_2 = ((!(EVP_EncryptInit_ex(__pyx_v_self->ctx, EVP_aes_256_ctr(), NULL, __pyx_v_self->enc_key, __pyx_v_self->iv) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":259
+      /* "borg/crypto/low_level.pyx":250
  *             offset += self.iv_len_short
  *             if not EVP_EncryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, self.iv):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 259, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 250, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_EncryptInit_ex_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_EncryptInit_ex_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 259, __pyx_L6_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 250, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 259, __pyx_L6_error)
+      __PYX_ERR(0, 250, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":258
+      /* "borg/crypto/low_level.pyx":249
  *             self.store_iv(odata+offset, self.iv)
  *             offset += self.iv_len_short
  *             if not EVP_EncryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":260
+    /* "borg/crypto/low_level.pyx":251
  *             if not EVP_EncryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, self.iv):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen
  */
     __pyx_t_2 = ((!(EVP_EncryptUpdate(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen), ((unsigned char const *)__pyx_v_idata.buf), __pyx_v_ilen) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":261
+      /* "borg/crypto/low_level.pyx":252
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 261, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 252, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_EncryptUpdate_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_EncryptUpdate_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 261, __pyx_L6_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 252, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 261, __pyx_L6_error)
+      __PYX_ERR(0, 252, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":260
+      /* "borg/crypto/low_level.pyx":251
  *             if not EVP_EncryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, self.iv):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen
  */
     }
 
-    /* "borg/crypto/low_level.pyx":262
+    /* "borg/crypto/low_level.pyx":253
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":263
+    /* "borg/crypto/low_level.pyx":254
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  *             offset += olen
  */
     __pyx_t_2 = ((!(EVP_EncryptFinal_ex(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen)) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":264
+      /* "borg/crypto/low_level.pyx":255
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             self.mac_compute(<const unsigned char *> hdata.buf+aoffset, alen,
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 264, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 255, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_EncryptFinal_ex_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_EncryptFinal_ex_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 264, __pyx_L6_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 255, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 264, __pyx_L6_error)
+      __PYX_ERR(0, 255, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":263
+      /* "borg/crypto/low_level.pyx":254
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  *             offset += olen
  */
     }
 
-    /* "borg/crypto/low_level.pyx":265
+    /* "borg/crypto/low_level.pyx":256
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             self.mac_compute(<const unsigned char *> hdata.buf+aoffset, alen,
  *                               odata+hlen+self.mac_len, offset-hlen-self.mac_len,
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":266
+    /* "borg/crypto/low_level.pyx":257
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  *             offset += olen
  *             self.mac_compute(<const unsigned char *> hdata.buf+aoffset, alen,             # <<<<<<<<<<<<<<
  *                               odata+hlen+self.mac_len, offset-hlen-self.mac_len,
  *                               odata+hlen)
  */
-    __pyx_t_3 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self->__pyx_vtab)->mac_compute(__pyx_v_self, (((unsigned char const *)__pyx_v_hdata.buf) + __pyx_v_aoffset), __pyx_v_alen, ((__pyx_v_odata + __pyx_v_hlen) + __pyx_v_self->mac_len), ((__pyx_v_offset - __pyx_v_hlen) - __pyx_v_self->mac_len), (__pyx_v_odata + __pyx_v_hlen)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 266, __pyx_L6_error)
+    __pyx_t_3 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self->__pyx_vtab)->mac_compute(__pyx_v_self, (((unsigned char const *)__pyx_v_hdata.buf) + __pyx_v_aoffset), __pyx_v_alen, ((__pyx_v_odata + __pyx_v_hlen) + __pyx_v_self->mac_len), ((__pyx_v_offset - __pyx_v_hlen) - __pyx_v_self->mac_len), (__pyx_v_odata + __pyx_v_hlen)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 257, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/crypto/low_level.pyx":269
+    /* "borg/crypto/low_level.pyx":260
  *                               odata+hlen+self.mac_len, offset-hlen-self.mac_len,
  *                               odata+hlen)
  *             self.blocks += self.block_count(ilen)             # <<<<<<<<<<<<<<
  *             return odata[:offset]
  *         finally:
  */
-    __pyx_t_3 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_self->blocks); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 269, __pyx_L6_error)
+    __pyx_t_3 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_self->blocks); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 260, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 269, __pyx_L6_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 260, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_12 = __Pyx_PyInt_From_int(__pyx_v_ilen); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 269, __pyx_L6_error)
+    __pyx_t_12 = __Pyx_PyInt_From_int(__pyx_v_ilen); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 260, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_12);
     __pyx_t_13 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_13)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_13);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_5 = (__pyx_t_13) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_13, __pyx_t_12) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_12);
     __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
     __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 269, __pyx_L6_error)
+    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 260, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = PyNumber_InPlaceAdd(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 269, __pyx_L6_error)
+    __pyx_t_4 = PyNumber_InPlaceAdd(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 260, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_14 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_4); if (unlikely((__pyx_t_14 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 269, __pyx_L6_error)
+    __pyx_t_14 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_4); if (unlikely((__pyx_t_14 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 260, __pyx_L6_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_v_self->blocks = __pyx_t_14;
 
-    /* "borg/crypto/low_level.pyx":270
+    /* "borg/crypto/low_level.pyx":261
  *                               odata+hlen)
  *             self.blocks += self.block_count(ilen)
  *             return odata[:offset]             # <<<<<<<<<<<<<<
  *         finally:
  *             PyMem_Free(odata)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_4 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 270, __pyx_L6_error)
+    __pyx_t_4 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 261, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L5_return;
   }
 
-  /* "borg/crypto/low_level.pyx":272
+  /* "borg/crypto/low_level.pyx":263
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)
  */
   /*finally:*/ {
@@ -5165,24 +5175,24 @@
       __Pyx_XGOTREF(__pyx_t_20);
       __Pyx_XGOTREF(__pyx_t_21);
       __Pyx_XGOTREF(__pyx_t_22);
       __pyx_t_7 = __pyx_lineno; __pyx_t_15 = __pyx_clineno; __pyx_t_16 = __pyx_filename;
       {
         PyMem_Free(__pyx_v_odata);
 
-        /* "borg/crypto/low_level.pyx":273
+        /* "borg/crypto/low_level.pyx":264
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&hdata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  * 
  */
         PyBuffer_Release((&__pyx_v_hdata));
 
-        /* "borg/crypto/low_level.pyx":274
+        /* "borg/crypto/low_level.pyx":265
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  * 
  *     def decrypt(self, envelope, aad=None):
  */
         PyBuffer_Release((&__pyx_v_idata));
@@ -5201,47 +5211,47 @@
       __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_15; __pyx_filename = __pyx_t_16;
       goto __pyx_L1_error;
     }
     __pyx_L5_return: {
       __pyx_t_22 = __pyx_r;
       __pyx_r = 0;
 
-      /* "borg/crypto/low_level.pyx":272
+      /* "borg/crypto/low_level.pyx":263
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)
  */
       PyMem_Free(__pyx_v_odata);
 
-      /* "borg/crypto/low_level.pyx":273
+      /* "borg/crypto/low_level.pyx":264
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&hdata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  * 
  */
       PyBuffer_Release((&__pyx_v_hdata));
 
-      /* "borg/crypto/low_level.pyx":274
+      /* "borg/crypto/low_level.pyx":265
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  * 
  *     def decrypt(self, envelope, aad=None):
  */
       PyBuffer_Release((&__pyx_v_idata));
       __pyx_r = __pyx_t_22;
       __pyx_t_22 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "borg/crypto/low_level.pyx":229
+  /* "borg/crypto/low_level.pyx":220
  *         raise NotImplementedError
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         encrypt data, compute mac over aad + iv + cdata, prepend header.
  */
 
@@ -5257,15 +5267,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_i);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":276
+/* "borg/crypto/low_level.pyx":267
  *             PyBuffer_Release(&idata)
  * 
  *     def decrypt(self, envelope, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         authenticate aad + iv + cdata, decrypt cdata, ignore header bytes up to aad_offset.
  */
 
@@ -5305,15 +5315,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decrypt") < 0)) __PYX_ERR(0, 276, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decrypt") < 0)) __PYX_ERR(0, 267, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -5321,15 +5331,15 @@
       }
     }
     __pyx_v_envelope = values[0];
     __pyx_v_aad = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decrypt", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 276, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decrypt", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 267, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BASE.decrypt", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_15AES256_CTR_BASE_10decrypt(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self), __pyx_v_envelope, __pyx_v_aad);
 
@@ -5371,405 +5381,405 @@
   PyObject *__pyx_t_18 = NULL;
   PyObject *__pyx_t_19 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decrypt", 0);
 
-  /* "borg/crypto/low_level.pyx":280
+  /* "borg/crypto/low_level.pyx":271
  *         authenticate aad + iv + cdata, decrypt cdata, ignore header bytes up to aad_offset.
  *         """
  *         cdef int ilen = len(envelope)             # <<<<<<<<<<<<<<
  *         cdef int hlen = self.header_len
  *         cdef int aoffset = self.aad_offset
  */
-  __pyx_t_1 = PyObject_Length(__pyx_v_envelope); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 280, __pyx_L1_error)
+  __pyx_t_1 = PyObject_Length(__pyx_v_envelope); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 271, __pyx_L1_error)
   __pyx_v_ilen = __pyx_t_1;
 
-  /* "borg/crypto/low_level.pyx":281
+  /* "borg/crypto/low_level.pyx":272
  *         """
  *         cdef int ilen = len(envelope)
  *         cdef int hlen = self.header_len             # <<<<<<<<<<<<<<
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset
  */
   __pyx_t_2 = __pyx_v_self->header_len;
   __pyx_v_hlen = __pyx_t_2;
 
-  /* "borg/crypto/low_level.pyx":282
+  /* "borg/crypto/low_level.pyx":273
  *         cdef int ilen = len(envelope)
  *         cdef int hlen = self.header_len
  *         cdef int aoffset = self.aad_offset             # <<<<<<<<<<<<<<
  *         cdef int alen = hlen - aoffset
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  */
   __pyx_t_2 = __pyx_v_self->aad_offset;
   __pyx_v_aoffset = __pyx_t_2;
 
-  /* "borg/crypto/low_level.pyx":283
+  /* "borg/crypto/low_level.pyx":274
  *         cdef int hlen = self.header_len
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset             # <<<<<<<<<<<<<<
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  *         if not odata:
  */
   __pyx_v_alen = (__pyx_v_hlen - __pyx_v_aoffset);
 
-  /* "borg/crypto/low_level.pyx":284
+  /* "borg/crypto/low_level.pyx":275
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)  # play safe, 1 extra blk             # <<<<<<<<<<<<<<
  *         if not odata:
  *             raise MemoryError
  */
   __pyx_v_odata = ((unsigned char *)PyMem_Malloc((__pyx_v_ilen + __pyx_v_self->cipher_blk_len)));
 
-  /* "borg/crypto/low_level.pyx":285
+  /* "borg/crypto/low_level.pyx":276
  *         cdef int alen = hlen - aoffset
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         cdef int olen = 0
  */
   __pyx_t_3 = ((!(__pyx_v_odata != 0)) != 0);
   if (unlikely(__pyx_t_3)) {
 
-    /* "borg/crypto/low_level.pyx":286
+    /* "borg/crypto/low_level.pyx":277
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  *         if not odata:
  *             raise MemoryError             # <<<<<<<<<<<<<<
  *         cdef int olen = 0
  *         cdef int offset
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 286, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 277, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":285
+    /* "borg/crypto/low_level.pyx":276
  *         cdef int alen = hlen - aoffset
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)  # play safe, 1 extra blk
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         cdef int olen = 0
  */
   }
 
-  /* "borg/crypto/low_level.pyx":287
+  /* "borg/crypto/low_level.pyx":278
  *         if not odata:
  *             raise MemoryError
  *         cdef int olen = 0             # <<<<<<<<<<<<<<
  *         cdef int offset
  *         cdef unsigned char mac_buf[32]
  */
   __pyx_v_olen = 0;
 
-  /* "borg/crypto/low_level.pyx":290
+  /* "borg/crypto/low_level.pyx":281
  *         cdef int offset
  *         cdef unsigned char mac_buf[32]
  *         assert sizeof(mac_buf) == self.mac_len             # <<<<<<<<<<<<<<
  *         cdef Py_buffer idata = ro_buffer(envelope)
  *         try:
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!(((sizeof(__pyx_v_mac_buf)) == __pyx_v_self->mac_len) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 290, __pyx_L1_error)
+      __PYX_ERR(0, 281, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":291
+  /* "borg/crypto/low_level.pyx":282
  *         cdef unsigned char mac_buf[32]
  *         assert sizeof(mac_buf) == self.mac_len
  *         cdef Py_buffer idata = ro_buffer(envelope)             # <<<<<<<<<<<<<<
  *         try:
  *             self.mac_verify(<const unsigned char *> idata.buf+aoffset, alen,
  */
-  __pyx_t_4 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_envelope); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 291, __pyx_L1_error)
+  __pyx_t_4 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_envelope); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 282, __pyx_L1_error)
   __pyx_v_idata = __pyx_t_4;
 
-  /* "borg/crypto/low_level.pyx":292
+  /* "borg/crypto/low_level.pyx":283
  *         assert sizeof(mac_buf) == self.mac_len
  *         cdef Py_buffer idata = ro_buffer(envelope)
  *         try:             # <<<<<<<<<<<<<<
  *             self.mac_verify(<const unsigned char *> idata.buf+aoffset, alen,
  *                              <const unsigned char *> idata.buf+hlen+self.mac_len, ilen-hlen-self.mac_len,
  */
   /*try:*/ {
 
-    /* "borg/crypto/low_level.pyx":293
+    /* "borg/crypto/low_level.pyx":284
  *         cdef Py_buffer idata = ro_buffer(envelope)
  *         try:
  *             self.mac_verify(<const unsigned char *> idata.buf+aoffset, alen,             # <<<<<<<<<<<<<<
  *                              <const unsigned char *> idata.buf+hlen+self.mac_len, ilen-hlen-self.mac_len,
  *                              mac_buf, <const unsigned char *> idata.buf+hlen)
  */
-    __pyx_t_5 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self->__pyx_vtab)->mac_verify(__pyx_v_self, (((unsigned char const *)__pyx_v_idata.buf) + __pyx_v_aoffset), __pyx_v_alen, ((((unsigned char const *)__pyx_v_idata.buf) + __pyx_v_hlen) + __pyx_v_self->mac_len), ((__pyx_v_ilen - __pyx_v_hlen) - __pyx_v_self->mac_len), __pyx_v_mac_buf, (((unsigned char const *)__pyx_v_idata.buf) + __pyx_v_hlen)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 293, __pyx_L5_error)
+    __pyx_t_5 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self->__pyx_vtab)->mac_verify(__pyx_v_self, (((unsigned char const *)__pyx_v_idata.buf) + __pyx_v_aoffset), __pyx_v_alen, ((((unsigned char const *)__pyx_v_idata.buf) + __pyx_v_hlen) + __pyx_v_self->mac_len), ((__pyx_v_ilen - __pyx_v_hlen) - __pyx_v_self->mac_len), __pyx_v_mac_buf, (((unsigned char const *)__pyx_v_idata.buf) + __pyx_v_hlen)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 284, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "borg/crypto/low_level.pyx":296
+    /* "borg/crypto/low_level.pyx":287
  *                              <const unsigned char *> idata.buf+hlen+self.mac_len, ilen-hlen-self.mac_len,
  *                              mac_buf, <const unsigned char *> idata.buf+hlen)
  *             iv = self.fetch_iv(<unsigned char *> idata.buf+hlen+self.mac_len)             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *             if not EVP_DecryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, iv):
  */
-    __pyx_t_5 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self->__pyx_vtab)->fetch_iv(__pyx_v_self, ((((unsigned char *)__pyx_v_idata.buf) + __pyx_v_hlen) + __pyx_v_self->mac_len)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 296, __pyx_L5_error)
+    __pyx_t_5 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self->__pyx_vtab)->fetch_iv(__pyx_v_self, ((((unsigned char *)__pyx_v_idata.buf) + __pyx_v_hlen) + __pyx_v_self->mac_len)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 287, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_v_iv = __pyx_t_5;
     __pyx_t_5 = 0;
 
-    /* "borg/crypto/low_level.pyx":297
+    /* "borg/crypto/low_level.pyx":288
  *                              mac_buf, <const unsigned char *> idata.buf+hlen)
  *             iv = self.fetch_iv(<unsigned char *> idata.buf+hlen+self.mac_len)
  *             self.set_iv(iv)             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, iv):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  */
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 297, __pyx_L5_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 288, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_6);
     __pyx_t_7 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
       __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
       if (likely(__pyx_t_7)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
         __Pyx_INCREF(__pyx_t_7);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_6, function);
       }
     }
     __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_v_iv) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_iv);
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 297, __pyx_L5_error)
+    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 288, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "borg/crypto/low_level.pyx":298
+    /* "borg/crypto/low_level.pyx":289
  *             iv = self.fetch_iv(<unsigned char *> idata.buf+hlen+self.mac_len)
  *             self.set_iv(iv)
  *             if not EVP_DecryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, iv):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             offset = 0
  */
-    __pyx_t_8 = __Pyx_PyObject_AsUString(__pyx_v_iv); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 298, __pyx_L5_error)
+    __pyx_t_8 = __Pyx_PyObject_AsUString(__pyx_v_iv); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 289, __pyx_L5_error)
     __pyx_t_3 = ((!(EVP_DecryptInit_ex(__pyx_v_self->ctx, EVP_aes_256_ctr(), NULL, __pyx_v_self->enc_key, __pyx_t_8) != 0)) != 0);
     if (unlikely(__pyx_t_3)) {
 
-      /* "borg/crypto/low_level.pyx":299
+      /* "borg/crypto/low_level.pyx":290
  *             self.set_iv(iv)
  *             if not EVP_DecryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, iv):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata+offset, &olen,
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 299, __pyx_L5_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 290, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_7 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
           __Pyx_INCREF(__pyx_t_7);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_6, function);
         }
       }
       __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_kp_s_EVP_DecryptInit_ex_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_kp_s_EVP_DecryptInit_ex_failed);
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 299, __pyx_L5_error)
+      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 290, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(0, 299, __pyx_L5_error)
+      __PYX_ERR(0, 290, __pyx_L5_error)
 
-      /* "borg/crypto/low_level.pyx":298
+      /* "borg/crypto/low_level.pyx":289
  *             iv = self.fetch_iv(<unsigned char *> idata.buf+hlen+self.mac_len)
  *             self.set_iv(iv)
  *             if not EVP_DecryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, iv):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             offset = 0
  */
     }
 
-    /* "borg/crypto/low_level.pyx":300
+    /* "borg/crypto/low_level.pyx":291
  *             if not EVP_DecryptInit_ex(self.ctx, EVP_aes_256_ctr(), NULL, self.enc_key, iv):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             offset = 0             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptUpdate(self.ctx, odata+offset, &olen,
  *                                      <const unsigned char*> idata.buf+hlen+self.mac_len+self.iv_len_short,
  */
     __pyx_v_offset = 0;
 
-    /* "borg/crypto/low_level.pyx":301
+    /* "borg/crypto/low_level.pyx":292
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata+offset, &olen,             # <<<<<<<<<<<<<<
  *                                      <const unsigned char*> idata.buf+hlen+self.mac_len+self.iv_len_short,
  *                                      ilen-hlen-self.mac_len-self.iv_len_short):
  */
     __pyx_t_3 = ((!(EVP_DecryptUpdate(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen), (((((unsigned char const *)__pyx_v_idata.buf) + __pyx_v_hlen) + __pyx_v_self->mac_len) + __pyx_v_self->iv_len_short), (((__pyx_v_ilen - __pyx_v_hlen) - __pyx_v_self->mac_len) - __pyx_v_self->iv_len_short)) != 0)) != 0);
     if (unlikely(__pyx_t_3)) {
 
-      /* "borg/crypto/low_level.pyx":304
+      /* "borg/crypto/low_level.pyx":295
  *                                      <const unsigned char*> idata.buf+hlen+self.mac_len+self.iv_len_short,
  *                                      ilen-hlen-self.mac_len-self.iv_len_short):
  *                 raise CryptoError('EVP_DecryptUpdate failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 304, __pyx_L5_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 295, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_7 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
           __Pyx_INCREF(__pyx_t_7);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_6, function);
         }
       }
       __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_kp_s_EVP_DecryptUpdate_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_kp_s_EVP_DecryptUpdate_failed);
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 304, __pyx_L5_error)
+      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 295, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(0, 304, __pyx_L5_error)
+      __PYX_ERR(0, 295, __pyx_L5_error)
 
-      /* "borg/crypto/low_level.pyx":301
+      /* "borg/crypto/low_level.pyx":292
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata+offset, &olen,             # <<<<<<<<<<<<<<
  *                                      <const unsigned char*> idata.buf+hlen+self.mac_len+self.iv_len_short,
  *                                      ilen-hlen-self.mac_len-self.iv_len_short):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":305
+    /* "borg/crypto/low_level.pyx":296
  *                                      ilen-hlen-self.mac_len-self.iv_len_short):
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise CryptoError('EVP_DecryptFinal_ex failed')
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":306
+    /* "borg/crypto/low_level.pyx":297
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset += olen
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptFinal_ex failed')
  *             offset += olen
  */
     __pyx_t_3 = ((!(EVP_DecryptFinal_ex(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen)) != 0)) != 0);
     if (unlikely(__pyx_t_3)) {
 
-      /* "borg/crypto/low_level.pyx":307
+      /* "borg/crypto/low_level.pyx":298
  *             offset += olen
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise CryptoError('EVP_DecryptFinal_ex failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             self.blocks += self.block_count(offset)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 307, __pyx_L5_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 298, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_7 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
           __Pyx_INCREF(__pyx_t_7);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_6, function);
         }
       }
       __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_kp_s_EVP_DecryptFinal_ex_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_kp_s_EVP_DecryptFinal_ex_failed);
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 307, __pyx_L5_error)
+      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 298, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(0, 307, __pyx_L5_error)
+      __PYX_ERR(0, 298, __pyx_L5_error)
 
-      /* "borg/crypto/low_level.pyx":306
+      /* "borg/crypto/low_level.pyx":297
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset += olen
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptFinal_ex failed')
  *             offset += olen
  */
     }
 
-    /* "borg/crypto/low_level.pyx":308
+    /* "borg/crypto/low_level.pyx":299
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise CryptoError('EVP_DecryptFinal_ex failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             self.blocks += self.block_count(offset)
  *             return odata[:offset]
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":309
+    /* "borg/crypto/low_level.pyx":300
  *                 raise CryptoError('EVP_DecryptFinal_ex failed')
  *             offset += olen
  *             self.blocks += self.block_count(offset)             # <<<<<<<<<<<<<<
  *             return odata[:offset]
  *         finally:
  */
-    __pyx_t_5 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_self->blocks); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 309, __pyx_L5_error)
+    __pyx_t_5 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_self->blocks); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 300, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 309, __pyx_L5_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 300, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_9 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 309, __pyx_L5_error)
+    __pyx_t_9 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 300, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_9);
     __pyx_t_10 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
       __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_10)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
         __Pyx_INCREF(__pyx_t_10);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
     __pyx_t_6 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_10, __pyx_t_9) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_9);
     __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
     __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 309, __pyx_L5_error)
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 300, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = PyNumber_InPlaceAdd(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 309, __pyx_L5_error)
+    __pyx_t_7 = PyNumber_InPlaceAdd(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 300, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_11 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_7); if (unlikely((__pyx_t_11 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 309, __pyx_L5_error)
+    __pyx_t_11 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_7); if (unlikely((__pyx_t_11 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 300, __pyx_L5_error)
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __pyx_v_self->blocks = __pyx_t_11;
 
-    /* "borg/crypto/low_level.pyx":310
+    /* "borg/crypto/low_level.pyx":301
  *             offset += olen
  *             self.blocks += self.block_count(offset)
  *             return odata[:offset]             # <<<<<<<<<<<<<<
  *         finally:
  *             PyMem_Free(odata)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_7 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 310, __pyx_L5_error)
+    __pyx_t_7 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 301, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_7);
     __pyx_r = __pyx_t_7;
     __pyx_t_7 = 0;
     goto __pyx_L4_return;
   }
 
-  /* "borg/crypto/low_level.pyx":312
+  /* "borg/crypto/low_level.pyx":303
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  * 
  */
   /*finally:*/ {
@@ -5791,15 +5801,15 @@
       __Pyx_XGOTREF(__pyx_t_17);
       __Pyx_XGOTREF(__pyx_t_18);
       __Pyx_XGOTREF(__pyx_t_19);
       __pyx_t_2 = __pyx_lineno; __pyx_t_12 = __pyx_clineno; __pyx_t_13 = __pyx_filename;
       {
         PyMem_Free(__pyx_v_odata);
 
-        /* "borg/crypto/low_level.pyx":313
+        /* "borg/crypto/low_level.pyx":304
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  * 
  *     def block_count(self, length):
  */
         PyBuffer_Release((&__pyx_v_idata));
@@ -5818,38 +5828,38 @@
       __pyx_lineno = __pyx_t_2; __pyx_clineno = __pyx_t_12; __pyx_filename = __pyx_t_13;
       goto __pyx_L1_error;
     }
     __pyx_L4_return: {
       __pyx_t_19 = __pyx_r;
       __pyx_r = 0;
 
-      /* "borg/crypto/low_level.pyx":312
+      /* "borg/crypto/low_level.pyx":303
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  * 
  */
       PyMem_Free(__pyx_v_odata);
 
-      /* "borg/crypto/low_level.pyx":313
+      /* "borg/crypto/low_level.pyx":304
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  * 
  *     def block_count(self, length):
  */
       PyBuffer_Release((&__pyx_v_idata));
       __pyx_r = __pyx_t_19;
       __pyx_t_19 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "borg/crypto/low_level.pyx":276
+  /* "borg/crypto/low_level.pyx":267
  *             PyBuffer_Release(&idata)
  * 
  *     def decrypt(self, envelope, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         authenticate aad + iv + cdata, decrypt cdata, ignore header bytes up to aad_offset.
  */
 
@@ -5865,15 +5875,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_iv);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":315
+/* "borg/crypto/low_level.pyx":306
  *             PyBuffer_Release(&idata)
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  */
 
@@ -5900,25 +5910,25 @@
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("block_count", 0);
 
-  /* "borg/crypto/low_level.pyx":316
+  /* "borg/crypto/low_level.pyx":307
  * 
  *     def block_count(self, length):
  *         return num_cipher_blocks(length, self.cipher_blk_len)             # <<<<<<<<<<<<<<
  * 
  *     def set_iv(self, iv):
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_num_cipher_blocks); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 316, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_num_cipher_blocks); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 307, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->cipher_blk_len); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 316, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->cipher_blk_len); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 307, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -5927,51 +5937,51 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_length, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 316, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 307, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_length, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 316, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 307, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 316, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 307, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_v_length);
     __Pyx_GIVEREF(__pyx_v_length);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_length);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 316, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 307, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":315
+  /* "borg/crypto/low_level.pyx":306
  *             PyBuffer_Release(&idata)
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  */
 
@@ -5986,15 +5996,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":318
+/* "borg/crypto/low_level.pyx":309
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         # set_iv needs to be called before each encrypt() call
  *         if isinstance(iv, int):
  */
 
@@ -6025,62 +6035,62 @@
   unsigned char __pyx_t_9[16];
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("set_iv", 0);
   __Pyx_INCREF(__pyx_v_iv);
 
-  /* "borg/crypto/low_level.pyx":320
+  /* "borg/crypto/low_level.pyx":311
  *     def set_iv(self, iv):
  *         # set_iv needs to be called before each encrypt() call
  *         if isinstance(iv, int):             # <<<<<<<<<<<<<<
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  */
   __pyx_t_1 = PyInt_Check(__pyx_v_iv); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/crypto/low_level.pyx":321
+    /* "borg/crypto/low_level.pyx":312
  *         # set_iv needs to be called before each encrypt() call
  *         if isinstance(iv, int):
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')             # <<<<<<<<<<<<<<
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  *         self.iv = iv
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_iv, __pyx_n_s_to_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 321, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_iv, __pyx_n_s_to_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 312, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_self->iv_len); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 321, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_self->iv_len); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 312, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 321, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 312, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 321, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 312, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 321, __pyx_L1_error)
-    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 321, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 312, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 312, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF_SET(__pyx_v_iv, __pyx_t_6);
     __pyx_t_6 = 0;
 
-    /* "borg/crypto/low_level.pyx":320
+    /* "borg/crypto/low_level.pyx":311
  *     def set_iv(self, iv):
  *         # set_iv needs to be called before each encrypt() call
  *         if isinstance(iv, int):             # <<<<<<<<<<<<<<
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  */
   }
 
-  /* "borg/crypto/low_level.pyx":322
+  /* "borg/crypto/low_level.pyx":313
  *         if isinstance(iv, int):
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len             # <<<<<<<<<<<<<<
  *         self.iv = iv
  *         self.blocks = 0  # how many AES blocks got encrypted with this IV?
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -6088,45 +6098,45 @@
     __pyx_t_1 = PyBytes_Check(__pyx_v_iv); 
     __pyx_t_7 = (__pyx_t_1 != 0);
     if (__pyx_t_7) {
     } else {
       __pyx_t_2 = __pyx_t_7;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_8 = PyObject_Length(__pyx_v_iv); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 322, __pyx_L1_error)
+    __pyx_t_8 = PyObject_Length(__pyx_v_iv); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 313, __pyx_L1_error)
     __pyx_t_7 = ((__pyx_t_8 == __pyx_v_self->iv_len) != 0);
     __pyx_t_2 = __pyx_t_7;
     __pyx_L4_bool_binop_done:;
     if (unlikely(!__pyx_t_2)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 322, __pyx_L1_error)
+      __PYX_ERR(0, 313, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":323
+  /* "borg/crypto/low_level.pyx":314
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  *         self.iv = iv             # <<<<<<<<<<<<<<
  *         self.blocks = 0  # how many AES blocks got encrypted with this IV?
  * 
  */
-  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_iv, __pyx_t_9, 16) < 0)) __PYX_ERR(0, 323, __pyx_L1_error)
+  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_iv, __pyx_t_9, 16) < 0)) __PYX_ERR(0, 314, __pyx_L1_error)
   memcpy(&(__pyx_v_self->iv[0]), __pyx_t_9, sizeof(__pyx_v_self->iv[0]) * (16));
 
-  /* "borg/crypto/low_level.pyx":324
+  /* "borg/crypto/low_level.pyx":315
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  *         self.iv = iv
  *         self.blocks = 0  # how many AES blocks got encrypted with this IV?             # <<<<<<<<<<<<<<
  * 
  *     def next_iv(self):
  */
   __pyx_v_self->blocks = 0;
 
-  /* "borg/crypto/low_level.pyx":318
+  /* "borg/crypto/low_level.pyx":309
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         # set_iv needs to be called before each encrypt() call
  *         if isinstance(iv, int):
  */
 
@@ -6143,15 +6153,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_iv);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":326
+/* "borg/crypto/low_level.pyx":317
  *         self.blocks = 0  # how many AES blocks got encrypted with this IV?
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')
  */
 
@@ -6177,59 +6187,59 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("next_iv", 0);
 
-  /* "borg/crypto/low_level.pyx":328
+  /* "borg/crypto/low_level.pyx":319
  *     def next_iv(self):
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')             # <<<<<<<<<<<<<<
  *         return iv + self.blocks
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)(&PyInt_Type)), __pyx_n_s_from_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 328, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)(&PyInt_Type)), __pyx_n_s_from_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 319, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->iv) + 0, __pyx_v_self->iv_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 328, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->iv) + 0, __pyx_v_self->iv_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 319, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 328, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 319, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 328, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 319, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 328, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 328, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 319, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 319, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_iv = __pyx_t_4;
   __pyx_t_4 = 0;
 
-  /* "borg/crypto/low_level.pyx":329
+  /* "borg/crypto/low_level.pyx":320
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')
  *         return iv + self.blocks             # <<<<<<<<<<<<<<
  * 
  *     cdef fetch_iv(self, unsigned char * iv_in):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_4 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_self->blocks); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 329, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_self->blocks); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 320, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 = PyNumber_Add(__pyx_v_iv, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 329, __pyx_L1_error)
+  __pyx_t_2 = PyNumber_Add(__pyx_v_iv, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 320, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":326
+  /* "borg/crypto/low_level.pyx":317
  *         self.blocks = 0  # how many AES blocks got encrypted with this IV?
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')
  */
 
@@ -6244,15 +6254,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_iv);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":331
+/* "borg/crypto/low_level.pyx":322
  *         return iv + self.blocks
  * 
  *     cdef fetch_iv(self, unsigned char * iv_in):             # <<<<<<<<<<<<<<
  *         # fetch lower self.iv_len_short bytes of iv and add upper zero bytes
  *         return b'\0' * (self.iv_len - self.iv_len_short) + iv_in[0:self.iv_len_short]
  */
 
@@ -6263,38 +6273,38 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fetch_iv", 0);
 
-  /* "borg/crypto/low_level.pyx":333
+  /* "borg/crypto/low_level.pyx":324
  *     cdef fetch_iv(self, unsigned char * iv_in):
  *         # fetch lower self.iv_len_short bytes of iv and add upper zero bytes
  *         return b'\0' * (self.iv_len - self.iv_len_short) + iv_in[0:self.iv_len_short]             # <<<<<<<<<<<<<<
  * 
  *     cdef store_iv(self, unsigned char * iv_out, unsigned char * iv):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int((__pyx_v_self->iv_len - __pyx_v_self->iv_len_short)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 333, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int((__pyx_v_self->iv_len - __pyx_v_self->iv_len_short)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 324, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyNumber_Multiply(__pyx_kp_b__2, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 333, __pyx_L1_error)
+  __pyx_t_2 = PyNumber_Multiply(__pyx_kp_b__2, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 324, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_iv_in) + 0, __pyx_v_self->iv_len_short - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 333, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_iv_in) + 0, __pyx_v_self->iv_len_short - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 324, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyNumber_Add(__pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 333, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Add(__pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 324, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":331
+  /* "borg/crypto/low_level.pyx":322
  *         return iv + self.blocks
  * 
  *     cdef fetch_iv(self, unsigned char * iv_in):             # <<<<<<<<<<<<<<
  *         # fetch lower self.iv_len_short bytes of iv and add upper zero bytes
  *         return b'\0' * (self.iv_len - self.iv_len_short) + iv_in[0:self.iv_len_short]
  */
 
@@ -6307,15 +6317,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":335
+/* "borg/crypto/low_level.pyx":326
  *         return b'\0' * (self.iv_len - self.iv_len_short) + iv_in[0:self.iv_len_short]
  * 
  *     cdef store_iv(self, unsigned char * iv_out, unsigned char * iv):             # <<<<<<<<<<<<<<
  *         # store only lower self.iv_len_short bytes, upper bytes are assumed to be 0
  *         cdef int i
  */
 
@@ -6324,52 +6334,52 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   __Pyx_RefNannySetupContext("store_iv", 0);
 
-  /* "borg/crypto/low_level.pyx":338
+  /* "borg/crypto/low_level.pyx":329
  *         # store only lower self.iv_len_short bytes, upper bytes are assumed to be 0
  *         cdef int i
  *         for i in range(self.iv_len_short):             # <<<<<<<<<<<<<<
  *             iv_out[i] = iv[(self.iv_len-self.iv_len_short)+i]
  * 
  */
   __pyx_t_1 = __pyx_v_self->iv_len_short;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "borg/crypto/low_level.pyx":339
+    /* "borg/crypto/low_level.pyx":330
  *         cdef int i
  *         for i in range(self.iv_len_short):
  *             iv_out[i] = iv[(self.iv_len-self.iv_len_short)+i]             # <<<<<<<<<<<<<<
  * 
  *     def extract_iv(self, envelope):
  */
     (__pyx_v_iv_out[__pyx_v_i]) = (__pyx_v_iv[((__pyx_v_self->iv_len - __pyx_v_self->iv_len_short) + __pyx_v_i)]);
   }
 
-  /* "borg/crypto/low_level.pyx":335
+  /* "borg/crypto/low_level.pyx":326
  *         return b'\0' * (self.iv_len - self.iv_len_short) + iv_in[0:self.iv_len_short]
  * 
  *     cdef store_iv(self, unsigned char * iv_out, unsigned char * iv):             # <<<<<<<<<<<<<<
  *         # store only lower self.iv_len_short bytes, upper bytes are assumed to be 0
  *         cdef int i
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":341
+/* "borg/crypto/low_level.pyx":332
  *             iv_out[i] = iv[(self.iv_len-self.iv_len_short)+i]
  * 
  *     def extract_iv(self, envelope):             # <<<<<<<<<<<<<<
  *         offset = self.header_len + self.mac_len
  *         return bytes_to_long(envelope[offset:offset+self.iv_len_short])
  */
 
@@ -6395,42 +6405,42 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("extract_iv", 0);
 
-  /* "borg/crypto/low_level.pyx":342
+  /* "borg/crypto/low_level.pyx":333
  * 
  *     def extract_iv(self, envelope):
  *         offset = self.header_len + self.mac_len             # <<<<<<<<<<<<<<
  *         return bytes_to_long(envelope[offset:offset+self.iv_len_short])
  * 
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int((__pyx_v_self->header_len + __pyx_v_self->mac_len)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 342, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int((__pyx_v_self->header_len + __pyx_v_self->mac_len)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 333, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_offset = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":343
+  /* "borg/crypto/low_level.pyx":334
  *     def extract_iv(self, envelope):
  *         offset = self.header_len + self.mac_len
  *         return bytes_to_long(envelope[offset:offset+self.iv_len_short])             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_bytes_to_long); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 343, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_bytes_to_long); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 334, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->iv_len_short); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 343, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->iv_len_short); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 334, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyNumber_Add(__pyx_v_offset, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 343, __pyx_L1_error)
+  __pyx_t_4 = PyNumber_Add(__pyx_v_offset, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 334, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetSlice(__pyx_v_envelope, 0, 0, &__pyx_v_offset, &__pyx_t_4, NULL, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 343, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetSlice(__pyx_v_envelope, 0, 0, &__pyx_v_offset, &__pyx_t_4, NULL, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 334, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -6438,22 +6448,22 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 343, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 334, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":341
+  /* "borg/crypto/low_level.pyx":332
  *             iv_out[i] = iv[(self.iv_len-self.iv_len_short)+i]
  * 
  *     def extract_iv(self, envelope):             # <<<<<<<<<<<<<<
  *         offset = self.header_len + self.mac_len
  *         return bytes_to_long(envelope[offset:offset+self.iv_len_short])
  */
 
@@ -6581,15 +6591,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BASE.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":349
+/* "borg/crypto/low_level.pyx":340
  *     cdef unsigned char mac_key[32]
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 32
  *         self.mac_key = mac_key
  */
 
@@ -6635,15 +6645,15 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mac_key)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_enc_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, 1); __PYX_ERR(0, 349, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, 1); __PYX_ERR(0, 340, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[2] = value; kw_args--; }
         }
@@ -6657,15 +6667,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 349, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 340, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -6681,15 +6691,15 @@
     __pyx_v_enc_key = values[1];
     __pyx_v_iv = values[2];
     __pyx_v_header_len = values[3];
     __pyx_v_aad_offset = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 349, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 340, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_HMAC_SHA256.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_22AES256_CTR_HMAC_SHA256___init__(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 *)__pyx_v_self), __pyx_v_mac_key, __pyx_v_enc_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -6711,15 +6721,15 @@
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/crypto/low_level.pyx":350
+  /* "borg/crypto/low_level.pyx":341
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 32             # <<<<<<<<<<<<<<
  *         self.mac_key = mac_key
  *         super().__init__(mac_key, enc_key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -6727,77 +6737,77 @@
     __pyx_t_2 = PyBytes_Check(__pyx_v_mac_key); 
     __pyx_t_3 = (__pyx_t_2 != 0);
     if (__pyx_t_3) {
     } else {
       __pyx_t_1 = __pyx_t_3;
       goto __pyx_L3_bool_binop_done;
     }
-    __pyx_t_4 = PyObject_Length(__pyx_v_mac_key); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 350, __pyx_L1_error)
+    __pyx_t_4 = PyObject_Length(__pyx_v_mac_key); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 341, __pyx_L1_error)
     __pyx_t_3 = ((__pyx_t_4 == 32) != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!__pyx_t_1)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 350, __pyx_L1_error)
+      __PYX_ERR(0, 341, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":351
+  /* "borg/crypto/low_level.pyx":342
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 32
  *         self.mac_key = mac_key             # <<<<<<<<<<<<<<
  *         super().__init__(mac_key, enc_key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  * 
  */
-  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_mac_key, __pyx_t_5, 32) < 0)) __PYX_ERR(0, 351, __pyx_L1_error)
+  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_mac_key, __pyx_t_5, 32) < 0)) __PYX_ERR(0, 342, __pyx_L1_error)
   memcpy(&(__pyx_v_self->mac_key[0]), __pyx_t_5, sizeof(__pyx_v_self->mac_key[0]) * (32));
 
-  /* "borg/crypto/low_level.pyx":352
+  /* "borg/crypto/low_level.pyx":343
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 32
  *         self.mac_key = mac_key
  *         super().__init__(mac_key, enc_key, iv=iv, header_len=header_len, aad_offset=aad_offset)             # <<<<<<<<<<<<<<
  * 
  *     def __cinit__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  */
-  __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 352, __pyx_L1_error)
+  __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 343, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256));
   PyTuple_SET_ITEM(__pyx_t_6, 0, ((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256));
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_6, 1, ((PyObject *)__pyx_v_self));
-  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_6, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 352, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_6, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 343, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_init); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 352, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_init); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 343, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 352, __pyx_L1_error)
+  __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 343, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_v_mac_key);
   __Pyx_GIVEREF(__pyx_v_mac_key);
   PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_mac_key);
   __Pyx_INCREF(__pyx_v_enc_key);
   __Pyx_GIVEREF(__pyx_v_enc_key);
   PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_v_enc_key);
-  __pyx_t_8 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 352, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 343, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 352, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 352, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_aad_offset, __pyx_v_aad_offset) < 0) __PYX_ERR(0, 352, __pyx_L1_error)
-  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 352, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 343, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 343, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_aad_offset, __pyx_v_aad_offset) < 0) __PYX_ERR(0, 343, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 343, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/crypto/low_level.pyx":349
+  /* "borg/crypto/low_level.pyx":340
  *     cdef unsigned char mac_key[32]
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 32
  *         self.mac_key = mac_key
  */
 
@@ -6812,15 +6822,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_HMAC_SHA256.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":354
+/* "borg/crypto/low_level.pyx":345
  *         super().__init__(mac_key, enc_key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  * 
  *     def __cinit__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
 
@@ -6866,15 +6876,15 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mac_key)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_enc_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, 1); __PYX_ERR(0, 354, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, 1); __PYX_ERR(0, 345, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[2] = value; kw_args--; }
         }
@@ -6888,15 +6898,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 354, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 345, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -6912,15 +6922,15 @@
     __pyx_v_enc_key = values[1];
     __pyx_v_iv = values[2];
     __pyx_v_header_len = values[3];
     __pyx_v_aad_offset = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 354, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 345, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_HMAC_SHA256.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_22AES256_CTR_HMAC_SHA256_2__cinit__(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 *)__pyx_v_self), __pyx_v_mac_key, __pyx_v_enc_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -6936,15 +6946,15 @@
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":357
+/* "borg/crypto/low_level.pyx":348
  *         pass
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
 
@@ -6963,15 +6973,15 @@
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "borg/crypto/low_level.pyx":360
+/* "borg/crypto/low_level.pyx":351
  *         pass
  * 
  *     cdef mac_compute(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                      const unsigned char *data2, int data2_len,
  *                      unsigned char *mac_buf):
  */
 
@@ -6991,45 +7001,45 @@
   int __pyx_t_8;
   unsigned char __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("mac_compute", 0);
 
-  /* "borg/crypto/low_level.pyx":363
+  /* "borg/crypto/low_level.pyx":354
  *                      const unsigned char *data2, int data2_len,
  *                      unsigned char *mac_buf):
  *         data = data1[:data1_len] + data2[:data2_len]             # <<<<<<<<<<<<<<
  *         mac = hmac.digest(self.mac_key[:self.mac_len], data, 'sha256')
  *         for i in range(self.mac_len):
  */
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data1) + 0, __pyx_v_data1_len - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 363, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data1) + 0, __pyx_v_data1_len - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 354, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data2) + 0, __pyx_v_data2_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 363, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data2) + 0, __pyx_v_data2_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 354, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 363, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 354, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_data = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* "borg/crypto/low_level.pyx":364
+  /* "borg/crypto/low_level.pyx":355
  *                      unsigned char *mac_buf):
  *         data = data1[:data1_len] + data2[:data2_len]
  *         mac = hmac.digest(self.mac_key[:self.mac_len], data, 'sha256')             # <<<<<<<<<<<<<<
  *         for i in range(self.mac_len):
  *             mac_buf[i] = mac[i]
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hmac); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 364, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hmac); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 355, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_digest); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 364, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_digest); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 355, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->mac_key) + 0, __pyx_v_self->__pyx_base.mac_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 364, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->mac_key) + 0, __pyx_v_self->__pyx_base.mac_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 355, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_1);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
@@ -7038,79 +7048,79 @@
       __Pyx_DECREF_SET(__pyx_t_1, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_1)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_2, __pyx_v_data, __pyx_n_s_sha256};
-    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 3+__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 364, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 3+__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 355, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_2, __pyx_v_data, __pyx_n_s_sha256};
-    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 3+__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 364, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_5, 3+__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 355, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(3+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 364, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(3+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 355, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_t_2);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_data);
     __Pyx_INCREF(__pyx_n_s_sha256);
     __Pyx_GIVEREF(__pyx_n_s_sha256);
     PyTuple_SET_ITEM(__pyx_t_6, 2+__pyx_t_5, __pyx_n_s_sha256);
     __pyx_t_2 = 0;
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 364, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 355, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_mac = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "borg/crypto/low_level.pyx":365
+  /* "borg/crypto/low_level.pyx":356
  *         data = data1[:data1_len] + data2[:data2_len]
  *         mac = hmac.digest(self.mac_key[:self.mac_len], data, 'sha256')
  *         for i in range(self.mac_len):             # <<<<<<<<<<<<<<
  *             mac_buf[i] = mac[i]
  * 
  */
   __pyx_t_5 = __pyx_v_self->__pyx_base.mac_len;
   __pyx_t_7 = __pyx_t_5;
   for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
     __pyx_v_i = __pyx_t_8;
 
-    /* "borg/crypto/low_level.pyx":366
+    /* "borg/crypto/low_level.pyx":357
  *         mac = hmac.digest(self.mac_key[:self.mac_len], data, 'sha256')
  *         for i in range(self.mac_len):
  *             mac_buf[i] = mac[i]             # <<<<<<<<<<<<<<
  * 
  *     cdef mac_verify(self, const unsigned char *data1, int data1_len,
  */
-    __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_mac, __pyx_v_i, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 366, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_mac, __pyx_v_i, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 357, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_9 = __Pyx_PyInt_As_unsigned_char(__pyx_t_3); if (unlikely((__pyx_t_9 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 366, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyInt_As_unsigned_char(__pyx_t_3); if (unlikely((__pyx_t_9 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 357, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     (__pyx_v_mac_buf[__pyx_v_i]) = __pyx_t_9;
   }
 
-  /* "borg/crypto/low_level.pyx":360
+  /* "borg/crypto/low_level.pyx":351
  *         pass
  * 
  *     cdef mac_compute(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                      const unsigned char *data2, int data2_len,
  *                      unsigned char *mac_buf):
  */
 
@@ -7129,15 +7139,15 @@
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XDECREF(__pyx_v_mac);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":368
+/* "borg/crypto/low_level.pyx":359
  *             mac_buf[i] = mac[i]
  * 
  *     cdef mac_verify(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                     const unsigned char *data2, int data2_len,
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  */
 
@@ -7149,73 +7159,73 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("mac_verify", 0);
 
-  /* "borg/crypto/low_level.pyx":371
+  /* "borg/crypto/low_level.pyx":362
  *                     const unsigned char *data2, int data2_len,
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  *         self.mac_compute(data1, data1_len, data2, data2_len, mac_buf)             # <<<<<<<<<<<<<<
  *         if CRYPTO_memcmp(mac_buf, mac_wanted, self.mac_len):
  *             raise IntegrityError('MAC Authentication failed')
  */
-  __pyx_t_1 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.mac_compute(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self), __pyx_v_data1, __pyx_v_data1_len, __pyx_v_data2, __pyx_v_data2_len, __pyx_v_mac_buf); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 371, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.mac_compute(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self), __pyx_v_data1, __pyx_v_data1_len, __pyx_v_data2, __pyx_v_data2_len, __pyx_v_mac_buf); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 362, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":372
+  /* "borg/crypto/low_level.pyx":363
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  *         self.mac_compute(data1, data1_len, data2, data2_len, mac_buf)
  *         if CRYPTO_memcmp(mac_buf, mac_wanted, self.mac_len):             # <<<<<<<<<<<<<<
  *             raise IntegrityError('MAC Authentication failed')
  * 
  */
   __pyx_t_2 = (CRYPTO_memcmp(__pyx_v_mac_buf, __pyx_v_mac_wanted, __pyx_v_self->__pyx_base.mac_len) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "borg/crypto/low_level.pyx":373
+    /* "borg/crypto/low_level.pyx":364
  *         self.mac_compute(data1, data1_len, data2, data2_len, mac_buf)
  *         if CRYPTO_memcmp(mac_buf, mac_wanted, self.mac_len):
  *             raise IntegrityError('MAC Authentication failed')             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_IntegrityError); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 373, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_IntegrityError); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 364, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_MAC_Authentication_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_MAC_Authentication_failed);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 373, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 364, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_1, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 373, __pyx_L1_error)
+    __PYX_ERR(0, 364, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":372
+    /* "borg/crypto/low_level.pyx":363
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  *         self.mac_compute(data1, data1_len, data2, data2_len, mac_buf)
  *         if CRYPTO_memcmp(mac_buf, mac_wanted, self.mac_len):             # <<<<<<<<<<<<<<
  *             raise IntegrityError('MAC Authentication failed')
  * 
  */
   }
 
-  /* "borg/crypto/low_level.pyx":368
+  /* "borg/crypto/low_level.pyx":359
  *             mac_buf[i] = mac[i]
  * 
  *     cdef mac_verify(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                     const unsigned char *data2, int data2_len,
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  */
 
@@ -7343,15 +7353,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_HMAC_SHA256.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":379
+/* "borg/crypto/low_level.pyx":370
  *     cdef unsigned char mac_key[128]
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 128
  *         self.mac_key = mac_key
  */
 
@@ -7397,15 +7407,15 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mac_key)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_enc_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, 1); __PYX_ERR(0, 379, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, 1); __PYX_ERR(0, 370, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[2] = value; kw_args--; }
         }
@@ -7419,15 +7429,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 379, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 370, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -7443,15 +7453,15 @@
     __pyx_v_enc_key = values[1];
     __pyx_v_iv = values[2];
     __pyx_v_header_len = values[3];
     __pyx_v_aad_offset = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 379, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 370, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BLAKE2b.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_18AES256_CTR_BLAKE2b___init__(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b *)__pyx_v_self), __pyx_v_mac_key, __pyx_v_enc_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -7473,15 +7483,15 @@
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/crypto/low_level.pyx":380
+  /* "borg/crypto/low_level.pyx":371
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 128             # <<<<<<<<<<<<<<
  *         self.mac_key = mac_key
  *         super().__init__(mac_key, enc_key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -7489,81 +7499,81 @@
     __pyx_t_2 = PyBytes_Check(__pyx_v_mac_key); 
     __pyx_t_3 = (__pyx_t_2 != 0);
     if (__pyx_t_3) {
     } else {
       __pyx_t_1 = __pyx_t_3;
       goto __pyx_L3_bool_binop_done;
     }
-    __pyx_t_4 = PyObject_Length(__pyx_v_mac_key); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 380, __pyx_L1_error)
+    __pyx_t_4 = PyObject_Length(__pyx_v_mac_key); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 371, __pyx_L1_error)
     __pyx_t_3 = ((__pyx_t_4 == 0x80) != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!__pyx_t_1)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 380, __pyx_L1_error)
+      __PYX_ERR(0, 371, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":381
+  /* "borg/crypto/low_level.pyx":372
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 128
  *         self.mac_key = mac_key             # <<<<<<<<<<<<<<
  *         super().__init__(mac_key, enc_key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  * 
  */
-  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_mac_key, __pyx_t_5, 0x80) < 0)) __PYX_ERR(0, 381, __pyx_L1_error)
+  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_mac_key, __pyx_t_5, 0x80) < 0)) __PYX_ERR(0, 372, __pyx_L1_error)
   if (unlikely((0x80) != (0x80))) {
     PyErr_Format(PyExc_ValueError, "Assignment to slice of wrong length, expected %" CYTHON_FORMAT_SSIZE_T "d, got %" CYTHON_FORMAT_SSIZE_T "d", (Py_ssize_t)(0x80), (Py_ssize_t)(0x80));
-    __PYX_ERR(0, 381, __pyx_L1_error)
+    __PYX_ERR(0, 372, __pyx_L1_error)
   }
   memcpy(&(__pyx_v_self->mac_key[0]), __pyx_t_5, sizeof(__pyx_v_self->mac_key[0]) * (0x80));
 
-  /* "borg/crypto/low_level.pyx":382
+  /* "borg/crypto/low_level.pyx":373
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 128
  *         self.mac_key = mac_key
  *         super().__init__(mac_key, enc_key, iv=iv, header_len=header_len, aad_offset=aad_offset)             # <<<<<<<<<<<<<<
  * 
  *     def __cinit__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):
  */
-  __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 373, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b));
   PyTuple_SET_ITEM(__pyx_t_6, 0, ((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b));
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_6, 1, ((PyObject *)__pyx_v_self));
-  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_6, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_6, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 373, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_init); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_init); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 373, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 373, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_v_mac_key);
   __Pyx_GIVEREF(__pyx_v_mac_key);
   PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_mac_key);
   __Pyx_INCREF(__pyx_v_enc_key);
   __Pyx_GIVEREF(__pyx_v_enc_key);
   PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_v_enc_key);
-  __pyx_t_8 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 382, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 373, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 382, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 382, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_aad_offset, __pyx_v_aad_offset) < 0) __PYX_ERR(0, 382, __pyx_L1_error)
-  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 382, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 373, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 373, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_aad_offset, __pyx_v_aad_offset) < 0) __PYX_ERR(0, 373, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 373, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-  /* "borg/crypto/low_level.pyx":379
+  /* "borg/crypto/low_level.pyx":370
  *     cdef unsigned char mac_key[128]
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         assert isinstance(mac_key, bytes) and len(mac_key) == 128
  *         self.mac_key = mac_key
  */
 
@@ -7578,15 +7588,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BLAKE2b.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":384
+/* "borg/crypto/low_level.pyx":375
  *         super().__init__(mac_key, enc_key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  * 
  *     def __cinit__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
 
@@ -7632,15 +7642,15 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mac_key)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_enc_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, 1); __PYX_ERR(0, 384, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, 1); __PYX_ERR(0, 375, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[2] = value; kw_args--; }
         }
@@ -7654,15 +7664,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 384, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 375, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -7678,15 +7688,15 @@
     __pyx_v_enc_key = values[1];
     __pyx_v_iv = values[2];
     __pyx_v_header_len = values[3];
     __pyx_v_aad_offset = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 384, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 375, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BLAKE2b.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_18AES256_CTR_BLAKE2b_2__cinit__(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b *)__pyx_v_self), __pyx_v_mac_key, __pyx_v_enc_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -7702,15 +7712,15 @@
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":387
+/* "borg/crypto/low_level.pyx":378
  *         pass
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
 
@@ -7729,15 +7739,15 @@
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "borg/crypto/low_level.pyx":390
+/* "borg/crypto/low_level.pyx":381
  *         pass
  * 
  *     cdef mac_compute(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                      const unsigned char *data2, int data2_len,
  *                      unsigned char *mac_buf):
  */
 
@@ -7757,114 +7767,114 @@
   int __pyx_t_8;
   unsigned char __pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("mac_compute", 0);
 
-  /* "borg/crypto/low_level.pyx":393
+  /* "borg/crypto/low_level.pyx":384
  *                      const unsigned char *data2, int data2_len,
  *                      unsigned char *mac_buf):
  *         data = self.mac_key[:128] + data1[:data1_len] + data2[:data2_len]             # <<<<<<<<<<<<<<
  *         mac = hashlib.blake2b(data, digest_size=self.mac_len).digest()
  *         for i in range(self.mac_len):
  */
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->mac_key) + 0, 0x80 - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 393, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->mac_key) + 0, 0x80 - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 384, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data1) + 0, __pyx_v_data1_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 393, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data1) + 0, __pyx_v_data1_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 384, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 393, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 384, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data2) + 0, __pyx_v_data2_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 393, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data2) + 0, __pyx_v_data2_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 384, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = PyNumber_Add(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 393, __pyx_L1_error)
+  __pyx_t_1 = PyNumber_Add(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 384, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_data = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":394
+  /* "borg/crypto/low_level.pyx":385
  *                      unsigned char *mac_buf):
  *         data = self.mac_key[:128] + data1[:data1_len] + data2[:data2_len]
  *         mac = hashlib.blake2b(data, digest_size=self.mac_len).digest()             # <<<<<<<<<<<<<<
  *         for i in range(self.mac_len):
  *             mac_buf[i] = mac[i]
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hashlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 394, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hashlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_blake2b); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 394, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_blake2b); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 394, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_v_data);
   __Pyx_GIVEREF(__pyx_v_data);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_data);
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 394, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_self->__pyx_base.mac_len); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 394, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_self->__pyx_base.mac_len); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_digest_size, __pyx_t_5) < 0) __PYX_ERR(0, 394, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_digest_size, __pyx_t_5) < 0) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 394, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_digest); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 394, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_digest); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_t_5 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 394, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_v_mac = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":395
+  /* "borg/crypto/low_level.pyx":386
  *         data = self.mac_key[:128] + data1[:data1_len] + data2[:data2_len]
  *         mac = hashlib.blake2b(data, digest_size=self.mac_len).digest()
  *         for i in range(self.mac_len):             # <<<<<<<<<<<<<<
  *             mac_buf[i] = mac[i]
  * 
  */
   __pyx_t_6 = __pyx_v_self->__pyx_base.mac_len;
   __pyx_t_7 = __pyx_t_6;
   for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
     __pyx_v_i = __pyx_t_8;
 
-    /* "borg/crypto/low_level.pyx":396
+    /* "borg/crypto/low_level.pyx":387
  *         mac = hashlib.blake2b(data, digest_size=self.mac_len).digest()
  *         for i in range(self.mac_len):
  *             mac_buf[i] = mac[i]             # <<<<<<<<<<<<<<
  * 
  *     cdef mac_verify(self, const unsigned char *data1, int data1_len,
  */
-    __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_mac, __pyx_v_i, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 396, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_mac, __pyx_v_i, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 387, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_9 = __Pyx_PyInt_As_unsigned_char(__pyx_t_1); if (unlikely((__pyx_t_9 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 396, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyInt_As_unsigned_char(__pyx_t_1); if (unlikely((__pyx_t_9 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 387, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     (__pyx_v_mac_buf[__pyx_v_i]) = __pyx_t_9;
   }
 
-  /* "borg/crypto/low_level.pyx":390
+  /* "borg/crypto/low_level.pyx":381
  *         pass
  * 
  *     cdef mac_compute(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                      const unsigned char *data2, int data2_len,
  *                      unsigned char *mac_buf):
  */
 
@@ -7883,15 +7893,15 @@
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XDECREF(__pyx_v_mac);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":398
+/* "borg/crypto/low_level.pyx":389
  *             mac_buf[i] = mac[i]
  * 
  *     cdef mac_verify(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                     const unsigned char *data2, int data2_len,
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  */
 
@@ -7903,73 +7913,73 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("mac_verify", 0);
 
-  /* "borg/crypto/low_level.pyx":401
+  /* "borg/crypto/low_level.pyx":392
  *                     const unsigned char *data2, int data2_len,
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  *         self.mac_compute(data1, data1_len, data2, data2_len, mac_buf)             # <<<<<<<<<<<<<<
  *         if CRYPTO_memcmp(mac_buf, mac_wanted, self.mac_len):
  *             raise IntegrityError('MAC Authentication failed')
  */
-  __pyx_t_1 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.mac_compute(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self), __pyx_v_data1, __pyx_v_data1_len, __pyx_v_data2, __pyx_v_data2_len, __pyx_v_mac_buf); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 401, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.mac_compute(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *)__pyx_v_self), __pyx_v_data1, __pyx_v_data1_len, __pyx_v_data2, __pyx_v_data2_len, __pyx_v_mac_buf); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 392, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":402
+  /* "borg/crypto/low_level.pyx":393
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  *         self.mac_compute(data1, data1_len, data2, data2_len, mac_buf)
  *         if CRYPTO_memcmp(mac_buf, mac_wanted, self.mac_len):             # <<<<<<<<<<<<<<
  *             raise IntegrityError('MAC Authentication failed')
  * 
  */
   __pyx_t_2 = (CRYPTO_memcmp(__pyx_v_mac_buf, __pyx_v_mac_wanted, __pyx_v_self->__pyx_base.mac_len) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "borg/crypto/low_level.pyx":403
+    /* "borg/crypto/low_level.pyx":394
  *         self.mac_compute(data1, data1_len, data2, data2_len, mac_buf)
  *         if CRYPTO_memcmp(mac_buf, mac_wanted, self.mac_len):
  *             raise IntegrityError('MAC Authentication failed')             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_IntegrityError); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 403, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_IntegrityError); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 394, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_MAC_Authentication_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_MAC_Authentication_failed);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 403, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 394, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_1, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 403, __pyx_L1_error)
+    __PYX_ERR(0, 394, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":402
+    /* "borg/crypto/low_level.pyx":393
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  *         self.mac_compute(data1, data1_len, data2, data2_len, mac_buf)
  *         if CRYPTO_memcmp(mac_buf, mac_wanted, self.mac_len):             # <<<<<<<<<<<<<<
  *             raise IntegrityError('MAC Authentication failed')
  * 
  */
   }
 
-  /* "borg/crypto/low_level.pyx":398
+  /* "borg/crypto/low_level.pyx":389
  *             mac_buf[i] = mac[i]
  * 
  *     cdef mac_verify(self, const unsigned char *data1, int data1_len,             # <<<<<<<<<<<<<<
  *                     const unsigned char *data2, int data2_len,
  *                     unsigned char *mac_buf, const unsigned char *mac_wanted):
  */
 
@@ -8097,15 +8107,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_CTR_BLAKE2b.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":425
+/* "borg/crypto/low_level.pyx":416
  * 
  *     @classmethod
  *     def requirements_check(cls):             # <<<<<<<<<<<<<<
  *         """check whether library requirements for this ciphersuite are satisfied"""
  *         raise NotImplemented  # override / implement in child class
  */
 
@@ -8127,25 +8137,25 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("requirements_check", 0);
 
-  /* "borg/crypto/low_level.pyx":427
+  /* "borg/crypto/low_level.pyx":418
  *     def requirements_check(cls):
  *         """check whether library requirements for this ciphersuite are satisfied"""
  *         raise NotImplemented  # override / implement in child class             # <<<<<<<<<<<<<<
  * 
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):
  */
   __Pyx_Raise(__pyx_builtin_NotImplemented, 0, 0, 0);
-  __PYX_ERR(0, 427, __pyx_L1_error)
+  __PYX_ERR(0, 418, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":425
+  /* "borg/crypto/low_level.pyx":416
  * 
  *     @classmethod
  *     def requirements_check(cls):             # <<<<<<<<<<<<<<
  *         """check whether library requirements for this ciphersuite are satisfied"""
  *         raise NotImplemented  # override / implement in child class
  */
 
@@ -8154,15 +8164,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level._AEAD_BASE.requirements_check", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":429
+/* "borg/crypto/low_level.pyx":420
  *         raise NotImplemented  # override / implement in child class
  * 
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):             # <<<<<<<<<<<<<<
  *         """
  *         init AEAD crypto
  */
 
@@ -8225,15 +8235,15 @@
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 429, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 420, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -8247,15 +8257,15 @@
     __pyx_v_key = values[0];
     __pyx_v_iv = values[1];
     __pyx_v_header_len = values[2];
     __pyx_v_aad_offset = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 429, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 420, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level._AEAD_BASE.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_10_AEAD_BASE_2__init__(((struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE *)__pyx_v_self), __pyx_v_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -8277,15 +8287,15 @@
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/crypto/low_level.pyx":438
+  /* "borg/crypto/low_level.pyx":429
  *         :param aad_offset: where in the header the authenticated data starts
  *         """
  *         assert isinstance(key, bytes) and len(key) == 32             # <<<<<<<<<<<<<<
  *         self.iv_len = sizeof(self.iv)
  *         self.header_len_expected = header_len
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -8293,152 +8303,152 @@
     __pyx_t_2 = PyBytes_Check(__pyx_v_key); 
     __pyx_t_3 = (__pyx_t_2 != 0);
     if (__pyx_t_3) {
     } else {
       __pyx_t_1 = __pyx_t_3;
       goto __pyx_L3_bool_binop_done;
     }
-    __pyx_t_4 = PyObject_Length(__pyx_v_key); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 438, __pyx_L1_error)
+    __pyx_t_4 = PyObject_Length(__pyx_v_key); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 429, __pyx_L1_error)
     __pyx_t_3 = ((__pyx_t_4 == 32) != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!__pyx_t_1)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 438, __pyx_L1_error)
+      __PYX_ERR(0, 429, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":439
+  /* "borg/crypto/low_level.pyx":430
  *         """
  *         assert isinstance(key, bytes) and len(key) == 32
  *         self.iv_len = sizeof(self.iv)             # <<<<<<<<<<<<<<
  *         self.header_len_expected = header_len
  *         assert aad_offset <= header_len
  */
   __pyx_v_self->iv_len = (sizeof(__pyx_v_self->iv));
 
-  /* "borg/crypto/low_level.pyx":440
+  /* "borg/crypto/low_level.pyx":431
  *         assert isinstance(key, bytes) and len(key) == 32
  *         self.iv_len = sizeof(self.iv)
  *         self.header_len_expected = header_len             # <<<<<<<<<<<<<<
  *         assert aad_offset <= header_len
  *         self.aad_offset = aad_offset
  */
-  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_v_header_len); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 440, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_v_header_len); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 431, __pyx_L1_error)
   __pyx_v_self->header_len_expected = __pyx_t_5;
 
-  /* "borg/crypto/low_level.pyx":441
+  /* "borg/crypto/low_level.pyx":432
  *         self.iv_len = sizeof(self.iv)
  *         self.header_len_expected = header_len
  *         assert aad_offset <= header_len             # <<<<<<<<<<<<<<
  *         self.aad_offset = aad_offset
  *         self.mac_len = 16
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
-    __pyx_t_6 = PyObject_RichCompare(__pyx_v_aad_offset, __pyx_v_header_len, Py_LE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 441, __pyx_L1_error)
-    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 441, __pyx_L1_error)
+    __pyx_t_6 = PyObject_RichCompare(__pyx_v_aad_offset, __pyx_v_header_len, Py_LE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 432, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 432, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     if (unlikely(!__pyx_t_1)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 441, __pyx_L1_error)
+      __PYX_ERR(0, 432, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":442
+  /* "borg/crypto/low_level.pyx":433
  *         self.header_len_expected = header_len
  *         assert aad_offset <= header_len
  *         self.aad_offset = aad_offset             # <<<<<<<<<<<<<<
  *         self.mac_len = 16
  *         self.key = key
  */
-  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_v_aad_offset); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 442, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_v_aad_offset); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 433, __pyx_L1_error)
   __pyx_v_self->aad_offset = __pyx_t_5;
 
-  /* "borg/crypto/low_level.pyx":443
+  /* "borg/crypto/low_level.pyx":434
  *         assert aad_offset <= header_len
  *         self.aad_offset = aad_offset
  *         self.mac_len = 16             # <<<<<<<<<<<<<<
  *         self.key = key
  *         if iv is not None:
  */
   __pyx_v_self->mac_len = 16;
 
-  /* "borg/crypto/low_level.pyx":444
+  /* "borg/crypto/low_level.pyx":435
  *         self.aad_offset = aad_offset
  *         self.mac_len = 16
  *         self.key = key             # <<<<<<<<<<<<<<
  *         if iv is not None:
  *             self.set_iv(iv)
  */
-  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_key, __pyx_t_7, 32) < 0)) __PYX_ERR(0, 444, __pyx_L1_error)
+  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_key, __pyx_t_7, 32) < 0)) __PYX_ERR(0, 435, __pyx_L1_error)
   memcpy(&(__pyx_v_self->key[0]), __pyx_t_7, sizeof(__pyx_v_self->key[0]) * (32));
 
-  /* "borg/crypto/low_level.pyx":445
+  /* "borg/crypto/low_level.pyx":436
  *         self.mac_len = 16
  *         self.key = key
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         else:
  */
   __pyx_t_1 = (__pyx_v_iv != Py_None);
   __pyx_t_3 = (__pyx_t_1 != 0);
   if (__pyx_t_3) {
 
-    /* "borg/crypto/low_level.pyx":446
+    /* "borg/crypto/low_level.pyx":437
  *         self.key = key
  *         if iv is not None:
  *             self.set_iv(iv)             # <<<<<<<<<<<<<<
  *         else:
  *             self.blocks = -1  # make sure set_iv is called before encrypt
  */
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 446, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 437, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __pyx_t_9 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
       __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
       if (likely(__pyx_t_9)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
         __Pyx_INCREF(__pyx_t_9);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_8, function);
       }
     }
     __pyx_t_6 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_9, __pyx_v_iv) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_v_iv);
     __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
-    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 446, __pyx_L1_error)
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 437, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-    /* "borg/crypto/low_level.pyx":445
+    /* "borg/crypto/low_level.pyx":436
  *         self.mac_len = 16
  *         self.key = key
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         else:
  */
     goto __pyx_L5;
   }
 
-  /* "borg/crypto/low_level.pyx":448
+  /* "borg/crypto/low_level.pyx":439
  *             self.set_iv(iv)
  *         else:
  *             self.blocks = -1  # make sure set_iv is called before encrypt             # <<<<<<<<<<<<<<
  * 
  *     def __cinit__(self, key, iv=None, header_len=0, aad_offset=0):
  */
   /*else*/ {
     __pyx_v_self->blocks = -1LL;
   }
   __pyx_L5:;
 
-  /* "borg/crypto/low_level.pyx":429
+  /* "borg/crypto/low_level.pyx":420
  *         raise NotImplemented  # override / implement in child class
  * 
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):             # <<<<<<<<<<<<<<
  *         """
  *         init AEAD crypto
  */
 
@@ -8452,15 +8462,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level._AEAD_BASE.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":450
+/* "borg/crypto/low_level.pyx":441
  *             self.blocks = -1  # make sure set_iv is called before encrypt
  * 
  *     def __cinit__(self, key, iv=None, header_len=0, aad_offset=0):             # <<<<<<<<<<<<<<
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  */
 
@@ -8519,15 +8529,15 @@
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 450, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 441, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -8541,15 +8551,15 @@
     __pyx_v_key = values[0];
     __pyx_v_iv = values[1];
     __pyx_v_header_len = values[2];
     __pyx_v_aad_offset = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 450, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 441, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level._AEAD_BASE.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_10_AEAD_BASE_4__cinit__(((struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE *)__pyx_v_self), __pyx_v_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -8559,38 +8569,38 @@
 }
 
 static int __pyx_pf_4borg_6crypto_9low_level_10_AEAD_BASE_4__cinit__(struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_key, CYTHON_UNUSED PyObject *__pyx_v_iv, CYTHON_UNUSED PyObject *__pyx_v_header_len, CYTHON_UNUSED PyObject *__pyx_v_aad_offset) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "borg/crypto/low_level.pyx":451
+  /* "borg/crypto/low_level.pyx":442
  * 
  *     def __cinit__(self, key, iv=None, header_len=0, aad_offset=0):
  *         self.ctx = EVP_CIPHER_CTX_new()             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(self):
  */
   __pyx_v_self->ctx = EVP_CIPHER_CTX_new();
 
-  /* "borg/crypto/low_level.pyx":450
+  /* "borg/crypto/low_level.pyx":441
  *             self.blocks = -1  # make sure set_iv is called before encrypt
  * 
  *     def __cinit__(self, key, iv=None, header_len=0, aad_offset=0):             # <<<<<<<<<<<<<<
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":453
+/* "borg/crypto/low_level.pyx":444
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  */
 
@@ -8605,36 +8615,36 @@
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_pf_4borg_6crypto_9low_level_10_AEAD_BASE_6__dealloc__(struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "borg/crypto/low_level.pyx":454
+  /* "borg/crypto/low_level.pyx":445
  * 
  *     def __dealloc__(self):
  *         EVP_CIPHER_CTX_free(self.ctx)             # <<<<<<<<<<<<<<
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=b''):
  */
   EVP_CIPHER_CTX_free(__pyx_v_self->ctx);
 
-  /* "borg/crypto/low_level.pyx":453
+  /* "borg/crypto/low_level.pyx":444
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "borg/crypto/low_level.pyx":456
+/* "borg/crypto/low_level.pyx":447
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=b''):             # <<<<<<<<<<<<<<
  *         """
  *         encrypt data, compute auth tag over aad + header + cdata.
  */
 
@@ -8694,15 +8704,15 @@
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "encrypt") < 0)) __PYX_ERR(0, 456, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "encrypt") < 0)) __PYX_ERR(0, 447, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -8716,15 +8726,15 @@
     __pyx_v_data = values[0];
     __pyx_v_header = values[1];
     __pyx_v_iv = values[2];
     __pyx_v_aad = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("encrypt", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 456, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("encrypt", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 447, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level._AEAD_BASE.encrypt", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_10_AEAD_BASE_8encrypt(((struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE *)__pyx_v_self), __pyx_v_data, __pyx_v_header, __pyx_v_iv, __pyx_v_aad);
 
@@ -8771,823 +8781,823 @@
   PyObject *__pyx_t_20 = NULL;
   PyObject *__pyx_t_21 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encrypt", 0);
 
-  /* "borg/crypto/low_level.pyx":464
+  /* "borg/crypto/low_level.pyx":455
  *         but only used for the auth tag computation.
  *         """
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  */
   __pyx_t_1 = (__pyx_v_iv != Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/crypto/low_level.pyx":465
+    /* "borg/crypto/low_level.pyx":456
  *         """
  *         if iv is not None:
  *             self.set_iv(iv)             # <<<<<<<<<<<<<<
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  *         # AES-OCB, CHACHA20 ciphers all add a internal 32bit counter to the 96bit (12Byte)
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 465, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 456, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_iv) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_iv);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 465, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 456, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/crypto/low_level.pyx":464
+    /* "borg/crypto/low_level.pyx":455
  *         but only used for the auth tag computation.
  *         """
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  */
   }
 
-  /* "borg/crypto/low_level.pyx":466
+  /* "borg/crypto/low_level.pyx":457
  *         if iv is not None:
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'             # <<<<<<<<<<<<<<
  *         # AES-OCB, CHACHA20 ciphers all add a internal 32bit counter to the 96bit (12Byte)
  *         # IV we provide, thus we must not encrypt more than 2^32 cipher blocks with same IV).
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_self->blocks == 0) != 0))) {
       PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_iv_needs_to_be_set_before_encryp);
-      __PYX_ERR(0, 466, __pyx_L1_error)
+      __PYX_ERR(0, 457, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":469
+  /* "borg/crypto/low_level.pyx":460
  *         # AES-OCB, CHACHA20 ciphers all add a internal 32bit counter to the 96bit (12Byte)
  *         # IV we provide, thus we must not encrypt more than 2^32 cipher blocks with same IV).
  *         block_count = self.block_count(len(data))             # <<<<<<<<<<<<<<
  *         if block_count > 2**32:
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 469, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 460, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 469, __pyx_L1_error)
-  __pyx_t_5 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 469, __pyx_L1_error)
+  __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 460, __pyx_L1_error)
+  __pyx_t_5 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 460, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_7 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_7)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_7);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_3 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_7, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5);
   __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 469, __pyx_L1_error)
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 460, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_v_block_count = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "borg/crypto/low_level.pyx":470
+  /* "borg/crypto/low_level.pyx":461
  *         # IV we provide, thus we must not encrypt more than 2^32 cipher blocks with same IV).
  *         block_count = self.block_count(len(data))
  *         if block_count > 2**32:             # <<<<<<<<<<<<<<
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  *         cdef int ilen = len(data)
  */
-  __pyx_t_3 = PyObject_RichCompare(__pyx_v_block_count, __pyx_int_4294967296, Py_GT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 470, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 470, __pyx_L1_error)
+  __pyx_t_3 = PyObject_RichCompare(__pyx_v_block_count, __pyx_int_4294967296, Py_GT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 461, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 461, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (unlikely(__pyx_t_2)) {
 
-    /* "borg/crypto/low_level.pyx":471
+    /* "borg/crypto/low_level.pyx":462
  *         block_count = self.block_count(len(data))
  *         if block_count > 2**32:
  *             raise ValueError('too much data, would overflow internal 32bit counter')             # <<<<<<<<<<<<<<
  *         cdef int ilen = len(data)
  *         cdef int hlen = len(header)
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 471, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 462, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 471, __pyx_L1_error)
+    __PYX_ERR(0, 462, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":470
+    /* "borg/crypto/low_level.pyx":461
  *         # IV we provide, thus we must not encrypt more than 2^32 cipher blocks with same IV).
  *         block_count = self.block_count(len(data))
  *         if block_count > 2**32:             # <<<<<<<<<<<<<<
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  *         cdef int ilen = len(data)
  */
   }
 
-  /* "borg/crypto/low_level.pyx":472
+  /* "borg/crypto/low_level.pyx":463
  *         if block_count > 2**32:
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  *         cdef int ilen = len(data)             # <<<<<<<<<<<<<<
  *         cdef int hlen = len(header)
  *         assert hlen == self.header_len_expected
  */
-  __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 472, __pyx_L1_error)
+  __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 463, __pyx_L1_error)
   __pyx_v_ilen = __pyx_t_6;
 
-  /* "borg/crypto/low_level.pyx":473
+  /* "borg/crypto/low_level.pyx":464
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  *         cdef int ilen = len(data)
  *         cdef int hlen = len(header)             # <<<<<<<<<<<<<<
  *         assert hlen == self.header_len_expected
  *         cdef int aoffset = self.aad_offset
  */
-  __pyx_t_6 = PyObject_Length(__pyx_v_header); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 473, __pyx_L1_error)
+  __pyx_t_6 = PyObject_Length(__pyx_v_header); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 464, __pyx_L1_error)
   __pyx_v_hlen = __pyx_t_6;
 
-  /* "borg/crypto/low_level.pyx":474
+  /* "borg/crypto/low_level.pyx":465
  *         cdef int ilen = len(data)
  *         cdef int hlen = len(header)
  *         assert hlen == self.header_len_expected             # <<<<<<<<<<<<<<
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_hlen == __pyx_v_self->header_len_expected) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 474, __pyx_L1_error)
+      __PYX_ERR(0, 465, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":475
+  /* "borg/crypto/low_level.pyx":466
  *         cdef int hlen = len(header)
  *         assert hlen == self.header_len_expected
  *         cdef int aoffset = self.aad_offset             # <<<<<<<<<<<<<<
  *         cdef int alen = hlen - aoffset
  *         cdef int aadlen = len(aad)
  */
   __pyx_t_8 = __pyx_v_self->aad_offset;
   __pyx_v_aoffset = __pyx_t_8;
 
-  /* "borg/crypto/low_level.pyx":476
+  /* "borg/crypto/low_level.pyx":467
  *         assert hlen == self.header_len_expected
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset             # <<<<<<<<<<<<<<
  *         cdef int aadlen = len(aad)
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len +
  */
   __pyx_v_alen = (__pyx_v_hlen - __pyx_v_aoffset);
 
-  /* "borg/crypto/low_level.pyx":477
+  /* "borg/crypto/low_level.pyx":468
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset
  *         cdef int aadlen = len(aad)             # <<<<<<<<<<<<<<
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len +
  *                                                                   ilen + self.cipher_blk_len)
  */
-  __pyx_t_6 = PyObject_Length(__pyx_v_aad); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 477, __pyx_L1_error)
+  __pyx_t_6 = PyObject_Length(__pyx_v_aad); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 468, __pyx_L1_error)
   __pyx_v_aadlen = __pyx_t_6;
 
-  /* "borg/crypto/low_level.pyx":478
+  /* "borg/crypto/low_level.pyx":469
  *         cdef int alen = hlen - aoffset
  *         cdef int aadlen = len(aad)
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len +             # <<<<<<<<<<<<<<
  *                                                                   ilen + self.cipher_blk_len)
  *         if not odata:
  */
   __pyx_v_odata = ((unsigned char *)PyMem_Malloc((((__pyx_v_hlen + __pyx_v_self->mac_len) + __pyx_v_ilen) + __pyx_v_self->cipher_blk_len)));
 
-  /* "borg/crypto/low_level.pyx":480
+  /* "borg/crypto/low_level.pyx":471
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len +
  *                                                                   ilen + self.cipher_blk_len)
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         cdef int olen = 0
  */
   __pyx_t_2 = ((!(__pyx_v_odata != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "borg/crypto/low_level.pyx":481
+    /* "borg/crypto/low_level.pyx":472
  *                                                                   ilen + self.cipher_blk_len)
  *         if not odata:
  *             raise MemoryError             # <<<<<<<<<<<<<<
  *         cdef int olen = 0
  *         cdef int offset
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 481, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 472, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":480
+    /* "borg/crypto/low_level.pyx":471
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(hlen + self.mac_len +
  *                                                                   ilen + self.cipher_blk_len)
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         cdef int olen = 0
  */
   }
 
-  /* "borg/crypto/low_level.pyx":482
+  /* "borg/crypto/low_level.pyx":473
  *         if not odata:
  *             raise MemoryError
  *         cdef int olen = 0             # <<<<<<<<<<<<<<
  *         cdef int offset
  *         cdef Py_buffer idata = ro_buffer(data)
  */
   __pyx_v_olen = 0;
 
-  /* "borg/crypto/low_level.pyx":484
+  /* "borg/crypto/low_level.pyx":475
  *         cdef int olen = 0
  *         cdef int offset
  *         cdef Py_buffer idata = ro_buffer(data)             # <<<<<<<<<<<<<<
  *         cdef Py_buffer hdata = ro_buffer(header)
  *         cdef Py_buffer aadata = ro_buffer(aad)
  */
-  __pyx_t_9 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_data); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 484, __pyx_L1_error)
+  __pyx_t_9 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_data); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 475, __pyx_L1_error)
   __pyx_v_idata = __pyx_t_9;
 
-  /* "borg/crypto/low_level.pyx":485
+  /* "borg/crypto/low_level.pyx":476
  *         cdef int offset
  *         cdef Py_buffer idata = ro_buffer(data)
  *         cdef Py_buffer hdata = ro_buffer(header)             # <<<<<<<<<<<<<<
  *         cdef Py_buffer aadata = ro_buffer(aad)
  *         try:
  */
-  __pyx_t_9 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_header); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 485, __pyx_L1_error)
+  __pyx_t_9 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_header); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 476, __pyx_L1_error)
   __pyx_v_hdata = __pyx_t_9;
 
-  /* "borg/crypto/low_level.pyx":486
+  /* "borg/crypto/low_level.pyx":477
  *         cdef Py_buffer idata = ro_buffer(data)
  *         cdef Py_buffer hdata = ro_buffer(header)
  *         cdef Py_buffer aadata = ro_buffer(aad)             # <<<<<<<<<<<<<<
  *         try:
  *             offset = 0
  */
-  __pyx_t_9 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_aad); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 486, __pyx_L1_error)
+  __pyx_t_9 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_aad); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 477, __pyx_L1_error)
   __pyx_v_aadata = __pyx_t_9;
 
-  /* "borg/crypto/low_level.pyx":487
+  /* "borg/crypto/low_level.pyx":478
  *         cdef Py_buffer hdata = ro_buffer(header)
  *         cdef Py_buffer aadata = ro_buffer(aad)
  *         try:             # <<<<<<<<<<<<<<
  *             offset = 0
  *             for i in range(hlen):
  */
   /*try:*/ {
 
-    /* "borg/crypto/low_level.pyx":488
+    /* "borg/crypto/low_level.pyx":479
  *         cdef Py_buffer aadata = ro_buffer(aad)
  *         try:
  *             offset = 0             # <<<<<<<<<<<<<<
  *             for i in range(hlen):
  *                 odata[offset+i] = header[i]
  */
     __pyx_v_offset = 0;
 
-    /* "borg/crypto/low_level.pyx":489
+    /* "borg/crypto/low_level.pyx":480
  *         try:
  *             offset = 0
  *             for i in range(hlen):             # <<<<<<<<<<<<<<
  *                 odata[offset+i] = header[i]
  *             offset += hlen
  */
-    __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_hlen); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 489, __pyx_L7_error)
+    __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_hlen); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 480, __pyx_L7_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 489, __pyx_L7_error)
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 480, __pyx_L7_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     if (likely(PyList_CheckExact(__pyx_t_4)) || PyTuple_CheckExact(__pyx_t_4)) {
       __pyx_t_3 = __pyx_t_4; __Pyx_INCREF(__pyx_t_3); __pyx_t_6 = 0;
       __pyx_t_10 = NULL;
     } else {
-      __pyx_t_6 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 489, __pyx_L7_error)
+      __pyx_t_6 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 480, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_10 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 489, __pyx_L7_error)
+      __pyx_t_10 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 480, __pyx_L7_error)
     }
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     for (;;) {
       if (likely(!__pyx_t_10)) {
         if (likely(PyList_CheckExact(__pyx_t_3))) {
           if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_3)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 489, __pyx_L7_error)
+          __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 480, __pyx_L7_error)
           #else
-          __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 489, __pyx_L7_error)
+          __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 480, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_4);
           #endif
         } else {
           if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 489, __pyx_L7_error)
+          __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 480, __pyx_L7_error)
           #else
-          __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 489, __pyx_L7_error)
+          __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 480, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_4);
           #endif
         }
       } else {
         __pyx_t_4 = __pyx_t_10(__pyx_t_3);
         if (unlikely(!__pyx_t_4)) {
           PyObject* exc_type = PyErr_Occurred();
           if (exc_type) {
             if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 489, __pyx_L7_error)
+            else __PYX_ERR(0, 480, __pyx_L7_error)
           }
           break;
         }
         __Pyx_GOTREF(__pyx_t_4);
       }
       __Pyx_XDECREF_SET(__pyx_v_i, __pyx_t_4);
       __pyx_t_4 = 0;
 
-      /* "borg/crypto/low_level.pyx":490
+      /* "borg/crypto/low_level.pyx":481
  *             offset = 0
  *             for i in range(hlen):
  *                 odata[offset+i] = header[i]             # <<<<<<<<<<<<<<
  *             offset += hlen
  *             offset += self.mac_len
  */
-      __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_header, __pyx_v_i); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 490, __pyx_L7_error)
+      __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_header, __pyx_v_i); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 481, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_11 = __Pyx_PyInt_As_unsigned_char(__pyx_t_4); if (unlikely((__pyx_t_11 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 490, __pyx_L7_error)
+      __pyx_t_11 = __Pyx_PyInt_As_unsigned_char(__pyx_t_4); if (unlikely((__pyx_t_11 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 481, __pyx_L7_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 490, __pyx_L7_error)
+      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 481, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = PyNumber_Add(__pyx_t_4, __pyx_v_i); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 490, __pyx_L7_error)
+      __pyx_t_5 = PyNumber_Add(__pyx_t_4, __pyx_v_i); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 481, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 490, __pyx_L7_error)
+      __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 481, __pyx_L7_error)
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       (__pyx_v_odata[__pyx_t_12]) = __pyx_t_11;
 
-      /* "borg/crypto/low_level.pyx":489
+      /* "borg/crypto/low_level.pyx":480
  *         try:
  *             offset = 0
  *             for i in range(hlen):             # <<<<<<<<<<<<<<
  *                 odata[offset+i] = header[i]
  *             offset += hlen
  */
     }
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/crypto/low_level.pyx":491
+    /* "borg/crypto/low_level.pyx":482
  *             for i in range(hlen):
  *                 odata[offset+i] = header[i]
  *             offset += hlen             # <<<<<<<<<<<<<<
  *             offset += self.mac_len
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_hlen);
 
-    /* "borg/crypto/low_level.pyx":492
+    /* "borg/crypto/low_level.pyx":483
  *                 odata[offset+i] = header[i]
  *             offset += hlen
  *             offset += self.mac_len             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_self->mac_len);
 
-    /* "borg/crypto/low_level.pyx":493
+    /* "borg/crypto/low_level.pyx":484
  *             offset += hlen
  *             offset += self.mac_len
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  */
     __pyx_t_2 = ((!(EVP_EncryptInit_ex(__pyx_v_self->ctx, __pyx_v_self->cipher(), NULL, NULL, NULL) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":494
+      /* "borg/crypto/low_level.pyx":485
  *             offset += self.mac_len
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 494, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 485, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_EncryptInit_ex_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_EncryptInit_ex_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 494, __pyx_L7_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 485, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 494, __pyx_L7_error)
+      __PYX_ERR(0, 485, __pyx_L7_error)
 
-      /* "borg/crypto/low_level.pyx":493
+      /* "borg/crypto/low_level.pyx":484
  *             offset += hlen
  *             offset += self.mac_len
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":495
+    /* "borg/crypto/low_level.pyx":486
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_EncryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  */
     __pyx_t_2 = ((!(EVP_CIPHER_CTX_ctrl(__pyx_v_self->ctx, EVP_CTRL_AEAD_SET_IVLEN, __pyx_v_self->iv_len, NULL) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":496
+      /* "borg/crypto/low_level.pyx":487
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 496, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 487, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_CIPHER_CTX_ctrl_SET_IVLEN_fa) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_CIPHER_CTX_ctrl_SET_IVLEN_fa);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 496, __pyx_L7_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 487, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 496, __pyx_L7_error)
+      __PYX_ERR(0, 487, __pyx_L7_error)
 
-      /* "borg/crypto/low_level.pyx":495
+      /* "borg/crypto/low_level.pyx":486
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_EncryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":497
+    /* "borg/crypto/low_level.pyx":488
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_EncryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  */
     __pyx_t_2 = ((!(EVP_EncryptInit_ex(__pyx_v_self->ctx, NULL, NULL, __pyx_v_self->key, __pyx_v_self->iv) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":498
+      /* "borg/crypto/low_level.pyx":489
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_EncryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 498, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 489, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_EncryptInit_ex_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_EncryptInit_ex_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 498, __pyx_L7_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 489, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 498, __pyx_L7_error)
+      __PYX_ERR(0, 489, __pyx_L7_error)
 
-      /* "borg/crypto/low_level.pyx":497
+      /* "borg/crypto/low_level.pyx":488
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_EncryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":499
+    /* "borg/crypto/low_level.pyx":490
  *             if not EVP_EncryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> hdata.buf+aoffset, alen):
  */
     __pyx_t_2 = ((!(EVP_EncryptUpdate(__pyx_v_self->ctx, NULL, (&__pyx_v_olen), ((unsigned char const *)__pyx_v_aadata.buf), __pyx_v_aadlen) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":500
+      /* "borg/crypto/low_level.pyx":491
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> hdata.buf+aoffset, alen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 500, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 491, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_EncryptUpdate_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_EncryptUpdate_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 500, __pyx_L7_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 491, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 500, __pyx_L7_error)
+      __PYX_ERR(0, 491, __pyx_L7_error)
 
-      /* "borg/crypto/low_level.pyx":499
+      /* "borg/crypto/low_level.pyx":490
  *             if not EVP_EncryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  *                 raise CryptoError('EVP_EncryptInit_ex failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> hdata.buf+aoffset, alen):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":501
+    /* "borg/crypto/low_level.pyx":492
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> hdata.buf+aoffset, alen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  */
     __pyx_t_2 = ((!(EVP_EncryptUpdate(__pyx_v_self->ctx, NULL, (&__pyx_v_olen), (((unsigned char const *)__pyx_v_hdata.buf) + __pyx_v_aoffset), __pyx_v_alen) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":502
+      /* "borg/crypto/low_level.pyx":493
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> hdata.buf+aoffset, alen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 502, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 493, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_EncryptUpdate_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_EncryptUpdate_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 502, __pyx_L7_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 493, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 502, __pyx_L7_error)
+      __PYX_ERR(0, 493, __pyx_L7_error)
 
-      /* "borg/crypto/low_level.pyx":501
+      /* "borg/crypto/low_level.pyx":492
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> hdata.buf+aoffset, alen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":503
+    /* "borg/crypto/low_level.pyx":494
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> hdata.buf+aoffset, alen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen
  */
     __pyx_t_2 = ((!(EVP_EncryptUpdate(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen), ((unsigned char const *)__pyx_v_idata.buf), __pyx_v_ilen) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":504
+      /* "borg/crypto/low_level.pyx":495
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 504, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 495, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_EncryptUpdate_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_EncryptUpdate_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 504, __pyx_L7_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 495, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 504, __pyx_L7_error)
+      __PYX_ERR(0, 495, __pyx_L7_error)
 
-      /* "borg/crypto/low_level.pyx":503
+      /* "borg/crypto/low_level.pyx":494
  *             if not EVP_EncryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> hdata.buf+aoffset, alen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen
  */
     }
 
-    /* "borg/crypto/low_level.pyx":505
+    /* "borg/crypto/low_level.pyx":496
  *             if not EVP_EncryptUpdate(self.ctx, odata+offset, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":506
+    /* "borg/crypto/low_level.pyx":497
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  *             offset += olen
  */
     __pyx_t_2 = ((!(EVP_EncryptFinal_ex(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen)) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":507
+      /* "borg/crypto/low_level.pyx":498
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_GET_TAG, self.mac_len, odata + hlen):
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 507, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 498, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_EncryptFinal_ex_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_EncryptFinal_ex_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 507, __pyx_L7_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 498, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 507, __pyx_L7_error)
+      __PYX_ERR(0, 498, __pyx_L7_error)
 
-      /* "borg/crypto/low_level.pyx":506
+      /* "borg/crypto/low_level.pyx":497
  *                 raise CryptoError('EVP_EncryptUpdate failed')
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  *             offset += olen
  */
     }
 
-    /* "borg/crypto/low_level.pyx":508
+    /* "borg/crypto/low_level.pyx":499
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_GET_TAG, self.mac_len, odata + hlen):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl GET TAG failed')
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":509
+    /* "borg/crypto/low_level.pyx":500
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  *             offset += olen
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_GET_TAG, self.mac_len, odata + hlen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl GET TAG failed')
  *             self.blocks = block_count
  */
     __pyx_t_2 = ((!(EVP_CIPHER_CTX_ctrl(__pyx_v_self->ctx, EVP_CTRL_AEAD_GET_TAG, __pyx_v_self->mac_len, (__pyx_v_odata + __pyx_v_hlen)) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":510
+      /* "borg/crypto/low_level.pyx":501
  *             offset += olen
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_GET_TAG, self.mac_len, odata + hlen):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl GET TAG failed')             # <<<<<<<<<<<<<<
  *             self.blocks = block_count
  *             return odata[:offset]
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 510, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 501, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_s_EVP_CIPHER_CTX_ctrl_GET_TAG_fail) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_s_EVP_CIPHER_CTX_ctrl_GET_TAG_fail);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 510, __pyx_L7_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 501, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 510, __pyx_L7_error)
+      __PYX_ERR(0, 501, __pyx_L7_error)
 
-      /* "borg/crypto/low_level.pyx":509
+      /* "borg/crypto/low_level.pyx":500
  *                 raise CryptoError('EVP_EncryptFinal_ex failed')
  *             offset += olen
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_GET_TAG, self.mac_len, odata + hlen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl GET TAG failed')
  *             self.blocks = block_count
  */
     }
 
-    /* "borg/crypto/low_level.pyx":511
+    /* "borg/crypto/low_level.pyx":502
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_GET_TAG, self.mac_len, odata + hlen):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl GET TAG failed')
  *             self.blocks = block_count             # <<<<<<<<<<<<<<
  *             return odata[:offset]
  *         finally:
  */
-    __pyx_t_13 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_v_block_count); if (unlikely((__pyx_t_13 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 511, __pyx_L7_error)
+    __pyx_t_13 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_v_block_count); if (unlikely((__pyx_t_13 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 502, __pyx_L7_error)
     __pyx_v_self->blocks = __pyx_t_13;
 
-    /* "borg/crypto/low_level.pyx":512
+    /* "borg/crypto/low_level.pyx":503
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl GET TAG failed')
  *             self.blocks = block_count
  *             return odata[:offset]             # <<<<<<<<<<<<<<
  *         finally:
  *             PyMem_Free(odata)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 512, __pyx_L7_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 503, __pyx_L7_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L6_return;
   }
 
-  /* "borg/crypto/low_level.pyx":514
+  /* "borg/crypto/low_level.pyx":505
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)
  */
   /*finally:*/ {
@@ -9608,33 +9618,33 @@
       __Pyx_XGOTREF(__pyx_t_19);
       __Pyx_XGOTREF(__pyx_t_20);
       __Pyx_XGOTREF(__pyx_t_21);
       __pyx_t_8 = __pyx_lineno; __pyx_t_14 = __pyx_clineno; __pyx_t_15 = __pyx_filename;
       {
         PyMem_Free(__pyx_v_odata);
 
-        /* "borg/crypto/low_level.pyx":515
+        /* "borg/crypto/low_level.pyx":506
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&hdata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  *             PyBuffer_Release(&aadata)
  */
         PyBuffer_Release((&__pyx_v_hdata));
 
-        /* "borg/crypto/low_level.pyx":516
+        /* "borg/crypto/low_level.pyx":507
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&aadata)
  * 
  */
         PyBuffer_Release((&__pyx_v_idata));
 
-        /* "borg/crypto/low_level.pyx":517
+        /* "borg/crypto/low_level.pyx":508
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)
  *             PyBuffer_Release(&aadata)             # <<<<<<<<<<<<<<
  * 
  *     def decrypt(self, envelope, aad=b''):
  */
         PyBuffer_Release((&__pyx_v_aadata));
@@ -9653,56 +9663,56 @@
       __pyx_lineno = __pyx_t_8; __pyx_clineno = __pyx_t_14; __pyx_filename = __pyx_t_15;
       goto __pyx_L1_error;
     }
     __pyx_L6_return: {
       __pyx_t_21 = __pyx_r;
       __pyx_r = 0;
 
-      /* "borg/crypto/low_level.pyx":514
+      /* "borg/crypto/low_level.pyx":505
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)
  */
       PyMem_Free(__pyx_v_odata);
 
-      /* "borg/crypto/low_level.pyx":515
+      /* "borg/crypto/low_level.pyx":506
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&hdata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  *             PyBuffer_Release(&aadata)
  */
       PyBuffer_Release((&__pyx_v_hdata));
 
-      /* "borg/crypto/low_level.pyx":516
+      /* "borg/crypto/low_level.pyx":507
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&aadata)
  * 
  */
       PyBuffer_Release((&__pyx_v_idata));
 
-      /* "borg/crypto/low_level.pyx":517
+      /* "borg/crypto/low_level.pyx":508
  *             PyBuffer_Release(&hdata)
  *             PyBuffer_Release(&idata)
  *             PyBuffer_Release(&aadata)             # <<<<<<<<<<<<<<
  * 
  *     def decrypt(self, envelope, aad=b''):
  */
       PyBuffer_Release((&__pyx_v_aadata));
       __pyx_r = __pyx_t_21;
       __pyx_t_21 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "borg/crypto/low_level.pyx":456
+  /* "borg/crypto/low_level.pyx":447
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=b''):             # <<<<<<<<<<<<<<
  *         """
  *         encrypt data, compute auth tag over aad + header + cdata.
  */
 
@@ -9718,15 +9728,15 @@
   __Pyx_XDECREF(__pyx_v_block_count);
   __Pyx_XDECREF(__pyx_v_i);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":519
+/* "borg/crypto/low_level.pyx":510
  *             PyBuffer_Release(&aadata)
  * 
  *     def decrypt(self, envelope, aad=b''):             # <<<<<<<<<<<<<<
  *         """
  *         authenticate aad + header + cdata (from envelope), ignore header bytes up to aad_offset.,
  */
 
@@ -9766,15 +9776,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decrypt") < 0)) __PYX_ERR(0, 519, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "decrypt") < 0)) __PYX_ERR(0, 510, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -9782,15 +9792,15 @@
       }
     }
     __pyx_v_envelope = values[0];
     __pyx_v_aad = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decrypt", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 519, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decrypt", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 510, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level._AEAD_BASE.decrypt", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_10_AEAD_BASE_10decrypt(((struct __pyx_obj_4borg_6crypto_9low_level__AEAD_BASE *)__pyx_v_self), __pyx_v_envelope, __pyx_v_aad);
 
@@ -9831,653 +9841,653 @@
   PyObject *__pyx_t_16 = NULL;
   PyObject *__pyx_t_17 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decrypt", 0);
 
-  /* "borg/crypto/low_level.pyx":526
+  /* "borg/crypto/low_level.pyx":517
  *         # AES-OCB, CHACHA20 ciphers all add a internal 32bit counter to the 96bit (12Byte)
  *         # IV we provide, thus we must not decrypt more than 2^32 cipher blocks with same IV):
  *         approx_block_count = self.block_count(len(envelope))  # sloppy, but good enough for borg             # <<<<<<<<<<<<<<
  *         if approx_block_count > 2**32:
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 526, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 517, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyObject_Length(__pyx_v_envelope); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 526, __pyx_L1_error)
-  __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 526, __pyx_L1_error)
+  __pyx_t_3 = PyObject_Length(__pyx_v_envelope); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 517, __pyx_L1_error)
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 517, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 526, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 517, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_approx_block_count = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":527
+  /* "borg/crypto/low_level.pyx":518
  *         # IV we provide, thus we must not decrypt more than 2^32 cipher blocks with same IV):
  *         approx_block_count = self.block_count(len(envelope))  # sloppy, but good enough for borg
  *         if approx_block_count > 2**32:             # <<<<<<<<<<<<<<
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  *         cdef int ilen = len(envelope)
  */
-  __pyx_t_1 = PyObject_RichCompare(__pyx_v_approx_block_count, __pyx_int_4294967296, Py_GT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 527, __pyx_L1_error)
-  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 527, __pyx_L1_error)
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_approx_block_count, __pyx_int_4294967296, Py_GT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 518, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 518, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if (unlikely(__pyx_t_6)) {
 
-    /* "borg/crypto/low_level.pyx":528
+    /* "borg/crypto/low_level.pyx":519
  *         approx_block_count = self.block_count(len(envelope))  # sloppy, but good enough for borg
  *         if approx_block_count > 2**32:
  *             raise ValueError('too much data, would overflow internal 32bit counter')             # <<<<<<<<<<<<<<
  *         cdef int ilen = len(envelope)
  *         cdef int hlen = self.header_len_expected
  */
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 528, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 519, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_Raise(__pyx_t_1, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 528, __pyx_L1_error)
+    __PYX_ERR(0, 519, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":527
+    /* "borg/crypto/low_level.pyx":518
  *         # IV we provide, thus we must not decrypt more than 2^32 cipher blocks with same IV):
  *         approx_block_count = self.block_count(len(envelope))  # sloppy, but good enough for borg
  *         if approx_block_count > 2**32:             # <<<<<<<<<<<<<<
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  *         cdef int ilen = len(envelope)
  */
   }
 
-  /* "borg/crypto/low_level.pyx":529
+  /* "borg/crypto/low_level.pyx":520
  *         if approx_block_count > 2**32:
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  *         cdef int ilen = len(envelope)             # <<<<<<<<<<<<<<
  *         cdef int hlen = self.header_len_expected
  *         cdef int aoffset = self.aad_offset
  */
-  __pyx_t_3 = PyObject_Length(__pyx_v_envelope); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 529, __pyx_L1_error)
+  __pyx_t_3 = PyObject_Length(__pyx_v_envelope); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 520, __pyx_L1_error)
   __pyx_v_ilen = __pyx_t_3;
 
-  /* "borg/crypto/low_level.pyx":530
+  /* "borg/crypto/low_level.pyx":521
  *             raise ValueError('too much data, would overflow internal 32bit counter')
  *         cdef int ilen = len(envelope)
  *         cdef int hlen = self.header_len_expected             # <<<<<<<<<<<<<<
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset
  */
   __pyx_t_7 = __pyx_v_self->header_len_expected;
   __pyx_v_hlen = __pyx_t_7;
 
-  /* "borg/crypto/low_level.pyx":531
+  /* "borg/crypto/low_level.pyx":522
  *         cdef int ilen = len(envelope)
  *         cdef int hlen = self.header_len_expected
  *         cdef int aoffset = self.aad_offset             # <<<<<<<<<<<<<<
  *         cdef int alen = hlen - aoffset
  *         cdef int aadlen = len(aad)
  */
   __pyx_t_7 = __pyx_v_self->aad_offset;
   __pyx_v_aoffset = __pyx_t_7;
 
-  /* "borg/crypto/low_level.pyx":532
+  /* "borg/crypto/low_level.pyx":523
  *         cdef int hlen = self.header_len_expected
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset             # <<<<<<<<<<<<<<
  *         cdef int aadlen = len(aad)
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  */
   __pyx_v_alen = (__pyx_v_hlen - __pyx_v_aoffset);
 
-  /* "borg/crypto/low_level.pyx":533
+  /* "borg/crypto/low_level.pyx":524
  *         cdef int aoffset = self.aad_offset
  *         cdef int alen = hlen - aoffset
  *         cdef int aadlen = len(aad)             # <<<<<<<<<<<<<<
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:
  */
-  __pyx_t_3 = PyObject_Length(__pyx_v_aad); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 533, __pyx_L1_error)
+  __pyx_t_3 = PyObject_Length(__pyx_v_aad); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 524, __pyx_L1_error)
   __pyx_v_aadlen = __pyx_t_3;
 
-  /* "borg/crypto/low_level.pyx":534
+  /* "borg/crypto/low_level.pyx":525
  *         cdef int alen = hlen - aoffset
  *         cdef int aadlen = len(aad)
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)             # <<<<<<<<<<<<<<
  *         if not odata:
  *             raise MemoryError
  */
   __pyx_v_odata = ((unsigned char *)PyMem_Malloc((__pyx_v_ilen + __pyx_v_self->cipher_blk_len)));
 
-  /* "borg/crypto/low_level.pyx":535
+  /* "borg/crypto/low_level.pyx":526
  *         cdef int aadlen = len(aad)
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         cdef int olen = 0
  */
   __pyx_t_6 = ((!(__pyx_v_odata != 0)) != 0);
   if (unlikely(__pyx_t_6)) {
 
-    /* "borg/crypto/low_level.pyx":536
+    /* "borg/crypto/low_level.pyx":527
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:
  *             raise MemoryError             # <<<<<<<<<<<<<<
  *         cdef int olen = 0
  *         cdef int offset
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 536, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 527, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":535
+    /* "borg/crypto/low_level.pyx":526
  *         cdef int aadlen = len(aad)
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         cdef int olen = 0
  */
   }
 
-  /* "borg/crypto/low_level.pyx":537
+  /* "borg/crypto/low_level.pyx":528
  *         if not odata:
  *             raise MemoryError
  *         cdef int olen = 0             # <<<<<<<<<<<<<<
  *         cdef int offset
  *         cdef Py_buffer idata = ro_buffer(envelope)
  */
   __pyx_v_olen = 0;
 
-  /* "borg/crypto/low_level.pyx":539
+  /* "borg/crypto/low_level.pyx":530
  *         cdef int olen = 0
  *         cdef int offset
  *         cdef Py_buffer idata = ro_buffer(envelope)             # <<<<<<<<<<<<<<
  *         cdef Py_buffer aadata = ro_buffer(aad)
  *         try:
  */
-  __pyx_t_8 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_envelope); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 539, __pyx_L1_error)
+  __pyx_t_8 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_envelope); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 530, __pyx_L1_error)
   __pyx_v_idata = __pyx_t_8;
 
-  /* "borg/crypto/low_level.pyx":540
+  /* "borg/crypto/low_level.pyx":531
  *         cdef int offset
  *         cdef Py_buffer idata = ro_buffer(envelope)
  *         cdef Py_buffer aadata = ro_buffer(aad)             # <<<<<<<<<<<<<<
  *         try:
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  */
-  __pyx_t_8 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_aad); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 540, __pyx_L1_error)
+  __pyx_t_8 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_aad); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 531, __pyx_L1_error)
   __pyx_v_aadata = __pyx_t_8;
 
-  /* "borg/crypto/low_level.pyx":541
+  /* "borg/crypto/low_level.pyx":532
  *         cdef Py_buffer idata = ro_buffer(envelope)
  *         cdef Py_buffer aadata = ro_buffer(aad)
  *         try:             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  */
   /*try:*/ {
 
-    /* "borg/crypto/low_level.pyx":542
+    /* "borg/crypto/low_level.pyx":533
  *         cdef Py_buffer aadata = ro_buffer(aad)
  *         try:
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  */
     __pyx_t_6 = ((!(EVP_DecryptInit_ex(__pyx_v_self->ctx, __pyx_v_self->cipher(), NULL, NULL, NULL) != 0)) != 0);
     if (unlikely(__pyx_t_6)) {
 
-      /* "borg/crypto/low_level.pyx":543
+      /* "borg/crypto/low_level.pyx":534
  *         try:
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 543, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 534, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_2, function);
         }
       }
       __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_kp_s_EVP_DecryptInit_ex_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_EVP_DecryptInit_ex_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 543, __pyx_L6_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 534, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 543, __pyx_L6_error)
+      __PYX_ERR(0, 534, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":542
+      /* "borg/crypto/low_level.pyx":533
  *         cdef Py_buffer aadata = ro_buffer(aad)
  *         try:
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":544
+    /* "borg/crypto/low_level.pyx":535
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_DecryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  */
     __pyx_t_6 = ((!(EVP_CIPHER_CTX_ctrl(__pyx_v_self->ctx, EVP_CTRL_AEAD_SET_IVLEN, __pyx_v_self->iv_len, NULL) != 0)) != 0);
     if (unlikely(__pyx_t_6)) {
 
-      /* "borg/crypto/low_level.pyx":545
+      /* "borg/crypto/low_level.pyx":536
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 545, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 536, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_2, function);
         }
       }
       __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_kp_s_EVP_CIPHER_CTX_ctrl_SET_IVLEN_fa) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_EVP_CIPHER_CTX_ctrl_SET_IVLEN_fa);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 545, __pyx_L6_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 536, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 545, __pyx_L6_error)
+      __PYX_ERR(0, 536, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":544
+      /* "borg/crypto/low_level.pyx":535
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, NULL, NULL):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_DecryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":546
+    /* "borg/crypto/low_level.pyx":537
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_DecryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  */
     __pyx_t_6 = ((!(EVP_DecryptInit_ex(__pyx_v_self->ctx, NULL, NULL, __pyx_v_self->key, __pyx_v_self->iv) != 0)) != 0);
     if (unlikely(__pyx_t_6)) {
 
-      /* "borg/crypto/low_level.pyx":547
+      /* "borg/crypto/low_level.pyx":538
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_DecryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 547, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 538, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_2, function);
         }
       }
       __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_kp_s_EVP_DecryptInit_ex_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_EVP_DecryptInit_ex_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 547, __pyx_L6_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 538, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 547, __pyx_L6_error)
+      __PYX_ERR(0, 538, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":546
+      /* "borg/crypto/low_level.pyx":537
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_IVLEN, self.iv_len, NULL):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET IVLEN failed')
  *             if not EVP_DecryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":548
+    /* "borg/crypto/low_level.pyx":539
  *             if not EVP_DecryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> idata.buf+aoffset, alen):
  */
     __pyx_t_6 = ((!(EVP_DecryptUpdate(__pyx_v_self->ctx, NULL, (&__pyx_v_olen), ((unsigned char const *)__pyx_v_aadata.buf), __pyx_v_aadlen) != 0)) != 0);
     if (unlikely(__pyx_t_6)) {
 
-      /* "borg/crypto/low_level.pyx":549
+      /* "borg/crypto/low_level.pyx":540
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  *                 raise CryptoError('EVP_DecryptUpdate failed')             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> idata.buf+aoffset, alen):
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 549, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 540, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_2, function);
         }
       }
       __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_kp_s_EVP_DecryptUpdate_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_EVP_DecryptUpdate_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 549, __pyx_L6_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 540, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 549, __pyx_L6_error)
+      __PYX_ERR(0, 540, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":548
+      /* "borg/crypto/low_level.pyx":539
  *             if not EVP_DecryptInit_ex(self.ctx, NULL, NULL, self.key, self.iv):
  *                 raise CryptoError('EVP_DecryptInit_ex failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> idata.buf+aoffset, alen):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":550
+    /* "borg/crypto/low_level.pyx":541
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> idata.buf+aoffset, alen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset = 0
  */
     __pyx_t_6 = ((!(EVP_DecryptUpdate(__pyx_v_self->ctx, NULL, (&__pyx_v_olen), (((unsigned char const *)__pyx_v_idata.buf) + __pyx_v_aoffset), __pyx_v_alen) != 0)) != 0);
     if (unlikely(__pyx_t_6)) {
 
-      /* "borg/crypto/low_level.pyx":551
+      /* "borg/crypto/low_level.pyx":542
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> idata.buf+aoffset, alen):
  *                 raise CryptoError('EVP_DecryptUpdate failed')             # <<<<<<<<<<<<<<
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata+offset, &olen,
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 551, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 542, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_2, function);
         }
       }
       __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_kp_s_EVP_DecryptUpdate_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_EVP_DecryptUpdate_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 551, __pyx_L6_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 542, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 551, __pyx_L6_error)
+      __PYX_ERR(0, 542, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":550
+      /* "borg/crypto/low_level.pyx":541
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> aadata.buf, aadlen):
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> idata.buf+aoffset, alen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset = 0
  */
     }
 
-    /* "borg/crypto/low_level.pyx":552
+    /* "borg/crypto/low_level.pyx":543
  *             if not EVP_DecryptUpdate(self.ctx, NULL, &olen, <const unsigned char*> idata.buf+aoffset, alen):
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset = 0             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptUpdate(self.ctx, odata+offset, &olen,
  *                                      <const unsigned char*> idata.buf+hlen+self.mac_len,
  */
     __pyx_v_offset = 0;
 
-    /* "borg/crypto/low_level.pyx":553
+    /* "borg/crypto/low_level.pyx":544
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata+offset, &olen,             # <<<<<<<<<<<<<<
  *                                      <const unsigned char*> idata.buf+hlen+self.mac_len,
  *                                      ilen-hlen-self.mac_len):
  */
     __pyx_t_6 = ((!(EVP_DecryptUpdate(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen), ((((unsigned char const *)__pyx_v_idata.buf) + __pyx_v_hlen) + __pyx_v_self->mac_len), ((__pyx_v_ilen - __pyx_v_hlen) - __pyx_v_self->mac_len)) != 0)) != 0);
     if (unlikely(__pyx_t_6)) {
 
-      /* "borg/crypto/low_level.pyx":556
+      /* "borg/crypto/low_level.pyx":547
  *                                      <const unsigned char*> idata.buf+hlen+self.mac_len,
  *                                      ilen-hlen-self.mac_len):
  *                 raise CryptoError('EVP_DecryptUpdate failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_TAG, self.mac_len, <unsigned char *> idata.buf + hlen):
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 556, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 547, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_2, function);
         }
       }
       __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_kp_s_EVP_DecryptUpdate_failed) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_EVP_DecryptUpdate_failed);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 556, __pyx_L6_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 547, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 556, __pyx_L6_error)
+      __PYX_ERR(0, 547, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":553
+      /* "borg/crypto/low_level.pyx":544
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata+offset, &olen,             # <<<<<<<<<<<<<<
  *                                      <const unsigned char*> idata.buf+hlen+self.mac_len,
  *                                      ilen-hlen-self.mac_len):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":557
+    /* "borg/crypto/low_level.pyx":548
  *                                      ilen-hlen-self.mac_len):
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_TAG, self.mac_len, <unsigned char *> idata.buf + hlen):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET TAG failed')
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":558
+    /* "borg/crypto/low_level.pyx":549
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset += olen
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_TAG, self.mac_len, <unsigned char *> idata.buf + hlen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET TAG failed')
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  */
     __pyx_t_6 = ((!(EVP_CIPHER_CTX_ctrl(__pyx_v_self->ctx, EVP_CTRL_AEAD_SET_TAG, __pyx_v_self->mac_len, (((unsigned char *)__pyx_v_idata.buf) + __pyx_v_hlen)) != 0)) != 0);
     if (unlikely(__pyx_t_6)) {
 
-      /* "borg/crypto/low_level.pyx":559
+      /* "borg/crypto/low_level.pyx":550
  *             offset += olen
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_TAG, self.mac_len, <unsigned char *> idata.buf + hlen):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET TAG failed')             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 # a failure here means corrupted or tampered tag (mac) or data.
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 559, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 550, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_2, function);
         }
       }
       __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_kp_s_EVP_CIPHER_CTX_ctrl_SET_TAG_fail) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_EVP_CIPHER_CTX_ctrl_SET_TAG_fail);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 559, __pyx_L6_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 550, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 559, __pyx_L6_error)
+      __PYX_ERR(0, 550, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":558
+      /* "borg/crypto/low_level.pyx":549
  *                 raise CryptoError('EVP_DecryptUpdate failed')
  *             offset += olen
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_TAG, self.mac_len, <unsigned char *> idata.buf + hlen):             # <<<<<<<<<<<<<<
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET TAG failed')
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  */
     }
 
-    /* "borg/crypto/low_level.pyx":560
+    /* "borg/crypto/low_level.pyx":551
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_TAG, self.mac_len, <unsigned char *> idata.buf + hlen):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET TAG failed')
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 # a failure here means corrupted or tampered tag (mac) or data.
  *                 raise IntegrityError('Authentication / EVP_DecryptFinal_ex failed')
  */
     __pyx_t_6 = ((!(EVP_DecryptFinal_ex(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen)) != 0)) != 0);
     if (unlikely(__pyx_t_6)) {
 
-      /* "borg/crypto/low_level.pyx":562
+      /* "borg/crypto/low_level.pyx":553
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 # a failure here means corrupted or tampered tag (mac) or data.
  *                 raise IntegrityError('Authentication / EVP_DecryptFinal_ex failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             self.blocks = self.block_count(offset)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_IntegrityError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 562, __pyx_L6_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_IntegrityError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 553, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __pyx_t_4 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
         __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
         if (likely(__pyx_t_4)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
           __Pyx_INCREF(__pyx_t_4);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_2, function);
         }
       }
       __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_kp_s_Authentication_EVP_DecryptFinal) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_s_Authentication_EVP_DecryptFinal);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 562, __pyx_L6_error)
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 553, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_1, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __PYX_ERR(0, 562, __pyx_L6_error)
+      __PYX_ERR(0, 553, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":560
+      /* "borg/crypto/low_level.pyx":551
  *             if not EVP_CIPHER_CTX_ctrl(self.ctx, EVP_CTRL_AEAD_SET_TAG, self.mac_len, <unsigned char *> idata.buf + hlen):
  *                 raise CryptoError('EVP_CIPHER_CTX_ctrl SET TAG failed')
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 # a failure here means corrupted or tampered tag (mac) or data.
  *                 raise IntegrityError('Authentication / EVP_DecryptFinal_ex failed')
  */
     }
 
-    /* "borg/crypto/low_level.pyx":563
+    /* "borg/crypto/low_level.pyx":554
  *                 # a failure here means corrupted or tampered tag (mac) or data.
  *                 raise IntegrityError('Authentication / EVP_DecryptFinal_ex failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             self.blocks = self.block_count(offset)
  *             return odata[:offset]
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":564
+    /* "borg/crypto/low_level.pyx":555
  *                 raise IntegrityError('Authentication / EVP_DecryptFinal_ex failed')
  *             offset += olen
  *             self.blocks = self.block_count(offset)             # <<<<<<<<<<<<<<
  *             return odata[:offset]
  *         finally:
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 564, __pyx_L6_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 555, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 564, __pyx_L6_error)
+    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 555, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_2, function);
       }
     }
     __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 564, __pyx_L6_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 555, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_9 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_1); if (unlikely((__pyx_t_9 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 564, __pyx_L6_error)
+    __pyx_t_9 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_1); if (unlikely((__pyx_t_9 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 555, __pyx_L6_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_v_self->blocks = __pyx_t_9;
 
-    /* "borg/crypto/low_level.pyx":565
+    /* "borg/crypto/low_level.pyx":556
  *             offset += olen
  *             self.blocks = self.block_count(offset)
  *             return odata[:offset]             # <<<<<<<<<<<<<<
  *         finally:
  *             PyMem_Free(odata)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 565, __pyx_L6_error)
+    __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 556, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L5_return;
   }
 
-  /* "borg/crypto/low_level.pyx":567
+  /* "borg/crypto/low_level.pyx":558
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  *             PyBuffer_Release(&aadata)
  */
   /*finally:*/ {
@@ -10498,24 +10508,24 @@
       __Pyx_XGOTREF(__pyx_t_15);
       __Pyx_XGOTREF(__pyx_t_16);
       __Pyx_XGOTREF(__pyx_t_17);
       __pyx_t_7 = __pyx_lineno; __pyx_t_10 = __pyx_clineno; __pyx_t_11 = __pyx_filename;
       {
         PyMem_Free(__pyx_v_odata);
 
-        /* "borg/crypto/low_level.pyx":568
+        /* "borg/crypto/low_level.pyx":559
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&aadata)
  * 
  */
         PyBuffer_Release((&__pyx_v_idata));
 
-        /* "borg/crypto/low_level.pyx":569
+        /* "borg/crypto/low_level.pyx":560
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)
  *             PyBuffer_Release(&aadata)             # <<<<<<<<<<<<<<
  * 
  *     def block_count(self, length):
  */
         PyBuffer_Release((&__pyx_v_aadata));
@@ -10534,47 +10544,47 @@
       __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_10; __pyx_filename = __pyx_t_11;
       goto __pyx_L1_error;
     }
     __pyx_L5_return: {
       __pyx_t_17 = __pyx_r;
       __pyx_r = 0;
 
-      /* "borg/crypto/low_level.pyx":567
+      /* "borg/crypto/low_level.pyx":558
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  *             PyBuffer_Release(&aadata)
  */
       PyMem_Free(__pyx_v_odata);
 
-      /* "borg/crypto/low_level.pyx":568
+      /* "borg/crypto/low_level.pyx":559
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&aadata)
  * 
  */
       PyBuffer_Release((&__pyx_v_idata));
 
-      /* "borg/crypto/low_level.pyx":569
+      /* "borg/crypto/low_level.pyx":560
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)
  *             PyBuffer_Release(&aadata)             # <<<<<<<<<<<<<<
  * 
  *     def block_count(self, length):
  */
       PyBuffer_Release((&__pyx_v_aadata));
       __pyx_r = __pyx_t_17;
       __pyx_t_17 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "borg/crypto/low_level.pyx":519
+  /* "borg/crypto/low_level.pyx":510
  *             PyBuffer_Release(&aadata)
  * 
  *     def decrypt(self, envelope, aad=b''):             # <<<<<<<<<<<<<<
  *         """
  *         authenticate aad + header + cdata (from envelope), ignore header bytes up to aad_offset.,
  */
 
@@ -10589,15 +10599,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_approx_block_count);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":571
+/* "borg/crypto/low_level.pyx":562
  *             PyBuffer_Release(&aadata)
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  */
 
@@ -10624,25 +10634,25 @@
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("block_count", 0);
 
-  /* "borg/crypto/low_level.pyx":572
+  /* "borg/crypto/low_level.pyx":563
  * 
  *     def block_count(self, length):
  *         return num_cipher_blocks(length, self.cipher_blk_len)             # <<<<<<<<<<<<<<
  * 
  *     def set_iv(self, iv):
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_num_cipher_blocks); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 572, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_num_cipher_blocks); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 563, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->cipher_blk_len); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 572, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->cipher_blk_len); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 563, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -10651,51 +10661,51 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_length, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 572, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 563, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_length, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 572, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 563, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 572, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 563, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_v_length);
     __Pyx_GIVEREF(__pyx_v_length);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_length);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 572, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 563, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":571
+  /* "borg/crypto/low_level.pyx":562
  *             PyBuffer_Release(&aadata)
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  */
 
@@ -10710,15 +10720,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":574
+/* "borg/crypto/low_level.pyx":565
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         # set_iv needs to be called before each encrypt() call,
  *         # because encrypt does a full initialisation of the cipher context.
  */
 
@@ -10749,62 +10759,62 @@
   unsigned char __pyx_t_9[12];
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("set_iv", 0);
   __Pyx_INCREF(__pyx_v_iv);
 
-  /* "borg/crypto/low_level.pyx":577
+  /* "borg/crypto/low_level.pyx":568
  *         # set_iv needs to be called before each encrypt() call,
  *         # because encrypt does a full initialisation of the cipher context.
  *         if isinstance(iv, int):             # <<<<<<<<<<<<<<
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  */
   __pyx_t_1 = PyInt_Check(__pyx_v_iv); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/crypto/low_level.pyx":578
+    /* "borg/crypto/low_level.pyx":569
  *         # because encrypt does a full initialisation of the cipher context.
  *         if isinstance(iv, int):
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')             # <<<<<<<<<<<<<<
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  *         self.iv = iv
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_iv, __pyx_n_s_to_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 578, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_iv, __pyx_n_s_to_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 569, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_self->iv_len); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 578, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_self->iv_len); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 569, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 578, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 569, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 578, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 569, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 578, __pyx_L1_error)
-    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 578, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 569, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 569, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF_SET(__pyx_v_iv, __pyx_t_6);
     __pyx_t_6 = 0;
 
-    /* "borg/crypto/low_level.pyx":577
+    /* "borg/crypto/low_level.pyx":568
  *         # set_iv needs to be called before each encrypt() call,
  *         # because encrypt does a full initialisation of the cipher context.
  *         if isinstance(iv, int):             # <<<<<<<<<<<<<<
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  */
   }
 
-  /* "borg/crypto/low_level.pyx":579
+  /* "borg/crypto/low_level.pyx":570
  *         if isinstance(iv, int):
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len             # <<<<<<<<<<<<<<
  *         self.iv = iv
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -10812,45 +10822,45 @@
     __pyx_t_1 = PyBytes_Check(__pyx_v_iv); 
     __pyx_t_7 = (__pyx_t_1 != 0);
     if (__pyx_t_7) {
     } else {
       __pyx_t_2 = __pyx_t_7;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_8 = PyObject_Length(__pyx_v_iv); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 579, __pyx_L1_error)
+    __pyx_t_8 = PyObject_Length(__pyx_v_iv); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 570, __pyx_L1_error)
     __pyx_t_7 = ((__pyx_t_8 == __pyx_v_self->iv_len) != 0);
     __pyx_t_2 = __pyx_t_7;
     __pyx_L4_bool_binop_done:;
     if (unlikely(!__pyx_t_2)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 579, __pyx_L1_error)
+      __PYX_ERR(0, 570, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":580
+  /* "borg/crypto/low_level.pyx":571
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  *         self.iv = iv             # <<<<<<<<<<<<<<
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV
  * 
  */
-  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_iv, __pyx_t_9, 12) < 0)) __PYX_ERR(0, 580, __pyx_L1_error)
+  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_iv, __pyx_t_9, 12) < 0)) __PYX_ERR(0, 571, __pyx_L1_error)
   memcpy(&(__pyx_v_self->iv[0]), __pyx_t_9, sizeof(__pyx_v_self->iv[0]) * (12));
 
-  /* "borg/crypto/low_level.pyx":581
+  /* "borg/crypto/low_level.pyx":572
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  *         self.iv = iv
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV             # <<<<<<<<<<<<<<
  * 
  *     def next_iv(self):
  */
   __pyx_v_self->blocks = 0;
 
-  /* "borg/crypto/low_level.pyx":574
+  /* "borg/crypto/low_level.pyx":565
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         # set_iv needs to be called before each encrypt() call,
  *         # because encrypt does a full initialisation of the cipher context.
  */
 
@@ -10867,15 +10877,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_iv);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":583
+/* "borg/crypto/low_level.pyx":574
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         # AES-OCB, CHACHA20 ciphers all add a internal 32bit counter to the 96bit
  */
 
@@ -10901,56 +10911,56 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("next_iv", 0);
 
-  /* "borg/crypto/low_level.pyx":587
+  /* "borg/crypto/low_level.pyx":578
  *         # AES-OCB, CHACHA20 ciphers all add a internal 32bit counter to the 96bit
  *         # (12 byte) IV we provide, thus we only need to increment the IV by 1.
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')             # <<<<<<<<<<<<<<
  *         return iv + 1
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)(&PyInt_Type)), __pyx_n_s_from_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 587, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)(&PyInt_Type)), __pyx_n_s_from_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 578, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->iv) + 0, __pyx_v_self->iv_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 587, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->iv) + 0, __pyx_v_self->iv_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 578, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 587, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 578, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 587, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 578, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 587, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 587, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 578, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 578, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_iv = __pyx_t_4;
   __pyx_t_4 = 0;
 
-  /* "borg/crypto/low_level.pyx":588
+  /* "borg/crypto/low_level.pyx":579
  *         # (12 byte) IV we provide, thus we only need to increment the IV by 1.
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')
  *         return iv + 1             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_4 = __Pyx_PyInt_AddObjC(__pyx_v_iv, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 588, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_AddObjC(__pyx_v_iv, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_r = __pyx_t_4;
   __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":583
+  /* "borg/crypto/low_level.pyx":574
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         # AES-OCB, CHACHA20 ciphers all add a internal 32bit counter to the 96bit
  */
 
@@ -11078,15 +11088,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level._AEAD_BASE.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":593
+/* "borg/crypto/low_level.pyx":584
  * cdef class AES256_OCB(_AEAD_BASE):
  *     @classmethod
  *     def requirements_check(cls):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
 
@@ -11111,15 +11121,15 @@
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":596
+/* "borg/crypto/low_level.pyx":587
  *         pass
  * 
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):             # <<<<<<<<<<<<<<
  *         self.requirements_check()
  *         self.cipher = EVP_aes_256_ocb
  */
 
@@ -11178,15 +11188,15 @@
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 596, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 587, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -11200,15 +11210,15 @@
     __pyx_v_key = values[0];
     __pyx_v_iv = values[1];
     __pyx_v_header_len = values[2];
     __pyx_v_aad_offset = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 596, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 587, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_OCB.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_10AES256_OCB_2__init__(((struct __pyx_obj_4borg_6crypto_9low_level_AES256_OCB *)__pyx_v_self), __pyx_v_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -11225,97 +11235,97 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/crypto/low_level.pyx":597
+  /* "borg/crypto/low_level.pyx":588
  * 
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):
  *         self.requirements_check()             # <<<<<<<<<<<<<<
  *         self.cipher = EVP_aes_256_ocb
  *         self.cipher_blk_len = 16
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 597, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 588, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 597, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 588, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":598
+  /* "borg/crypto/low_level.pyx":589
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):
  *         self.requirements_check()
  *         self.cipher = EVP_aes_256_ocb             # <<<<<<<<<<<<<<
  *         self.cipher_blk_len = 16
  *         super().__init__(key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  */
   __pyx_v_self->__pyx_base.cipher = EVP_aes_256_ocb;
 
-  /* "borg/crypto/low_level.pyx":599
+  /* "borg/crypto/low_level.pyx":590
  *         self.requirements_check()
  *         self.cipher = EVP_aes_256_ocb
  *         self.cipher_blk_len = 16             # <<<<<<<<<<<<<<
  *         super().__init__(key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  * 
  */
   __pyx_v_self->__pyx_base.cipher_blk_len = 16;
 
-  /* "borg/crypto/low_level.pyx":600
+  /* "borg/crypto/low_level.pyx":591
  *         self.cipher = EVP_aes_256_ocb
  *         self.cipher_blk_len = 16
  *         super().__init__(key, iv=iv, header_len=header_len, aad_offset=aad_offset)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_OCB));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_OCB));
   PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_OCB));
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_v_self));
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_v_key);
   __Pyx_GIVEREF(__pyx_v_key);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_key);
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 600, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 600, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_aad_offset, __pyx_v_aad_offset) < 0) __PYX_ERR(0, 600, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 600, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_aad_offset, __pyx_v_aad_offset) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 591, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "borg/crypto/low_level.pyx":596
+  /* "borg/crypto/low_level.pyx":587
  *         pass
  * 
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):             # <<<<<<<<<<<<<<
  *         self.requirements_check()
  *         self.cipher = EVP_aes_256_ocb
  */
 
@@ -11443,15 +11453,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES256_OCB.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":605
+/* "borg/crypto/low_level.pyx":596
  * cdef class CHACHA20_POLY1305(_AEAD_BASE):
  *     @classmethod
  *     def requirements_check(cls):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
 
@@ -11476,15 +11486,15 @@
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":608
+/* "borg/crypto/low_level.pyx":599
  *         pass
  * 
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):             # <<<<<<<<<<<<<<
  *         self.requirements_check()
  *         self.cipher = EVP_chacha20_poly1305
  */
 
@@ -11543,15 +11553,15 @@
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_aad_offset);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 608, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 599, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -11565,15 +11575,15 @@
     __pyx_v_key = values[0];
     __pyx_v_iv = values[1];
     __pyx_v_header_len = values[2];
     __pyx_v_aad_offset = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 608, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 599, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.CHACHA20_POLY1305.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_17CHACHA20_POLY1305_2__init__(((struct __pyx_obj_4borg_6crypto_9low_level_CHACHA20_POLY1305 *)__pyx_v_self), __pyx_v_key, __pyx_v_iv, __pyx_v_header_len, __pyx_v_aad_offset);
 
@@ -11590,97 +11600,97 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/crypto/low_level.pyx":609
+  /* "borg/crypto/low_level.pyx":600
  * 
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):
  *         self.requirements_check()             # <<<<<<<<<<<<<<
  *         self.cipher = EVP_chacha20_poly1305
  *         self.cipher_blk_len = 64
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 609, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 600, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 609, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 600, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":610
+  /* "borg/crypto/low_level.pyx":601
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):
  *         self.requirements_check()
  *         self.cipher = EVP_chacha20_poly1305             # <<<<<<<<<<<<<<
  *         self.cipher_blk_len = 64
  *         super().__init__(key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  */
   __pyx_v_self->__pyx_base.cipher = EVP_chacha20_poly1305;
 
-  /* "borg/crypto/low_level.pyx":611
+  /* "borg/crypto/low_level.pyx":602
  *         self.requirements_check()
  *         self.cipher = EVP_chacha20_poly1305
  *         self.cipher_blk_len = 64             # <<<<<<<<<<<<<<
  *         super().__init__(key, iv=iv, header_len=header_len, aad_offset=aad_offset)
  * 
  */
   __pyx_v_self->__pyx_base.cipher_blk_len = 64;
 
-  /* "borg/crypto/low_level.pyx":612
+  /* "borg/crypto/low_level.pyx":603
  *         self.cipher = EVP_chacha20_poly1305
  *         self.cipher_blk_len = 64
  *         super().__init__(key, iv=iv, header_len=header_len, aad_offset=aad_offset)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 612, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 603, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_CHACHA20_POLY1305));
   __Pyx_GIVEREF(((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_CHACHA20_POLY1305));
   PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_CHACHA20_POLY1305));
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_v_self));
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 612, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 603, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 612, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 603, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 612, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 603, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_v_key);
   __Pyx_GIVEREF(__pyx_v_key);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_key);
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 612, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 603, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 612, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 612, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_aad_offset, __pyx_v_aad_offset) < 0) __PYX_ERR(0, 612, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 612, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_iv, __pyx_v_iv) < 0) __PYX_ERR(0, 603, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_header_len, __pyx_v_header_len) < 0) __PYX_ERR(0, 603, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_aad_offset, __pyx_v_aad_offset) < 0) __PYX_ERR(0, 603, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 603, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "borg/crypto/low_level.pyx":608
+  /* "borg/crypto/low_level.pyx":599
  *         pass
  * 
  *     def __init__(self, key, iv=None, header_len=0, aad_offset=0):             # <<<<<<<<<<<<<<
  *         self.requirements_check()
  *         self.cipher = EVP_chacha20_poly1305
  */
 
@@ -11808,15 +11818,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.CHACHA20_POLY1305.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":625
+/* "borg/crypto/low_level.pyx":616
  *     cdef long long blocks
  * 
  *     def __init__(self, enc_key, iv=None):             # <<<<<<<<<<<<<<
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32
  *         self.enc_key = enc_key
  */
 
@@ -11855,15 +11865,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 625, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 616, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -11871,15 +11881,15 @@
       }
     }
     __pyx_v_enc_key = values[0];
     __pyx_v_iv = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 625, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 616, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_3AES___init__(((struct __pyx_obj_4borg_6crypto_9low_level_AES *)__pyx_v_self), __pyx_v_enc_key, __pyx_v_iv);
 
@@ -11900,15 +11910,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/crypto/low_level.pyx":626
+  /* "borg/crypto/low_level.pyx":617
  * 
  *     def __init__(self, enc_key, iv=None):
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32             # <<<<<<<<<<<<<<
  *         self.enc_key = enc_key
  *         self.iv_len = 16
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -11916,138 +11926,138 @@
     __pyx_t_2 = PyBytes_Check(__pyx_v_enc_key); 
     __pyx_t_3 = (__pyx_t_2 != 0);
     if (__pyx_t_3) {
     } else {
       __pyx_t_1 = __pyx_t_3;
       goto __pyx_L3_bool_binop_done;
     }
-    __pyx_t_4 = PyObject_Length(__pyx_v_enc_key); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 626, __pyx_L1_error)
+    __pyx_t_4 = PyObject_Length(__pyx_v_enc_key); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 617, __pyx_L1_error)
     __pyx_t_3 = ((__pyx_t_4 == 32) != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!__pyx_t_1)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 626, __pyx_L1_error)
+      __PYX_ERR(0, 617, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":627
+  /* "borg/crypto/low_level.pyx":618
  *     def __init__(self, enc_key, iv=None):
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32
  *         self.enc_key = enc_key             # <<<<<<<<<<<<<<
  *         self.iv_len = 16
  *         assert sizeof(self.iv) == self.iv_len
  */
-  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_enc_key, __pyx_t_5, 32) < 0)) __PYX_ERR(0, 627, __pyx_L1_error)
+  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_enc_key, __pyx_t_5, 32) < 0)) __PYX_ERR(0, 618, __pyx_L1_error)
   memcpy(&(__pyx_v_self->enc_key[0]), __pyx_t_5, sizeof(__pyx_v_self->enc_key[0]) * (32));
 
-  /* "borg/crypto/low_level.pyx":628
+  /* "borg/crypto/low_level.pyx":619
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32
  *         self.enc_key = enc_key
  *         self.iv_len = 16             # <<<<<<<<<<<<<<
  *         assert sizeof(self.iv) == self.iv_len
  *         self.cipher = EVP_aes_256_ctr
  */
   __pyx_v_self->iv_len = 16;
 
-  /* "borg/crypto/low_level.pyx":629
+  /* "borg/crypto/low_level.pyx":620
  *         self.enc_key = enc_key
  *         self.iv_len = 16
  *         assert sizeof(self.iv) == self.iv_len             # <<<<<<<<<<<<<<
  *         self.cipher = EVP_aes_256_ctr
  *         self.cipher_blk_len = 16
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!(((sizeof(__pyx_v_self->iv)) == __pyx_v_self->iv_len) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 629, __pyx_L1_error)
+      __PYX_ERR(0, 620, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":630
+  /* "borg/crypto/low_level.pyx":621
  *         self.iv_len = 16
  *         assert sizeof(self.iv) == self.iv_len
  *         self.cipher = EVP_aes_256_ctr             # <<<<<<<<<<<<<<
  *         self.cipher_blk_len = 16
  *         if iv is not None:
  */
   __pyx_v_self->cipher = EVP_aes_256_ctr;
 
-  /* "borg/crypto/low_level.pyx":631
+  /* "borg/crypto/low_level.pyx":622
  *         assert sizeof(self.iv) == self.iv_len
  *         self.cipher = EVP_aes_256_ctr
  *         self.cipher_blk_len = 16             # <<<<<<<<<<<<<<
  *         if iv is not None:
  *             self.set_iv(iv)
  */
   __pyx_v_self->cipher_blk_len = 16;
 
-  /* "borg/crypto/low_level.pyx":632
+  /* "borg/crypto/low_level.pyx":623
  *         self.cipher = EVP_aes_256_ctr
  *         self.cipher_blk_len = 16
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         else:
  */
   __pyx_t_1 = (__pyx_v_iv != Py_None);
   __pyx_t_3 = (__pyx_t_1 != 0);
   if (__pyx_t_3) {
 
-    /* "borg/crypto/low_level.pyx":633
+    /* "borg/crypto/low_level.pyx":624
  *         self.cipher_blk_len = 16
  *         if iv is not None:
  *             self.set_iv(iv)             # <<<<<<<<<<<<<<
  *         else:
  *             self.blocks = -1  # make sure set_iv is called before encrypt
  */
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 633, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 624, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __pyx_t_8 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
       __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_8)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
         __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
     __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_v_iv) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_iv);
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 633, __pyx_L1_error)
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 624, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-    /* "borg/crypto/low_level.pyx":632
+    /* "borg/crypto/low_level.pyx":623
  *         self.cipher = EVP_aes_256_ctr
  *         self.cipher_blk_len = 16
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         else:
  */
     goto __pyx_L5;
   }
 
-  /* "borg/crypto/low_level.pyx":635
+  /* "borg/crypto/low_level.pyx":626
  *             self.set_iv(iv)
  *         else:
  *             self.blocks = -1  # make sure set_iv is called before encrypt             # <<<<<<<<<<<<<<
  * 
  *     def __cinit__(self, enc_key, iv=None):
  */
   /*else*/ {
     __pyx_v_self->blocks = -1LL;
   }
   __pyx_L5:;
 
-  /* "borg/crypto/low_level.pyx":625
+  /* "borg/crypto/low_level.pyx":616
  *     cdef long long blocks
  * 
  *     def __init__(self, enc_key, iv=None):             # <<<<<<<<<<<<<<
  *         assert isinstance(enc_key, bytes) and len(enc_key) == 32
  *         self.enc_key = enc_key
  */
 
@@ -12061,15 +12071,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":637
+/* "borg/crypto/low_level.pyx":628
  *             self.blocks = -1  # make sure set_iv is called before encrypt
  * 
  *     def __cinit__(self, enc_key, iv=None):             # <<<<<<<<<<<<<<
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  */
 
@@ -12108,15 +12118,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 637, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 628, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -12124,15 +12134,15 @@
       }
     }
     __pyx_v_enc_key = values[0];
     __pyx_v_iv = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 637, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 628, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_3AES_2__cinit__(((struct __pyx_obj_4borg_6crypto_9low_level_AES *)__pyx_v_self), __pyx_v_enc_key, __pyx_v_iv);
 
@@ -12142,38 +12152,38 @@
 }
 
 static int __pyx_pf_4borg_6crypto_9low_level_3AES_2__cinit__(struct __pyx_obj_4borg_6crypto_9low_level_AES *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_enc_key, CYTHON_UNUSED PyObject *__pyx_v_iv) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "borg/crypto/low_level.pyx":638
+  /* "borg/crypto/low_level.pyx":629
  * 
  *     def __cinit__(self, enc_key, iv=None):
  *         self.ctx = EVP_CIPHER_CTX_new()             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(self):
  */
   __pyx_v_self->ctx = EVP_CIPHER_CTX_new();
 
-  /* "borg/crypto/low_level.pyx":637
+  /* "borg/crypto/low_level.pyx":628
  *             self.blocks = -1  # make sure set_iv is called before encrypt
  * 
  *     def __cinit__(self, enc_key, iv=None):             # <<<<<<<<<<<<<<
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":640
+/* "borg/crypto/low_level.pyx":631
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  */
 
@@ -12188,36 +12198,36 @@
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_pf_4borg_6crypto_9low_level_3AES_4__dealloc__(struct __pyx_obj_4borg_6crypto_9low_level_AES *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "borg/crypto/low_level.pyx":641
+  /* "borg/crypto/low_level.pyx":632
  * 
  *     def __dealloc__(self):
  *         EVP_CIPHER_CTX_free(self.ctx)             # <<<<<<<<<<<<<<
  * 
  *     def encrypt(self, data, iv=None):
  */
   EVP_CIPHER_CTX_free(__pyx_v_self->ctx);
 
-  /* "borg/crypto/low_level.pyx":640
+  /* "borg/crypto/low_level.pyx":631
  *         self.ctx = EVP_CIPHER_CTX_new()
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "borg/crypto/low_level.pyx":643
+/* "borg/crypto/low_level.pyx":634
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  *     def encrypt(self, data, iv=None):             # <<<<<<<<<<<<<<
  *         if iv is not None:
  *             self.set_iv(iv)
  */
 
@@ -12256,15 +12266,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iv);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "encrypt") < 0)) __PYX_ERR(0, 643, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "encrypt") < 0)) __PYX_ERR(0, 634, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -12272,15 +12282,15 @@
       }
     }
     __pyx_v_data = values[0];
     __pyx_v_iv = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("encrypt", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 643, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("encrypt", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 634, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.AES.encrypt", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_3AES_6encrypt(((struct __pyx_obj_4borg_6crypto_9low_level_AES *)__pyx_v_self), __pyx_v_data, __pyx_v_iv);
 
@@ -12316,321 +12326,321 @@
   PyObject *__pyx_t_17 = NULL;
   PyObject *__pyx_t_18 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encrypt", 0);
 
-  /* "borg/crypto/low_level.pyx":644
+  /* "borg/crypto/low_level.pyx":635
  * 
  *     def encrypt(self, data, iv=None):
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  */
   __pyx_t_1 = (__pyx_v_iv != Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/crypto/low_level.pyx":645
+    /* "borg/crypto/low_level.pyx":636
  *     def encrypt(self, data, iv=None):
  *         if iv is not None:
  *             self.set_iv(iv)             # <<<<<<<<<<<<<<
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  *         cdef Py_buffer idata = ro_buffer(data)
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 645, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_iv); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 636, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_iv) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_iv);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 645, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 636, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/crypto/low_level.pyx":644
+    /* "borg/crypto/low_level.pyx":635
  * 
  *     def encrypt(self, data, iv=None):
  *         if iv is not None:             # <<<<<<<<<<<<<<
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  */
   }
 
-  /* "borg/crypto/low_level.pyx":646
+  /* "borg/crypto/low_level.pyx":637
  *         if iv is not None:
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'             # <<<<<<<<<<<<<<
  *         cdef Py_buffer idata = ro_buffer(data)
  *         cdef int ilen = len(data)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_self->blocks == 0) != 0))) {
       PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_iv_needs_to_be_set_before_encryp);
-      __PYX_ERR(0, 646, __pyx_L1_error)
+      __PYX_ERR(0, 637, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":647
+  /* "borg/crypto/low_level.pyx":638
  *             self.set_iv(iv)
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  *         cdef Py_buffer idata = ro_buffer(data)             # <<<<<<<<<<<<<<
  *         cdef int ilen = len(data)
  *         cdef int offset
  */
-  __pyx_t_6 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_data); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 647, __pyx_L1_error)
+  __pyx_t_6 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_data); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 638, __pyx_L1_error)
   __pyx_v_idata = __pyx_t_6;
 
-  /* "borg/crypto/low_level.pyx":648
+  /* "borg/crypto/low_level.pyx":639
  *         assert self.blocks == 0, 'iv needs to be set before encrypt is called'
  *         cdef Py_buffer idata = ro_buffer(data)
  *         cdef int ilen = len(data)             # <<<<<<<<<<<<<<
  *         cdef int offset
  *         cdef int olen = 0
  */
-  __pyx_t_7 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 648, __pyx_L1_error)
+  __pyx_t_7 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 639, __pyx_L1_error)
   __pyx_v_ilen = __pyx_t_7;
 
-  /* "borg/crypto/low_level.pyx":650
+  /* "borg/crypto/low_level.pyx":641
  *         cdef int ilen = len(data)
  *         cdef int offset
  *         cdef int olen = 0             # <<<<<<<<<<<<<<
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:
  */
   __pyx_v_olen = 0;
 
-  /* "borg/crypto/low_level.pyx":651
+  /* "borg/crypto/low_level.pyx":642
  *         cdef int offset
  *         cdef int olen = 0
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)             # <<<<<<<<<<<<<<
  *         if not odata:
  *             raise MemoryError
  */
   __pyx_v_odata = ((unsigned char *)PyMem_Malloc((__pyx_v_ilen + __pyx_v_self->cipher_blk_len)));
 
-  /* "borg/crypto/low_level.pyx":652
+  /* "borg/crypto/low_level.pyx":643
  *         cdef int olen = 0
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         try:
  */
   __pyx_t_2 = ((!(__pyx_v_odata != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "borg/crypto/low_level.pyx":653
+    /* "borg/crypto/low_level.pyx":644
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:
  *             raise MemoryError             # <<<<<<<<<<<<<<
  *         try:
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 653, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 644, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":652
+    /* "borg/crypto/low_level.pyx":643
  *         cdef int olen = 0
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         try:
  */
   }
 
-  /* "borg/crypto/low_level.pyx":654
+  /* "borg/crypto/low_level.pyx":645
  *         if not odata:
  *             raise MemoryError
  *         try:             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):
  *                 raise Exception('EVP_EncryptInit_ex failed')
  */
   /*try:*/ {
 
-    /* "borg/crypto/low_level.pyx":655
+    /* "borg/crypto/low_level.pyx":646
  *             raise MemoryError
  *         try:
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_EncryptInit_ex failed')
  *             offset = 0
  */
     __pyx_t_2 = ((!(EVP_EncryptInit_ex(__pyx_v_self->ctx, __pyx_v_self->cipher(), NULL, __pyx_v_self->enc_key, __pyx_v_self->iv) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":656
+      /* "borg/crypto/low_level.pyx":647
  *         try:
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):
  *                 raise Exception('EVP_EncryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             offset = 0
  *             if not EVP_EncryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  */
-      __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 656, __pyx_L6_error)
+      __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 647, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 656, __pyx_L6_error)
+      __PYX_ERR(0, 647, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":655
+      /* "borg/crypto/low_level.pyx":646
  *             raise MemoryError
  *         try:
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_EncryptInit_ex failed')
  *             offset = 0
  */
     }
 
-    /* "borg/crypto/low_level.pyx":657
+    /* "borg/crypto/low_level.pyx":648
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):
  *                 raise Exception('EVP_EncryptInit_ex failed')
  *             offset = 0             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise Exception('EVP_EncryptUpdate failed')
  */
     __pyx_v_offset = 0;
 
-    /* "borg/crypto/low_level.pyx":658
+    /* "borg/crypto/low_level.pyx":649
  *                 raise Exception('EVP_EncryptInit_ex failed')
  *             offset = 0
  *             if not EVP_EncryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_EncryptUpdate failed')
  *             offset += olen
  */
     __pyx_t_2 = ((!(EVP_EncryptUpdate(__pyx_v_self->ctx, __pyx_v_odata, (&__pyx_v_olen), ((unsigned char const *)__pyx_v_idata.buf), __pyx_v_ilen) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":659
+      /* "borg/crypto/low_level.pyx":650
  *             offset = 0
  *             if not EVP_EncryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise Exception('EVP_EncryptUpdate failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  */
-      __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 659, __pyx_L6_error)
+      __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 650, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 659, __pyx_L6_error)
+      __PYX_ERR(0, 650, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":658
+      /* "borg/crypto/low_level.pyx":649
  *                 raise Exception('EVP_EncryptInit_ex failed')
  *             offset = 0
  *             if not EVP_EncryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_EncryptUpdate failed')
  *             offset += olen
  */
     }
 
-    /* "borg/crypto/low_level.pyx":660
+    /* "borg/crypto/low_level.pyx":651
  *             if not EVP_EncryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise Exception('EVP_EncryptUpdate failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise Exception('EVP_EncryptFinal failed')
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":661
+    /* "borg/crypto/low_level.pyx":652
  *                 raise Exception('EVP_EncryptUpdate failed')
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_EncryptFinal failed')
  *             offset += olen
  */
     __pyx_t_2 = ((!(EVP_EncryptFinal_ex(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen)) != 0)) != 0);
     if (unlikely(__pyx_t_2)) {
 
-      /* "borg/crypto/low_level.pyx":662
+      /* "borg/crypto/low_level.pyx":653
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise Exception('EVP_EncryptFinal failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             self.blocks = self.block_count(offset)
  */
-      __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 662, __pyx_L6_error)
+      __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 653, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 662, __pyx_L6_error)
+      __PYX_ERR(0, 653, __pyx_L6_error)
 
-      /* "borg/crypto/low_level.pyx":661
+      /* "borg/crypto/low_level.pyx":652
  *                 raise Exception('EVP_EncryptUpdate failed')
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_EncryptFinal failed')
  *             offset += olen
  */
     }
 
-    /* "borg/crypto/low_level.pyx":663
+    /* "borg/crypto/low_level.pyx":654
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise Exception('EVP_EncryptFinal failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             self.blocks = self.block_count(offset)
  *             return odata[:offset]
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":664
+    /* "borg/crypto/low_level.pyx":655
  *                 raise Exception('EVP_EncryptFinal failed')
  *             offset += olen
  *             self.blocks = self.block_count(offset)             # <<<<<<<<<<<<<<
  *             return odata[:offset]
  *         finally:
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 664, __pyx_L6_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 655, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 664, __pyx_L6_error)
+    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_offset); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 655, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_8 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_8)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_3 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_8, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5);
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 664, __pyx_L6_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 655, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_9 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_3); if (unlikely((__pyx_t_9 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 664, __pyx_L6_error)
+    __pyx_t_9 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_3); if (unlikely((__pyx_t_9 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 655, __pyx_L6_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_self->blocks = __pyx_t_9;
 
-    /* "borg/crypto/low_level.pyx":665
+    /* "borg/crypto/low_level.pyx":656
  *             offset += olen
  *             self.blocks = self.block_count(offset)
  *             return odata[:offset]             # <<<<<<<<<<<<<<
  *         finally:
  *             PyMem_Free(odata)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 665, __pyx_L6_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 656, __pyx_L6_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L5_return;
   }
 
-  /* "borg/crypto/low_level.pyx":667
+  /* "borg/crypto/low_level.pyx":658
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  * 
  */
   /*finally:*/ {
@@ -12651,15 +12661,15 @@
       __Pyx_XGOTREF(__pyx_t_16);
       __Pyx_XGOTREF(__pyx_t_17);
       __Pyx_XGOTREF(__pyx_t_18);
       __pyx_t_10 = __pyx_lineno; __pyx_t_11 = __pyx_clineno; __pyx_t_12 = __pyx_filename;
       {
         PyMem_Free(__pyx_v_odata);
 
-        /* "borg/crypto/low_level.pyx":668
+        /* "borg/crypto/low_level.pyx":659
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  * 
  *     def decrypt(self, data):
  */
         PyBuffer_Release((&__pyx_v_idata));
@@ -12678,38 +12688,38 @@
       __pyx_lineno = __pyx_t_10; __pyx_clineno = __pyx_t_11; __pyx_filename = __pyx_t_12;
       goto __pyx_L1_error;
     }
     __pyx_L5_return: {
       __pyx_t_18 = __pyx_r;
       __pyx_r = 0;
 
-      /* "borg/crypto/low_level.pyx":667
+      /* "borg/crypto/low_level.pyx":658
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  * 
  */
       PyMem_Free(__pyx_v_odata);
 
-      /* "borg/crypto/low_level.pyx":668
+      /* "borg/crypto/low_level.pyx":659
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  * 
  *     def decrypt(self, data):
  */
       PyBuffer_Release((&__pyx_v_idata));
       __pyx_r = __pyx_t_18;
       __pyx_t_18 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "borg/crypto/low_level.pyx":643
+  /* "borg/crypto/low_level.pyx":634
  *         EVP_CIPHER_CTX_free(self.ctx)
  * 
  *     def encrypt(self, data, iv=None):             # <<<<<<<<<<<<<<
  *         if iv is not None:
  *             self.set_iv(iv)
  */
 
@@ -12723,15 +12733,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":670
+/* "borg/crypto/low_level.pyx":661
  *             PyBuffer_Release(&idata)
  * 
  *     def decrypt(self, data):             # <<<<<<<<<<<<<<
  *         cdef Py_buffer idata = ro_buffer(data)
  *         cdef int ilen = len(data)
  */
 
@@ -12774,259 +12784,259 @@
   PyObject *__pyx_t_16 = NULL;
   PyObject *__pyx_t_17 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decrypt", 0);
 
-  /* "borg/crypto/low_level.pyx":671
+  /* "borg/crypto/low_level.pyx":662
  * 
  *     def decrypt(self, data):
  *         cdef Py_buffer idata = ro_buffer(data)             # <<<<<<<<<<<<<<
  *         cdef int ilen = len(data)
  *         cdef int offset
  */
-  __pyx_t_1 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_data); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 671, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_4borg_6crypto_9low_level_ro_buffer(__pyx_v_data); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 662, __pyx_L1_error)
   __pyx_v_idata = __pyx_t_1;
 
-  /* "borg/crypto/low_level.pyx":672
+  /* "borg/crypto/low_level.pyx":663
  *     def decrypt(self, data):
  *         cdef Py_buffer idata = ro_buffer(data)
  *         cdef int ilen = len(data)             # <<<<<<<<<<<<<<
  *         cdef int offset
  *         cdef int olen = 0
  */
-  __pyx_t_2 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 672, __pyx_L1_error)
+  __pyx_t_2 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 663, __pyx_L1_error)
   __pyx_v_ilen = __pyx_t_2;
 
-  /* "borg/crypto/low_level.pyx":674
+  /* "borg/crypto/low_level.pyx":665
  *         cdef int ilen = len(data)
  *         cdef int offset
  *         cdef int olen = 0             # <<<<<<<<<<<<<<
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:
  */
   __pyx_v_olen = 0;
 
-  /* "borg/crypto/low_level.pyx":675
+  /* "borg/crypto/low_level.pyx":666
  *         cdef int offset
  *         cdef int olen = 0
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)             # <<<<<<<<<<<<<<
  *         if not odata:
  *             raise MemoryError
  */
   __pyx_v_odata = ((unsigned char *)PyMem_Malloc((__pyx_v_ilen + __pyx_v_self->cipher_blk_len)));
 
-  /* "borg/crypto/low_level.pyx":676
+  /* "borg/crypto/low_level.pyx":667
  *         cdef int olen = 0
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         try:
  */
   __pyx_t_3 = ((!(__pyx_v_odata != 0)) != 0);
   if (unlikely(__pyx_t_3)) {
 
-    /* "borg/crypto/low_level.pyx":677
+    /* "borg/crypto/low_level.pyx":668
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:
  *             raise MemoryError             # <<<<<<<<<<<<<<
  *         try:
  *             # Set cipher type and mode
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 677, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 668, __pyx_L1_error)
 
-    /* "borg/crypto/low_level.pyx":676
+    /* "borg/crypto/low_level.pyx":667
  *         cdef int olen = 0
  *         cdef unsigned char *odata = <unsigned char *>PyMem_Malloc(ilen + self.cipher_blk_len)
  *         if not odata:             # <<<<<<<<<<<<<<
  *             raise MemoryError
  *         try:
  */
   }
 
-  /* "borg/crypto/low_level.pyx":678
+  /* "borg/crypto/low_level.pyx":669
  *         if not odata:
  *             raise MemoryError
  *         try:             # <<<<<<<<<<<<<<
  *             # Set cipher type and mode
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):
  */
   /*try:*/ {
 
-    /* "borg/crypto/low_level.pyx":680
+    /* "borg/crypto/low_level.pyx":671
  *         try:
  *             # Set cipher type and mode
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_DecryptInit_ex failed')
  *             offset = 0
  */
     __pyx_t_3 = ((!(EVP_DecryptInit_ex(__pyx_v_self->ctx, __pyx_v_self->cipher(), NULL, __pyx_v_self->enc_key, __pyx_v_self->iv) != 0)) != 0);
     if (unlikely(__pyx_t_3)) {
 
-      /* "borg/crypto/low_level.pyx":681
+      /* "borg/crypto/low_level.pyx":672
  *             # Set cipher type and mode
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):
  *                 raise Exception('EVP_DecryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  */
-      __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 681, __pyx_L5_error)
+      __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 672, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_Raise(__pyx_t_4, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __PYX_ERR(0, 681, __pyx_L5_error)
+      __PYX_ERR(0, 672, __pyx_L5_error)
 
-      /* "borg/crypto/low_level.pyx":680
+      /* "borg/crypto/low_level.pyx":671
  *         try:
  *             # Set cipher type and mode
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_DecryptInit_ex failed')
  *             offset = 0
  */
     }
 
-    /* "borg/crypto/low_level.pyx":682
+    /* "borg/crypto/low_level.pyx":673
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):
  *                 raise Exception('EVP_DecryptInit_ex failed')
  *             offset = 0             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise Exception('EVP_DecryptUpdate failed')
  */
     __pyx_v_offset = 0;
 
-    /* "borg/crypto/low_level.pyx":683
+    /* "borg/crypto/low_level.pyx":674
  *                 raise Exception('EVP_DecryptInit_ex failed')
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_DecryptUpdate failed')
  *             offset += olen
  */
     __pyx_t_3 = ((!(EVP_DecryptUpdate(__pyx_v_self->ctx, __pyx_v_odata, (&__pyx_v_olen), ((unsigned char const *)__pyx_v_idata.buf), __pyx_v_ilen) != 0)) != 0);
     if (unlikely(__pyx_t_3)) {
 
-      /* "borg/crypto/low_level.pyx":684
+      /* "borg/crypto/low_level.pyx":675
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise Exception('EVP_DecryptUpdate failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  */
-      __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 684, __pyx_L5_error)
+      __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 675, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_Raise(__pyx_t_4, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __PYX_ERR(0, 684, __pyx_L5_error)
+      __PYX_ERR(0, 675, __pyx_L5_error)
 
-      /* "borg/crypto/low_level.pyx":683
+      /* "borg/crypto/low_level.pyx":674
  *                 raise Exception('EVP_DecryptInit_ex failed')
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):             # <<<<<<<<<<<<<<
  *                 raise Exception('EVP_DecryptUpdate failed')
  *             offset += olen
  */
     }
 
-    /* "borg/crypto/low_level.pyx":685
+    /* "borg/crypto/low_level.pyx":676
  *             if not EVP_DecryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise Exception('EVP_DecryptUpdate failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 # this error check is very important for modes with padding or
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":686
+    /* "borg/crypto/low_level.pyx":677
  *                 raise Exception('EVP_DecryptUpdate failed')
  *             offset += olen
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 # this error check is very important for modes with padding or
  *                 # authentication. for them, a failure here means corrupted data.
  */
     __pyx_t_3 = ((!(EVP_DecryptFinal_ex(__pyx_v_self->ctx, (__pyx_v_odata + __pyx_v_offset), (&__pyx_v_olen)) != 0)) != 0);
     if (unlikely(__pyx_t_3)) {
 
-      /* "borg/crypto/low_level.pyx":690
+      /* "borg/crypto/low_level.pyx":681
  *                 # authentication. for them, a failure here means corrupted data.
  *                 # CTR mode does not use padding nor authentication.
  *                 raise Exception('EVP_DecryptFinal failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             self.blocks = self.block_count(ilen)
  */
-      __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 690, __pyx_L5_error)
+      __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 681, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_Raise(__pyx_t_4, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __PYX_ERR(0, 690, __pyx_L5_error)
+      __PYX_ERR(0, 681, __pyx_L5_error)
 
-      /* "borg/crypto/low_level.pyx":686
+      /* "borg/crypto/low_level.pyx":677
  *                 raise Exception('EVP_DecryptUpdate failed')
  *             offset += olen
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):             # <<<<<<<<<<<<<<
  *                 # this error check is very important for modes with padding or
  *                 # authentication. for them, a failure here means corrupted data.
  */
     }
 
-    /* "borg/crypto/low_level.pyx":691
+    /* "borg/crypto/low_level.pyx":682
  *                 # CTR mode does not use padding nor authentication.
  *                 raise Exception('EVP_DecryptFinal failed')
  *             offset += olen             # <<<<<<<<<<<<<<
  *             self.blocks = self.block_count(ilen)
  *             return odata[:offset]
  */
     __pyx_v_offset = (__pyx_v_offset + __pyx_v_olen);
 
-    /* "borg/crypto/low_level.pyx":692
+    /* "borg/crypto/low_level.pyx":683
  *                 raise Exception('EVP_DecryptFinal failed')
  *             offset += olen
  *             self.blocks = self.block_count(ilen)             # <<<<<<<<<<<<<<
  *             return odata[:offset]
  *         finally:
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 692, __pyx_L5_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_block_count); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 683, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_ilen); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 692, __pyx_L5_error)
+    __pyx_t_6 = __Pyx_PyInt_From_int(__pyx_v_ilen); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 683, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_6);
     __pyx_t_7 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_7)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_7);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_4 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_7, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6);
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 692, __pyx_L5_error)
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 683, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_8 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_4); if (unlikely((__pyx_t_8 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 692, __pyx_L5_error)
+    __pyx_t_8 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_4); if (unlikely((__pyx_t_8 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 683, __pyx_L5_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_v_self->blocks = __pyx_t_8;
 
-    /* "borg/crypto/low_level.pyx":693
+    /* "borg/crypto/low_level.pyx":684
  *             offset += olen
  *             self.blocks = self.block_count(ilen)
  *             return odata[:offset]             # <<<<<<<<<<<<<<
  *         finally:
  *             PyMem_Free(odata)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_4 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 693, __pyx_L5_error)
+    __pyx_t_4 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_odata) + 0, __pyx_v_offset - 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 684, __pyx_L5_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L4_return;
   }
 
-  /* "borg/crypto/low_level.pyx":695
+  /* "borg/crypto/low_level.pyx":686
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  * 
  */
   /*finally:*/ {
@@ -13047,15 +13057,15 @@
       __Pyx_XGOTREF(__pyx_t_15);
       __Pyx_XGOTREF(__pyx_t_16);
       __Pyx_XGOTREF(__pyx_t_17);
       __pyx_t_9 = __pyx_lineno; __pyx_t_10 = __pyx_clineno; __pyx_t_11 = __pyx_filename;
       {
         PyMem_Free(__pyx_v_odata);
 
-        /* "borg/crypto/low_level.pyx":696
+        /* "borg/crypto/low_level.pyx":687
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  * 
  *     def block_count(self, length):
  */
         PyBuffer_Release((&__pyx_v_idata));
@@ -13074,38 +13084,38 @@
       __pyx_lineno = __pyx_t_9; __pyx_clineno = __pyx_t_10; __pyx_filename = __pyx_t_11;
       goto __pyx_L1_error;
     }
     __pyx_L4_return: {
       __pyx_t_17 = __pyx_r;
       __pyx_r = 0;
 
-      /* "borg/crypto/low_level.pyx":695
+      /* "borg/crypto/low_level.pyx":686
  *             return odata[:offset]
  *         finally:
  *             PyMem_Free(odata)             # <<<<<<<<<<<<<<
  *             PyBuffer_Release(&idata)
  * 
  */
       PyMem_Free(__pyx_v_odata);
 
-      /* "borg/crypto/low_level.pyx":696
+      /* "borg/crypto/low_level.pyx":687
  *         finally:
  *             PyMem_Free(odata)
  *             PyBuffer_Release(&idata)             # <<<<<<<<<<<<<<
  * 
  *     def block_count(self, length):
  */
       PyBuffer_Release((&__pyx_v_idata));
       __pyx_r = __pyx_t_17;
       __pyx_t_17 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "borg/crypto/low_level.pyx":670
+  /* "borg/crypto/low_level.pyx":661
  *             PyBuffer_Release(&idata)
  * 
  *     def decrypt(self, data):             # <<<<<<<<<<<<<<
  *         cdef Py_buffer idata = ro_buffer(data)
  *         cdef int ilen = len(data)
  */
 
@@ -13119,15 +13129,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":698
+/* "borg/crypto/low_level.pyx":689
  *             PyBuffer_Release(&idata)
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  */
 
@@ -13154,25 +13164,25 @@
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("block_count", 0);
 
-  /* "borg/crypto/low_level.pyx":699
+  /* "borg/crypto/low_level.pyx":690
  * 
  *     def block_count(self, length):
  *         return num_cipher_blocks(length, self.cipher_blk_len)             # <<<<<<<<<<<<<<
  * 
  *     def set_iv(self, iv):
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_num_cipher_blocks); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 699, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_num_cipher_blocks); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 690, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->cipher_blk_len); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 699, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->cipher_blk_len); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 690, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -13181,51 +13191,51 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_length, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 699, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 690, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_length, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 699, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 690, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 699, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 690, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_v_length);
     __Pyx_GIVEREF(__pyx_v_length);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_length);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 699, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 690, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":698
+  /* "borg/crypto/low_level.pyx":689
  *             PyBuffer_Release(&idata)
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  */
 
@@ -13240,15 +13250,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":701
+/* "borg/crypto/low_level.pyx":692
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         # set_iv needs to be called before each encrypt() call,
  *         # because encrypt does a full initialisation of the cipher context.
  */
 
@@ -13279,62 +13289,62 @@
   unsigned char __pyx_t_9[16];
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("set_iv", 0);
   __Pyx_INCREF(__pyx_v_iv);
 
-  /* "borg/crypto/low_level.pyx":704
+  /* "borg/crypto/low_level.pyx":695
  *         # set_iv needs to be called before each encrypt() call,
  *         # because encrypt does a full initialisation of the cipher context.
  *         if isinstance(iv, int):             # <<<<<<<<<<<<<<
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  */
   __pyx_t_1 = PyInt_Check(__pyx_v_iv); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/crypto/low_level.pyx":705
+    /* "borg/crypto/low_level.pyx":696
  *         # because encrypt does a full initialisation of the cipher context.
  *         if isinstance(iv, int):
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')             # <<<<<<<<<<<<<<
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  *         self.iv = iv
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_iv, __pyx_n_s_to_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 705, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_iv, __pyx_n_s_to_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_self->iv_len); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 705, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_self->iv_len); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 705, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 705, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 705, __pyx_L1_error)
-    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 705, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 696, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 696, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF_SET(__pyx_v_iv, __pyx_t_6);
     __pyx_t_6 = 0;
 
-    /* "borg/crypto/low_level.pyx":704
+    /* "borg/crypto/low_level.pyx":695
  *         # set_iv needs to be called before each encrypt() call,
  *         # because encrypt does a full initialisation of the cipher context.
  *         if isinstance(iv, int):             # <<<<<<<<<<<<<<
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  */
   }
 
-  /* "borg/crypto/low_level.pyx":706
+  /* "borg/crypto/low_level.pyx":697
  *         if isinstance(iv, int):
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len             # <<<<<<<<<<<<<<
  *         self.iv = iv
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -13342,45 +13352,45 @@
     __pyx_t_1 = PyBytes_Check(__pyx_v_iv); 
     __pyx_t_7 = (__pyx_t_1 != 0);
     if (__pyx_t_7) {
     } else {
       __pyx_t_2 = __pyx_t_7;
       goto __pyx_L4_bool_binop_done;
     }
-    __pyx_t_8 = PyObject_Length(__pyx_v_iv); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 706, __pyx_L1_error)
+    __pyx_t_8 = PyObject_Length(__pyx_v_iv); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 697, __pyx_L1_error)
     __pyx_t_7 = ((__pyx_t_8 == __pyx_v_self->iv_len) != 0);
     __pyx_t_2 = __pyx_t_7;
     __pyx_L4_bool_binop_done:;
     if (unlikely(!__pyx_t_2)) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 706, __pyx_L1_error)
+      __PYX_ERR(0, 697, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":707
+  /* "borg/crypto/low_level.pyx":698
  *             iv = iv.to_bytes(self.iv_len, byteorder='big')
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  *         self.iv = iv             # <<<<<<<<<<<<<<
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV
  * 
  */
-  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_iv, __pyx_t_9, 16) < 0)) __PYX_ERR(0, 707, __pyx_L1_error)
+  if (unlikely(__Pyx_carray_from_py_unsigned_char(__pyx_v_iv, __pyx_t_9, 16) < 0)) __PYX_ERR(0, 698, __pyx_L1_error)
   memcpy(&(__pyx_v_self->iv[0]), __pyx_t_9, sizeof(__pyx_v_self->iv[0]) * (16));
 
-  /* "borg/crypto/low_level.pyx":708
+  /* "borg/crypto/low_level.pyx":699
  *         assert isinstance(iv, bytes) and len(iv) == self.iv_len
  *         self.iv = iv
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV             # <<<<<<<<<<<<<<
  * 
  *     def next_iv(self):
  */
   __pyx_v_self->blocks = 0;
 
-  /* "borg/crypto/low_level.pyx":701
+  /* "borg/crypto/low_level.pyx":692
  *         return num_cipher_blocks(length, self.cipher_blk_len)
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         # set_iv needs to be called before each encrypt() call,
  *         # because encrypt does a full initialisation of the cipher context.
  */
 
@@ -13397,15 +13407,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_iv);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":710
+/* "borg/crypto/low_level.pyx":701
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')
  */
 
@@ -13431,59 +13441,59 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("next_iv", 0);
 
-  /* "borg/crypto/low_level.pyx":712
+  /* "borg/crypto/low_level.pyx":703
  *     def next_iv(self):
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')             # <<<<<<<<<<<<<<
  *         return iv + self.blocks
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)(&PyInt_Type)), __pyx_n_s_from_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 712, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)(&PyInt_Type)), __pyx_n_s_from_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 703, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->iv) + 0, __pyx_v_self->iv_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 712, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_self->iv) + 0, __pyx_v_self->iv_len - 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 703, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 712, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 703, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 712, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 703, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 712, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 712, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_byteorder, __pyx_n_s_big) < 0) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 703, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_iv = __pyx_t_4;
   __pyx_t_4 = 0;
 
-  /* "borg/crypto/low_level.pyx":713
+  /* "borg/crypto/low_level.pyx":704
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')
  *         return iv + self.blocks             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_4 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_self->blocks); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 713, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_self->blocks); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 704, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 = PyNumber_Add(__pyx_v_iv, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 713, __pyx_L1_error)
+  __pyx_t_2 = PyNumber_Add(__pyx_v_iv, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 704, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":710
+  /* "borg/crypto/low_level.pyx":701
  *         self.blocks = 0  # number of cipher blocks encrypted with this IV
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         # call this after encrypt() to get the next iv (int) for the next encrypt() call
  *         iv = int.from_bytes(self.iv[:self.iv_len], byteorder='big')
  */
 
@@ -13611,15 +13621,15 @@
   __Pyx_AddTraceback("borg.crypto.low_level.AES.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":716
+/* "borg/crypto/low_level.pyx":707
  * 
  * 
  * def hmac_sha256(key, data):             # <<<<<<<<<<<<<<
  *     return hmac.digest(key, data, 'sha256')
  * 
  */
 
@@ -13654,32 +13664,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_key)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("hmac_sha256", 1, 2, 2, 1); __PYX_ERR(0, 716, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("hmac_sha256", 1, 2, 2, 1); __PYX_ERR(0, 707, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "hmac_sha256") < 0)) __PYX_ERR(0, 716, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "hmac_sha256") < 0)) __PYX_ERR(0, 707, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_key = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("hmac_sha256", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 716, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("hmac_sha256", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 707, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.hmac_sha256", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_2hmac_sha256(__pyx_self, __pyx_v_key, __pyx_v_data);
 
@@ -13697,25 +13707,25 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("hmac_sha256", 0);
 
-  /* "borg/crypto/low_level.pyx":717
+  /* "borg/crypto/low_level.pyx":708
  * 
  * def hmac_sha256(key, data):
  *     return hmac.digest(key, data, 'sha256')             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hmac); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 717, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hmac); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 708, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_digest); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 717, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_digest); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 708, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
@@ -13725,52 +13735,52 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_key, __pyx_v_data, __pyx_n_s_sha256};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 717, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 708, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_key, __pyx_v_data, __pyx_n_s_sha256};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 717, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 708, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(3+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 717, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(3+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 708, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_2) {
       __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_key);
     __Pyx_GIVEREF(__pyx_v_key);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_key);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_data);
     __Pyx_INCREF(__pyx_n_s_sha256);
     __Pyx_GIVEREF(__pyx_n_s_sha256);
     PyTuple_SET_ITEM(__pyx_t_5, 2+__pyx_t_4, __pyx_n_s_sha256);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 717, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 708, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":716
+  /* "borg/crypto/low_level.pyx":707
  * 
  * 
  * def hmac_sha256(key, data):             # <<<<<<<<<<<<<<
  *     return hmac.digest(key, data, 'sha256')
  * 
  */
 
@@ -13784,15 +13794,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":720
+/* "borg/crypto/low_level.pyx":711
  * 
  * 
  * def blake2b_256(key, data):             # <<<<<<<<<<<<<<
  *     return hashlib.blake2b(key+data, digest_size=32).digest()
  * 
  */
 
@@ -13827,32 +13837,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_key)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("blake2b_256", 1, 2, 2, 1); __PYX_ERR(0, 720, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("blake2b_256", 1, 2, 2, 1); __PYX_ERR(0, 711, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "blake2b_256") < 0)) __PYX_ERR(0, 720, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "blake2b_256") < 0)) __PYX_ERR(0, 711, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_key = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("blake2b_256", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 720, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("blake2b_256", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 711, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.blake2b_256", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_4blake2b_256(__pyx_self, __pyx_v_key, __pyx_v_data);
 
@@ -13870,65 +13880,65 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("blake2b_256", 0);
 
-  /* "borg/crypto/low_level.pyx":721
+  /* "borg/crypto/low_level.pyx":712
  * 
  * def blake2b_256(key, data):
  *     return hashlib.blake2b(key+data, digest_size=32).digest()             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hashlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 721, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hashlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 712, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_blake2b); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 721, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_blake2b); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 712, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyNumber_Add(__pyx_v_key, __pyx_v_data); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 721, __pyx_L1_error)
+  __pyx_t_2 = PyNumber_Add(__pyx_v_key, __pyx_v_data); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 712, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 721, __pyx_L1_error)
+  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 712, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 721, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 712, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_digest_size, __pyx_int_32) < 0) __PYX_ERR(0, 721, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 721, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_digest_size, __pyx_int_32) < 0) __PYX_ERR(0, 712, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 712, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_digest); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 721, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_digest); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 712, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_t_5 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 721, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 712, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":720
+  /* "borg/crypto/low_level.pyx":711
  * 
  * 
  * def blake2b_256(key, data):             # <<<<<<<<<<<<<<
  *     return hashlib.blake2b(key+data, digest_size=32).digest()
  * 
  */
 
@@ -13943,15 +13953,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":724
+/* "borg/crypto/low_level.pyx":715
  * 
  * 
  * def blake2b_128(data):             # <<<<<<<<<<<<<<
  *     return hashlib.blake2b(data, digest_size=16).digest()
  * 
  */
 
@@ -13978,63 +13988,63 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("blake2b_128", 0);
 
-  /* "borg/crypto/low_level.pyx":725
+  /* "borg/crypto/low_level.pyx":716
  * 
  * def blake2b_128(data):
  *     return hashlib.blake2b(data, digest_size=16).digest()             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hashlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 725, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_hashlib); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 716, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_blake2b); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 725, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_blake2b); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 716, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 725, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 716, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_v_data);
   __Pyx_GIVEREF(__pyx_v_data);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_data);
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 725, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 716, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_digest_size, __pyx_int_16) < 0) __PYX_ERR(0, 725, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 725, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_digest_size, __pyx_int_16) < 0) __PYX_ERR(0, 716, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 716, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_digest); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 725, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_digest); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 716, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_t_5 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 725, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 716, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":724
+  /* "borg/crypto/low_level.pyx":715
  * 
  * 
  * def blake2b_128(data):             # <<<<<<<<<<<<<<
  *     return hashlib.blake2b(data, digest_size=16).digest()
  * 
  */
 
@@ -14049,15 +14059,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/crypto/low_level.pyx":728
+/* "borg/crypto/low_level.pyx":719
  * 
  * 
  * def hkdf_hmac_sha512(ikm, salt, info, output_length):             # <<<<<<<<<<<<<<
  *     """
  *     Compute HKDF-HMAC-SHA512 with input key material *ikm*, *salt* and *info* to produce *output_length* bytes.
  */
 
@@ -14099,31 +14109,31 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ikm)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_salt)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("hkdf_hmac_sha512", 1, 4, 4, 1); __PYX_ERR(0, 728, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("hkdf_hmac_sha512", 1, 4, 4, 1); __PYX_ERR(0, 719, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_info)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("hkdf_hmac_sha512", 1, 4, 4, 2); __PYX_ERR(0, 728, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("hkdf_hmac_sha512", 1, 4, 4, 2); __PYX_ERR(0, 719, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_output_length)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("hkdf_hmac_sha512", 1, 4, 4, 3); __PYX_ERR(0, 728, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("hkdf_hmac_sha512", 1, 4, 4, 3); __PYX_ERR(0, 719, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "hkdf_hmac_sha512") < 0)) __PYX_ERR(0, 728, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "hkdf_hmac_sha512") < 0)) __PYX_ERR(0, 719, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
@@ -14132,15 +14142,15 @@
     __pyx_v_ikm = values[0];
     __pyx_v_salt = values[1];
     __pyx_v_info = values[2];
     __pyx_v_output_length = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("hkdf_hmac_sha512", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 728, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("hkdf_hmac_sha512", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 719, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.crypto.low_level.hkdf_hmac_sha512", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_6crypto_9low_level_8hkdf_hmac_sha512(__pyx_self, __pyx_v_ikm, __pyx_v_salt, __pyx_v_info, __pyx_v_output_length);
 
@@ -14171,88 +14181,88 @@
   PyObject *__pyx_t_10 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("hkdf_hmac_sha512", 0);
   __Pyx_INCREF(__pyx_v_salt);
 
-  /* "borg/crypto/low_level.pyx":737
+  /* "borg/crypto/low_level.pyx":728
  *     *output_length* must not be greater than 64 * 255 bytes.
  *     """
  *     digest_length = 64             # <<<<<<<<<<<<<<
  *     assert output_length <= (255 * digest_length), 'output_length must be <= 255 * 64 bytes'
  *     # Step 1. HKDF-Extract (ikm, salt) -> prk
  */
   __Pyx_INCREF(__pyx_int_64);
   __pyx_v_digest_length = __pyx_int_64;
 
-  /* "borg/crypto/low_level.pyx":738
+  /* "borg/crypto/low_level.pyx":729
  *     """
  *     digest_length = 64
  *     assert output_length <= (255 * digest_length), 'output_length must be <= 255 * 64 bytes'             # <<<<<<<<<<<<<<
  *     # Step 1. HKDF-Extract (ikm, salt) -> prk
  *     if salt is None:
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
-    __pyx_t_1 = PyNumber_Multiply(__pyx_int_255, __pyx_v_digest_length); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 738, __pyx_L1_error)
+    __pyx_t_1 = PyNumber_Multiply(__pyx_int_255, __pyx_v_digest_length); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 729, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = PyObject_RichCompare(__pyx_v_output_length, __pyx_t_1, Py_LE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 738, __pyx_L1_error)
+    __pyx_t_2 = PyObject_RichCompare(__pyx_v_output_length, __pyx_t_1, Py_LE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 729, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 738, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 729, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     if (unlikely(!__pyx_t_3)) {
       PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_output_length_must_be_255_64_byt);
-      __PYX_ERR(0, 738, __pyx_L1_error)
+      __PYX_ERR(0, 729, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/crypto/low_level.pyx":740
+  /* "borg/crypto/low_level.pyx":731
  *     assert output_length <= (255 * digest_length), 'output_length must be <= 255 * 64 bytes'
  *     # Step 1. HKDF-Extract (ikm, salt) -> prk
  *     if salt is None:             # <<<<<<<<<<<<<<
  *         salt = bytes(64)
  *     prk = hmac.digest(salt, ikm, 'sha512')
  */
   __pyx_t_3 = (__pyx_v_salt == Py_None);
   __pyx_t_4 = (__pyx_t_3 != 0);
   if (__pyx_t_4) {
 
-    /* "borg/crypto/low_level.pyx":741
+    /* "borg/crypto/low_level.pyx":732
  *     # Step 1. HKDF-Extract (ikm, salt) -> prk
  *     if salt is None:
  *         salt = bytes(64)             # <<<<<<<<<<<<<<
  *     prk = hmac.digest(salt, ikm, 'sha512')
  * 
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&PyBytes_Type)), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 741, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&PyBytes_Type)), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 732, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF_SET(__pyx_v_salt, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "borg/crypto/low_level.pyx":740
+    /* "borg/crypto/low_level.pyx":731
  *     assert output_length <= (255 * digest_length), 'output_length must be <= 255 * 64 bytes'
  *     # Step 1. HKDF-Extract (ikm, salt) -> prk
  *     if salt is None:             # <<<<<<<<<<<<<<
  *         salt = bytes(64)
  *     prk = hmac.digest(salt, ikm, 'sha512')
  */
   }
 
-  /* "borg/crypto/low_level.pyx":742
+  /* "borg/crypto/low_level.pyx":733
  *     if salt is None:
  *         salt = bytes(64)
  *     prk = hmac.digest(salt, ikm, 'sha512')             # <<<<<<<<<<<<<<
  * 
  *     # Step 2. HKDF-Expand (prk, info, output_length) -> output key
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_hmac); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_hmac); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 733, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_digest); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_digest); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 733, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_1)) {
@@ -14262,186 +14272,186 @@
       __Pyx_DECREF_SET(__pyx_t_5, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[4] = {__pyx_t_1, __pyx_v_salt, __pyx_v_ikm, __pyx_n_s_sha512};
-    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 742, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 733, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[4] = {__pyx_t_1, __pyx_v_salt, __pyx_v_ikm, __pyx_n_s_sha512};
-    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 742, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 733, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 742, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 733, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_1) {
       __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1); __pyx_t_1 = NULL;
     }
     __Pyx_INCREF(__pyx_v_salt);
     __Pyx_GIVEREF(__pyx_v_salt);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_salt);
     __Pyx_INCREF(__pyx_v_ikm);
     __Pyx_GIVEREF(__pyx_v_ikm);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_ikm);
     __Pyx_INCREF(__pyx_n_s_sha512);
     __Pyx_GIVEREF(__pyx_n_s_sha512);
     PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_n_s_sha512);
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 742, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 733, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_v_prk = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":745
+  /* "borg/crypto/low_level.pyx":736
  * 
  *     # Step 2. HKDF-Expand (prk, info, output_length) -> output key
  *     n = ceil(output_length / digest_length)             # <<<<<<<<<<<<<<
  *     t_n = b''
  *     output = b''
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_ceil); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 745, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_ceil); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 736, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_7 = __Pyx_PyNumber_Divide(__pyx_v_output_length, __pyx_v_digest_length); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 745, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyNumber_Divide(__pyx_v_output_length, __pyx_v_digest_length); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 736, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __pyx_t_1 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_1)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_1);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
     }
   }
   __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_7);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 745, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 736, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_v_n = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":746
+  /* "borg/crypto/low_level.pyx":737
  *     # Step 2. HKDF-Expand (prk, info, output_length) -> output key
  *     n = ceil(output_length / digest_length)
  *     t_n = b''             # <<<<<<<<<<<<<<
  *     output = b''
  *     for i in range(n):
  */
   __Pyx_INCREF(__pyx_kp_b_);
   __pyx_v_t_n = __pyx_kp_b_;
 
-  /* "borg/crypto/low_level.pyx":747
+  /* "borg/crypto/low_level.pyx":738
  *     n = ceil(output_length / digest_length)
  *     t_n = b''
  *     output = b''             # <<<<<<<<<<<<<<
  *     for i in range(n):
  *         msg = t_n + info + (i + 1).to_bytes(1, 'little')
  */
   __Pyx_INCREF(__pyx_kp_b_);
   __pyx_v_output = __pyx_kp_b_;
 
-  /* "borg/crypto/low_level.pyx":748
+  /* "borg/crypto/low_level.pyx":739
  *     t_n = b''
  *     output = b''
  *     for i in range(n):             # <<<<<<<<<<<<<<
  *         msg = t_n + info + (i + 1).to_bytes(1, 'little')
  *         t_n = hmac.digest(prk, msg, 'sha512')
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_v_n); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 748, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_v_n); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 739, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
     __pyx_t_5 = __pyx_t_2; __Pyx_INCREF(__pyx_t_5); __pyx_t_8 = 0;
     __pyx_t_9 = NULL;
   } else {
-    __pyx_t_8 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 748, __pyx_L1_error)
+    __pyx_t_8 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 739, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_9 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 748, __pyx_L1_error)
+    __pyx_t_9 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 739, __pyx_L1_error)
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   for (;;) {
     if (likely(!__pyx_t_9)) {
       if (likely(PyList_CheckExact(__pyx_t_5))) {
         if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_5)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_8); __Pyx_INCREF(__pyx_t_2); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 748, __pyx_L1_error)
+        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_8); __Pyx_INCREF(__pyx_t_2); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 739, __pyx_L1_error)
         #else
-        __pyx_t_2 = PySequence_ITEM(__pyx_t_5, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 748, __pyx_L1_error)
+        __pyx_t_2 = PySequence_ITEM(__pyx_t_5, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 739, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         #endif
       } else {
         if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_5)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_8); __Pyx_INCREF(__pyx_t_2); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 748, __pyx_L1_error)
+        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_8); __Pyx_INCREF(__pyx_t_2); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 739, __pyx_L1_error)
         #else
-        __pyx_t_2 = PySequence_ITEM(__pyx_t_5, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 748, __pyx_L1_error)
+        __pyx_t_2 = PySequence_ITEM(__pyx_t_5, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 739, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         #endif
       }
     } else {
       __pyx_t_2 = __pyx_t_9(__pyx_t_5);
       if (unlikely(!__pyx_t_2)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 748, __pyx_L1_error)
+          else __PYX_ERR(0, 739, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_2);
     }
     __Pyx_XDECREF_SET(__pyx_v_i, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "borg/crypto/low_level.pyx":749
+    /* "borg/crypto/low_level.pyx":740
  *     output = b''
  *     for i in range(n):
  *         msg = t_n + info + (i + 1).to_bytes(1, 'little')             # <<<<<<<<<<<<<<
  *         t_n = hmac.digest(prk, msg, 'sha512')
  *         output += t_n
  */
-    __pyx_t_2 = PyNumber_Add(__pyx_v_t_n, __pyx_v_info); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 749, __pyx_L1_error)
+    __pyx_t_2 = PyNumber_Add(__pyx_v_t_n, __pyx_v_info); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 740, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_v_i, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 749, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_v_i, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 740, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_to_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 749, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_to_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 740, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 749, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 740, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = PyNumber_Add(__pyx_t_2, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 749, __pyx_L1_error)
+    __pyx_t_1 = PyNumber_Add(__pyx_t_2, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 740, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_XDECREF_SET(__pyx_v_msg, __pyx_t_1);
     __pyx_t_1 = 0;
 
-    /* "borg/crypto/low_level.pyx":750
+    /* "borg/crypto/low_level.pyx":741
  *     for i in range(n):
  *         msg = t_n + info + (i + 1).to_bytes(1, 'little')
  *         t_n = hmac.digest(prk, msg, 'sha512')             # <<<<<<<<<<<<<<
  *         output += t_n
  *     return output[:output_length]
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_hmac); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 750, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_hmac); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 741, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_digest); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 750, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_digest); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 741, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __pyx_t_7 = NULL;
     __pyx_t_6 = 0;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
       __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
       if (likely(__pyx_t_7)) {
@@ -14451,84 +14461,84 @@
         __Pyx_DECREF_SET(__pyx_t_2, function);
         __pyx_t_6 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_2)) {
       PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_v_prk, __pyx_v_msg, __pyx_n_s_sha512};
-      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 750, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_GOTREF(__pyx_t_1);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
       PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_v_prk, __pyx_v_msg, __pyx_n_s_sha512};
-      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 750, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_GOTREF(__pyx_t_1);
     } else
     #endif
     {
-      __pyx_t_10 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 750, __pyx_L1_error)
+      __pyx_t_10 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 741, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
       if (__pyx_t_7) {
         __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_7); __pyx_t_7 = NULL;
       }
       __Pyx_INCREF(__pyx_v_prk);
       __Pyx_GIVEREF(__pyx_v_prk);
       PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_6, __pyx_v_prk);
       __Pyx_INCREF(__pyx_v_msg);
       __Pyx_GIVEREF(__pyx_v_msg);
       PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_6, __pyx_v_msg);
       __Pyx_INCREF(__pyx_n_s_sha512);
       __Pyx_GIVEREF(__pyx_n_s_sha512);
       PyTuple_SET_ITEM(__pyx_t_10, 2+__pyx_t_6, __pyx_n_s_sha512);
-      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 750, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
     }
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF_SET(__pyx_v_t_n, __pyx_t_1);
     __pyx_t_1 = 0;
 
-    /* "borg/crypto/low_level.pyx":751
+    /* "borg/crypto/low_level.pyx":742
  *         msg = t_n + info + (i + 1).to_bytes(1, 'little')
  *         t_n = hmac.digest(prk, msg, 'sha512')
  *         output += t_n             # <<<<<<<<<<<<<<
  *     return output[:output_length]
  */
-    __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_v_output, __pyx_v_t_n); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 751, __pyx_L1_error)
+    __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_v_output, __pyx_v_t_n); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 742, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF_SET(__pyx_v_output, __pyx_t_1);
     __pyx_t_1 = 0;
 
-    /* "borg/crypto/low_level.pyx":748
+    /* "borg/crypto/low_level.pyx":739
  *     t_n = b''
  *     output = b''
  *     for i in range(n):             # <<<<<<<<<<<<<<
  *         msg = t_n + info + (i + 1).to_bytes(1, 'little')
  *         t_n = hmac.digest(prk, msg, 'sha512')
  */
   }
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-  /* "borg/crypto/low_level.pyx":752
+  /* "borg/crypto/low_level.pyx":743
  *         t_n = hmac.digest(prk, msg, 'sha512')
  *         output += t_n
  *     return output[:output_length]             # <<<<<<<<<<<<<<
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_5 = __Pyx_PyObject_GetSlice(__pyx_v_output, 0, 0, NULL, &__pyx_v_output_length, NULL, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 752, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetSlice(__pyx_v_output, 0, 0, NULL, &__pyx_v_output_length, NULL, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 743, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "borg/crypto/low_level.pyx":728
+  /* "borg/crypto/low_level.pyx":719
  * 
  * 
  * def hkdf_hmac_sha512(ikm, salt, info, output_length):             # <<<<<<<<<<<<<<
  *     """
  *     Compute HKDF-HMAC-SHA512 with input key material *ikm*, *salt* and *info* to produce *output_length* bytes.
  */
 
@@ -14996,15 +15006,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256;
 
 static PyObject *__pyx_tp_new_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 *p;
@@ -15105,15 +15115,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b;
 
 static PyObject *__pyx_tp_new_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b *p;
@@ -15214,15 +15224,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_6crypto_9low_level__AEAD_BASE(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
@@ -15330,15 +15340,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_6crypto_9low_level_AES256_OCB(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_6crypto_9low_level__AEAD_BASE(t, a, k);
   if (unlikely(!o)) return 0;
@@ -15415,15 +15425,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_6crypto_9low_level_CHACHA20_POLY1305(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_6crypto_9low_level__AEAD_BASE(t, a, k);
   if (unlikely(!o)) return 0;
@@ -15500,15 +15510,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_6crypto_9low_level_AES(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o;
   if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
@@ -15615,15 +15625,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
@@ -15804,21 +15814,21 @@
   {&__pyx_n_s_to_bytes, __pyx_k_to_bytes, sizeof(__pyx_k_to_bytes), 0, 0, 1, 1},
   {&__pyx_kp_s_too_much_data_would_overflow_int, __pyx_k_too_much_data_would_overflow_int, sizeof(__pyx_k_too_much_data_would_overflow_int), 0, 0, 1, 0},
   {&__pyx_n_s_unpack_from, __pyx_k_unpack_from, sizeof(__pyx_k_unpack_from), 0, 0, 1, 1},
   {&__pyx_n_s_x, __pyx_k_x, sizeof(__pyx_k_x), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 219, __pyx_L1_error)
-  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 245, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 252, __pyx_L1_error)
+  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 210, __pyx_L1_error)
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 236, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 243, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
-  __pyx_builtin_super = __Pyx_GetBuiltinName(__pyx_n_s_super); if (!__pyx_builtin_super) __PYX_ERR(0, 352, __pyx_L1_error)
-  __pyx_builtin_NotImplemented = __Pyx_GetBuiltinName(__pyx_n_s_NotImplemented); if (!__pyx_builtin_NotImplemented) __PYX_ERR(0, 427, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 471, __pyx_L1_error)
+  __pyx_builtin_super = __Pyx_GetBuiltinName(__pyx_n_s_super); if (!__pyx_builtin_super) __PYX_ERR(0, 343, __pyx_L1_error)
+  __pyx_builtin_NotImplemented = __Pyx_GetBuiltinName(__pyx_n_s_NotImplemented); if (!__pyx_builtin_NotImplemented) __PYX_ERR(0, 418, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 462, __pyx_L1_error)
   __pyx_builtin_OverflowError = __Pyx_GetBuiltinName(__pyx_n_s_OverflowError); if (!__pyx_builtin_OverflowError) __PYX_ERR(1, 81, __pyx_L1_error)
   __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 84, __pyx_L1_error)
   __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 94, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
@@ -15880,22 +15890,22 @@
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
   __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "borg/crypto/low_level.pyx":471
+  /* "borg/crypto/low_level.pyx":462
  *         block_count = self.block_count(len(data))
  *         if block_count > 2**32:
  *             raise ValueError('too much data, would overflow internal 32bit counter')             # <<<<<<<<<<<<<<
  *         cdef int ilen = len(data)
  *         cdef int hlen = len(header)
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_too_much_data_would_overflow_int); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 471, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_too_much_data_would_overflow_int); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 462, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__9);
   __Pyx_GIVEREF(__pyx_tuple__9);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
@@ -15948,77 +15958,77 @@
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
   __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__15);
   __Pyx_GIVEREF(__pyx_tuple__15);
 
-  /* "borg/crypto/low_level.pyx":656
+  /* "borg/crypto/low_level.pyx":647
  *         try:
  *             if not EVP_EncryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):
  *                 raise Exception('EVP_EncryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             offset = 0
  *             if not EVP_EncryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  */
-  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_EVP_EncryptInit_ex_failed); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 656, __pyx_L1_error)
+  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_EVP_EncryptInit_ex_failed); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 647, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__16);
   __Pyx_GIVEREF(__pyx_tuple__16);
 
-  /* "borg/crypto/low_level.pyx":659
+  /* "borg/crypto/low_level.pyx":650
  *             offset = 0
  *             if not EVP_EncryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise Exception('EVP_EncryptUpdate failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_EVP_EncryptUpdate_failed); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 659, __pyx_L1_error)
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_EVP_EncryptUpdate_failed); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 650, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__17);
   __Pyx_GIVEREF(__pyx_tuple__17);
 
-  /* "borg/crypto/low_level.pyx":662
+  /* "borg/crypto/low_level.pyx":653
  *             offset += olen
  *             if not EVP_EncryptFinal_ex(self.ctx, odata+offset, &olen):
  *                 raise Exception('EVP_EncryptFinal failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             self.blocks = self.block_count(offset)
  */
-  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_EVP_EncryptFinal_failed); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 662, __pyx_L1_error)
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_EVP_EncryptFinal_failed); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 653, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__18);
   __Pyx_GIVEREF(__pyx_tuple__18);
 
-  /* "borg/crypto/low_level.pyx":681
+  /* "borg/crypto/low_level.pyx":672
  *             # Set cipher type and mode
  *             if not EVP_DecryptInit_ex(self.ctx, self.cipher(), NULL, self.enc_key, self.iv):
  *                 raise Exception('EVP_DecryptInit_ex failed')             # <<<<<<<<<<<<<<
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  */
-  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_EVP_DecryptInit_ex_failed); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 681, __pyx_L1_error)
+  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_EVP_DecryptInit_ex_failed); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 672, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__19);
   __Pyx_GIVEREF(__pyx_tuple__19);
 
-  /* "borg/crypto/low_level.pyx":684
+  /* "borg/crypto/low_level.pyx":675
  *             offset = 0
  *             if not EVP_DecryptUpdate(self.ctx, odata, &olen, <const unsigned char*> idata.buf, ilen):
  *                 raise Exception('EVP_DecryptUpdate failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             if not EVP_DecryptFinal_ex(self.ctx, odata+offset, &olen):
  */
-  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_EVP_DecryptUpdate_failed); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 684, __pyx_L1_error)
+  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_EVP_DecryptUpdate_failed); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 675, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__20);
   __Pyx_GIVEREF(__pyx_tuple__20);
 
-  /* "borg/crypto/low_level.pyx":690
+  /* "borg/crypto/low_level.pyx":681
  *                 # authentication. for them, a failure here means corrupted data.
  *                 # CTR mode does not use padding nor authentication.
  *                 raise Exception('EVP_DecryptFinal failed')             # <<<<<<<<<<<<<<
  *             offset += olen
  *             self.blocks = self.block_count(ilen)
  */
-  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_EVP_DecryptFinal_failed); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 690, __pyx_L1_error)
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_EVP_DecryptFinal_failed); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 681, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__21);
   __Pyx_GIVEREF(__pyx_tuple__21);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
@@ -16033,232 +16043,232 @@
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
   __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__23);
   __Pyx_GIVEREF(__pyx_tuple__23);
 
-  /* "borg/crypto/low_level.pyx":741
+  /* "borg/crypto/low_level.pyx":732
  *     # Step 1. HKDF-Extract (ikm, salt) -> prk
  *     if salt is None:
  *         salt = bytes(64)             # <<<<<<<<<<<<<<
  *     prk = hmac.digest(salt, ikm, 'sha512')
  * 
  */
-  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_int_64); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(0, 741, __pyx_L1_error)
+  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_int_64); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(0, 732, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__24);
   __Pyx_GIVEREF(__pyx_tuple__24);
 
-  /* "borg/crypto/low_level.pyx":749
+  /* "borg/crypto/low_level.pyx":740
  *     output = b''
  *     for i in range(n):
  *         msg = t_n + info + (i + 1).to_bytes(1, 'little')             # <<<<<<<<<<<<<<
  *         t_n = hmac.digest(prk, msg, 'sha512')
  *         output += t_n
  */
-  __pyx_tuple__25 = PyTuple_Pack(2, __pyx_int_1, __pyx_n_s_little); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 749, __pyx_L1_error)
+  __pyx_tuple__25 = PyTuple_Pack(2, __pyx_int_1, __pyx_n_s_little); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 740, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__25);
   __Pyx_GIVEREF(__pyx_tuple__25);
 
-  /* "borg/crypto/low_level.pyx":99
+  /* "borg/crypto/low_level.pyx":90
  * import struct
  * 
  * _int = struct.Struct('>I')             # <<<<<<<<<<<<<<
  * _long = struct.Struct('>Q')
  * 
  */
-  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_I); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_I); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(0, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__26);
   __Pyx_GIVEREF(__pyx_tuple__26);
 
-  /* "borg/crypto/low_level.pyx":100
+  /* "borg/crypto/low_level.pyx":91
  * 
  * _int = struct.Struct('>I')
  * _long = struct.Struct('>Q')             # <<<<<<<<<<<<<<
  * 
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]
  */
-  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_Q); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_Q); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__27);
   __Pyx_GIVEREF(__pyx_tuple__27);
 
-  /* "borg/crypto/low_level.pyx":102
+  /* "borg/crypto/low_level.pyx":93
  * _long = struct.Struct('>Q')
  * 
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]             # <<<<<<<<<<<<<<
  * bytes_to_long = lambda x, offset=0: _long.unpack_from(x, offset)[0]
  * long_to_bytes = lambda x: _long.pack(x)
  */
-  __pyx_tuple__28 = PyTuple_Pack(1, ((PyObject *)__pyx_int_0)); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __pyx_tuple__28 = PyTuple_Pack(1, ((PyObject *)__pyx_int_0)); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__28);
   __Pyx_GIVEREF(__pyx_tuple__28);
 
-  /* "borg/crypto/low_level.pyx":103
+  /* "borg/crypto/low_level.pyx":94
  * 
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]
  * bytes_to_long = lambda x, offset=0: _long.unpack_from(x, offset)[0]             # <<<<<<<<<<<<<<
  * long_to_bytes = lambda x: _long.pack(x)
  * 
  */
-  __pyx_tuple__29 = PyTuple_Pack(1, ((PyObject *)__pyx_int_0)); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 103, __pyx_L1_error)
+  __pyx_tuple__29 = PyTuple_Pack(1, ((PyObject *)__pyx_int_0)); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__29);
   __Pyx_GIVEREF(__pyx_tuple__29);
 
-  /* "borg/crypto/low_level.pyx":107
+  /* "borg/crypto/low_level.pyx":98
  * 
  * 
  * def num_cipher_blocks(length, blocksize=16):             # <<<<<<<<<<<<<<
  *     """Return the number of cipher blocks required to encrypt/decrypt <length> bytes of data.
  * 
  */
-  __pyx_tuple__30 = PyTuple_Pack(2, __pyx_n_s_length, __pyx_n_s_blocksize); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 107, __pyx_L1_error)
+  __pyx_tuple__30 = PyTuple_Pack(2, __pyx_n_s_length, __pyx_n_s_blocksize); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 98, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__30);
   __Pyx_GIVEREF(__pyx_tuple__30);
-  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__30, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_num_cipher_blocks, 107, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(0, 107, __pyx_L1_error)
+  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__30, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_num_cipher_blocks, 98, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(0, 98, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":140
+  /* "borg/crypto/low_level.pyx":131
  *     # Layout: HEADER + PlainText
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         assert mac_key is None
  *         assert enc_key is None
  */
-  __pyx_tuple__32 = PyTuple_Pack(6, __pyx_n_s_self, __pyx_n_s_mac_key, __pyx_n_s_enc_key, __pyx_n_s_iv, __pyx_n_s_header_len, __pyx_n_s_aad_offset); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 140, __pyx_L1_error)
+  __pyx_tuple__32 = PyTuple_Pack(6, __pyx_n_s_self, __pyx_n_s_mac_key, __pyx_n_s_enc_key, __pyx_n_s_iv, __pyx_n_s_header_len, __pyx_n_s_aad_offset); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 131, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__32);
   __Pyx_GIVEREF(__pyx_tuple__32);
-  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_init, 140, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(0, 140, __pyx_L1_error)
-  __pyx_tuple__34 = PyTuple_Pack(3, ((PyObject *)Py_None), ((PyObject *)__pyx_int_1), ((PyObject *)__pyx_int_1)); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 140, __pyx_L1_error)
+  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_init, 131, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(0, 131, __pyx_L1_error)
+  __pyx_tuple__34 = PyTuple_Pack(3, ((PyObject *)Py_None), ((PyObject *)__pyx_int_1), ((PyObject *)__pyx_int_1)); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 131, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__34);
   __Pyx_GIVEREF(__pyx_tuple__34);
 
-  /* "borg/crypto/low_level.pyx":146
+  /* "borg/crypto/low_level.pyx":137
  *         self.set_iv(iv)
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         IMPORTANT: it is called encrypt to satisfy the crypto api naming convention,
  */
-  __pyx_tuple__35 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_data, __pyx_n_s_header, __pyx_n_s_iv, __pyx_n_s_aad); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_tuple__35 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_data, __pyx_n_s_header, __pyx_n_s_iv, __pyx_n_s_aad); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 137, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__35);
   __Pyx_GIVEREF(__pyx_tuple__35);
-  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_encrypt, 146, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 146, __pyx_L1_error)
-  __pyx_tuple__37 = PyTuple_Pack(3, ((PyObject*)__pyx_kp_b_), ((PyObject *)Py_None), ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_encrypt, 137, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 137, __pyx_L1_error)
+  __pyx_tuple__37 = PyTuple_Pack(3, ((PyObject*)__pyx_kp_b_), ((PyObject *)Py_None), ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 137, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__37);
   __Pyx_GIVEREF(__pyx_tuple__37);
 
-  /* "borg/crypto/low_level.pyx":156
+  /* "borg/crypto/low_level.pyx":147
  *         return header + data
  * 
  *     def decrypt(self, envelope, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         IMPORTANT: it is called decrypt to satisfy the crypto api naming convention,
  */
-  __pyx_tuple__38 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_envelope, __pyx_n_s_aad); if (unlikely(!__pyx_tuple__38)) __PYX_ERR(0, 156, __pyx_L1_error)
+  __pyx_tuple__38 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_envelope, __pyx_n_s_aad); if (unlikely(!__pyx_tuple__38)) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__38);
   __Pyx_GIVEREF(__pyx_tuple__38);
-  __pyx_codeobj__39 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__38, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_decrypt, 156, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__39)) __PYX_ERR(0, 156, __pyx_L1_error)
-  __pyx_tuple__40 = PyTuple_Pack(1, ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 156, __pyx_L1_error)
+  __pyx_codeobj__39 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__38, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_decrypt, 147, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__39)) __PYX_ERR(0, 147, __pyx_L1_error)
+  __pyx_tuple__40 = PyTuple_Pack(1, ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__40);
   __Pyx_GIVEREF(__pyx_tuple__40);
 
-  /* "borg/crypto/low_level.pyx":164
+  /* "borg/crypto/low_level.pyx":155
  *         return memoryview(envelope)[self.header_len:]
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return 0
  * 
  */
-  __pyx_tuple__41 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_length); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 164, __pyx_L1_error)
+  __pyx_tuple__41 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_length); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 155, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__41);
   __Pyx_GIVEREF(__pyx_tuple__41);
-  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_block_count, 164, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 164, __pyx_L1_error)
+  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_block_count, 155, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 155, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":167
+  /* "borg/crypto/low_level.pyx":158
  *         return 0
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         self.iv = iv
  * 
  */
-  __pyx_tuple__43 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_iv); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(0, 167, __pyx_L1_error)
+  __pyx_tuple__43 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_iv); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(0, 158, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__43);
   __Pyx_GIVEREF(__pyx_tuple__43);
-  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__43, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_set_iv, 167, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) __PYX_ERR(0, 167, __pyx_L1_error)
+  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__43, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_set_iv, 158, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) __PYX_ERR(0, 158, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":170
+  /* "borg/crypto/low_level.pyx":161
  *         self.iv = iv
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         return self.iv
  * 
  */
-  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 170, __pyx_L1_error)
+  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__45);
   __Pyx_GIVEREF(__pyx_tuple__45);
-  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_next_iv, 170, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) __PYX_ERR(0, 170, __pyx_L1_error)
+  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_next_iv, 161, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) __PYX_ERR(0, 161, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":173
+  /* "borg/crypto/low_level.pyx":164
  *         return self.iv
  * 
  *     def extract_iv(self, envelope):             # <<<<<<<<<<<<<<
  *         return 0
  * 
  */
-  __pyx_tuple__47 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_envelope); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(0, 173, __pyx_L1_error)
+  __pyx_tuple__47 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_envelope); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(0, 164, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__47);
   __Pyx_GIVEREF(__pyx_tuple__47);
-  __pyx_codeobj__48 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__47, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_extract_iv, 173, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__48)) __PYX_ERR(0, 173, __pyx_L1_error)
+  __pyx_codeobj__48 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__47, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_extract_iv, 164, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__48)) __PYX_ERR(0, 164, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":716
+  /* "borg/crypto/low_level.pyx":707
  * 
  * 
  * def hmac_sha256(key, data):             # <<<<<<<<<<<<<<
  *     return hmac.digest(key, data, 'sha256')
  * 
  */
-  __pyx_tuple__49 = PyTuple_Pack(2, __pyx_n_s_key, __pyx_n_s_data); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(0, 716, __pyx_L1_error)
+  __pyx_tuple__49 = PyTuple_Pack(2, __pyx_n_s_key, __pyx_n_s_data); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(0, 707, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__49);
   __Pyx_GIVEREF(__pyx_tuple__49);
-  __pyx_codeobj__50 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__49, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_hmac_sha256, 716, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__50)) __PYX_ERR(0, 716, __pyx_L1_error)
+  __pyx_codeobj__50 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__49, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_hmac_sha256, 707, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__50)) __PYX_ERR(0, 707, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":720
+  /* "borg/crypto/low_level.pyx":711
  * 
  * 
  * def blake2b_256(key, data):             # <<<<<<<<<<<<<<
  *     return hashlib.blake2b(key+data, digest_size=32).digest()
  * 
  */
-  __pyx_tuple__51 = PyTuple_Pack(2, __pyx_n_s_key, __pyx_n_s_data); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 720, __pyx_L1_error)
+  __pyx_tuple__51 = PyTuple_Pack(2, __pyx_n_s_key, __pyx_n_s_data); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__51);
   __Pyx_GIVEREF(__pyx_tuple__51);
-  __pyx_codeobj__52 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__51, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_blake2b_256, 720, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__52)) __PYX_ERR(0, 720, __pyx_L1_error)
+  __pyx_codeobj__52 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__51, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_blake2b_256, 711, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__52)) __PYX_ERR(0, 711, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":724
+  /* "borg/crypto/low_level.pyx":715
  * 
  * 
  * def blake2b_128(data):             # <<<<<<<<<<<<<<
  *     return hashlib.blake2b(data, digest_size=16).digest()
  * 
  */
-  __pyx_tuple__53 = PyTuple_Pack(1, __pyx_n_s_data); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 724, __pyx_L1_error)
+  __pyx_tuple__53 = PyTuple_Pack(1, __pyx_n_s_data); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 715, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__53);
   __Pyx_GIVEREF(__pyx_tuple__53);
-  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_blake2b_128, 724, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) __PYX_ERR(0, 724, __pyx_L1_error)
+  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_blake2b_128, 715, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) __PYX_ERR(0, 715, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":728
+  /* "borg/crypto/low_level.pyx":719
  * 
  * 
  * def hkdf_hmac_sha512(ikm, salt, info, output_length):             # <<<<<<<<<<<<<<
  *     """
  *     Compute HKDF-HMAC-SHA512 with input key material *ikm*, *salt* and *info* to produce *output_length* bytes.
  */
-  __pyx_tuple__55 = PyTuple_Pack(11, __pyx_n_s_ikm, __pyx_n_s_salt, __pyx_n_s_info, __pyx_n_s_output_length, __pyx_n_s_digest_length, __pyx_n_s_prk, __pyx_n_s_n, __pyx_n_s_t_n, __pyx_n_s_output, __pyx_n_s_i, __pyx_n_s_msg); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 728, __pyx_L1_error)
+  __pyx_tuple__55 = PyTuple_Pack(11, __pyx_n_s_ikm, __pyx_n_s_salt, __pyx_n_s_info, __pyx_n_s_output_length, __pyx_n_s_digest_length, __pyx_n_s_prk, __pyx_n_s_n, __pyx_n_s_t_n, __pyx_n_s_output, __pyx_n_s_i, __pyx_n_s_msg); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 719, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__55);
   __Pyx_GIVEREF(__pyx_tuple__55);
-  __pyx_codeobj__56 = (PyObject*)__Pyx_PyCode_New(4, 0, 11, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__55, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_hkdf_hmac_sha512, 728, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__56)) __PYX_ERR(0, 728, __pyx_L1_error)
+  __pyx_codeobj__56 = (PyObject*)__Pyx_PyCode_New(4, 0, 11, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__55, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_crypto_low_level_pyx, __pyx_n_s_hkdf_hmac_sha512, 719, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__56)) __PYX_ERR(0, 719, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
@@ -16316,108 +16326,108 @@
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
   __pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_BASE = &__pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BASE;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BASE.mac_compute = (PyObject *(*)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char const *, int, unsigned char const *, int, unsigned char *))__pyx_f_4borg_6crypto_9low_level_15AES256_CTR_BASE_mac_compute;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BASE.mac_verify = (PyObject *(*)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char const *, int, unsigned char const *, int, unsigned char *, unsigned char const *))__pyx_f_4borg_6crypto_9low_level_15AES256_CTR_BASE_mac_verify;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BASE.fetch_iv = (PyObject *(*)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char *))__pyx_f_4borg_6crypto_9low_level_15AES256_CTR_BASE_fetch_iv;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BASE.store_iv = (PyObject *(*)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char *, unsigned char *))__pyx_f_4borg_6crypto_9low_level_15AES256_CTR_BASE_store_iv;
-  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE) < 0) __PYX_ERR(0, 177, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE) < 0) __PYX_ERR(0, 168, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE.tp_dictoffset && __pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE.tp_dict, __pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_BASE) < 0) __PYX_ERR(0, 177, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES256_CTR_BASE, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE) < 0) __PYX_ERR(0, 177, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE) < 0) __PYX_ERR(0, 177, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE.tp_dict, __pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_BASE) < 0) __PYX_ERR(0, 168, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES256_CTR_BASE, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE) < 0) __PYX_ERR(0, 168, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE) < 0) __PYX_ERR(0, 168, __pyx_L1_error)
   __pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BASE = &__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BASE;
   __pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 = &__pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.__pyx_base = *__pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_BASE;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.__pyx_base.mac_compute = (PyObject *(*)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char const *, int, unsigned char const *, int, unsigned char *))__pyx_f_4borg_6crypto_9low_level_22AES256_CTR_HMAC_SHA256_mac_compute;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.__pyx_base.mac_verify = (PyObject *(*)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char const *, int, unsigned char const *, int, unsigned char *, unsigned char const *))__pyx_f_4borg_6crypto_9low_level_22AES256_CTR_HMAC_SHA256_mac_verify;
   __pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.tp_base = __pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BASE;
-  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256) < 0) __PYX_ERR(0, 346, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256) < 0) __PYX_ERR(0, 337, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.tp_dictoffset && __pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.tp_dict, __pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256) < 0) __PYX_ERR(0, 346, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES256_CTR_HMAC_SHA256, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256) < 0) __PYX_ERR(0, 346, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256) < 0) __PYX_ERR(0, 346, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256.tp_dict, __pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256) < 0) __PYX_ERR(0, 337, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES256_CTR_HMAC_SHA256, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256) < 0) __PYX_ERR(0, 337, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256) < 0) __PYX_ERR(0, 337, __pyx_L1_error)
   __pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256 = &__pyx_type_4borg_6crypto_9low_level_AES256_CTR_HMAC_SHA256;
   __pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b = &__pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.__pyx_base = *__pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_BASE;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.__pyx_base.mac_compute = (PyObject *(*)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char const *, int, unsigned char const *, int, unsigned char *))__pyx_f_4borg_6crypto_9low_level_18AES256_CTR_BLAKE2b_mac_compute;
   __pyx_vtable_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.__pyx_base.mac_verify = (PyObject *(*)(struct __pyx_obj_4borg_6crypto_9low_level_AES256_CTR_BASE *, unsigned char const *, int, unsigned char const *, int, unsigned char *, unsigned char const *))__pyx_f_4borg_6crypto_9low_level_18AES256_CTR_BLAKE2b_mac_verify;
   __pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.tp_base = __pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BASE;
-  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b) < 0) __PYX_ERR(0, 376, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b) < 0) __PYX_ERR(0, 367, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.tp_dictoffset && __pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.tp_dict, __pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b) < 0) __PYX_ERR(0, 376, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES256_CTR_BLAKE2b, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b) < 0) __PYX_ERR(0, 376, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b) < 0) __PYX_ERR(0, 376, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b.tp_dict, __pyx_vtabptr_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b) < 0) __PYX_ERR(0, 367, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES256_CTR_BLAKE2b, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b) < 0) __PYX_ERR(0, 367, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b) < 0) __PYX_ERR(0, 367, __pyx_L1_error)
   __pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b = &__pyx_type_4borg_6crypto_9low_level_AES256_CTR_BLAKE2b;
-  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level__AEAD_BASE) < 0) __PYX_ERR(0, 409, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level__AEAD_BASE) < 0) __PYX_ERR(0, 400, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_6crypto_9low_level__AEAD_BASE.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_6crypto_9low_level__AEAD_BASE.tp_dictoffset && __pyx_type_4borg_6crypto_9low_level__AEAD_BASE.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_6crypto_9low_level__AEAD_BASE.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #if CYTHON_UPDATE_DESCRIPTOR_DOC
   {
-    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_4borg_6crypto_9low_level__AEAD_BASE, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 409, __pyx_L1_error)
+    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_4borg_6crypto_9low_level__AEAD_BASE, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 400, __pyx_L1_error)
     if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
       __pyx_wrapperbase_4borg_6crypto_9low_level_10_AEAD_BASE_2__init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
       __pyx_wrapperbase_4borg_6crypto_9low_level_10_AEAD_BASE_2__init__.doc = __pyx_doc_4borg_6crypto_9low_level_10_AEAD_BASE_2__init__;
       ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_4borg_6crypto_9low_level_10_AEAD_BASE_2__init__;
     }
   }
   #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AEAD_BASE, (PyObject *)&__pyx_type_4borg_6crypto_9low_level__AEAD_BASE) < 0) __PYX_ERR(0, 409, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level__AEAD_BASE) < 0) __PYX_ERR(0, 409, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AEAD_BASE, (PyObject *)&__pyx_type_4borg_6crypto_9low_level__AEAD_BASE) < 0) __PYX_ERR(0, 400, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level__AEAD_BASE) < 0) __PYX_ERR(0, 400, __pyx_L1_error)
   __pyx_ptype_4borg_6crypto_9low_level__AEAD_BASE = &__pyx_type_4borg_6crypto_9low_level__AEAD_BASE;
   __pyx_type_4borg_6crypto_9low_level_AES256_OCB.tp_base = __pyx_ptype_4borg_6crypto_9low_level__AEAD_BASE;
-  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES256_OCB) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES256_OCB) < 0) __PYX_ERR(0, 582, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_6crypto_9low_level_AES256_OCB.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_6crypto_9low_level_AES256_OCB.tp_dictoffset && __pyx_type_4borg_6crypto_9low_level_AES256_OCB.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_6crypto_9low_level_AES256_OCB.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES256_OCB, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES256_OCB) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES256_OCB) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES256_OCB, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES256_OCB) < 0) __PYX_ERR(0, 582, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES256_OCB) < 0) __PYX_ERR(0, 582, __pyx_L1_error)
   __pyx_ptype_4borg_6crypto_9low_level_AES256_OCB = &__pyx_type_4borg_6crypto_9low_level_AES256_OCB;
   __pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305.tp_base = __pyx_ptype_4borg_6crypto_9low_level__AEAD_BASE;
-  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305) < 0) __PYX_ERR(0, 603, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305) < 0) __PYX_ERR(0, 594, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305.tp_dictoffset && __pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_CHACHA20_POLY1305, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305) < 0) __PYX_ERR(0, 603, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305) < 0) __PYX_ERR(0, 603, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_CHACHA20_POLY1305, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305) < 0) __PYX_ERR(0, 594, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305) < 0) __PYX_ERR(0, 594, __pyx_L1_error)
   __pyx_ptype_4borg_6crypto_9low_level_CHACHA20_POLY1305 = &__pyx_type_4borg_6crypto_9low_level_CHACHA20_POLY1305;
-  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES) < 0) __PYX_ERR(0, 615, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_6crypto_9low_level_AES) < 0) __PYX_ERR(0, 606, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_6crypto_9low_level_AES.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_6crypto_9low_level_AES.tp_dictoffset && __pyx_type_4borg_6crypto_9low_level_AES.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_6crypto_9low_level_AES.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES) < 0) __PYX_ERR(0, 615, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES) < 0) __PYX_ERR(0, 615, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AES, (PyObject *)&__pyx_type_4borg_6crypto_9low_level_AES) < 0) __PYX_ERR(0, 606, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_6crypto_9low_level_AES) < 0) __PYX_ERR(0, 606, __pyx_L1_error)
   __pyx_ptype_4borg_6crypto_9low_level_AES = &__pyx_type_4borg_6crypto_9low_level_AES;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
@@ -16428,32 +16438,29 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_0_29_35(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 8, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(3, 8, __pyx_L1_error)
+  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType_0_29_35(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyBoolObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(3, 8, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 15, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(4, 15, __pyx_L1_error)
+  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType_0_29_35(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyComplexObject),__Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(4, 15, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -16728,414 +16735,414 @@
  * 
  * API_VERSION = '1.3_01'             # <<<<<<<<<<<<<<
  * 
  * cdef extern from "openssl/crypto.h":
  */
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_API_VERSION, __pyx_kp_s_1_3_01) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
 
-  /* "borg/crypto/low_level.pyx":97
+  /* "borg/crypto/low_level.pyx":88
  * 
  * 
  * import struct             # <<<<<<<<<<<<<<
  * 
  * _int = struct.Struct('>I')
  */
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 97, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_struct, __pyx_t_2) < 0) __PYX_ERR(0, 97, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_struct, __pyx_t_2) < 0) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":99
+  /* "borg/crypto/low_level.pyx":90
  * import struct
  * 
  * _int = struct.Struct('>I')             # <<<<<<<<<<<<<<
  * _long = struct.Struct('>Q')
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_struct); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_struct); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_Struct); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_Struct); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_int, __pyx_t_2) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_int, __pyx_t_2) < 0) __PYX_ERR(0, 90, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":100
+  /* "borg/crypto/low_level.pyx":91
  * 
  * _int = struct.Struct('>I')
  * _long = struct.Struct('>Q')             # <<<<<<<<<<<<<<
  * 
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_struct); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_struct); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_Struct); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_Struct); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_long, __pyx_t_2) < 0) __PYX_ERR(0, 100, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_long, __pyx_t_2) < 0) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":102
+  /* "borg/crypto/low_level.pyx":93
  * _long = struct.Struct('>Q')
  * 
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]             # <<<<<<<<<<<<<<
  * bytes_to_long = lambda x, offset=0: _long.unpack_from(x, offset)[0]
  * long_to_bytes = lambda x: _long.pack(x)
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_10lambda, 0, __pyx_n_s_lambda, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_10lambda, 0, __pyx_n_s_lambda, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_2, __pyx_tuple__28);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_bytes_to_int, __pyx_t_2) < 0) __PYX_ERR(0, 102, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_bytes_to_int, __pyx_t_2) < 0) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":103
+  /* "borg/crypto/low_level.pyx":94
  * 
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]
  * bytes_to_long = lambda x, offset=0: _long.unpack_from(x, offset)[0]             # <<<<<<<<<<<<<<
  * long_to_bytes = lambda x: _long.pack(x)
  * 
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11lambda1, 0, __pyx_n_s_lambda, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 103, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11lambda1, 0, __pyx_n_s_lambda, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_2, __pyx_tuple__29);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_bytes_to_long, __pyx_t_2) < 0) __PYX_ERR(0, 103, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_bytes_to_long, __pyx_t_2) < 0) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":104
+  /* "borg/crypto/low_level.pyx":95
  * bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]
  * bytes_to_long = lambda x, offset=0: _long.unpack_from(x, offset)[0]
  * long_to_bytes = lambda x: _long.pack(x)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_12lambda2, 0, __pyx_n_s_lambda, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_12lambda2, 0, __pyx_n_s_lambda, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_long_to_bytes, __pyx_t_2) < 0) __PYX_ERR(0, 104, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_long_to_bytes, __pyx_t_2) < 0) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":107
+  /* "borg/crypto/low_level.pyx":98
  * 
  * 
  * def num_cipher_blocks(length, blocksize=16):             # <<<<<<<<<<<<<<
  *     """Return the number of cipher blocks required to encrypt/decrypt <length> bytes of data.
  * 
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_1num_cipher_blocks, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 107, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_1num_cipher_blocks, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 98, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_num_cipher_blocks, __pyx_t_2) < 0) __PYX_ERR(0, 107, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_num_cipher_blocks, __pyx_t_2) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":123
+  /* "borg/crypto/low_level.pyx":114
  * 
  * 
  * class CryptoError(Exception):             # <<<<<<<<<<<<<<
  *     """Malfunction in the crypto module."""
  * 
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 123, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 114, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
   __Pyx_GIVEREF(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
   PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
-  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 123, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 114, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_2, __pyx_n_s_CryptoError, __pyx_n_s_CryptoError, (PyObject *) NULL, __pyx_n_s_borg_crypto_low_level, __pyx_kp_s_Malfunction_in_the_crypto_module); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 123, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_2, __pyx_n_s_CryptoError, __pyx_n_s_CryptoError, (PyObject *) NULL, __pyx_n_s_borg_crypto_low_level, __pyx_kp_s_Malfunction_in_the_crypto_module); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 114, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_CryptoError, __pyx_t_2, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 123, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_CryptoError, __pyx_t_2, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 114, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CryptoError, __pyx_t_4) < 0) __PYX_ERR(0, 123, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CryptoError, __pyx_t_4) < 0) __PYX_ERR(0, 114, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":127
+  /* "borg/crypto/low_level.pyx":118
  * 
  * 
  * class IntegrityError(CryptoError):             # <<<<<<<<<<<<<<
  *     """Integrity checks failed. Corrupted or tampered data."""
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_CryptoError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 118, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 118, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 118, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_IntegrityError, __pyx_n_s_IntegrityError, (PyObject *) NULL, __pyx_n_s_borg_crypto_low_level, __pyx_kp_s_Integrity_checks_failed_Corrupte); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_IntegrityError, __pyx_n_s_IntegrityError, (PyObject *) NULL, __pyx_n_s_borg_crypto_low_level, __pyx_kp_s_Integrity_checks_failed_Corrupte); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 118, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_IntegrityError, __pyx_t_1, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_IntegrityError, __pyx_t_1, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 118, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_IntegrityError, __pyx_t_4) < 0) __PYX_ERR(0, 127, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_IntegrityError, __pyx_t_4) < 0) __PYX_ERR(0, 118, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":137
+  /* "borg/crypto/low_level.pyx":128
  * 
  * 
  * class UNENCRYPTED:             # <<<<<<<<<<<<<<
  *     # Layout: HEADER + PlainText
  * 
  */
-  __pyx_t_1 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_UNENCRYPTED, __pyx_n_s_UNENCRYPTED, (PyObject *) NULL, __pyx_n_s_borg_crypto_low_level, (PyObject *) NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_UNENCRYPTED, __pyx_n_s_UNENCRYPTED, (PyObject *) NULL, __pyx_n_s_borg_crypto_low_level, (PyObject *) NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
 
-  /* "borg/crypto/low_level.pyx":140
+  /* "borg/crypto/low_level.pyx":131
  *     # Layout: HEADER + PlainText
  * 
  *     def __init__(self, mac_key, enc_key, iv=None, header_len=1, aad_offset=1):             # <<<<<<<<<<<<<<
  *         assert mac_key is None
  *         assert enc_key is None
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_1__init__, 0, __pyx_n_s_UNENCRYPTED___init, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__33)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 140, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_1__init__, 0, __pyx_n_s_UNENCRYPTED___init, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__33)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 131, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_2, __pyx_tuple__34);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_2) < 0) __PYX_ERR(0, 140, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_init, __pyx_t_2) < 0) __PYX_ERR(0, 131, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":146
+  /* "borg/crypto/low_level.pyx":137
  *         self.set_iv(iv)
  * 
  *     def encrypt(self, data, header=b'', iv=None, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         IMPORTANT: it is called encrypt to satisfy the crypto api naming convention,
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_3encrypt, 0, __pyx_n_s_UNENCRYPTED_encrypt, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_3encrypt, 0, __pyx_n_s_UNENCRYPTED_encrypt, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_2, __pyx_tuple__37);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_encrypt, __pyx_t_2) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_encrypt, __pyx_t_2) < 0) __PYX_ERR(0, 137, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":156
+  /* "borg/crypto/low_level.pyx":147
  *         return header + data
  * 
  *     def decrypt(self, envelope, aad=None):             # <<<<<<<<<<<<<<
  *         """
  *         IMPORTANT: it is called decrypt to satisfy the crypto api naming convention,
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_5decrypt, 0, __pyx_n_s_UNENCRYPTED_decrypt, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__39)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 156, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_5decrypt, 0, __pyx_n_s_UNENCRYPTED_decrypt, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__39)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_2, __pyx_tuple__40);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decrypt, __pyx_t_2) < 0) __PYX_ERR(0, 156, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_decrypt, __pyx_t_2) < 0) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":164
+  /* "borg/crypto/low_level.pyx":155
  *         return memoryview(envelope)[self.header_len:]
  * 
  *     def block_count(self, length):             # <<<<<<<<<<<<<<
  *         return 0
  * 
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_7block_count, 0, __pyx_n_s_UNENCRYPTED_block_count, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__42)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 164, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_7block_count, 0, __pyx_n_s_UNENCRYPTED_block_count, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__42)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 155, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_block_count, __pyx_t_2) < 0) __PYX_ERR(0, 164, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_block_count, __pyx_t_2) < 0) __PYX_ERR(0, 155, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":167
+  /* "borg/crypto/low_level.pyx":158
  *         return 0
  * 
  *     def set_iv(self, iv):             # <<<<<<<<<<<<<<
  *         self.iv = iv
  * 
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_9set_iv, 0, __pyx_n_s_UNENCRYPTED_set_iv, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__44)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 167, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_9set_iv, 0, __pyx_n_s_UNENCRYPTED_set_iv, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__44)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 158, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_set_iv, __pyx_t_2) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_set_iv, __pyx_t_2) < 0) __PYX_ERR(0, 158, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":170
+  /* "borg/crypto/low_level.pyx":161
  *         self.iv = iv
  * 
  *     def next_iv(self):             # <<<<<<<<<<<<<<
  *         return self.iv
  * 
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_11next_iv, 0, __pyx_n_s_UNENCRYPTED_next_iv, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__46)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 170, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_11next_iv, 0, __pyx_n_s_UNENCRYPTED_next_iv, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__46)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_next_iv, __pyx_t_2) < 0) __PYX_ERR(0, 170, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_next_iv, __pyx_t_2) < 0) __PYX_ERR(0, 161, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":173
+  /* "borg/crypto/low_level.pyx":164
  *         return self.iv
  * 
  *     def extract_iv(self, envelope):             # <<<<<<<<<<<<<<
  *         return 0
  * 
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_13extract_iv, 0, __pyx_n_s_UNENCRYPTED_extract_iv, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__48)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 173, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_6crypto_9low_level_11UNENCRYPTED_13extract_iv, 0, __pyx_n_s_UNENCRYPTED_extract_iv, NULL, __pyx_n_s_borg_crypto_low_level, __pyx_d, ((PyObject *)__pyx_codeobj__48)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 164, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_extract_iv, __pyx_t_2) < 0) __PYX_ERR(0, 173, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_1, __pyx_n_s_extract_iv, __pyx_t_2) < 0) __PYX_ERR(0, 164, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/crypto/low_level.pyx":137
+  /* "borg/crypto/low_level.pyx":128
  * 
  * 
  * class UNENCRYPTED:             # <<<<<<<<<<<<<<
  *     # Layout: HEADER + PlainText
  * 
  */
-  __pyx_t_2 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_UNENCRYPTED, __pyx_empty_tuple, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_UNENCRYPTED, __pyx_empty_tuple, __pyx_t_1, NULL, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 128, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_UNENCRYPTED, __pyx_t_2) < 0) __PYX_ERR(0, 137, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_UNENCRYPTED, __pyx_t_2) < 0) __PYX_ERR(0, 128, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":191
+  /* "borg/crypto/low_level.pyx":182
  * 
  *     @classmethod
  *     def requirements_check(cls):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
-  __Pyx_GetNameInClass(__pyx_t_1, (PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BASE, __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
+  __Pyx_GetNameInClass(__pyx_t_1, (PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BASE, __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 182, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
 
-  /* "borg/crypto/low_level.pyx":190
+  /* "borg/crypto/low_level.pyx":181
  *     cdef long long blocks
  * 
  *     @classmethod             # <<<<<<<<<<<<<<
  *     def requirements_check(cls):
  *         pass
  */
-  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 181, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BASE->tp_dict, __pyx_n_s_requirements_check, __pyx_t_2) < 0) __PYX_ERR(0, 191, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BASE->tp_dict, __pyx_n_s_requirements_check, __pyx_t_2) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_6crypto_9low_level_AES256_CTR_BASE);
 
-  /* "borg/crypto/low_level.pyx":425
+  /* "borg/crypto/low_level.pyx":416
  * 
  *     @classmethod
  *     def requirements_check(cls):             # <<<<<<<<<<<<<<
  *         """check whether library requirements for this ciphersuite are satisfied"""
  *         raise NotImplemented  # override / implement in child class
  */
-  __Pyx_GetNameInClass(__pyx_t_2, (PyObject *)__pyx_ptype_4borg_6crypto_9low_level__AEAD_BASE, __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 425, __pyx_L1_error)
+  __Pyx_GetNameInClass(__pyx_t_2, (PyObject *)__pyx_ptype_4borg_6crypto_9low_level__AEAD_BASE, __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 416, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "borg/crypto/low_level.pyx":424
+  /* "borg/crypto/low_level.pyx":415
  *     cdef long long blocks
  * 
  *     @classmethod             # <<<<<<<<<<<<<<
  *     def requirements_check(cls):
  *         """check whether library requirements for this ciphersuite are satisfied"""
  */
-  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 424, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 415, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_6crypto_9low_level__AEAD_BASE->tp_dict, __pyx_n_s_requirements_check, __pyx_t_1) < 0) __PYX_ERR(0, 425, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_6crypto_9low_level__AEAD_BASE->tp_dict, __pyx_n_s_requirements_check, __pyx_t_1) < 0) __PYX_ERR(0, 416, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_6crypto_9low_level__AEAD_BASE);
 
-  /* "borg/crypto/low_level.pyx":593
+  /* "borg/crypto/low_level.pyx":584
  * cdef class AES256_OCB(_AEAD_BASE):
  *     @classmethod
  *     def requirements_check(cls):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
-  __Pyx_GetNameInClass(__pyx_t_1, (PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_OCB, __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 593, __pyx_L1_error)
+  __Pyx_GetNameInClass(__pyx_t_1, (PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_OCB, __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 584, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
 
-  /* "borg/crypto/low_level.pyx":592
+  /* "borg/crypto/low_level.pyx":583
  * 
  * cdef class AES256_OCB(_AEAD_BASE):
  *     @classmethod             # <<<<<<<<<<<<<<
  *     def requirements_check(cls):
  *         pass
  */
-  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 592, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 583, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_OCB->tp_dict, __pyx_n_s_requirements_check, __pyx_t_2) < 0) __PYX_ERR(0, 593, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_AES256_OCB->tp_dict, __pyx_n_s_requirements_check, __pyx_t_2) < 0) __PYX_ERR(0, 584, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_6crypto_9low_level_AES256_OCB);
 
-  /* "borg/crypto/low_level.pyx":605
+  /* "borg/crypto/low_level.pyx":596
  * cdef class CHACHA20_POLY1305(_AEAD_BASE):
  *     @classmethod
  *     def requirements_check(cls):             # <<<<<<<<<<<<<<
  *         pass
  * 
  */
-  __Pyx_GetNameInClass(__pyx_t_2, (PyObject *)__pyx_ptype_4borg_6crypto_9low_level_CHACHA20_POLY1305, __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 605, __pyx_L1_error)
+  __Pyx_GetNameInClass(__pyx_t_2, (PyObject *)__pyx_ptype_4borg_6crypto_9low_level_CHACHA20_POLY1305, __pyx_n_s_requirements_check); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 596, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "borg/crypto/low_level.pyx":604
+  /* "borg/crypto/low_level.pyx":595
  * 
  * cdef class CHACHA20_POLY1305(_AEAD_BASE):
  *     @classmethod             # <<<<<<<<<<<<<<
  *     def requirements_check(cls):
  *         pass
  */
-  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 604, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 595, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_CHACHA20_POLY1305->tp_dict, __pyx_n_s_requirements_check, __pyx_t_1) < 0) __PYX_ERR(0, 605, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_6crypto_9low_level_CHACHA20_POLY1305->tp_dict, __pyx_n_s_requirements_check, __pyx_t_1) < 0) __PYX_ERR(0, 596, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_6crypto_9low_level_CHACHA20_POLY1305);
 
-  /* "borg/crypto/low_level.pyx":716
+  /* "borg/crypto/low_level.pyx":707
  * 
  * 
  * def hmac_sha256(key, data):             # <<<<<<<<<<<<<<
  *     return hmac.digest(key, data, 'sha256')
  * 
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_3hmac_sha256, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 716, __pyx_L1_error)
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_3hmac_sha256, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 707, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_hmac_sha256, __pyx_t_1) < 0) __PYX_ERR(0, 716, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_hmac_sha256, __pyx_t_1) < 0) __PYX_ERR(0, 707, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":720
+  /* "borg/crypto/low_level.pyx":711
  * 
  * 
  * def blake2b_256(key, data):             # <<<<<<<<<<<<<<
  *     return hashlib.blake2b(key+data, digest_size=32).digest()
  * 
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_5blake2b_256, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 720, __pyx_L1_error)
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_5blake2b_256, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_blake2b_256, __pyx_t_1) < 0) __PYX_ERR(0, 720, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_blake2b_256, __pyx_t_1) < 0) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":724
+  /* "borg/crypto/low_level.pyx":715
  * 
  * 
  * def blake2b_128(data):             # <<<<<<<<<<<<<<
  *     return hashlib.blake2b(data, digest_size=16).digest()
  * 
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_7blake2b_128, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 724, __pyx_L1_error)
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_7blake2b_128, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 715, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_blake2b_128, __pyx_t_1) < 0) __PYX_ERR(0, 724, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_blake2b_128, __pyx_t_1) < 0) __PYX_ERR(0, 715, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/crypto/low_level.pyx":728
+  /* "borg/crypto/low_level.pyx":719
  * 
  * 
  * def hkdf_hmac_sha512(ikm, salt, info, output_length):             # <<<<<<<<<<<<<<
  *     """
  *     Compute HKDF-HMAC-SHA512 with input key material *ikm*, *salt* and *info* to produce *output_length* bytes.
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_9hkdf_hmac_sha512, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 728, __pyx_L1_error)
+  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_4borg_6crypto_9low_level_9hkdf_hmac_sha512, NULL, __pyx_n_s_borg_crypto_low_level); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 719, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_hkdf_hmac_sha512, __pyx_t_1) < 0) __PYX_ERR(0, 728, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_hkdf_hmac_sha512, __pyx_t_1) < 0) __PYX_ERR(0, 719, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "borg/crypto/low_level.pyx":1
  * """An AEAD style OpenSSL wrapper             # <<<<<<<<<<<<<<
  * 
  * API:
  */
@@ -18180,28 +18187,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -18740,61 +18747,79 @@
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 
 /* TypeImport */
-#ifndef __PYX_HAVE_RT_ImportType
-#define __PYX_HAVE_RT_ImportType
-static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, enum __Pyx_ImportType_CheckSize check_size)
+#ifndef __PYX_HAVE_RT_ImportType_0_29_35
+#define __PYX_HAVE_RT_ImportType_0_29_35
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
+    Py_ssize_t itemsize;
 #ifdef Py_LIMITED_API
     PyObject *py_basicsize;
+    PyObject *py_itemsize;
 #endif
     result = PyObject_GetAttrString(module, class_name);
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
             "%.200s.%.200s is not a type object",
             module_name, class_name);
         goto bad;
     }
 #ifndef Py_LIMITED_API
     basicsize = ((PyTypeObject *)result)->tp_basicsize;
+    itemsize = ((PyTypeObject *)result)->tp_itemsize;
 #else
     py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
     if (!py_basicsize)
         goto bad;
     basicsize = PyLong_AsSsize_t(py_basicsize);
     Py_DECREF(py_basicsize);
     py_basicsize = 0;
     if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
         goto bad;
+    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
+    if (!py_itemsize)
+        goto bad;
+    itemsize = PyLong_AsSsize_t(py_itemsize);
+    Py_DECREF(py_itemsize);
+    py_itemsize = 0;
+    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
 #endif
-    if ((size_t)basicsize < size) {
+    if (itemsize) {
+        if (size % alignment) {
+            alignment = size % alignment;
+        }
+        if (itemsize < (Py_ssize_t)alignment)
+            itemsize = (Py_ssize_t)alignment;
+    }
+    if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
+    if (check_size == __Pyx_ImportType_CheckSize_Error_0_29_35 && (size_t)basicsize != size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_0_29_35 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
@@ -19497,15 +19522,18 @@
 #endif
 #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
     0,
 #endif
 };
 static int __pyx_CyFunction_init(void) {
     __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
     if (unlikely(__pyx_CyFunctionType == NULL)) {
         return -1;
@@ -20063,15 +20091,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -20259,15 +20287,15 @@
                         } else if (8 * sizeof(unsigned char) >= 4 * PyLong_SHIFT) {
                             return (unsigned char) (((((((((unsigned char)digits[3]) << PyLong_SHIFT) | (unsigned char)digits[2]) << PyLong_SHIFT) | (unsigned char)digits[1]) << PyLong_SHIFT) | (unsigned char)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -20531,15 +20559,15 @@
                         } else if (8 * sizeof(PY_LONG_LONG) >= 4 * PyLong_SHIFT) {
                             return (PY_LONG_LONG) (((((((((PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -20727,15 +20755,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/crypto/low_level.pyx` & `borgbackup-2.0.0b6/src/borg/crypto/low_level.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -59,14 +59,16 @@
     ctypedef struct ENGINE:
         pass
 
     const EVP_CIPHER *EVP_aes_256_ctr()
     const EVP_CIPHER *EVP_aes_256_ocb()
     const EVP_CIPHER *EVP_chacha20_poly1305()
 
+    EVP_CIPHER_CTX *EVP_CIPHER_CTX_new()
+    void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a)
     void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a)
     void EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a)
 
     int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
                            const unsigned char *key, const unsigned char *iv)
     int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
                            const unsigned char *key, const unsigned char *iv)
@@ -78,25 +80,14 @@
     int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
 
     int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
     int EVP_CTRL_AEAD_GET_TAG
     int EVP_CTRL_AEAD_SET_TAG
     int EVP_CTRL_AEAD_SET_IVLEN
 
-    const EVP_MD *EVP_sha256() nogil
-
-    EVP_CIPHER_CTX *EVP_CIPHER_CTX_new()
-    void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a)
-
-cdef extern from "openssl/hmac.h":
-    unsigned char *HMAC(const EVP_MD *evp_md,
-                    const void *key, int key_len,
-                    const unsigned char *data, int data_len,
-                    unsigned char *md, unsigned int *md_len) nogil
-
 
 import struct
 
 _int = struct.Struct('>I')
 _long = struct.Struct('>Q')
 
 bytes_to_int = lambda x, offset=0: _int.unpack_from(x, offset)[0]
@@ -171,15 +162,15 @@
         return self.iv
 
     def extract_iv(self, envelope):
         return 0
 
 
 cdef class AES256_CTR_BASE:
-    # Layout: HEADER + MAC 32 + IV 8 + CT (same as attic / borg < 1.3 IF HEADER = TYPE_BYTE, no AAD)
+    # Layout: HEADER + MAC 32 + IV 8 + CT (same as attic / borg < 2.0 IF HEADER = TYPE_BYTE, no AAD)
 
     cdef EVP_CIPHER_CTX *ctx
     cdef unsigned char enc_key[32]
     cdef int cipher_blk_len
     cdef int iv_len, iv_len_short
     cdef int aad_offset
     cdef int header_len
@@ -403,15 +394,15 @@
             raise IntegrityError('MAC Authentication failed')
 
 
 ctypedef const EVP_CIPHER * (* CIPHER)()
 
 
 cdef class _AEAD_BASE:
-    # new crypto used in borg >= 1.3
+    # new crypto used in borg >= 2.0
     # Layout: HEADER + MAC 16 + CT
 
     cdef CIPHER cipher
     cdef EVP_CIPHER_CTX *ctx
     cdef unsigned char key[32]
     cdef int cipher_blk_len
     cdef int iv_len
```

### Comparing `borgbackup-2.0.0b5/src/borg/fuse.py` & `borgbackup-2.0.0b6/src/borg/fuse.py`

 * *Files 3% similar despite different names*

```diff
@@ -111,15 +111,15 @@
         self.fd = tempfile.TemporaryFile(prefix="borg-tmp")
 
         # A small LRU cache for chunks requested by ItemCache.get() from the object cache,
         # this significantly speeds up directory traversal and similar operations which
         # tend to re-read the same chunks over and over.
         # The capacity is kept low because increasing it does not provide any significant advantage,
         # but makes LRUCache's square behaviour noticeable and consumes more memory.
-        self.chunks = LRUCache(capacity=10, dispose=lambda _: None)
+        self.chunks = LRUCache(capacity=10)
 
         # Instrumentation
         # Count of indirect items, i.e. data is cached in the object cache, not directly in this cache
         self.indirect_items = 0
         # Count of direct items, i.e. data is in self.fd
         self.direct_items = 0
 
@@ -248,15 +248,15 @@
         self.repo_objs = manifest.repo_objs
         self.repository_uncached = manifest.repository
         # Maps inode numbers to Item instances. This is used for synthetic inodes, i.e. file-system objects that are
         # made up and are not contained in the archives. For example archive directories or intermediate directories
         # not contained in archives.
         self._items = {}
         # cache up to <FILES> Items
-        self._inode_cache = LRUCache(capacity=FILES, dispose=lambda _: None)
+        self._inode_cache = LRUCache(capacity=FILES)
         # _inode_count is the current count of synthetic inodes, i.e. those in self._items
         self.inode_count = 0
         # Maps inode numbers to the inode number of the parent
         self.parent = {}
         # Maps inode numbers to a dictionary mapping byte directory entry names to their inode numbers,
         # i.e. this contains all dirents of everything that is mounted. (It becomes really big).
         self.contents = defaultdict(dict)
@@ -441,16 +441,16 @@
 
     def __init__(self, manifest, args, decrypted_repository):
         llfuse.Operations.__init__(self)
         FuseBackend.__init__(self, manifest, args, decrypted_repository)
         self.decrypted_repository = decrypted_repository
         data_cache_capacity = int(os.environ.get("BORG_MOUNT_DATA_CACHE_ENTRIES", os.cpu_count() or 1))
         logger.debug("mount data cache capacity: %d chunks", data_cache_capacity)
-        self.data_cache = LRUCache(capacity=data_cache_capacity, dispose=lambda _: None)
-        self._last_pos = LRUCache(capacity=FILES, dispose=lambda _: None)
+        self.data_cache = LRUCache(capacity=data_cache_capacity)
+        self._last_pos = LRUCache(capacity=FILES)
 
     def sig_info_handler(self, sig_no, stack):
         logger.debug(
             "fuse: %d synth inodes, %d edges (%s)",
             self.inode_count,
             len(self.parent),
             # getsizeof is the size of the dict itself; key and value are two small-ish integers,
@@ -558,22 +558,22 @@
             umount = signal is None or (signal == SIGINT and foreground)
         finally:
             llfuse.close(umount)
 
     @async_wrapper
     def statfs(self, ctx=None):
         stat_ = llfuse.StatvfsData()
-        stat_.f_bsize = 512
-        stat_.f_frsize = 512
-        stat_.f_blocks = 0
-        stat_.f_bfree = 0
-        stat_.f_bavail = 0
-        stat_.f_files = 0
-        stat_.f_ffree = 0
-        stat_.f_favail = 0
+        stat_.f_bsize = 512  # Filesystem block size
+        stat_.f_frsize = 512  # Fragment size
+        stat_.f_blocks = 0  # Size of fs in f_frsize units
+        stat_.f_bfree = 0  # Number of free blocks
+        stat_.f_bavail = 0  # Number of free blocks for unprivileged users
+        stat_.f_files = 0  # Number of inodes
+        stat_.f_ffree = 0  # Number of free inodes
+        stat_.f_favail = 0  # Number of free inodes for unprivileged users
         stat_.f_namemax = 255  # == NAME_MAX (depends on archive source OS / FS)
         return stat_
 
     def _getattr(self, inode, ctx=None):
         item = self.get_item(inode)
         entry = llfuse.EntryAttributes()
         entry.st_ino = inode
@@ -685,15 +685,15 @@
                     # chunk was only partially read, cache it
                     self.data_cache[id] = data
             parts.append(data[offset : offset + n])
             offset = 0
             size -= n
             if not size:
                 if fh in self._last_pos:
-                    self._last_pos.upd(fh, (chunk_no, chunk_offset))
+                    self._last_pos.replace(fh, (chunk_no, chunk_offset))
                 else:
                     self._last_pos[fh] = (chunk_no, chunk_offset)
                 break
         return b"".join(parts)
 
     # note: we can't have a generator (with yield) and not a generator (async) in the same method
     if has_pyfuse3:
```

### Comparing `borgbackup-2.0.0b5/src/borg/fuse_impl.py` & `borgbackup-2.0.0b6/src/borg/fuse_impl.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/hashindex.c` & `borgbackup-2.0.0b6/src/borg/hashindex.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
             "src/borg/_hashindex.c",
             "src/borg/cache_sync/cache_sync.c"
@@ -32,16 +32,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -101,16 +101,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -226,15 +230,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -265,15 +269,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -1535,22 +1539,30 @@
 /* SetupReduce.proto */
 static int __Pyx_setup_reduce(PyObject* type_obj);
 
 /* SetVTable.proto */
 static int __Pyx_SetVtable(PyObject *dict, void *vtable);
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto
-#define __PYX_HAVE_RT_ImportType_proto
-enum __Pyx_ImportType_CheckSize {
-   __Pyx_ImportType_CheckSize_Error = 0,
-   __Pyx_ImportType_CheckSize_Warn = 1,
-   __Pyx_ImportType_CheckSize_Ignore = 2
+#ifndef __PYX_HAVE_RT_ImportType_proto_0_29_35
+#define __PYX_HAVE_RT_ImportType_proto_0_29_35
+#if __STDC_VERSION__ >= 201112L
+#include <stdalign.h>
+#endif
+#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) alignof(s)
+#else
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) sizeof(void*)
+#endif
+enum __Pyx_ImportType_CheckSize_0_29_35 {
+   __Pyx_ImportType_CheckSize_Error_0_29_35 = 0,
+   __Pyx_ImportType_CheckSize_Warn_0_29_35 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_0_29_35 = 2
 };
-static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size);
 #endif
 
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
@@ -11937,15 +11949,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_9hashindex_FuseVersionsIndex(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_9hashindex_IndexBase(t, a, k);
   if (unlikely(!o)) return 0;
@@ -12068,15 +12080,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_9hashindex_NSIndex(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_9hashindex_IndexBase(t, a, k);
   if (unlikely(!o)) return 0;
@@ -12201,15 +12213,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_9hashindex_NSKeyIterator(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_obj_4borg_9hashindex_NSKeyIterator *p;
   PyObject *o;
@@ -12330,15 +12342,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_9hashindex_NSIndex1(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_9hashindex_IndexBase(t, a, k);
   if (unlikely(!o)) return 0;
@@ -12463,15 +12475,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_9hashindex_NSKeyIterator1(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_obj_4borg_9hashindex_NSKeyIterator1 *p;
   PyObject *o;
@@ -12592,15 +12604,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_4borg_9hashindex_ChunkIndex __pyx_vtable_4borg_9hashindex_ChunkIndex;
 
 static PyObject *__pyx_tp_new_4borg_9hashindex_ChunkIndex(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_obj_4borg_9hashindex_ChunkIndex *p;
@@ -12734,15 +12746,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_9hashindex_ChunkKeyIterator(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_obj_4borg_9hashindex_ChunkKeyIterator *p;
   PyObject *o;
@@ -12863,15 +12875,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_9hashindex_CacheSynchronizer(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_obj_4borg_9hashindex_CacheSynchronizer *p;
   PyObject *o;
@@ -13012,15 +13024,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
@@ -13633,22 +13645,21 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_0_29_35(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -14847,28 +14858,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -15542,61 +15553,79 @@
     return 0;
 bad:
     Py_XDECREF(ob);
     return -1;
 }
 
 /* TypeImport */
-#ifndef __PYX_HAVE_RT_ImportType
-#define __PYX_HAVE_RT_ImportType
-static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, enum __Pyx_ImportType_CheckSize check_size)
+#ifndef __PYX_HAVE_RT_ImportType_0_29_35
+#define __PYX_HAVE_RT_ImportType_0_29_35
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
+    Py_ssize_t itemsize;
 #ifdef Py_LIMITED_API
     PyObject *py_basicsize;
+    PyObject *py_itemsize;
 #endif
     result = PyObject_GetAttrString(module, class_name);
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
             "%.200s.%.200s is not a type object",
             module_name, class_name);
         goto bad;
     }
 #ifndef Py_LIMITED_API
     basicsize = ((PyTypeObject *)result)->tp_basicsize;
+    itemsize = ((PyTypeObject *)result)->tp_itemsize;
 #else
     py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
     if (!py_basicsize)
         goto bad;
     basicsize = PyLong_AsSsize_t(py_basicsize);
     Py_DECREF(py_basicsize);
     py_basicsize = 0;
     if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
         goto bad;
+    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
+    if (!py_itemsize)
+        goto bad;
+    itemsize = PyLong_AsSsize_t(py_itemsize);
+    Py_DECREF(py_itemsize);
+    py_itemsize = 0;
+    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
 #endif
-    if ((size_t)basicsize < size) {
+    if (itemsize) {
+        if (size % alignment) {
+            alignment = size % alignment;
+        }
+        if (itemsize < (Py_ssize_t)alignment)
+            itemsize = (Py_ssize_t)alignment;
+    }
+    if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
+    if (check_size == __Pyx_ImportType_CheckSize_Error_0_29_35 && (size_t)basicsize != size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_0_29_35 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
@@ -16098,15 +16127,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -16408,15 +16437,15 @@
                         } else if (8 * sizeof(uint32_t) >= 4 * PyLong_SHIFT) {
                             return (uint32_t) (((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -16604,15 +16633,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/hashindex.pyi` & `borgbackup-2.0.0b6/src/borg/hashindex.pyi`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/hashindex.pyx` & `borgbackup-2.0.0b6/src/borg/hashindex.pyx`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/__init__.py` & `borgbackup-2.0.0b6/src/borg/helpers/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,37 +7,39 @@
 """
 import os
 
 from ..constants import *  # NOQA
 from .checks import check_extension_modules, check_python
 from .datastruct import StableDict, Buffer, EfficientCollectionQueue
 from .errors import Error, ErrorWithTraceback, IntegrityError, DecompressionError
-from .fs import ensure_dir, get_security_dir, get_keys_dir, get_base_dir, join_base_dir, get_cache_dir, get_config_dir
-from .fs import dir_is_tagged, dir_is_cachedir, make_path_safe, scandir_inorder
+from .fs import ensure_dir, join_base_dir, get_socket_filename
+from .fs import get_security_dir, get_keys_dir, get_base_dir, get_cache_dir, get_config_dir, get_runtime_dir
+from .fs import dir_is_tagged, dir_is_cachedir, remove_dotdot_prefixes, make_path_safe, scandir_inorder
 from .fs import secure_erase, safe_unlink, dash_open, os_open, os_stat, umount
 from .fs import O_, flags_root, flags_dir, flags_special_follow, flags_special, flags_base, flags_normal, flags_noatime
 from .fs import HardLinkManager
 from .misc import sysinfo, log_multi, consume
 from .misc import ChunkIteratorFileWrapper, open_item, chunkit, iter_separated, ErrorIgnoringTextIOWrapper
 from .parseformat import bin_to_hex, safe_encode, safe_decode
 from .parseformat import text_to_json, binary_to_json, remove_surrogates, join_cmd
 from .parseformat import eval_escapes, decode_dict, positive_int_validator, interval
 from .parseformat import SortBySpec, ChunkerParams, FilesCacheMode, partial_format, DatetimeWrapper
 from .parseformat import format_file_size, parse_file_size, FileSize, parse_storage_quota
 from .parseformat import sizeof_fmt, sizeof_fmt_iec, sizeof_fmt_decimal, Location, text_validator
 from .parseformat import format_line, replace_placeholders, PlaceholderError, relative_time_marker_validator
 from .parseformat import format_archive, parse_stringified_list, clean_lines
 from .parseformat import location_validator, archivename_validator, comment_validator
-from .parseformat import BaseFormatter, ArchiveFormatter, ItemFormatter, file_status
+from .parseformat import BaseFormatter, ArchiveFormatter, ItemFormatter, DiffFormatter, file_status
 from .parseformat import swidth_slice, ellipsis_truncate
 from .parseformat import BorgJsonEncoder, basic_json_data, json_print, json_dump, prepare_dump_dict
+from .parseformat import Highlander, MakePathSafeAction
 from .process import daemonize, daemonizing
 from .process import signal_handler, raising_signal_handler, sig_int, ignore_sigint, SigHup, SigTerm
 from .process import popen_with_error_handling, is_terminal, prepare_subprocess_env, create_filter_process
-from .progress import ProgressIndicatorPercent, ProgressIndicatorEndless, ProgressIndicatorMessage
+from .progress import ProgressIndicatorPercent, ProgressIndicatorMessage
 from .time import parse_timestamp, timestamp, safe_timestamp, safe_s, safe_ns, MAX_S, SUPPORT_32BIT_PLATFORMS
 from .time import format_time, format_timedelta, OutputTimestamp, archive_ts_now
 from .yes_no import yes, TRUISH, FALSISH, DEFAULTISH
 
 from .msgpack import is_slow_msgpack, is_supported_msgpack, get_limited_unpacker
 from . import msgpack
```

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/checks.py` & `borgbackup-2.0.0b6/src/borg/helpers/checks.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/datastruct.py` & `borgbackup-2.0.0b6/src/borg/helpers/datastruct.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/errors.py` & `borgbackup-2.0.0b6/src/borg/helpers/errors.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/fs.py` & `borgbackup-2.0.0b6/src/borg/helpers/fs.py`

 * *Files 8% similar despite different names*

```diff
@@ -81,36 +81,65 @@
     return keys_dir
 
 
 def get_security_dir(repository_id=None, *, legacy=False):
     """Determine where to store local security information."""
     security_dir = os.environ.get("BORG_SECURITY_DIR")
     if security_dir is None:
+        get_dir = get_config_dir if legacy else get_data_dir
         # note: do not just give this as default to the environment.get(), see issue #5979.
-        security_dir = os.path.join(get_config_dir(legacy=legacy), "security")
+        security_dir = os.path.join(get_dir(legacy=legacy), "security")
     if repository_id:
         security_dir = os.path.join(security_dir, repository_id)
     ensure_dir(security_dir)
     return security_dir
 
 
+def get_data_dir(*, legacy=False):
+    """Determine where to store borg changing data on the client"""
+    assert legacy is False, "there is no legacy variant of the borg data dir"
+    data_dir = os.environ.get(
+        "BORG_DATA_DIR", join_base_dir(".local", "share", "borg", legacy=legacy) or platformdirs.user_data_dir("borg")
+    )
+
+    # Create path if it doesn't exist yet
+    ensure_dir(data_dir)
+    return data_dir
+
+
+def get_runtime_dir(*, legacy=False):
+    """Determine where to store runtime files, like sockets, PID files, ..."""
+    assert legacy is False, "there is no legacy variant of the borg runtime dir"
+    runtime_dir = os.environ.get(
+        "BORG_RUNTIME_DIR", join_base_dir(".cache", "borg", legacy=legacy) or platformdirs.user_runtime_dir("borg")
+    )
+
+    # Create path if it doesn't exist yet
+    ensure_dir(runtime_dir)
+    return runtime_dir
+
+
+def get_socket_filename():
+    return os.path.join(get_runtime_dir(), "borg.sock")
+
+
 def get_cache_dir(*, legacy=False):
     """Determine where to repository keys and cache"""
 
     if legacy:
         # Get cache home path
         cache_home = join_base_dir(".cache", legacy=legacy)
         # Try to use XDG_CACHE_HOME instead if BORG_BASE_DIR isn't explicitly set
         if not os.environ.get("BORG_BASE_DIR"):
             cache_home = os.environ.get("XDG_CACHE_HOME", cache_home)
         # Use BORG_CACHE_DIR if set, otherwise assemble final path from cache home path
         cache_dir = os.environ.get("BORG_CACHE_DIR", os.path.join(cache_home, "borg"))
     else:
         cache_dir = os.environ.get(
-            "BORG_CACHE_DIR", join_base_dir(".cache", legacy=legacy) or platformdirs.user_cache_dir("borg")
+            "BORG_CACHE_DIR", join_base_dir(".cache", "borg", legacy=legacy) or platformdirs.user_cache_dir("borg")
         )
 
     # Create path if it doesn't exist yet
     ensure_dir(cache_dir)
     cache_tag_fn = os.path.join(cache_dir, CACHE_TAG_NAME)
     if not os.path.exists(cache_tag_fn):
         cache_tag_contents = (
@@ -139,15 +168,15 @@
         # Try to use XDG_CONFIG_HOME instead if BORG_BASE_DIR isn't explicitly set
         if not os.environ.get("BORG_BASE_DIR"):
             config_home = os.environ.get("XDG_CONFIG_HOME", config_home)
         # Use BORG_CONFIG_DIR if set, otherwise assemble final path from config home path
         config_dir = os.environ.get("BORG_CONFIG_DIR", os.path.join(config_home, "borg"))
     else:
         config_dir = os.environ.get(
-            "BORG_CONFIG_DIR", join_base_dir(".config", legacy=legacy) or platformdirs.user_config_dir("borg")
+            "BORG_CONFIG_DIR", join_base_dir(".config", "borg", legacy=legacy) or platformdirs.user_config_dir("borg")
         )
 
     # Create path if it doesn't exist yet
     ensure_dir(config_dir)
     return config_dir
 
 
@@ -184,20 +213,74 @@
         for tag in exclude_if_present:
             tag_path = os.path.join(path, tag)
             if os.path.exists(tag_path):
                 tag_names.append(tag)
     return tag_names
 
 
-_safe_re = re.compile(r"^((\.\.)?/+)+")
+def make_path_safe(path):
+    """
+    Make path safe by making it relative and normalized.
 
+    `path` is sanitized by making it relative, removing
+    consecutive slashes (e.g. '//'), removing '.' elements,
+    and removing trailing slashes.
 
-def make_path_safe(path):
-    """Make path safe by making it relative and local"""
-    return _safe_re.sub("", path) or "."
+    For reasons of security, a ValueError is raised should
+    `path` contain any '..' elements.
+    """
+    path = path.lstrip("/")
+    if "\\" in path:  # borg always wants slashes, never backslashes.
+        raise ValueError(f"unexpected backslash(es) in path {path!r}")
+    if path.startswith("../") or "/../" in path or path.endswith("/..") or path == "..":
+        raise ValueError(f"unexpected '..' element in path {path!r}")
+    path = os.path.normpath(path)
+    return path
+
+
+_dotdot_re = re.compile(r"^(\.\./)+")
+
+
+def remove_dotdot_prefixes(path):
+    """
+    Remove '../'s at the beginning of `path`. Additionally,
+    the path is made relative.
+
+    `path` is expected to be normalized already (e.g. via `os.path.normpath()`).
+    """
+    path = path.lstrip("/")
+    path = _dotdot_re.sub("", path)
+    if path in ["", ".."]:
+        return "."
+    return path
+
+
+def assert_sanitized_path(path):
+    assert isinstance(path, str)
+    # `path` should have been sanitized earlier. Some features,
+    # like pattern matching rely on a sanitized path. As a
+    # precaution we check here again.
+    if make_path_safe(path) != path:
+        raise ValueError(f"path {path!r} is not sanitized")
+    return path
+
+
+def to_sanitized_path(path):
+    assert isinstance(path, str)
+    # Legacy versions of Borg still allowed non-sanitized paths
+    # to be stored. So, we sanitize them when reading.
+    #
+    # Borg 2 ensures paths are safe before storing them. Thus, when
+    # support for reading Borg 1 archives is dropped, this should be
+    # changed to a simple check to verify paths aren't malicious.
+    # Namely, absolute paths and paths containing '..' elements must
+    # be rejected.
+    #
+    # Also checks for '..' elements in `path` for reasons of security.
+    return make_path_safe(path)
 
 
 class HardLinkManager:
     """
     Manage hardlinks (and avoid code duplication doing so).
 
     A) When creating a borg2 archive from the filesystem, we have to maintain a mapping like:
```

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/misc.py` & `borgbackup-2.0.0b6/src/borg/helpers/misc.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/msgpack.py` & `borgbackup-2.0.0b6/src/borg/helpers/msgpack.py`

 * *Files 1% similar despite different names*

```diff
@@ -200,22 +200,20 @@
     import msgpack
     import msgpack.fallback
 
     return msgpack.Packer is msgpack.fallback.Packer
 
 
 def is_supported_msgpack():
-    # DO NOT CHANGE OR REMOVE! See also requirements and comments in setup.py.
+    # DO NOT CHANGE OR REMOVE! See also requirements and comments in setup.cfg.
     import msgpack
 
-    return (1, 0, 3) <= msgpack.version <= (
-        1,
-        0,
-        4,
-    ) and msgpack.version not in []  # < add bad releases here to deny list
+    if msgpack.version in []:  # < add bad releases here to deny list
+        return False
+    return (1, 0, 3) <= msgpack.version <= (1, 0, 5)
 
 
 def get_limited_unpacker(kind):
     """return a limited Unpacker because we should not trust msgpack data received from remote"""
     # Note: msgpack >= 0.6.1 auto-computes DoS-safe max values from len(data) for
     #       unpack(data) or from max_buffer_size for Unpacker(max_buffer_size=N).
     args = dict(use_list=False, max_buffer_size=3 * max(BUFSIZE, MAX_OBJECT_SIZE))  # return tuples, not lists
```

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/nanorst.py` & `borgbackup-2.0.0b6/src/borg/helpers/nanorst.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/parseformat.py` & `borgbackup-2.0.0b6/src/borg/helpers/parseformat.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,36 +1,41 @@
+import abc
 import argparse
 import base64
 import hashlib
 import json
 import os
 import os.path
 import re
 import shlex
 import stat
 import uuid
+from typing import List, Dict, Set, Tuple, ClassVar, Any, TYPE_CHECKING, Literal
 from binascii import hexlify
 from collections import Counter, OrderedDict
 from datetime import datetime, timezone
 from functools import partial
 from string import Formatter
 
 from ..logger import create_logger
 
 logger = create_logger()
 
 from .errors import Error
-from .fs import get_keys_dir
+from .fs import get_keys_dir, make_path_safe
 from .msgpack import Timestamp
 from .time import OutputTimestamp, format_time, safe_timestamp
 from .. import __version__ as borg_version
 from .. import __version_tuple__ as borg_version_tuple
 from ..constants import *  # NOQA
 from ..platformflags import is_win32
 
+if TYPE_CHECKING:
+    from ..item import ItemDiff
+
 
 def bin_to_hex(binary):
     return hexlify(binary).decode("ascii")
 
 
 def safe_decode(s, coding="utf-8", errors="surrogateescape"):
     """decode bytes to str, with round-tripping "invalid" bytes"""
@@ -133,59 +138,67 @@
     return hours
 
 
 def ChunkerParams(s):
     params = s.strip().split(",")
     count = len(params)
     if count == 0:
-        raise ValueError("no chunker params given")
+        raise argparse.ArgumentTypeError("no chunker params given")
     algo = params[0].lower()
     if algo == CH_FAIL and count == 3:
         block_size = int(params[1])
         fail_map = str(params[2])
         return algo, block_size, fail_map
     if algo == CH_FIXED and 2 <= count <= 3:  # fixed, block_size[, header_size]
         block_size = int(params[1])
         header_size = int(params[2]) if count == 3 else 0
         if block_size < 64:
             # we are only disallowing the most extreme cases of abuse here - this does NOT imply
             # that cutting chunks of the minimum allowed size is efficient concerning storage
             # or in-memory chunk management.
             # choose the block (chunk) size wisely: if you have a lot of data and you cut
             # it into very small chunks, you are asking for trouble!
-            raise ValueError("block_size must not be less than 64 Bytes")
+            raise argparse.ArgumentTypeError("block_size must not be less than 64 Bytes")
         if block_size > MAX_DATA_SIZE or header_size > MAX_DATA_SIZE:
-            raise ValueError("block_size and header_size must not exceed MAX_DATA_SIZE [%d]" % MAX_DATA_SIZE)
+            raise argparse.ArgumentTypeError(
+                "block_size and header_size must not exceed MAX_DATA_SIZE [%d]" % MAX_DATA_SIZE
+            )
         return algo, block_size, header_size
     if algo == "default" and count == 1:  # default
         return CHUNKER_PARAMS
     # this must stay last as it deals with old-style compat mode (no algorithm, 4 params, buzhash):
     if algo == CH_BUZHASH and count == 5 or count == 4:  # [buzhash, ]chunk_min, chunk_max, chunk_mask, window_size
         chunk_min, chunk_max, chunk_mask, window_size = (int(p) for p in params[count - 4 :])
         if not (chunk_min <= chunk_mask <= chunk_max):
-            raise ValueError("required: chunk_min <= chunk_mask <= chunk_max")
+            raise argparse.ArgumentTypeError("required: chunk_min <= chunk_mask <= chunk_max")
         if chunk_min < 6:
             # see comment in 'fixed' algo check
-            raise ValueError("min. chunk size exponent must not be less than 6 (2^6 = 64B min. chunk size)")
+            raise argparse.ArgumentTypeError(
+                "min. chunk size exponent must not be less than 6 (2^6 = 64B min. chunk size)"
+            )
         if chunk_max > 23:
-            raise ValueError("max. chunk size exponent must not be more than 23 (2^23 = 8MiB max. chunk size)")
+            raise argparse.ArgumentTypeError(
+                "max. chunk size exponent must not be more than 23 (2^23 = 8MiB max. chunk size)"
+            )
         return CH_BUZHASH, chunk_min, chunk_max, chunk_mask, window_size
-    raise ValueError("invalid chunker params")
+    raise argparse.ArgumentTypeError("invalid chunker params")
 
 
 def FilesCacheMode(s):
     ENTRIES_MAP = dict(ctime="c", mtime="m", size="s", inode="i", rechunk="r", disabled="d")
     VALID_MODES = ("cis", "ims", "cs", "ms", "cr", "mr", "d", "s")  # letters in alpha order
     entries = set(s.strip().split(","))
     if not entries <= set(ENTRIES_MAP):
-        raise ValueError("cache mode must be a comma-separated list of: %s" % ",".join(sorted(ENTRIES_MAP)))
+        raise argparse.ArgumentTypeError(
+            "cache mode must be a comma-separated list of: %s" % ",".join(sorted(ENTRIES_MAP))
+        )
     short_entries = {ENTRIES_MAP[entry] for entry in entries}
     mode = "".join(sorted(short_entries))
     if mode not in VALID_MODES:
-        raise ValueError("cache mode short must be one of: %s" % ",".join(VALID_MODES))
+        raise argparse.ArgumentTypeError("cache mode short must be one of: %s" % ",".join(VALID_MODES))
     return mode
 
 
 def partial_format(format, mapping):
     """
     Apply format.format_map(mapping) while preserving unknown keys
 
@@ -273,15 +286,15 @@
 
 
 def SortBySpec(text):
     from ..manifest import AI_HUMAN_SORT_KEYS
 
     for token in text.split(","):
         if token not in AI_HUMAN_SORT_KEYS:
-            raise ValueError("Invalid sort key: %s" % token)
+            raise argparse.ArgumentTypeError("Invalid sort key: %s" % token)
     return text.replace("timestamp", "ts")
 
 
 def format_file_size(v, precision=2, sign=False, iec=False):
     """Format file size into a human friendly format"""
     fn = sizeof_fmt_iec if iec else sizeof_fmt_decimal
     return fn(v, suffix="B", sep=" ", precision=precision, sign=sign)
@@ -378,15 +391,15 @@
     optional_user_re = r"""
         (?:(?P<user>[^@:/]+)@)?
     """
 
     # path must not contain :: (it ends at :: or string end), but may contain single colons.
     # to avoid ambiguities with other regexes, it must also not start with ":" nor with "//" nor with "ssh://".
     local_path_re = r"""
-        (?!(:|//|ssh://))                                   # not starting with ":" or // or ssh://
+        (?!(:|//|ssh://|socket://))                         # not starting with ":" or // or ssh:// or socket://
         (?P<path>([^:]|(:(?!:)))+)                          # any chars, but no "::"
         """
 
     # file_path must not contain :: (it ends at :: or string end), but may contain single colons.
     # it must start with a / and that slash is part of the path.
     file_path_re = r"""
         (?P<path>(([^/]*)/([^:]|(:(?!:)))+))                # start opt. servername, then /, then any chars, but no "::"
@@ -417,14 +430,22 @@
         + r"""                 # user@  (optional), host name or address
         (?::(?P<port>\d+))?                                     # :port (optional)
         """
         + abs_path_re,
         re.VERBOSE,
     )  # path
 
+    socket_re = re.compile(
+        r"""
+        (?P<proto>socket)://                                    # socket://
+        """
+        + abs_path_re,
+        re.VERBOSE,
+    )  # path
+
     file_re = re.compile(
         r"""
         (?P<proto>file)://                                      # file://
         """
         + file_path_re,
         re.VERBOSE,
     )  # servername/path or path
@@ -485,14 +506,19 @@
             self.path = normpath_special(m.group("path"))
             return True
         m = self.file_re.match(text)
         if m:
             self.proto = m.group("proto")
             self.path = normpath_special(m.group("path"))
             return True
+        m = self.socket_re.match(text)
+        if m:
+            self.proto = m.group("proto")
+            self.path = normpath_special(m.group("path"))
+            return True
         m = self.local_re.match(text)
         if m:
             self.proto = "file"
             self.path = normpath_special(m.group("path"))
             return True
         return False
 
@@ -504,15 +530,15 @@
             "port=%r" % self.port,
             "path=%r" % self.path,
         ]
         return ", ".join(items)
 
     def to_key_filename(self):
         name = re.sub(r"[^\w]", "_", self.path).strip("_")
-        if self.proto != "file":
+        if self.proto not in ("file", "socket"):
             name = re.sub(r"[^\w]", "_", self.host) + "__" + name
         if len(name) > 100:
             # Limit file names to some reasonable length. Most file systems
             # limit them to 255 [unit of choice]; due to variations in unicode
             # handling we truncate to 100 *characters*.
             name = name[:100]
         return os.path.join(get_keys_dir(), name)
@@ -523,15 +549,15 @@
     @property
     def host(self):
         # strip square brackets used for IPv6 addrs
         if self._host is not None:
             return self._host.lstrip("[").rstrip("]")
 
     def canonical_path(self):
-        if self.proto == "file":
+        if self.proto in ("file", "socket"):
             return self.path
         else:
             if self.path and self.path.startswith("~"):
                 path = "/" + self.path  # /~/x = path x relative to home dir
             elif self.path and not self.path.startswith("/"):
                 path = "/./" + self.path  # /./x = path x relative to cwd
             else:
@@ -624,129 +650,122 @@
         invalid_ctrl_chars=invalid_ctrl_chars,
         invalid_chars=invalid_chars,
         no_blanks=True,
     )
     return validate_text(text)
 
 
-class BaseFormatter:
-    FIXED_KEYS = {
+class BaseFormatter(metaclass=abc.ABCMeta):
+    format: str
+    static_data: Dict[str, Any]
+    FIXED_KEYS: ClassVar[Dict[str, str]] = {
         # Formatting aids
         "LF": "\n",
         "SPACE": " ",
         "TAB": "\t",
         "CR": "\r",
         "NUL": "\0",
         "NEWLINE": "\n",
         "NL": "\n",  # \n is automatically converted to os.linesep on write
     }
+    KEY_DESCRIPTIONS: ClassVar[Dict[str, str]] = {
+        "NEWLINE": "OS dependent line separator",
+        "NL": "alias of NEWLINE",
+        "NUL": "NUL character for creating print0 / xargs -0 like output",
+        "SPACE": "space character",
+        "TAB": "tab character",
+        "CR": "carriage return character",
+        "LF": "line feed character",
+    }
+    KEY_GROUPS: ClassVar[Tuple[Tuple[str, ...], ...]] = (("NEWLINE", "NL", "NUL", "SPACE", "TAB", "CR", "LF"),)
 
-    def get_item_data(self, item):
-        raise NotImplementedError
+    def __init__(self, format: str, static: Dict[str, Any]) -> None:
+        self.format = partial_format(format, static)
+        self.static_data = static
 
-    def format_item(self, item):
-        return self.format.format_map(self.get_item_data(item))
+    @abc.abstractmethod
+    def get_item_data(self, item, jsonline=False) -> dict:
+        raise NotImplementedError
 
-    @staticmethod
-    def keys_help():
+    def format_item(self, item, jsonline=False, sort=False):
+        data = self.get_item_data(item, jsonline)
         return (
-            "- NEWLINE: OS dependent line separator\n"
-            "- NL: alias of NEWLINE\n"
-            "- NUL: NUL character for creating print0 / xargs -0 like output\n"
-            "- SPACE\n"
-            "- TAB\n"
-            "- CR\n"
-            "- LF"
+            f"{json.dumps(data, cls=BorgJsonEncoder, sort_keys=sort)}\n" if jsonline else self.format.format_map(data)
         )
 
+    @classmethod
+    def keys_help(cls):
+        help = []
+        keys: Set[str] = set()
+        keys.update(cls.KEY_DESCRIPTIONS.keys())
+        keys.update(key for group in cls.KEY_GROUPS for key in group)
+
+        for group in cls.KEY_GROUPS:
+            for key in group:
+                keys.remove(key)
+                text = "- " + key
+                if key in cls.KEY_DESCRIPTIONS:
+                    text += ": " + cls.KEY_DESCRIPTIONS[key]
+                help.append(text)
+            help.append("")
+        assert not keys, str(keys)
+        return "\n".join(help)
+
 
 class ArchiveFormatter(BaseFormatter):
     KEY_DESCRIPTIONS = {
         "archive": "archive name",
         "name": 'alias of "archive"',
         "comment": "archive comment",
         # *start* is the key used by borg-info for this timestamp, this makes the formats more compatible
         "start": "time (start) of creation of the archive",
         "time": 'alias of "start"',
         "end": "time (end) of creation of the archive",
         "command_line": "command line which was used to create the archive",
         "id": "internal ID of the archive",
         "hostname": "hostname of host on which this archive was created",
         "username": "username of user who created this archive",
+        "size": "size of this archive (data plus metadata, not considering compression and deduplication)",
+        "nfiles": "count of files in this archive",
     }
     KEY_GROUPS = (
         ("archive", "name", "comment", "id"),
         ("start", "time", "end", "command_line"),
         ("hostname", "username"),
+        ("size", "nfiles"),
     )
 
-    @classmethod
-    def available_keys(cls):
-        from ..manifest import ArchiveInfo
-
-        fake_archive_info = ArchiveInfo("archivename", b"\1" * 32, datetime(1970, 1, 1, tzinfo=timezone.utc))
-        formatter = cls("", None, None, None)
-        keys = []
-        keys.extend(formatter.call_keys.keys())
-        keys.extend(formatter.get_item_data(fake_archive_info).keys())
-        return keys
-
-    @classmethod
-    def keys_help(cls):
-        help = []
-        keys = cls.available_keys()
-        for key in cls.FIXED_KEYS:
-            keys.remove(key)
-
-        for group in cls.KEY_GROUPS:
-            for key in group:
-                keys.remove(key)
-                text = "- " + key
-                if key in cls.KEY_DESCRIPTIONS:
-                    text += ": " + cls.KEY_DESCRIPTIONS[key]
-                help.append(text)
-            help.append("")
-        assert not keys, str(keys)
-        return "\n".join(help)
-
-    def __init__(self, format, repository, manifest, key, *, json=False, iec=False):
+    def __init__(self, format, repository, manifest, key, *, iec=False):
+        static_data = {}  # here could be stuff on repo level, above archive level
+        static_data.update(self.FIXED_KEYS)
+        super().__init__(format, static_data)
         self.repository = repository
         self.manifest = manifest
         self.key = key
         self.name = None
         self.id = None
         self._archive = None
-        self.json = json
         self.iec = iec
-        static_keys = {}  # here could be stuff on repo level, above archive level
-        static_keys.update(self.FIXED_KEYS)
-        self.format = partial_format(format, static_keys)
         self.format_keys = {f[1] for f in Formatter().parse(format)}
         self.call_keys = {
-            "hostname": partial(self.get_meta, "hostname"),
-            "username": partial(self.get_meta, "username"),
-            "comment": partial(self.get_meta, "comment"),
-            "command_line": partial(self.get_meta, "command_line"),
+            "hostname": partial(self.get_meta, "hostname", ""),
+            "username": partial(self.get_meta, "username", ""),
+            "comment": partial(self.get_meta, "comment", ""),
+            "command_line": partial(self.get_meta, "command_line", ""),
+            "size": partial(self.get_meta, "size", 0),
+            "nfiles": partial(self.get_meta, "nfiles", 0),
             "end": self.get_ts_end,
         }
         self.used_call_keys = set(self.call_keys) & self.format_keys
-        if self.json:
-            self.item_data = {}
-            self.format_item = self.format_item_json
-        else:
-            self.item_data = static_keys
 
-    def format_item_json(self, item):
-        return json.dumps(self.get_item_data(item), cls=BorgJsonEncoder) + "\n"
-
-    def get_item_data(self, archive_info):
+    def get_item_data(self, archive_info, jsonline=False):
         self.name = archive_info.name
         self.id = archive_info.id
         item_data = {}
-        item_data.update(self.item_data)
+        item_data.update({} if jsonline else self.static_data)
         item_data.update(
             {
                 "name": archive_info.name,
                 "archive": archive_info.name,
                 "id": bin_to_hex(archive_info.id),
                 "time": self.format_time(archive_info.ts),
                 "start": self.format_time(archive_info.ts),
@@ -767,101 +786,79 @@
         """lazy load / update loaded archive"""
         if self._archive is None or self._archive.id != self.id:
             from ..archive import Archive
 
             self._archive = Archive(self.manifest, self.name, iec=self.iec)
         return self._archive
 
-    def get_meta(self, key):
-        return self.archive.metadata.get(key, "")
+    def get_meta(self, key, default=None):
+        return self.archive.metadata.get(key, default)
 
     def get_ts_end(self):
         return self.format_time(self.archive.ts_end)
 
     def format_time(self, ts):
         return OutputTimestamp(ts)
 
 
 class ItemFormatter(BaseFormatter):
     # we provide the hash algos from python stdlib (except shake_*) and additionally xxh64.
     # shake_* is not provided because it uses an incompatible .digest() method to support variable length.
     hash_algorithms = set(hashlib.algorithms_guaranteed).union({"xxh64"}).difference({"shake_128", "shake_256"})
     KEY_DESCRIPTIONS = {
+        "type": "file type (file, dir, symlink, ...)",
+        "mode": "file mode (as in stat)",
+        "uid": "user id of file owner",
+        "gid": "group id of file owner",
+        "user": "user name of file owner",
+        "group": "group name of file owner",
         "path": "file path",
         "target": "link target for symlinks",
         "hlid": "hard link identity (same if hardlinking same fs object)",
+        "flags": "file flags",
         "extra": 'prepends {target} with " -> " for soft links and " link to " for hard links',
+        "size": "file size",
         "dsize": "deduplicated size",
         "num_chunks": "number of chunks in this file",
         "unique_chunks": "number of unique chunks in this file",
+        "mtime": "file modification time",
+        "ctime": "file change time",
+        "atime": "file access time",
+        "isomtime": "file modification time (ISO 8601 format)",
+        "isoctime": "file change time (ISO 8601 format)",
+        "isoatime": "file access time (ISO 8601 format)",
         "xxh64": "XXH64 checksum of this file (note: this is NOT a cryptographic hash!)",
         "health": 'either "healthy" (file ok) or "broken" (if file has all-zero replacement chunks)',
+        "archiveid": "internal ID of the archive",
+        "archivename": "name of the archive",
     }
     KEY_GROUPS = (
         ("type", "mode", "uid", "gid", "user", "group", "path", "target", "hlid", "flags"),
         ("size", "dsize", "num_chunks", "unique_chunks"),
         ("mtime", "ctime", "atime", "isomtime", "isoctime", "isoatime"),
         tuple(sorted(hash_algorithms)),
         ("archiveid", "archivename", "extra"),
         ("health",),
     )
 
     KEYS_REQUIRING_CACHE = ("dsize", "unique_chunks")
 
     @classmethod
-    def available_keys(cls):
-        class FakeArchive:
-            fpr = name = ""
-
-        from ..item import Item
-
-        fake_item = Item(mode=0, path="", user="", group="", mtime=0, uid=0, gid=0)
-        formatter = cls(FakeArchive, "")
-        keys = []
-        keys.extend(formatter.call_keys.keys())
-        keys.extend(formatter.get_item_data(fake_item).keys())
-        return keys
-
-    @classmethod
-    def keys_help(cls):
-        help = []
-        keys = cls.available_keys()
-        for key in cls.FIXED_KEYS:
-            keys.remove(key)
-
-        for group in cls.KEY_GROUPS:
-            for key in group:
-                keys.remove(key)
-                text = "- " + key
-                if key in cls.KEY_DESCRIPTIONS:
-                    text += ": " + cls.KEY_DESCRIPTIONS[key]
-                help.append(text)
-            help.append("")
-        assert not keys, str(keys)
-        return "\n".join(help)
-
-    @classmethod
     def format_needs_cache(cls, format):
         format_keys = {f[1] for f in Formatter().parse(format)}
         return any(key in cls.KEYS_REQUIRING_CACHE for key in format_keys)
 
-    def __init__(self, archive, format, *, json_lines=False):
+    def __init__(self, archive, format):
         from ..checksums import StreamingXXH64
 
+        static_data = {"archivename": archive.name, "archiveid": archive.fpr}
+        static_data.update(self.FIXED_KEYS)
+        super().__init__(format, static_data)
         self.xxh64 = StreamingXXH64
         self.archive = archive
-        self.json_lines = json_lines
-        static_keys = {"archivename": archive.name, "archiveid": archive.fpr}
-        static_keys.update(self.FIXED_KEYS)
-        if self.json_lines:
-            self.item_data = {}
-            self.format_item = self.format_item_json
-        else:
-            self.item_data = static_keys
-        self.format = partial_format(format, static_keys)
         self.format_keys = {f[1] for f in Formatter().parse(format)}
         self.call_keys = {
             "size": self.calculate_size,
             "dsize": partial(self.sum_unique_chunks_metadata, lambda chunk: chunk.size),
             "num_chunks": self.calculate_num_chunks,
             "unique_chunks": partial(self.sum_unique_chunks_metadata, lambda chunk: 1),
             "isomtime": partial(self.format_iso_time, "mtime"),
@@ -871,25 +868,22 @@
             "ctime": partial(self.format_time, "ctime"),
             "atime": partial(self.format_time, "atime"),
         }
         for hash_function in self.hash_algorithms:
             self.call_keys[hash_function] = partial(self.hash_item, hash_function)
         self.used_call_keys = set(self.call_keys) & self.format_keys
 
-    def format_item_json(self, item):
-        return json.dumps(self.get_item_data(item), cls=BorgJsonEncoder) + "\n"
-
-    def get_item_data(self, item):
+    def get_item_data(self, item, jsonline=False):
         item_data = {}
-        item_data.update(self.item_data)
+        item_data.update({} if jsonline else self.static_data)
 
         item_data.update(text_to_json("path", item.path))
         target = item.get("target", "")
         item_data.update(text_to_json("target", target))
-        if not self.json_lines:
+        if not jsonline:
             item_data["extra"] = "" if not target else f" -> {item_data['target']}"
 
         hlid = item.get("hlid")
         hlid = bin_to_hex(hlid) if hlid else ""
         item_data["hlid"] = hlid
 
         mode = stat.filemode(item.mode)
@@ -898,15 +892,15 @@
         item_data["mode"] = mode
 
         item_data["uid"] = item.get("uid")  # int or None
         item_data["gid"] = item.get("gid")  # int or None
         item_data.update(text_to_json("user", item.get("user", str(item_data["uid"]))))
         item_data.update(text_to_json("group", item.get("group", str(item_data["gid"]))))
 
-        if self.json_lines:
+        if jsonline:
             item_data["healthy"] = "chunks_healthy" not in item
         else:
             item_data["health"] = "broken" if "chunks_healthy" in item else "healthy"
         item_data["flags"] = item.get("bsdflags")  # int if flags known, else (if flags unknown) None
         for key in self.used_call_keys:
             item_data[key] = self.call_keys[key](item)
         return item_data
@@ -914,15 +908,15 @@
     def sum_unique_chunks_metadata(self, metadata_func, item):
         """
         sum unique chunks metadata, a unique chunk is a chunk which is referenced globally as often as it is in the
         item
 
         item: The item to sum its unique chunks' metadata
         metadata_func: A function that takes a parameter of type ChunkIndexEntry and returns a number, used to return
-                       the metadata needed from the chunk
+        the metadata needed from the chunk
         """
         chunk_index = self.archive.cache.chunks
         chunks = item.get("chunks", [])
         chunks_counter = Counter(c.id for c in chunks)
         return sum(metadata_func(c) for c in chunks if chunk_index[c.id].refcount == chunks_counter[c.id])
 
     def calculate_num_chunks(self, item):
@@ -946,14 +940,142 @@
     def format_time(self, key, item):
         return OutputTimestamp(safe_timestamp(item.get(key) or item.mtime))
 
     def format_iso_time(self, key, item):
         return self.format_time(key, item).isoformat()
 
 
+class DiffFormatter(BaseFormatter):
+    KEY_DESCRIPTIONS = {
+        "path": "archived file path",
+        "change": "all available changes",
+        "content": "file content change",
+        "mode": "file mode change",
+        "type": "file type change",
+        "owner": "file owner (user/group) change",
+        "user": "file user change",
+        "group": "file group change",
+        "link": "file link change",
+        "directory": "file directory change",
+        "blkdev": "file block device change",
+        "chrdev": "file character device change",
+        "fifo": "file fifo change",
+        "mtime": "file modification time change",
+        "ctime": "file change time change",
+        "isomtime": "file modification time change (ISO 8601)",
+        "isoctime": "file creation time change (ISO 8601)",
+    }
+    KEY_GROUPS = (
+        ("path", "change"),
+        ("content", "mode", "type", "owner", "group", "user"),
+        ("link", "directory", "blkdev", "chrdev", "fifo"),
+        ("mtime", "ctime", "isomtime", "isoctime"),
+    )
+    METADATA = ("mode", "type", "owner", "group", "user", "mtime", "ctime")
+
+    def __init__(self, format, content_only=False):
+        static_data = {}
+        static_data.update(self.FIXED_KEYS)
+        super().__init__(format or "{content}{link}{directory}{blkdev}{chrdev}{fifo} {path}{NL}", static_data)
+        self.content_only = content_only
+        self.format_keys = {f[1] for f in Formatter().parse(format)}
+        self.call_keys = {
+            "content": self.format_content,
+            "mode": self.format_mode,
+            "type": partial(self.format_mode, filetype=True),
+            "owner": partial(self.format_owner),
+            "group": partial(self.format_owner, spec="group"),
+            "user": partial(self.format_owner, spec="user"),
+            "link": partial(self.format_other, "link"),
+            "directory": partial(self.format_other, "directory"),
+            "blkdev": partial(self.format_other, "blkdev"),
+            "chrdev": partial(self.format_other, "chrdev"),
+            "fifo": partial(self.format_other, "fifo"),
+            "mtime": partial(self.format_time, "mtime"),
+            "ctime": partial(self.format_time, "ctime"),
+            "isomtime": partial(self.format_iso_time, "mtime"),
+            "isoctime": partial(self.format_iso_time, "ctime"),
+        }
+        self.used_call_keys = set(self.call_keys) & self.format_keys
+        if self.content_only:
+            self.used_call_keys -= set(self.METADATA)
+
+    def get_item_data(self, item: "ItemDiff", jsonline=False) -> dict:
+        diff_data = {}
+        for key in self.used_call_keys:
+            diff_data[key] = self.call_keys[key](item)
+
+        change = []
+        for key in self.call_keys:
+            if key in ("isomtime", "isoctime"):
+                continue
+            if self.content_only and key in self.METADATA:
+                continue
+            change.append(self.call_keys[key](item))
+        diff_data["change"] = " ".join([v for v in change if v])
+        diff_data["path"] = item.path
+        diff_data.update({} if jsonline else self.static_data)
+        return diff_data
+
+    def format_other(self, key, diff: "ItemDiff"):
+        change = diff.changes().get(key)
+        return f"{change.diff_type}".ljust(27) if change else ""  # 27 is the length of the content change
+
+    def format_mode(self, diff: "ItemDiff", filetype=False):
+        change = diff.type() if filetype else diff.mode()
+        return f"[{change.diff_data['item1']} -> {change.diff_data['item2']}]" if change else ""
+
+    def format_owner(self, diff: "ItemDiff", spec: Literal["owner", "user", "group"] = "owner"):
+        if spec == "user":
+            change = diff.user()
+            return f"[{change.diff_data['item1']} -> {change.diff_data['item2']}]" if change else ""
+        if spec == "group":
+            change = diff.group()
+            return f"[{change.diff_data['item1']} -> {change.diff_data['item2']}]" if change else ""
+        if spec != "owner":
+            raise ValueError(f"Invalid owner spec: {spec}")
+        change = diff.owner()
+        if change:
+            return "[{}:{} -> {}:{}]".format(
+                change.diff_data["item1"][0],
+                change.diff_data["item1"][1],
+                change.diff_data["item2"][0],
+                change.diff_data["item2"][1],
+            )
+        return ""
+
+    def format_content(self, diff: "ItemDiff"):
+        change = diff.content()
+        if change:
+            if change.diff_type == "added":
+                return "{}: {:>20}".format(change.diff_type, format_file_size(change.diff_data["added"]))
+            if change.diff_type == "removed":
+                return "{}: {:>18}".format(change.diff_type, format_file_size(change.diff_data["removed"]))
+            if "added" not in change.diff_data and "removed" not in change.diff_data:
+                return "modified:  (can't get size)"
+            return "{}: {:>8} {:>8}".format(
+                change.diff_type,
+                format_file_size(change.diff_data["added"], precision=1, sign=True),
+                format_file_size(-change.diff_data["removed"], precision=1, sign=True),
+            )
+        return ""
+
+    def format_time(self, key, diff: "ItemDiff"):
+        change = diff.changes().get(key)
+        return f"[{key}: {change.diff_data['item1']} -> {change.diff_data['item2']}]" if change else ""
+
+    def format_iso_time(self, key, diff: "ItemDiff"):
+        change = diff.changes().get(key)
+        return (
+            f"[{key}: {change.diff_data['item1'].isoformat()} -> {change.diff_data['item2'].isoformat()}]"
+            if change
+            else ""
+        )
+
+
 def file_status(mode):
     if stat.S_ISREG(mode):
         return "A"
     elif stat.S_ISDIR(mode):
         return "d"
     elif stat.S_ISBLK(mode):
         return "b"
@@ -1029,15 +1151,15 @@
 
     ellipsis_width = swidth("...")
     msg_width = swidth(msg)
     if space < 8:
         # if there is very little space, just show ...
         return "..." + " " * (space - ellipsis_width)
     if space < ellipsis_width + msg_width:
-        return "{}...{}".format(swidth_slice(msg, space // 2 - ellipsis_width), swidth_slice(msg, -space // 2))
+        return f"{swidth_slice(msg, space // 2 - ellipsis_width)}...{swidth_slice(msg, -space // 2)}"
     return msg + " " * (space - msg_width)
 
 
 class BorgJsonEncoder(json.JSONEncoder):
     def default(self, o):
         from ..repository import Repository
         from ..remote import RemoteRepository
@@ -1117,7 +1239,32 @@
                 value = value.to_unix_nano()
             if isinstance(key, bytes):
                 key = key.decode()
             res[key] = value
         return res
 
     return decode(d)
+
+
+class Highlander(argparse.Action):
+    """make sure some option is only given once"""
+
+    def __init__(self, *args, **kwargs):
+        self.__called = False
+        super().__init__(*args, **kwargs)
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        if self.__called:
+            raise argparse.ArgumentError(self, "There can be only one.")
+        self.__called = True
+        setattr(namespace, self.dest, values)
+
+
+class MakePathSafeAction(Highlander):
+    def __call__(self, parser, namespace, path, option_string=None):
+        try:
+            sanitized_path = make_path_safe(path)
+        except ValueError as e:
+            raise argparse.ArgumentError(self, e)
+        if sanitized_path == ".":
+            raise argparse.ArgumentError(self, f"{path!r} is not a valid file name")
+        setattr(namespace, self.dest, sanitized_path)
```

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/passphrase.py` & `borgbackup-2.0.0b6/src/borg/helpers/passphrase.py`

 * *Files 0% similar despite different names*

```diff
@@ -52,15 +52,15 @@
     @classmethod
     def env_passcommand(cls, default=None):
         passcommand = os.environ.get("BORG_PASSCOMMAND", None)
         if passcommand is not None:
             # passcommand is a system command (not inside pyinstaller env)
             env = prepare_subprocess_env(system=True)
             try:
-                passphrase = subprocess.check_output(shlex.split(passcommand), universal_newlines=True, env=env)
+                passphrase = subprocess.check_output(shlex.split(passcommand), text=True, env=env)
             except (subprocess.CalledProcessError, FileNotFoundError) as e:
                 raise PasscommandFailure(e)
             return cls(passphrase.rstrip("\n"))
 
     @classmethod
     def fd_passphrase(cls):
         try:
```

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/process.py` & `borgbackup-2.0.0b6/src/borg/helpers/process.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/time.py` & `borgbackup-2.0.0b6/src/borg/helpers/time.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/helpers/yes_no.py` & `borgbackup-2.0.0b6/src/borg/helpers/yes_no.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/item.c` & `borgbackup-2.0.0b6/src/borg/item.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
             "src/borg/_item.c"
         ],
@@ -28,16 +28,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -97,16 +97,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -222,15 +226,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -261,15 +265,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -993,31 +997,29 @@
 struct __pyx_obj_4borg_4item___pyx_scope_struct_1_genexpr;
 struct __pyx_obj_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int;
 struct __pyx_obj_4borg_4item___pyx_scope_struct_3_genexpr;
 struct __pyx_obj_4borg_4item___pyx_scope_struct_4_genexpr;
 struct __pyx_obj_4borg_4item___pyx_scope_struct_5_get_size;
 struct __pyx_obj_4borg_4item___pyx_scope_struct_6_genexpr;
 struct __pyx_obj_4borg_4item___pyx_scope_struct_7_genexpr;
-struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__;
-struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr;
 
-/* "borg/item.pyx":117
+/* "borg/item.pyx":119
  * 
  * 
  * cdef class PropDict:             # <<<<<<<<<<<<<<
  *     """
  *     Manage a dictionary via properties.
  */
 struct __pyx_obj_4borg_4item_PropDict {
   PyObject_HEAD
   PyObject *_dict;
 };
 
 
-/* "borg/item.pyx":197
+/* "borg/item.pyx":199
  * 
  * 
  * cdef class PropDictProperty:             # <<<<<<<<<<<<<<
  *     """return a property that deals with self._dict[key] of PropDict"""
  *     cdef readonly str key
  */
 struct __pyx_obj_4borg_4item_PropDictProperty {
@@ -1030,88 +1032,88 @@
   PyObject *encode;
   PyObject *decode;
   PyObject *type_error_msg;
   PyObject *attr_error_msg;
 };
 
 
-/* "borg/item.pyx":248
+/* "borg/item.pyx":250
  * ChunkListEntry = namedtuple('ChunkListEntry', 'id size')
  * 
  * cdef class Item(PropDict):             # <<<<<<<<<<<<<<
  *     """
  *     Item abstraction that deals with validation and the low-level details internally:
  */
 struct __pyx_obj_4borg_4item_Item {
   struct __pyx_obj_4borg_4item_PropDict __pyx_base;
 };
 
 
-/* "borg/item.pyx":410
+/* "borg/item.pyx":412
  * 
  * 
  * cdef class EncryptedKey(PropDict):             # <<<<<<<<<<<<<<
  *     """
  *     EncryptedKey abstraction that deals with validation and the low-level details internally:
  */
 struct __pyx_obj_4borg_4item_EncryptedKey {
   struct __pyx_obj_4borg_4item_PropDict __pyx_base;
 };
 
 
-/* "borg/item.pyx":449
+/* "borg/item.pyx":451
  * 
  * 
  * cdef class Key(PropDict):             # <<<<<<<<<<<<<<
  *     """
  *     Key abstraction that deals with validation and the low-level details internally:
  */
 struct __pyx_obj_4borg_4item_Key {
   struct __pyx_obj_4borg_4item_PropDict __pyx_base;
 };
 
 
-/* "borg/item.pyx":485
+/* "borg/item.pyx":487
  *             self._dict['crypt_key'] = k
  * 
  * cdef class ArchiveItem(PropDict):             # <<<<<<<<<<<<<<
  *     """
  *     ArchiveItem abstraction that deals with validation and the low-level details internally:
  */
 struct __pyx_obj_4borg_4item_ArchiveItem {
   struct __pyx_obj_4borg_4item_PropDict __pyx_base;
 };
 
 
-/* "borg/item.pyx":545
+/* "borg/item.pyx":547
  * 
  * 
  * cdef class ManifestItem(PropDict):             # <<<<<<<<<<<<<<
  *     """
  *     ManifestItem abstraction that deals with validation and the low-level details internally:
  */
 struct __pyx_obj_4borg_4item_ManifestItem {
   struct __pyx_obj_4borg_4item_PropDict __pyx_base;
 };
 
 
-/* "borg/item.pyx":75
+/* "borg/item.pyx":77
  * 
  * 
  * def fix_tuple_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))
  */
 struct __pyx_obj_4borg_4item___pyx_scope_struct__fix_tuple_of_str {
   PyObject_HEAD
   PyObject *__pyx_v_v;
 };
 
 
-/* "borg/item.pyx":78
+/* "borg/item.pyx":80
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))
  *     return tuple(want_str(e) for e in v)             # <<<<<<<<<<<<<<
  * 
  * 
  */
 struct __pyx_obj_4borg_4item___pyx_scope_struct_1_genexpr {
@@ -1120,29 +1122,29 @@
   PyObject *__pyx_v_e;
   PyObject *__pyx_t_0;
   Py_ssize_t __pyx_t_1;
   PyObject *(*__pyx_t_2)(PyObject *);
 };
 
 
-/* "borg/item.pyx":81
+/* "borg/item.pyx":83
  * 
  * 
  * def fix_tuple_of_str_and_int(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))
  */
 struct __pyx_obj_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int {
   PyObject_HEAD
   PyObject *__pyx_v_t;
   PyObject *__pyx_v_v;
 };
 
 
-/* "borg/item.pyx":84
+/* "borg/item.pyx":86
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))
  *     t = tuple(e.decode() if isinstance(e, bytes) else e for e in v)             # <<<<<<<<<<<<<<
  *     assert all(isinstance(e, (str, int)) for e in t), repr(t)
  *     return t
  */
 struct __pyx_obj_4borg_4item___pyx_scope_struct_3_genexpr {
@@ -1151,44 +1153,44 @@
   PyObject *__pyx_v_e;
   PyObject *__pyx_t_0;
   Py_ssize_t __pyx_t_1;
   PyObject *(*__pyx_t_2)(PyObject *);
 };
 
 
-/* "borg/item.pyx":85
+/* "borg/item.pyx":87
  *     assert isinstance(v, (tuple, list))
  *     t = tuple(e.decode() if isinstance(e, bytes) else e for e in v)
  *     assert all(isinstance(e, (str, int)) for e in t), repr(t)             # <<<<<<<<<<<<<<
  *     return t
  * 
  */
 struct __pyx_obj_4borg_4item___pyx_scope_struct_4_genexpr {
   PyObject_HEAD
   struct __pyx_obj_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int *__pyx_outer_scope;
   PyObject *__pyx_v_e;
 };
 
 
-/* "borg/item.pyx":302
+/* "borg/item.pyx":304
  *     part = PropDictProperty(int)  # legacy only
  * 
  *     def get_size(self, *, memorize=False, from_chunks=False, consider_ids=None):             # <<<<<<<<<<<<<<
  *         """
  *         Determine the uncompressed size of this item.
  */
 struct __pyx_obj_4borg_4item___pyx_scope_struct_5_get_size {
   PyObject_HEAD
   PyObject *__pyx_v_attr;
   PyObject *__pyx_v_chunks;
   PyObject *__pyx_v_consider_ids;
 };
 
 
-/* "borg/item.pyx":328
+/* "borg/item.pyx":330
  *                 return 0
  *             if consider_ids is not None:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks if chunk.id in consider_ids)             # <<<<<<<<<<<<<<
  *             else:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks)
  */
 struct __pyx_obj_4borg_4item___pyx_scope_struct_6_genexpr {
@@ -1197,15 +1199,15 @@
   PyObject *__pyx_v_chunk;
   PyObject *__pyx_t_0;
   Py_ssize_t __pyx_t_1;
   PyObject *(*__pyx_t_2)(PyObject *);
 };
 
 
-/* "borg/item.pyx":330
+/* "borg/item.pyx":332
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks if chunk.id in consider_ids)
  *             else:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks)             # <<<<<<<<<<<<<<
  *             # if requested, memorize the precomputed (c)size for items that have an own chunks list:
  *             if memorize:
  */
 struct __pyx_obj_4borg_4item___pyx_scope_struct_7_genexpr {
@@ -1214,47 +1216,16 @@
   PyObject *__pyx_v_chunk;
   PyObject *__pyx_t_0;
   Py_ssize_t __pyx_t_1;
   PyObject *(*__pyx_t_2)(PyObject *);
 };
 
 
-/* "borg/item.pyx":665
- *         return self._changes
- * 
- *     def __repr__(self):             # <<<<<<<<<<<<<<
- *         if self.equal:
- *             return 'equal'
- */
-struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ {
-  PyObject_HEAD
-  PyObject *__pyx_v_self;
-};
-
 
-/* "borg/item.pyx":668
- *         if self.equal:
- *             return 'equal'
- *         return ' '.join(str for d, str in self._changes)             # <<<<<<<<<<<<<<
- * 
- *     def _equal(self, chunk_iterator1, chunk_iterator2):
- */
-struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr {
-  PyObject_HEAD
-  struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *__pyx_outer_scope;
-  PyObject *__pyx_v_d;
-  PyObject *__pyx_v_str;
-  PyObject *__pyx_t_0;
-  Py_ssize_t __pyx_t_1;
-  PyObject *(*__pyx_t_2)(PyObject *);
-};
-
-
-
-/* "borg/item.pyx":197
+/* "borg/item.pyx":199
  * 
  * 
  * cdef class PropDictProperty:             # <<<<<<<<<<<<<<
  *     """return a property that deals with self._dict[key] of PropDict"""
  *     cdef readonly str key
  */
 
@@ -1698,14 +1669,17 @@
 #define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
 static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
 #else
 #define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
 #define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
 #endif
 
+/* RaiseMappingExpected.proto */
+static void __Pyx_RaiseMappingExpectedError(PyObject* arg);
+
 /* StringJoin.proto */
 #if PY_MAJOR_VERSION < 3
 #define __Pyx_PyString_Join __Pyx_PyBytes_Join
 #define __Pyx_PyBaseString_Join(s, v) (PyUnicode_CheckExact(s) ? PyUnicode_Join(s, v) : __Pyx_PyBytes_Join(s, v))
 #else
 #define __Pyx_PyString_Join PyUnicode_Join
 #define __Pyx_PyBaseString_Join PyUnicode_Join
@@ -1716,14 +1690,36 @@
     #else
     #define __Pyx_PyBytes_Join _PyBytes_Join
     #endif
 #else
 static CYTHON_INLINE PyObject* __Pyx_PyBytes_Join(PyObject* sep, PyObject* values);
 #endif
 
+/* PyObjectFormatSimple.proto */
+#if CYTHON_COMPILING_IN_PYPY
+    #define __Pyx_PyObject_FormatSimple(s, f) (\
+        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
+        PyObject_Format(s, f))
+#elif PY_MAJOR_VERSION < 3
+    #define __Pyx_PyObject_FormatSimple(s, f) (\
+        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
+        likely(PyString_CheckExact(s)) ? PyUnicode_FromEncodedObject(s, NULL, "strict") :\
+        PyObject_Format(s, f))
+#elif CYTHON_USE_TYPE_SLOTS
+    #define __Pyx_PyObject_FormatSimple(s, f) (\
+        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
+        likely(PyLong_CheckExact(s)) ? PyLong_Type.tp_str(s) :\
+        likely(PyFloat_CheckExact(s)) ? PyFloat_Type.tp_str(s) :\
+        PyObject_Format(s, f))
+#else
+    #define __Pyx_PyObject_FormatSimple(s, f) (\
+        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
+        PyObject_Format(s, f))
+#endif
+
 /* IterNext.proto */
 #define __Pyx_PyIter_Next(obj) __Pyx_PyIter_Next2(obj, NULL)
 static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject *, PyObject *);
 
 /* PyObject_GenericGetAttrNoDict.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
@@ -1744,22 +1740,30 @@
 /* SetupReduce.proto */
 static int __Pyx_setup_reduce(PyObject* type_obj);
 
 /* SetVTable.proto */
 static int __Pyx_SetVtable(PyObject *dict, void *vtable);
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto
-#define __PYX_HAVE_RT_ImportType_proto
-enum __Pyx_ImportType_CheckSize {
-   __Pyx_ImportType_CheckSize_Error = 0,
-   __Pyx_ImportType_CheckSize_Warn = 1,
-   __Pyx_ImportType_CheckSize_Ignore = 2
+#ifndef __PYX_HAVE_RT_ImportType_proto_0_29_35
+#define __PYX_HAVE_RT_ImportType_proto_0_29_35
+#if __STDC_VERSION__ >= 201112L
+#include <stdalign.h>
+#endif
+#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) alignof(s)
+#else
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_35(s) sizeof(void*)
+#endif
+enum __Pyx_ImportType_CheckSize_0_29_35 {
+   __Pyx_ImportType_CheckSize_Error_0_29_35 = 0,
+   __Pyx_ImportType_CheckSize_Warn_0_29_35 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_0_29_35 = 2
 };
-static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size);
 #endif
 
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
@@ -2030,16 +2034,14 @@
 static PyTypeObject *__pyx_ptype_4borg_4item___pyx_scope_struct_1_genexpr = 0;
 static PyTypeObject *__pyx_ptype_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int = 0;
 static PyTypeObject *__pyx_ptype_4borg_4item___pyx_scope_struct_3_genexpr = 0;
 static PyTypeObject *__pyx_ptype_4borg_4item___pyx_scope_struct_4_genexpr = 0;
 static PyTypeObject *__pyx_ptype_4borg_4item___pyx_scope_struct_5_get_size = 0;
 static PyTypeObject *__pyx_ptype_4borg_4item___pyx_scope_struct_6_genexpr = 0;
 static PyTypeObject *__pyx_ptype_4borg_4item___pyx_scope_struct_7_genexpr = 0;
-static PyTypeObject *__pyx_ptype_4borg_4item___pyx_scope_struct_8___repr__ = 0;
-static PyTypeObject *__pyx_ptype_4borg_4item___pyx_scope_struct_9_genexpr = 0;
 static PyObject *__pyx_f_4borg_4item__init_names(int __pyx_skip_dispatch); /*proto*/
 #define __Pyx_MODULE_NAME "borg.item"
 extern int __pyx_module_is_main_borg__item;
 int __pyx_module_is_main_borg__item = 0;
 
 /* Implementation of 'borg.item' */
 static PyObject *__pyx_builtin_TypeError;
@@ -2054,76 +2056,73 @@
 static const char __pyx_k_e[] = "e";
 static const char __pyx_k_t[] = "t";
 static const char __pyx_k_v[] = "v";
 static const char __pyx_k__9[] = "";
 static const char __pyx_k_ap[] = "ap";
 static const char __pyx_k_bp[] = "bp";
 static const char __pyx_k_ce[] = "ce";
-static const char __pyx_k_ch[] = "ch";
 static const char __pyx_k_g1[] = "g1";
 static const char __pyx_k_g2[] = "g2";
 static const char __pyx_k_id[] = "id";
-static const char __pyx_k_pd[] = "pd";
 static const char __pyx_k_sz[] = "sz";
 static const char __pyx_k_u1[] = "u1";
 static const char __pyx_k_u2[] = "u2";
-static const char __pyx_k_9_9[] = "{:>9} {:>9}";
 static const char __pyx_k_Key[] = "Key";
 static const char __pyx_k__20[] = " ";
-static const char __pyx_k__23[] = "[{}:{} -> {}:{}]";
-static const char __pyx_k__24[] = "[{} -> {}]";
-static const char __pyx_k_chg[] = "chg";
 static const char __pyx_k_doc[] = "__doc__";
 static const char __pyx_k_get[] = "get";
 static const char __pyx_k_gid[] = "gid";
 static const char __pyx_k_k_r[] = "k == %r";
 static const char __pyx_k_key[] = "key";
 static const char __pyx_k_pop[] = "pop";
 static const char __pyx_k_s_s[] = "%s (%s)";
 static const char __pyx_k_sum[] = "sum";
+static const char __pyx_k_ts1[] = "ts1";
+static const char __pyx_k_ts2[] = "ts2";
 static const char __pyx_k_uid[] = "uid";
 static const char __pyx_k_Item[] = "Item";
 static const char __pyx_k_alen[] = "alen";
 static const char __pyx_k_args[] = "args";
 static const char __pyx_k_attr[] = "attr";
 static const char __pyx_k_blen[] = "blen";
 static const char __pyx_k_data[] = "data";
 static const char __pyx_k_fifo[] = "fifo";
 static const char __pyx_k_hash[] = "hash";
 static const char __pyx_k_hlid[] = "hlid";
 static const char __pyx_k_init[] = "__init__";
 static const char __pyx_k_join[] = "join";
+static const char __pyx_k_keys[] = "keys";
 static const char __pyx_k_link[] = "link";
 static const char __pyx_k_list[] = "list";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_mode[] = "mode";
 static const char __pyx_k_name[] = "__name__";
 static const char __pyx_k_part[] = "part";
 static const char __pyx_k_path[] = "path";
 static const char __pyx_k_rdev[] = "rdev";
 static const char __pyx_k_read[] = "read";
 static const char __pyx_k_repr[] = "__repr__";
 static const char __pyx_k_salt[] = "salt";
 static const char __pyx_k_self[] = "self";
 static const char __pyx_k_send[] = "send";
-static const char __pyx_k_sign[] = "sign";
 static const char __pyx_k_size[] = "size";
 static const char __pyx_k_stat[] = "stat";
 static const char __pyx_k_test[] = "__test__";
 static const char __pyx_k_time[] = "time";
 static const char __pyx_k_type[] = "type";
 static const char __pyx_k_user[] = "user";
 static const char __pyx_k_vars[] = "vars";
 static const char __pyx_k_added[] = "added ";
 static const char __pyx_k_atime[] = "atime";
+static const char __pyx_k_attrs[] = "attrs";
 static const char __pyx_k_check[] = "check";
 static const char __pyx_k_class[] = "__class__";
 static const char __pyx_k_close[] = "close";
 static const char __pyx_k_ctime[] = "ctime";
-static const char __pyx_k_equal[] = "_equal";
+static const char __pyx_k_equal[] = "equal";
 static const char __pyx_k_group[] = "group";
 static const char __pyx_k_item1[] = "item1";
 static const char __pyx_k_item2[] = "item2";
 static const char __pyx_k_items[] = "items";
 static const char __pyx_k_mode1[] = "mode1";
 static const char __pyx_k_mode2[] = "mode2";
 static const char __pyx_k_mtime[] = "mtime";
@@ -2138,15 +2137,14 @@
 static const char __pyx_k_chrdev[] = "chrdev";
 static const char __pyx_k_chunks[] = "chunks";
 static const char __pyx_k_config[] = "config";
 static const char __pyx_k_decode[] = "decode";
 static const char __pyx_k_delete[] = "delete";
 static const char __pyx_k_encode[] = "encode";
 static const char __pyx_k_errors[] = "errors";
-static const char __pyx_k_format[] = "format";
 static const char __pyx_k_g_attr[] = "g_attr";
 static const char __pyx_k_id_key[] = "id_key";
 static const char __pyx_k_import[] = "__import__";
 static const char __pyx_k_int_ns[] = "int (ns)";
 static const char __pyx_k_is_blk[] = "is_blk";
 static const char __pyx_k_is_chr[] = "is_chr";
 static const char __pyx_k_is_dir[] = "is_dir";
@@ -2165,55 +2163,53 @@
 static const char __pyx_k_S_ISBLK[] = "S_ISBLK";
 static const char __pyx_k_S_ISCHR[] = "S_ISCHR";
 static const char __pyx_k_S_ISDIR[] = "S_ISDIR";
 static const char __pyx_k_S_ISLNK[] = "S_ISLNK";
 static const char __pyx_k_added_2[] = "added";
 static const char __pyx_k_as_dict[] = "as_dict";
 static const char __pyx_k_changes[] = "_changes";
+static const char __pyx_k_chunk_1[] = "chunk_1";
+static const char __pyx_k_chunk_2[] = "chunk_2";
 static const char __pyx_k_cmdline[] = "cmdline";
 static const char __pyx_k_comment[] = "comment";
+static const char __pyx_k_content[] = "content";
 static const char __pyx_k_default[] = "default";
 static const char __pyx_k_deleted[] = "deleted";
 static const char __pyx_k_enc_key[] = "enc_key";
-static const char __pyx_k_equal_2[] = "equal";
 static const char __pyx_k_fix_key[] = "fix_key";
 static const char __pyx_k_genexpr[] = "genexpr";
 static const char __pyx_k_helpers[] = "helpers";
 static const char __pyx_k_id_size[] = "id size";
 static const char __pyx_k_is_fifo[] = "is_fifo";
 static const char __pyx_k_is_link[] = "is_link";
 static const char __pyx_k_is_type[] = "_is_type";
 static const char __pyx_k_item1_2[] = "_item1";
 static const char __pyx_k_item2_2[] = "_item2";
 static const char __pyx_k_prepare[] = "__prepare__";
 static const char __pyx_k_removed[] = "removed ";
 static const char __pyx_k_replace[] = "replace";
+static const char __pyx_k_to_dict[] = "to_dict";
 static const char __pyx_k_version[] = "version";
 static const char __pyx_k_ItemDiff[] = "ItemDiff";
 static const char __pyx_k_KeyError[] = "KeyError";
 static const char __pyx_k_PropDict[] = "PropDict";
 static const char __pyx_k_S_ISFIFO[] = "S_ISFIFO";
 static const char __pyx_k_acl_nfs4[] = "acl_nfs4";
-static const char __pyx_k_added_13[] = "added {:>13}";
 static const char __pyx_k_archives[] = "archives";
 static const char __pyx_k_bsdflags[] = "bsdflags";
 static const char __pyx_k_ce_fixed[] = "ce_fixed";
 static const char __pyx_k_chunks_a[] = "chunks_a";
 static const char __pyx_k_chunks_b[] = "chunks_b";
 static const char __pyx_k_filemode[] = "filemode";
 static const char __pyx_k_get_size[] = "get_size";
 static const char __pyx_k_getstate[] = "__getstate__";
 static const char __pyx_k_hostname[] = "hostname";
 static const char __pyx_k_issubset[] = "issubset";
 static const char __pyx_k_memorize[] = "memorize";
 static const char __pyx_k_modified[] = "modified";
-static const char __pyx_k_new_mode[] = "new_mode";
-static const char __pyx_k_new_user[] = "new_user";
-static const char __pyx_k_old_mode[] = "old_mode";
-static const char __pyx_k_old_user[] = "old_user";
 static const char __pyx_k_qualname[] = "__qualname__";
 static const char __pyx_k_set_name[] = "__set_name__";
 static const char __pyx_k_setstate[] = "__setstate__";
 static const char __pyx_k_slicelen[] = "slicelen";
 static const char __pyx_k_time_end[] = "time_end";
 static const char __pyx_k_username[] = "username";
 static const char __pyx_k_want_str[] = "want_str";
@@ -2223,47 +2219,50 @@
 static const char __pyx_k_added_ids[] = "added_ids";
 static const char __pyx_k_algorithm[] = "algorithm";
 static const char __pyx_k_attr_list[] = "attr_list";
 static const char __pyx_k_birthtime[] = "birthtime";
 static const char __pyx_k_borg_item[] = "borg.item";
 static const char __pyx_k_changes_2[] = "changes";
 static const char __pyx_k_check_key[] = "_check_key";
+static const char __pyx_k_chunk_1_2[] = "_chunk_1";
+static const char __pyx_k_chunk_2_2[] = "_chunk_2";
 static const char __pyx_k_constants[] = "constants";
 static const char __pyx_k_crypt_key[] = "crypt_key";
 static const char __pyx_k_data_dict[] = "data_dict";
+static const char __pyx_k_diff_data[] = "diff_data";
+static const char __pyx_k_diff_type[] = "diff_type";
 static const char __pyx_k_directory[] = "directory";
 static const char __pyx_k_from_optr[] = "from_optr";
 static const char __pyx_k_item_keys[] = "item_keys";
 static const char __pyx_k_item_ptrs[] = "item_ptrs";
 static const char __pyx_k_item_type[] = "item_type";
 static const char __pyx_k_link_diff[] = "_link_diff";
 static const char __pyx_k_mandatory[] = "mandatory";
 static const char __pyx_k_metaclass[] = "__metaclass__";
 static const char __pyx_k_mode_diff[] = "_mode_diff";
-static const char __pyx_k_new_group[] = "new_group";
-static const char __pyx_k_old_group[] = "old_group";
-static const char __pyx_k_precision[] = "precision";
 static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
 static const char __pyx_k_removed_2[] = "removed";
 static const char __pyx_k_timestamp[] = "timestamp";
+static const char __pyx_k_DiffChange[] = "DiffChange";
 static const char __pyx_k_StableDict[] = "StableDict";
 static const char __pyx_k_VALID_KEYS[] = "VALID_KEYS";
 static const char __pyx_k_ValueError[] = "ValueError";
 static const char __pyx_k_acl_access[] = "acl_access";
 static const char __pyx_k_chunk_ids1[] = "chunk_ids1";
 static const char __pyx_k_chunk_ids2[] = "chunk_ids2";
 static const char __pyx_k_chunk_seed[] = "chunk_seed";
 static const char __pyx_k_from_bytes[] = "from_bytes";
+static const char __pyx_k_helpers_fs[] = "helpers.fs";
 static const char __pyx_k_iterations[] = "iterations";
 static const char __pyx_k_namedtuple[] = "namedtuple";
 static const char __pyx_k_owner_diff[] = "_owner_diff";
 static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
-static const char __pyx_k_removed_11[] = "removed {:>11}";
 static const char __pyx_k_size_parts[] = "size_parts";
 static const char __pyx_k_subclasses[] = "__subclasses__";
+static const char __pyx_k_time_diffs[] = "_time_diffs";
 static const char __pyx_k_value_type[] = "value_type";
 static const char __pyx_k_want_bytes[] = "want_bytes";
 static const char __pyx_k_API_VERSION[] = "API_VERSION";
 static const char __pyx_k_ArchiveItem[] = "ArchiveItem";
 static const char __pyx_k_acl_default[] = "acl_default";
 static const char __pyx_k_argon2_type[] = "argon2_type";
 static const char __pyx_k_collections[] = "collections";
@@ -2271,71 +2270,91 @@
 static const char __pyx_k_numeric_ids[] = "numeric_ids";
 static const char __pyx_k_removed_ids[] = "removed_ids";
 static const char __pyx_k_ARCHIVE_KEYS[] = "ARCHIVE_KEYS";
 static const char __pyx_k_EncryptedKey[] = "EncryptedKey";
 static const char __pyx_k_ManifestItem[] = "ManifestItem";
 static const char __pyx_k_acl_extended[] = "acl_extended";
 static const char __pyx_k_changed_link[] = "changed link";
+static const char __pyx_k_changed_mode[] = "changed mode";
+static const char __pyx_k_changed_type[] = "changed type";
+static const char __pyx_k_changed_user[] = "changed user";
 static const char __pyx_k_command_line[] = "command_line";
 static const char __pyx_k_consider_ids[] = "consider_ids";
 static const char __pyx_k_content_diff[] = "_content_diff";
+static const char __pyx_k_content_only[] = "content_only";
 static const char __pyx_k_enc_hmac_key[] = "enc_hmac_key";
+static const char __pyx_k_helpers_time[] = "helpers.time";
 static const char __pyx_k_nfiles_parts[] = "nfiles_parts";
 static const char __pyx_k_tam_required[] = "tam_required";
 static const char __pyx_k_tuple_of_str[] = "tuple of str";
+static const char __pyx_k_ItemDiff_mode[] = "ItemDiff.mode";
+static const char __pyx_k_ItemDiff_type[] = "ItemDiff.type";
+static const char __pyx_k_ItemDiff_user[] = "ItemDiff.user";
+static const char __pyx_k_changed_group[] = "changed group";
+static const char __pyx_k_changed_owner[] = "changed owner";
 static const char __pyx_k_content_equal[] = "_content_equal";
 static const char __pyx_k_feature_flags[] = "feature_flags";
 static const char __pyx_k_fix_str_value[] = "fix_str_value";
 static const char __pyx_k_fix_timestamp[] = "fix_timestamp";
 static const char __pyx_k_internal_dict[] = "internal_dict";
 static const char __pyx_k_numeric_ids_2[] = "_numeric_ids";
 static const char __pyx_k_presence_diff[] = "_presence_diff";
 static const char __pyx_k_recreate_args[] = "recreate_args";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_repository_id[] = "repository_id";
 static const char __pyx_k_AttributeError[] = "AttributeError";
 static const char __pyx_k_ChunkListEntry[] = "ChunkListEntry";
+static const char __pyx_k_ItemDiff_ctime[] = "ItemDiff.ctime";
+static const char __pyx_k_ItemDiff_equal[] = "ItemDiff.equal";
+static const char __pyx_k_ItemDiff_group[] = "ItemDiff.group";
+static const char __pyx_k_ItemDiff_mtime[] = "ItemDiff.mtime";
+static const char __pyx_k_ItemDiff_owner[] = "ItemDiff.owner";
 static const char __pyx_k_chunker_params[] = "chunker_params";
 static const char __pyx_k_chunks_healthy[] = "chunks_healthy";
 static const char __pyx_k_create_deleted[] = "create_deleted";
+static const char __pyx_k_safe_timestamp[] = "safe_timestamp";
 static const char __pyx_k_ItemDiff___init[] = "ItemDiff.__init__";
 static const char __pyx_k_ItemDiff___repr[] = "ItemDiff.__repr__";
-static const char __pyx_k_ItemDiff__equal[] = "ItemDiff._equal";
-static const char __pyx_k_chunk_iterator1[] = "chunk_iterator1";
-static const char __pyx_k_chunk_iterator2[] = "chunk_iterator2";
+static const char __pyx_k_OutputTimestamp[] = "OutputTimestamp";
 static const char __pyx_k_fix_bytes_value[] = "fix_bytes_value";
 static const char __pyx_k_fix_list_of_str[] = "fix_list_of_str";
 static const char __pyx_k_hardlink_master[] = "hardlink_master";
 static const char __pyx_k_helpers_msgpack[] = "helpers.msgpack";
 static const char __pyx_k_key_must_be_str[] = "key must be str";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
 static const char __pyx_k_surrogateescape[] = "surrogateescape";
 static const char __pyx_k_update_internal[] = "update_internal";
 static const char __pyx_k_value_type_name[] = "value_type_name";
 static const char __pyx_k_ItemDiff_changes[] = "ItemDiff.changes";
+static const char __pyx_k_ItemDiff_content[] = "ItemDiff.content";
 static const char __pyx_k_PropDictProperty[] = "PropDictProperty";
 static const char __pyx_k_argon2_time_cost[] = "argon2_time_cost";
 static const char __pyx_k_dict_of_str_dict[] = "dict of str -> dict";
 static const char __pyx_k_fix_tuple_of_str[] = "fix_tuple_of_str";
 static const char __pyx_k_format_file_size[] = "format_file_size";
 static const char __pyx_k_int_to_timestamp[] = "int_to_timestamp";
 static const char __pyx_k_recreate_cmdline[] = "recreate_cmdline";
 static const char __pyx_k_timestamp_to_int[] = "timestamp_to_int";
+static const char __pyx_k_DiffChange___init[] = "DiffChange.__init__";
 static const char __pyx_k_fix_list_of_bytes[] = "fix_list_of_bytes";
 static const char __pyx_k_s_internal_dict_r[] = "%s(internal_dict=%r)";
 static const char __pyx_k_s_value_must_be_s[] = "%s value must be %s";
 static const char __pyx_k_src_borg_item_pyx[] = "src/borg/item.pyx";
+static const char __pyx_k_to_sanitized_path[] = "to_sanitized_path";
+static const char __pyx_k_DiffChange_to_dict[] = "DiffChange.to_dict";
 static const char __pyx_k_argon2_memory_cost[] = "argon2_memory_cost";
 static const char __pyx_k_argon2_parallelism[] = "argon2_parallelism";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_recreate_source_id[] = "recreate_source_id";
 static const char __pyx_k_ItemDiff__link_diff[] = "ItemDiff._link_diff";
 static const char __pyx_k_ItemDiff__mode_diff[] = "ItemDiff._mode_diff";
 static const char __pyx_k_ItemDiff__owner_diff[] = "ItemDiff._owner_diff";
+static const char __pyx_k_ItemDiff__time_diffs[] = "ItemDiff._time_diffs";
 static const char __pyx_k_not_a_str_object_but[] = "not a str object, but ";
+static const char __pyx_k_assert_sanitized_path[] = "assert_sanitized_path";
 static const char __pyx_k_attribute_s_not_found[] = "attribute %s not found";
 static const char __pyx_k_can_compare_chunk_ids[] = "can_compare_chunk_ids";
 static const char __pyx_k_chunks_contents_equal[] = "chunks_contents_equal";
 static const char __pyx_k_recreate_command_line[] = "recreate_command_line";
 static const char __pyx_k_surrogate_escaped_str[] = "surrogate-escaped str";
 static const char __pyx_k_ItemDiff__content_diff[] = "ItemDiff._content_diff";
 static const char __pyx_k_not_a_bytes_object_but[] = "not a bytes object, but ";
@@ -2345,110 +2364,126 @@
 static const char __pyx_k_get_size_locals_genexpr[] = "get_size.<locals>.genexpr";
 static const char __pyx_k_recreate_partial_chunks[] = "recreate_partial_chunks";
 static const char __pyx_k_data_dict_must_be_a_dict[] = "data_dict must be a dict";
 static const char __pyx_k_fix_list_of_chunkentries[] = "fix_list_of_chunkentries";
 static const char __pyx_k_fix_tuple_of_str_and_int[] = "fix_tuple_of_str_and_int";
 static const char __pyx_k_key_s_is_not_a_valid_key[] = "key '%s' is not a valid key";
 static const char __pyx_k_internal_dict_must_be_a_dict[] = "internal_dict must be a dict";
-static const char __pyx_k_Comparison_of_two_items_from_di[] = "\n    Comparison of two items from different archives.\n\n    The items may have different paths and still be considered equal (e.g. for renames).\n    It does not include extended or time attributes in the comparison.\n    ";
+static const char __pyx_k_Comparison_of_two_items_from_di[] = "\n    Comparison of two items from different archives.\n\n    The items may have different paths and still be considered equal (e.g. for renames).\n    ";
+static const char __pyx_k_Stores_a_change_in_a_diff_The_d[] = "\n    Stores a change in a diff.\n\n    The diff_type denotes the type of change, e.g. \"added\", \"removed\", \"modified\".\n    The diff_data contains additional information about the change, e.g. the old and new mode.\n    ";
 static const char __pyx_k_fix_tuple_of_str_and_int_locals[] = "fix_tuple_of_str_and_int.<locals>.genexpr";
 static const char __pyx_k_fix_tuple_of_str_locals_genexpr[] = "fix_tuple_of_str.<locals>.genexpr";
 static const char __pyx_k_Can_t_store_size_when_considerin[] = "Can't store size when considering only certain ids";
-static const char __pyx_k_ItemDiff___repr___locals_genexpr[] = "ItemDiff.__repr__.<locals>.genexpr";
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
 static PyObject *__pyx_kp_s_1_2_01;
-static PyObject *__pyx_kp_s_9_9;
 static PyObject *__pyx_n_s_API_VERSION;
 static PyObject *__pyx_n_s_ARCHIVE_KEYS;
 static PyObject *__pyx_n_s_ArchiveItem;
 static PyObject *__pyx_n_s_AttributeError;
 static PyObject *__pyx_kp_s_Can_t_store_size_when_considerin;
 static PyObject *__pyx_n_s_ChunkListEntry;
 static PyObject *__pyx_kp_s_Comparison_of_two_items_from_di;
+static PyObject *__pyx_n_s_DiffChange;
+static PyObject *__pyx_n_s_DiffChange___init;
+static PyObject *__pyx_n_s_DiffChange_to_dict;
 static PyObject *__pyx_n_s_EncryptedKey;
 static PyObject *__pyx_n_s_ITEM_KEYS;
 static PyObject *__pyx_n_s_Item;
 static PyObject *__pyx_n_s_ItemDiff;
 static PyObject *__pyx_n_s_ItemDiff___init;
 static PyObject *__pyx_n_s_ItemDiff___repr;
-static PyObject *__pyx_n_s_ItemDiff___repr___locals_genexpr;
 static PyObject *__pyx_n_s_ItemDiff__content_diff;
 static PyObject *__pyx_n_s_ItemDiff__content_equal;
-static PyObject *__pyx_n_s_ItemDiff__equal;
 static PyObject *__pyx_n_s_ItemDiff__link_diff;
 static PyObject *__pyx_n_s_ItemDiff__mode_diff;
 static PyObject *__pyx_n_s_ItemDiff__owner_diff;
 static PyObject *__pyx_n_s_ItemDiff__presence_diff;
+static PyObject *__pyx_n_s_ItemDiff__time_diffs;
 static PyObject *__pyx_n_s_ItemDiff_changes;
+static PyObject *__pyx_n_s_ItemDiff_content;
+static PyObject *__pyx_n_s_ItemDiff_ctime;
+static PyObject *__pyx_n_s_ItemDiff_equal;
+static PyObject *__pyx_n_s_ItemDiff_group;
+static PyObject *__pyx_n_s_ItemDiff_mode;
+static PyObject *__pyx_n_s_ItemDiff_mtime;
+static PyObject *__pyx_n_s_ItemDiff_owner;
+static PyObject *__pyx_n_s_ItemDiff_type;
+static PyObject *__pyx_n_s_ItemDiff_user;
 static PyObject *__pyx_n_s_Key;
 static PyObject *__pyx_n_s_KeyError;
 static PyObject *__pyx_n_s_ManifestItem;
+static PyObject *__pyx_n_s_OutputTimestamp;
 static PyObject *__pyx_n_s_PropDict;
 static PyObject *__pyx_n_s_PropDictProperty;
 static PyObject *__pyx_n_s_S_ISBLK;
 static PyObject *__pyx_n_s_S_ISCHR;
 static PyObject *__pyx_n_s_S_ISDIR;
 static PyObject *__pyx_n_s_S_ISFIFO;
 static PyObject *__pyx_n_s_S_ISLNK;
 static PyObject *__pyx_n_s_StableDict;
+static PyObject *__pyx_kp_s_Stores_a_change_in_a_diff_The_d;
 static PyObject *__pyx_n_s_Timestamp;
 static PyObject *__pyx_n_s_TypeError;
 static PyObject *__pyx_n_s_VALID_KEYS;
 static PyObject *__pyx_n_s_ValueError;
 static PyObject *__pyx_kp_s__20;
-static PyObject *__pyx_kp_s__23;
-static PyObject *__pyx_kp_s__24;
 static PyObject *__pyx_kp_b__9;
 static PyObject *__pyx_n_s_a;
 static PyObject *__pyx_n_s_acl_access;
 static PyObject *__pyx_n_s_acl_default;
 static PyObject *__pyx_n_s_acl_extended;
 static PyObject *__pyx_n_s_acl_nfs4;
-static PyObject *__pyx_kp_s_added;
-static PyObject *__pyx_kp_s_added_13;
+static PyObject *__pyx_kp_u_added;
 static PyObject *__pyx_n_s_added_2;
 static PyObject *__pyx_n_s_added_ids;
 static PyObject *__pyx_n_s_alen;
 static PyObject *__pyx_n_s_algorithm;
 static PyObject *__pyx_n_s_ap;
 static PyObject *__pyx_n_s_archives;
 static PyObject *__pyx_n_s_argon2_memory_cost;
 static PyObject *__pyx_n_s_argon2_parallelism;
 static PyObject *__pyx_n_s_argon2_time_cost;
 static PyObject *__pyx_n_s_argon2_type;
 static PyObject *__pyx_n_s_args;
 static PyObject *__pyx_n_s_as_dict;
+static PyObject *__pyx_n_s_assert_sanitized_path;
 static PyObject *__pyx_n_s_atime;
 static PyObject *__pyx_n_s_attr;
 static PyObject *__pyx_n_s_attr_list;
 static PyObject *__pyx_kp_s_attribute_s_not_found;
+static PyObject *__pyx_n_s_attrs;
 static PyObject *__pyx_n_s_b;
 static PyObject *__pyx_n_s_birthtime;
 static PyObject *__pyx_n_s_blen;
 static PyObject *__pyx_n_s_blkdev;
 static PyObject *__pyx_n_s_borg_item;
 static PyObject *__pyx_n_s_bp;
 static PyObject *__pyx_n_s_bsdflags;
 static PyObject *__pyx_n_s_c;
 static PyObject *__pyx_n_s_can_compare_chunk_ids;
 static PyObject *__pyx_n_s_can_compare_chunk_ids_2;
 static PyObject *__pyx_n_s_ce;
 static PyObject *__pyx_n_s_ce_fixed;
-static PyObject *__pyx_n_s_ch;
+static PyObject *__pyx_kp_s_changed_group;
 static PyObject *__pyx_kp_s_changed_link;
+static PyObject *__pyx_kp_s_changed_mode;
+static PyObject *__pyx_kp_s_changed_owner;
+static PyObject *__pyx_kp_s_changed_type;
+static PyObject *__pyx_kp_s_changed_user;
 static PyObject *__pyx_n_s_changes;
 static PyObject *__pyx_n_s_changes_2;
 static PyObject *__pyx_n_s_check;
 static PyObject *__pyx_n_s_check_key;
-static PyObject *__pyx_n_s_chg;
 static PyObject *__pyx_n_s_chrdev;
+static PyObject *__pyx_n_s_chunk_1;
+static PyObject *__pyx_n_s_chunk_1_2;
+static PyObject *__pyx_n_s_chunk_2;
+static PyObject *__pyx_n_s_chunk_2_2;
 static PyObject *__pyx_n_s_chunk_ids1;
 static PyObject *__pyx_n_s_chunk_ids2;
-static PyObject *__pyx_n_s_chunk_iterator1;
-static PyObject *__pyx_n_s_chunk_iterator2;
 static PyObject *__pyx_n_s_chunk_seed;
 static PyObject *__pyx_n_s_chunker_params;
 static PyObject *__pyx_n_s_chunks;
 static PyObject *__pyx_n_s_chunks_a;
 static PyObject *__pyx_n_s_chunks_b;
 static PyObject *__pyx_n_s_chunks_contents_equal;
 static PyObject *__pyx_n_s_chunks_healthy;
@@ -2458,35 +2493,38 @@
 static PyObject *__pyx_n_s_cmdline;
 static PyObject *__pyx_n_s_collections;
 static PyObject *__pyx_n_s_command_line;
 static PyObject *__pyx_n_s_comment;
 static PyObject *__pyx_n_s_config;
 static PyObject *__pyx_n_s_consider_ids;
 static PyObject *__pyx_n_s_constants;
+static PyObject *__pyx_n_s_content;
 static PyObject *__pyx_n_s_content_diff;
 static PyObject *__pyx_n_s_content_equal;
+static PyObject *__pyx_n_s_content_only;
 static PyObject *__pyx_n_s_create_deleted;
 static PyObject *__pyx_n_s_crypt_key;
 static PyObject *__pyx_n_s_ctime;
 static PyObject *__pyx_n_s_data;
 static PyObject *__pyx_n_s_data_dict;
 static PyObject *__pyx_kp_s_data_dict_must_be_a_dict;
 static PyObject *__pyx_n_s_decode;
 static PyObject *__pyx_n_s_default;
 static PyObject *__pyx_n_s_delete;
 static PyObject *__pyx_n_s_deleted;
 static PyObject *__pyx_kp_s_dict_of_str_dict;
+static PyObject *__pyx_n_s_diff_data;
+static PyObject *__pyx_n_s_diff_type;
 static PyObject *__pyx_n_s_directory;
 static PyObject *__pyx_n_s_doc;
 static PyObject *__pyx_n_s_e;
 static PyObject *__pyx_n_s_enc_hmac_key;
 static PyObject *__pyx_n_s_enc_key;
 static PyObject *__pyx_n_s_encode;
 static PyObject *__pyx_n_s_equal;
-static PyObject *__pyx_n_s_equal_2;
 static PyObject *__pyx_n_s_errors;
 static PyObject *__pyx_n_s_feature_flags;
 static PyObject *__pyx_n_s_fifo;
 static PyObject *__pyx_n_s_filemode;
 static PyObject *__pyx_n_s_fix_bytes_value;
 static PyObject *__pyx_n_s_fix_key;
 static PyObject *__pyx_n_s_fix_list_of_bytes;
@@ -2494,15 +2532,14 @@
 static PyObject *__pyx_n_s_fix_list_of_str;
 static PyObject *__pyx_n_s_fix_str_value;
 static PyObject *__pyx_n_s_fix_timestamp;
 static PyObject *__pyx_n_s_fix_tuple_of_str;
 static PyObject *__pyx_n_s_fix_tuple_of_str_and_int;
 static PyObject *__pyx_n_s_fix_tuple_of_str_and_int_locals;
 static PyObject *__pyx_n_s_fix_tuple_of_str_locals_genexpr;
-static PyObject *__pyx_n_s_format;
 static PyObject *__pyx_n_s_format_file_size;
 static PyObject *__pyx_n_s_from_bytes;
 static PyObject *__pyx_n_s_from_chunks;
 static PyObject *__pyx_n_s_from_optr;
 static PyObject *__pyx_n_s_g1;
 static PyObject *__pyx_n_s_g2;
 static PyObject *__pyx_n_s_g_attr;
@@ -2512,15 +2549,17 @@
 static PyObject *__pyx_n_s_get_size_locals_genexpr;
 static PyObject *__pyx_n_s_getstate;
 static PyObject *__pyx_n_s_gid;
 static PyObject *__pyx_n_s_group;
 static PyObject *__pyx_n_s_hardlink_master;
 static PyObject *__pyx_n_s_hash;
 static PyObject *__pyx_n_s_helpers;
+static PyObject *__pyx_n_s_helpers_fs;
 static PyObject *__pyx_n_s_helpers_msgpack;
+static PyObject *__pyx_n_s_helpers_time;
 static PyObject *__pyx_n_s_hlid;
 static PyObject *__pyx_n_s_hostname;
 static PyObject *__pyx_n_s_id;
 static PyObject *__pyx_n_s_id_key;
 static PyObject *__pyx_kp_s_id_size;
 static PyObject *__pyx_n_s_import;
 static PyObject *__pyx_n_s_init;
@@ -2545,14 +2584,15 @@
 static PyObject *__pyx_n_s_items;
 static PyObject *__pyx_n_s_iterations;
 static PyObject *__pyx_n_s_join;
 static PyObject *__pyx_kp_s_k_r;
 static PyObject *__pyx_n_s_key;
 static PyObject *__pyx_kp_s_key_must_be_str;
 static PyObject *__pyx_kp_s_key_s_is_not_a_valid_key;
+static PyObject *__pyx_n_s_keys;
 static PyObject *__pyx_n_s_link;
 static PyObject *__pyx_n_s_link_diff;
 static PyObject *__pyx_n_s_list;
 static PyObject *__pyx_n_s_little;
 static PyObject *__pyx_n_s_main;
 static PyObject *__pyx_n_s_mandatory;
 static PyObject *__pyx_n_s_memorize;
@@ -2563,66 +2603,57 @@
 static PyObject *__pyx_n_s_mode_diff;
 static PyObject *__pyx_n_s_modified;
 static PyObject *__pyx_n_s_module;
 static PyObject *__pyx_n_s_mtime;
 static PyObject *__pyx_n_s_name;
 static PyObject *__pyx_n_s_name_2;
 static PyObject *__pyx_n_s_namedtuple;
-static PyObject *__pyx_n_s_new_group;
-static PyObject *__pyx_n_s_new_mode;
-static PyObject *__pyx_n_s_new_user;
 static PyObject *__pyx_n_s_nfiles;
 static PyObject *__pyx_n_s_nfiles_parts;
 static PyObject *__pyx_n_s_nlink;
 static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
 static PyObject *__pyx_kp_u_not_a_bytes_object_but;
 static PyObject *__pyx_kp_u_not_a_str_object_but;
 static PyObject *__pyx_n_s_numeric_ids;
 static PyObject *__pyx_n_s_numeric_ids_2;
-static PyObject *__pyx_n_s_old_group;
-static PyObject *__pyx_n_s_old_mode;
-static PyObject *__pyx_n_s_old_user;
 static PyObject *__pyx_n_s_owner;
 static PyObject *__pyx_n_s_owner_diff;
 static PyObject *__pyx_n_s_part;
 static PyObject *__pyx_n_s_path;
-static PyObject *__pyx_n_s_pd;
 static PyObject *__pyx_n_s_pop;
-static PyObject *__pyx_n_s_precision;
 static PyObject *__pyx_n_s_prepare;
 static PyObject *__pyx_n_s_presence_diff;
 static PyObject *__pyx_n_s_pyx_vtable;
 static PyObject *__pyx_n_s_qualname;
 static PyObject *__pyx_n_s_rdev;
 static PyObject *__pyx_n_s_read;
 static PyObject *__pyx_n_s_recreate_args;
 static PyObject *__pyx_n_s_recreate_cmdline;
 static PyObject *__pyx_n_s_recreate_command_line;
 static PyObject *__pyx_n_s_recreate_partial_chunks;
 static PyObject *__pyx_n_s_recreate_source_id;
 static PyObject *__pyx_n_s_reduce;
 static PyObject *__pyx_n_s_reduce_cython;
 static PyObject *__pyx_n_s_reduce_ex;
-static PyObject *__pyx_kp_s_removed;
-static PyObject *__pyx_kp_s_removed_11;
+static PyObject *__pyx_kp_u_removed;
 static PyObject *__pyx_n_s_removed_2;
 static PyObject *__pyx_n_s_removed_ids;
 static PyObject *__pyx_n_s_replace;
 static PyObject *__pyx_n_s_repository_id;
 static PyObject *__pyx_n_s_repr;
 static PyObject *__pyx_kp_s_s_internal_dict_r;
 static PyObject *__pyx_kp_s_s_s;
 static PyObject *__pyx_kp_s_s_value_must_be_s;
+static PyObject *__pyx_n_s_safe_timestamp;
 static PyObject *__pyx_n_s_salt;
 static PyObject *__pyx_n_s_self;
 static PyObject *__pyx_n_s_send;
 static PyObject *__pyx_n_s_set_name;
 static PyObject *__pyx_n_s_setstate;
 static PyObject *__pyx_n_s_setstate_cython;
-static PyObject *__pyx_n_s_sign;
 static PyObject *__pyx_n_s_signed;
 static PyObject *__pyx_n_s_size;
 static PyObject *__pyx_n_s_size_parts;
 static PyObject *__pyx_n_s_slicelen;
 static PyObject *__pyx_n_s_source;
 static PyObject *__pyx_kp_s_src_borg_item_pyx;
 static PyObject *__pyx_n_s_stat;
@@ -2634,17 +2665,22 @@
 static PyObject *__pyx_n_s_sz;
 static PyObject *__pyx_n_s_t;
 static PyObject *__pyx_n_s_tam_required;
 static PyObject *__pyx_n_s_target;
 static PyObject *__pyx_n_s_test;
 static PyObject *__pyx_n_s_throw;
 static PyObject *__pyx_n_s_time;
+static PyObject *__pyx_n_s_time_diffs;
 static PyObject *__pyx_n_s_time_end;
 static PyObject *__pyx_n_s_timestamp;
 static PyObject *__pyx_n_s_timestamp_to_int;
+static PyObject *__pyx_n_s_to_dict;
+static PyObject *__pyx_n_s_to_sanitized_path;
+static PyObject *__pyx_n_s_ts1;
+static PyObject *__pyx_n_s_ts2;
 static PyObject *__pyx_kp_s_tuple_of_str;
 static PyObject *__pyx_n_s_type;
 static PyObject *__pyx_n_s_u1;
 static PyObject *__pyx_n_s_u2;
 static PyObject *__pyx_n_s_u_attr;
 static PyObject *__pyx_n_s_uid;
 static PyObject *__pyx_n_s_update;
@@ -2721,25 +2757,35 @@
 static PyObject *__pyx_pf_4borg_4item_11ArchiveItem_update_internal(struct __pyx_obj_4borg_4item_ArchiveItem *__pyx_v_self, PyObject *__pyx_v_d); /* proto */
 static PyObject *__pyx_pf_4borg_4item_11ArchiveItem_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_4borg_4item_ArchiveItem *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_4borg_4item_11ArchiveItem_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_4borg_4item_ArchiveItem *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_4borg_4item_12ManifestItem_update_internal(struct __pyx_obj_4borg_4item_ManifestItem *__pyx_v_self, PyObject *__pyx_v_d); /* proto */
 static PyObject *__pyx_pf_4borg_4item_12ManifestItem_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_4borg_4item_ManifestItem *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_4borg_4item_12ManifestItem_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_4borg_4item_ManifestItem *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_4borg_4item_22_init_names(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
-static PyObject *__pyx_pf_4borg_4item_8ItemDiff___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_item1, PyObject *__pyx_v_item2, PyObject *__pyx_v_chunk_iterator1, PyObject *__pyx_v_chunk_iterator2, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_can_compare_chunk_ids); /* proto */
+static PyObject *__pyx_pf_4borg_4item_10DiffChange___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_diff_type, PyObject *__pyx_v_diff_data); /* proto */
+static PyObject *__pyx_pf_4borg_4item_10DiffChange_2to_dict(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item1, PyObject *__pyx_v_item2, PyObject *__pyx_v_chunk_1, PyObject *__pyx_v_chunk_2, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_can_compare_chunk_ids); /* proto */
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_2changes(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_4borg_4item_8ItemDiff_8__repr___genexpr(PyObject *__pyx_self); /* proto */
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_4__repr__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_4borg_4item_8ItemDiff_6_equal(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_chunk_iterator1, PyObject *__pyx_v_chunk_iterator2); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_6equal(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_content_only); /* proto */
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_8_presence_diff(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_item_type); /* proto */
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_10_link_diff(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_12_content_diff(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_14_owner_diff(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_16_mode_diff(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_4borg_4item_8ItemDiff_18_content_equal(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_chunk_iterator1, PyObject *__pyx_v_chunk_iterator2); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_18_time_diffs(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_20content(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_22ctime(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_24mtime(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_26mode(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_28type(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_30owner(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_32user(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_34group(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_36_content_equal(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_4borg_4item_24chunks_contents_equal(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_chunks_a, PyObject *__pyx_v_chunks_b); /* proto */
 static PyObject *__pyx_tp_new_4borg_4item_PropDict(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item_PropDictProperty(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item_Item(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item_EncryptedKey(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item_Key(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item_ArchiveItem(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
@@ -2748,18 +2794,15 @@
 static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_1_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_3_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_4_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_5_get_size(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_6_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_7_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
-static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_8___repr__(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
-static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_9_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_int_0;
-static PyObject *__pyx_int_1;
 static PyObject *__pyx_tuple_;
 static PyObject *__pyx_tuple__2;
 static PyObject *__pyx_tuple__3;
 static PyObject *__pyx_tuple__4;
 static PyObject *__pyx_tuple__5;
 static PyObject *__pyx_tuple__6;
 static PyObject *__pyx_tuple__7;
@@ -2772,63 +2815,87 @@
 static PyObject *__pyx_tuple__15;
 static PyObject *__pyx_tuple__16;
 static PyObject *__pyx_tuple__17;
 static PyObject *__pyx_tuple__18;
 static PyObject *__pyx_tuple__19;
 static PyObject *__pyx_tuple__21;
 static PyObject *__pyx_tuple__22;
+static PyObject *__pyx_tuple__23;
 static PyObject *__pyx_tuple__25;
 static PyObject *__pyx_tuple__27;
 static PyObject *__pyx_tuple__29;
 static PyObject *__pyx_tuple__31;
 static PyObject *__pyx_tuple__33;
 static PyObject *__pyx_tuple__35;
 static PyObject *__pyx_tuple__37;
 static PyObject *__pyx_tuple__39;
 static PyObject *__pyx_tuple__41;
 static PyObject *__pyx_tuple__43;
 static PyObject *__pyx_tuple__45;
-static PyObject *__pyx_tuple__47;
+static PyObject *__pyx_tuple__46;
 static PyObject *__pyx_tuple__48;
-static PyObject *__pyx_tuple__50;
+static PyObject *__pyx_tuple__49;
 static PyObject *__pyx_tuple__51;
 static PyObject *__pyx_tuple__53;
-static PyObject *__pyx_tuple__55;
-static PyObject *__pyx_tuple__57;
-static PyObject *__pyx_tuple__59;
+static PyObject *__pyx_tuple__54;
+static PyObject *__pyx_tuple__56;
+static PyObject *__pyx_tuple__58;
+static PyObject *__pyx_tuple__60;
 static PyObject *__pyx_tuple__61;
 static PyObject *__pyx_tuple__63;
 static PyObject *__pyx_tuple__65;
 static PyObject *__pyx_tuple__67;
 static PyObject *__pyx_tuple__69;
+static PyObject *__pyx_tuple__71;
+static PyObject *__pyx_tuple__73;
+static PyObject *__pyx_tuple__75;
+static PyObject *__pyx_tuple__77;
+static PyObject *__pyx_tuple__79;
+static PyObject *__pyx_tuple__81;
+static PyObject *__pyx_tuple__83;
+static PyObject *__pyx_tuple__85;
+static PyObject *__pyx_tuple__87;
+static PyObject *__pyx_tuple__89;
+static PyObject *__pyx_tuple__91;
+static PyObject *__pyx_codeobj__24;
 static PyObject *__pyx_codeobj__26;
 static PyObject *__pyx_codeobj__28;
 static PyObject *__pyx_codeobj__30;
 static PyObject *__pyx_codeobj__32;
 static PyObject *__pyx_codeobj__34;
 static PyObject *__pyx_codeobj__36;
 static PyObject *__pyx_codeobj__38;
 static PyObject *__pyx_codeobj__40;
 static PyObject *__pyx_codeobj__42;
 static PyObject *__pyx_codeobj__44;
-static PyObject *__pyx_codeobj__46;
-static PyObject *__pyx_codeobj__49;
+static PyObject *__pyx_codeobj__47;
+static PyObject *__pyx_codeobj__50;
 static PyObject *__pyx_codeobj__52;
-static PyObject *__pyx_codeobj__54;
-static PyObject *__pyx_codeobj__56;
-static PyObject *__pyx_codeobj__58;
-static PyObject *__pyx_codeobj__60;
+static PyObject *__pyx_codeobj__55;
+static PyObject *__pyx_codeobj__57;
+static PyObject *__pyx_codeobj__59;
 static PyObject *__pyx_codeobj__62;
 static PyObject *__pyx_codeobj__64;
 static PyObject *__pyx_codeobj__66;
 static PyObject *__pyx_codeobj__68;
 static PyObject *__pyx_codeobj__70;
+static PyObject *__pyx_codeobj__72;
+static PyObject *__pyx_codeobj__74;
+static PyObject *__pyx_codeobj__76;
+static PyObject *__pyx_codeobj__78;
+static PyObject *__pyx_codeobj__80;
+static PyObject *__pyx_codeobj__82;
+static PyObject *__pyx_codeobj__84;
+static PyObject *__pyx_codeobj__86;
+static PyObject *__pyx_codeobj__88;
+static PyObject *__pyx_codeobj__90;
+static PyObject *__pyx_codeobj__92;
 /* Late includes */
 
-/* "borg/item.pyx":21
+/* "borg/item.pyx":23
  * 
  * 
  * def fix_key(data, key, *, errors='strict'):             # <<<<<<<<<<<<<<
  *     """if k is a bytes-typed key, migrate key/value to a str-typed key in dict data"""
  *     if isinstance(key, bytes):
  */
 
@@ -2866,38 +2933,38 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fix_key", 1, 2, 2, 1); __PYX_ERR(0, 21, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fix_key", 1, 2, 2, 1); __PYX_ERR(0, 23, __pyx_L3_error)
         }
       }
       if (kw_args == 1) {
         const Py_ssize_t index = 2;
         PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
         if (value) { values[index] = value; kw_args--; }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fix_key") < 0)) __PYX_ERR(0, 21, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fix_key") < 0)) __PYX_ERR(0, 23, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_data = values[0];
     __pyx_v_key = values[1];
     __pyx_v_errors = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("fix_key", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 21, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("fix_key", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 23, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.fix_key", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_fix_key(__pyx_self, __pyx_v_data, __pyx_v_key, __pyx_v_errors);
 
@@ -2917,119 +2984,119 @@
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fix_key", 0);
   __Pyx_INCREF(__pyx_v_key);
 
-  /* "borg/item.pyx":23
+  /* "borg/item.pyx":25
  * def fix_key(data, key, *, errors='strict'):
  *     """if k is a bytes-typed key, migrate key/value to a str-typed key in dict data"""
  *     if isinstance(key, bytes):             # <<<<<<<<<<<<<<
  *         value = data.pop(key)
  *         key = key.decode('utf-8', errors=errors)
  */
   __pyx_t_1 = PyBytes_Check(__pyx_v_key); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/item.pyx":24
+    /* "borg/item.pyx":26
  *     """if k is a bytes-typed key, migrate key/value to a str-typed key in dict data"""
  *     if isinstance(key, bytes):
  *         value = data.pop(key)             # <<<<<<<<<<<<<<
  *         key = key.decode('utf-8', errors=errors)
  *         data[key] = value
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_pop); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 24, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_pop); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 26, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_key) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_key);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 24, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 26, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_v_value = __pyx_t_3;
     __pyx_t_3 = 0;
 
-    /* "borg/item.pyx":25
+    /* "borg/item.pyx":27
  *     if isinstance(key, bytes):
  *         value = data.pop(key)
  *         key = key.decode('utf-8', errors=errors)             # <<<<<<<<<<<<<<
  *         data[key] = value
  *     assert isinstance(key, str)
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_key, __pyx_n_s_decode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 25, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_key, __pyx_n_s_decode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 27, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 25, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 27, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_errors, __pyx_v_errors) < 0) __PYX_ERR(0, 25, __pyx_L1_error)
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 25, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_errors, __pyx_v_errors) < 0) __PYX_ERR(0, 27, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 27, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF_SET(__pyx_v_key, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "borg/item.pyx":26
+    /* "borg/item.pyx":28
  *         value = data.pop(key)
  *         key = key.decode('utf-8', errors=errors)
  *         data[key] = value             # <<<<<<<<<<<<<<
  *     assert isinstance(key, str)
  *     return key
  */
-    if (unlikely(PyObject_SetItem(__pyx_v_data, __pyx_v_key, __pyx_v_value) < 0)) __PYX_ERR(0, 26, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_data, __pyx_v_key, __pyx_v_value) < 0)) __PYX_ERR(0, 28, __pyx_L1_error)
 
-    /* "borg/item.pyx":23
+    /* "borg/item.pyx":25
  * def fix_key(data, key, *, errors='strict'):
  *     """if k is a bytes-typed key, migrate key/value to a str-typed key in dict data"""
  *     if isinstance(key, bytes):             # <<<<<<<<<<<<<<
  *         value = data.pop(key)
  *         key = key.decode('utf-8', errors=errors)
  */
   }
 
-  /* "borg/item.pyx":27
+  /* "borg/item.pyx":29
  *         key = key.decode('utf-8', errors=errors)
  *         data[key] = value
  *     assert isinstance(key, str)             # <<<<<<<<<<<<<<
  *     return key
  * 
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_2 = PyString_Check(__pyx_v_key); 
     if (unlikely(!(__pyx_t_2 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 27, __pyx_L1_error)
+      __PYX_ERR(0, 29, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":28
+  /* "borg/item.pyx":30
  *         data[key] = value
  *     assert isinstance(key, str)
  *     return key             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_key);
   __pyx_r = __pyx_v_key;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":21
+  /* "borg/item.pyx":23
  * 
  * 
  * def fix_key(data, key, *, errors='strict'):             # <<<<<<<<<<<<<<
  *     """if k is a bytes-typed key, migrate key/value to a str-typed key in dict data"""
  *     if isinstance(key, bytes):
  */
 
@@ -3044,15 +3111,15 @@
   __Pyx_XDECREF(__pyx_v_value);
   __Pyx_XDECREF(__pyx_v_key);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":31
+/* "borg/item.pyx":33
  * 
  * 
  * def fix_str_value(data, key, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """makes sure that data[key] is a str (decode if it is bytes)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  */
 
@@ -3092,25 +3159,25 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fix_str_value", 0, 2, 3, 1); __PYX_ERR(0, 31, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fix_str_value", 0, 2, 3, 1); __PYX_ERR(0, 33, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_errors);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fix_str_value") < 0)) __PYX_ERR(0, 31, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fix_str_value") < 0)) __PYX_ERR(0, 33, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
@@ -3120,15 +3187,15 @@
     }
     __pyx_v_data = values[0];
     __pyx_v_key = values[1];
     __pyx_v_errors = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("fix_str_value", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 31, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("fix_str_value", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 33, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.fix_str_value", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_2fix_str_value(__pyx_self, __pyx_v_data, __pyx_v_key, __pyx_v_errors);
 
@@ -3147,90 +3214,90 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fix_str_value", 0);
 
-  /* "borg/item.pyx":33
+  /* "borg/item.pyx":35
  * def fix_str_value(data, key, errors='surrogateescape'):
  *     """makes sure that data[key] is a str (decode if it is bytes)"""
  *     assert isinstance(key, str)  # fix_key must be called first             # <<<<<<<<<<<<<<
  *     value = data[key]
  *     value = want_str(value, errors=errors)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_1 = PyString_Check(__pyx_v_key); 
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 33, __pyx_L1_error)
+      __PYX_ERR(0, 35, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":34
+  /* "borg/item.pyx":36
  *     """makes sure that data[key] is a str (decode if it is bytes)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  *     value = data[key]             # <<<<<<<<<<<<<<
  *     value = want_str(value, errors=errors)
  *     data[key] = value
  */
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 34, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 36, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_v_value = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":35
+  /* "borg/item.pyx":37
  *     assert isinstance(key, str)  # fix_key must be called first
  *     value = data[key]
  *     value = want_str(value, errors=errors)             # <<<<<<<<<<<<<<
  *     data[key] = value
  *     return value
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_want_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 35, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_want_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 37, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 35, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 37, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(__pyx_v_value);
   __Pyx_GIVEREF(__pyx_v_value);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_value);
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 35, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 37, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_errors, __pyx_v_errors) < 0) __PYX_ERR(0, 35, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 35, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_errors, __pyx_v_errors) < 0) __PYX_ERR(0, 37, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 37, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_5);
   __pyx_t_5 = 0;
 
-  /* "borg/item.pyx":36
+  /* "borg/item.pyx":38
  *     value = data[key]
  *     value = want_str(value, errors=errors)
  *     data[key] = value             # <<<<<<<<<<<<<<
  *     return value
  * 
  */
-  if (unlikely(PyObject_SetItem(__pyx_v_data, __pyx_v_key, __pyx_v_value) < 0)) __PYX_ERR(0, 36, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_v_data, __pyx_v_key, __pyx_v_value) < 0)) __PYX_ERR(0, 38, __pyx_L1_error)
 
-  /* "borg/item.pyx":37
+  /* "borg/item.pyx":39
  *     value = want_str(value, errors=errors)
  *     data[key] = value
  *     return value             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_value);
   __pyx_r = __pyx_v_value;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":31
+  /* "borg/item.pyx":33
  * 
  * 
  * def fix_str_value(data, key, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """makes sure that data[key] is a str (decode if it is bytes)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  */
 
@@ -3245,15 +3312,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_value);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":40
+/* "borg/item.pyx":42
  * 
  * 
  * def fix_bytes_value(data, key):             # <<<<<<<<<<<<<<
  *     """makes sure that data[key] is bytes (encode if it is str)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  */
 
@@ -3289,32 +3356,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_key)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fix_bytes_value", 1, 2, 2, 1); __PYX_ERR(0, 40, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fix_bytes_value", 1, 2, 2, 1); __PYX_ERR(0, 42, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fix_bytes_value") < 0)) __PYX_ERR(0, 40, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fix_bytes_value") < 0)) __PYX_ERR(0, 42, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_data = values[0];
     __pyx_v_key = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("fix_bytes_value", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 40, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("fix_bytes_value", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 42, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.fix_bytes_value", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_4fix_bytes_value(__pyx_self, __pyx_v_data, __pyx_v_key);
 
@@ -3332,92 +3399,92 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fix_bytes_value", 0);
 
-  /* "borg/item.pyx":42
+  /* "borg/item.pyx":44
  * def fix_bytes_value(data, key):
  *     """makes sure that data[key] is bytes (encode if it is str)"""
  *     assert isinstance(key, str)  # fix_key must be called first             # <<<<<<<<<<<<<<
  *     value = data[key]
  *     value = want_bytes(value)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_1 = PyString_Check(__pyx_v_key); 
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 42, __pyx_L1_error)
+      __PYX_ERR(0, 44, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":43
+  /* "borg/item.pyx":45
  *     """makes sure that data[key] is bytes (encode if it is str)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  *     value = data[key]             # <<<<<<<<<<<<<<
  *     value = want_bytes(value)
  *     data[key] = value
  */
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 43, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 45, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_v_value = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":44
+  /* "borg/item.pyx":46
  *     assert isinstance(key, str)  # fix_key must be called first
  *     value = data[key]
  *     value = want_bytes(value)             # <<<<<<<<<<<<<<
  *     data[key] = value
  *     return value
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 44, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 46, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_value) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_value);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 46, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":45
+  /* "borg/item.pyx":47
  *     value = data[key]
  *     value = want_bytes(value)
  *     data[key] = value             # <<<<<<<<<<<<<<
  *     return value
  * 
  */
-  if (unlikely(PyObject_SetItem(__pyx_v_data, __pyx_v_key, __pyx_v_value) < 0)) __PYX_ERR(0, 45, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_v_data, __pyx_v_key, __pyx_v_value) < 0)) __PYX_ERR(0, 47, __pyx_L1_error)
 
-  /* "borg/item.pyx":46
+  /* "borg/item.pyx":48
  *     value = want_bytes(value)
  *     data[key] = value
  *     return value             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_value);
   __pyx_r = __pyx_v_value;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":40
+  /* "borg/item.pyx":42
  * 
  * 
  * def fix_bytes_value(data, key):             # <<<<<<<<<<<<<<
  *     """makes sure that data[key] is bytes (encode if it is str)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  */
 
@@ -3431,15 +3498,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_value);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":49
+/* "borg/item.pyx":51
  * 
  * 
  * def fix_list_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of str"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -3473,15 +3540,15 @@
   PyObject *__pyx_t_9 = NULL;
   PyObject *__pyx_t_10 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fix_list_of_str", 0);
 
-  /* "borg/item.pyx":51
+  /* "borg/item.pyx":53
  * def fix_list_of_str(v):
  *     """make sure we have a list of str"""
  *     assert isinstance(v, (tuple, list))             # <<<<<<<<<<<<<<
  *     return [want_str(e) for e in v]
  * 
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -3495,104 +3562,104 @@
     }
     __pyx_t_3 = PyList_Check(__pyx_v_v); 
     __pyx_t_2 = (__pyx_t_3 != 0);
     __pyx_t_1 = __pyx_t_2;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 51, __pyx_L1_error)
+      __PYX_ERR(0, 53, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":52
+  /* "borg/item.pyx":54
  *     """make sure we have a list of str"""
  *     assert isinstance(v, (tuple, list))
  *     return [want_str(e) for e in v]             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   { /* enter inner scope */
-    __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 52, __pyx_L7_error)
+    __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 54, __pyx_L7_error)
     __Pyx_GOTREF(__pyx_t_4);
     if (likely(PyList_CheckExact(__pyx_v_v)) || PyTuple_CheckExact(__pyx_v_v)) {
       __pyx_t_5 = __pyx_v_v; __Pyx_INCREF(__pyx_t_5); __pyx_t_6 = 0;
       __pyx_t_7 = NULL;
     } else {
-      __pyx_t_6 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_v_v); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 52, __pyx_L7_error)
+      __pyx_t_6 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_v_v); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 54, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_7 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 52, __pyx_L7_error)
+      __pyx_t_7 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 54, __pyx_L7_error)
     }
     for (;;) {
       if (likely(!__pyx_t_7)) {
         if (likely(PyList_CheckExact(__pyx_t_5))) {
           if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_5)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_8 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 52, __pyx_L7_error)
+          __pyx_t_8 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 54, __pyx_L7_error)
           #else
-          __pyx_t_8 = PySequence_ITEM(__pyx_t_5, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 52, __pyx_L7_error)
+          __pyx_t_8 = PySequence_ITEM(__pyx_t_5, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 54, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_8);
           #endif
         } else {
           if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_5)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_8 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 52, __pyx_L7_error)
+          __pyx_t_8 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 54, __pyx_L7_error)
           #else
-          __pyx_t_8 = PySequence_ITEM(__pyx_t_5, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 52, __pyx_L7_error)
+          __pyx_t_8 = PySequence_ITEM(__pyx_t_5, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 54, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_8);
           #endif
         }
       } else {
         __pyx_t_8 = __pyx_t_7(__pyx_t_5);
         if (unlikely(!__pyx_t_8)) {
           PyObject* exc_type = PyErr_Occurred();
           if (exc_type) {
             if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 52, __pyx_L7_error)
+            else __PYX_ERR(0, 54, __pyx_L7_error)
           }
           break;
         }
         __Pyx_GOTREF(__pyx_t_8);
       }
       __Pyx_XDECREF_SET(__pyx_7genexpr__pyx_v_e, __pyx_t_8);
       __pyx_t_8 = 0;
-      __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_want_str); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 52, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_want_str); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 54, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_10 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
         __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_9);
         if (likely(__pyx_t_10)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
           __Pyx_INCREF(__pyx_t_10);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_9, function);
         }
       }
       __pyx_t_8 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_10, __pyx_7genexpr__pyx_v_e) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_7genexpr__pyx_v_e);
       __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
-      if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 52, __pyx_L7_error)
+      if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 54, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_4, (PyObject*)__pyx_t_8))) __PYX_ERR(0, 52, __pyx_L7_error)
+      if (unlikely(__Pyx_ListComp_Append(__pyx_t_4, (PyObject*)__pyx_t_8))) __PYX_ERR(0, 54, __pyx_L7_error)
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_7genexpr__pyx_v_e); __pyx_7genexpr__pyx_v_e = 0;
     goto __pyx_L10_exit_scope;
     __pyx_L7_error:;
     __Pyx_XDECREF(__pyx_7genexpr__pyx_v_e); __pyx_7genexpr__pyx_v_e = 0;
     goto __pyx_L1_error;
     __pyx_L10_exit_scope:;
   } /* exit inner scope */
   __pyx_r = __pyx_t_4;
   __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":49
+  /* "borg/item.pyx":51
  * 
  * 
  * def fix_list_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of str"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -3608,15 +3675,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_7genexpr__pyx_v_e);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":55
+/* "borg/item.pyx":57
  * 
  * 
  * def fix_list_of_bytes(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of bytes"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -3650,15 +3717,15 @@
   PyObject *__pyx_t_9 = NULL;
   PyObject *__pyx_t_10 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fix_list_of_bytes", 0);
 
-  /* "borg/item.pyx":57
+  /* "borg/item.pyx":59
  * def fix_list_of_bytes(v):
  *     """make sure we have a list of bytes"""
  *     assert isinstance(v, (tuple, list))             # <<<<<<<<<<<<<<
  *     return [want_bytes(e) for e in v]
  * 
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -3672,104 +3739,104 @@
     }
     __pyx_t_3 = PyList_Check(__pyx_v_v); 
     __pyx_t_2 = (__pyx_t_3 != 0);
     __pyx_t_1 = __pyx_t_2;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 57, __pyx_L1_error)
+      __PYX_ERR(0, 59, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":58
+  /* "borg/item.pyx":60
  *     """make sure we have a list of bytes"""
  *     assert isinstance(v, (tuple, list))
  *     return [want_bytes(e) for e in v]             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   { /* enter inner scope */
-    __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 58, __pyx_L7_error)
+    __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 60, __pyx_L7_error)
     __Pyx_GOTREF(__pyx_t_4);
     if (likely(PyList_CheckExact(__pyx_v_v)) || PyTuple_CheckExact(__pyx_v_v)) {
       __pyx_t_5 = __pyx_v_v; __Pyx_INCREF(__pyx_t_5); __pyx_t_6 = 0;
       __pyx_t_7 = NULL;
     } else {
-      __pyx_t_6 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_v_v); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 58, __pyx_L7_error)
+      __pyx_t_6 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_v_v); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 60, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_7 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 58, __pyx_L7_error)
+      __pyx_t_7 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 60, __pyx_L7_error)
     }
     for (;;) {
       if (likely(!__pyx_t_7)) {
         if (likely(PyList_CheckExact(__pyx_t_5))) {
           if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_5)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_8 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 58, __pyx_L7_error)
+          __pyx_t_8 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 60, __pyx_L7_error)
           #else
-          __pyx_t_8 = PySequence_ITEM(__pyx_t_5, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 58, __pyx_L7_error)
+          __pyx_t_8 = PySequence_ITEM(__pyx_t_5, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 60, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_8);
           #endif
         } else {
           if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_5)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_8 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 58, __pyx_L7_error)
+          __pyx_t_8 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 60, __pyx_L7_error)
           #else
-          __pyx_t_8 = PySequence_ITEM(__pyx_t_5, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 58, __pyx_L7_error)
+          __pyx_t_8 = PySequence_ITEM(__pyx_t_5, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 60, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_8);
           #endif
         }
       } else {
         __pyx_t_8 = __pyx_t_7(__pyx_t_5);
         if (unlikely(!__pyx_t_8)) {
           PyObject* exc_type = PyErr_Occurred();
           if (exc_type) {
             if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 58, __pyx_L7_error)
+            else __PYX_ERR(0, 60, __pyx_L7_error)
           }
           break;
         }
         __Pyx_GOTREF(__pyx_t_8);
       }
       __Pyx_XDECREF_SET(__pyx_8genexpr1__pyx_v_e, __pyx_t_8);
       __pyx_t_8 = 0;
-      __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 58, __pyx_L7_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 60, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_10 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
         __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_9);
         if (likely(__pyx_t_10)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
           __Pyx_INCREF(__pyx_t_10);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_9, function);
         }
       }
       __pyx_t_8 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_10, __pyx_8genexpr1__pyx_v_e) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_8genexpr1__pyx_v_e);
       __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
-      if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 58, __pyx_L7_error)
+      if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 60, __pyx_L7_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-      if (unlikely(__Pyx_ListComp_Append(__pyx_t_4, (PyObject*)__pyx_t_8))) __PYX_ERR(0, 58, __pyx_L7_error)
+      if (unlikely(__Pyx_ListComp_Append(__pyx_t_4, (PyObject*)__pyx_t_8))) __PYX_ERR(0, 60, __pyx_L7_error)
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_8genexpr1__pyx_v_e); __pyx_8genexpr1__pyx_v_e = 0;
     goto __pyx_L10_exit_scope;
     __pyx_L7_error:;
     __Pyx_XDECREF(__pyx_8genexpr1__pyx_v_e); __pyx_8genexpr1__pyx_v_e = 0;
     goto __pyx_L1_error;
     __pyx_L10_exit_scope:;
   } /* exit inner scope */
   __pyx_r = __pyx_t_4;
   __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":55
+  /* "borg/item.pyx":57
  * 
  * 
  * def fix_list_of_bytes(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of bytes"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -3785,15 +3852,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_8genexpr1__pyx_v_e);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":61
+/* "borg/item.pyx":63
  * 
  * 
  * def fix_list_of_chunkentries(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of correct chunkentries"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -3831,15 +3898,15 @@
   PyObject *__pyx_t_11 = NULL;
   int __pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fix_list_of_chunkentries", 0);
 
-  /* "borg/item.pyx":63
+  /* "borg/item.pyx":65
  * def fix_list_of_chunkentries(v):
  *     """make sure we have a list of correct chunkentries"""
  *     assert isinstance(v, (tuple, list))             # <<<<<<<<<<<<<<
  *     chunks = []
  *     for ce in v:
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -3853,81 +3920,81 @@
     }
     __pyx_t_3 = PyList_Check(__pyx_v_v); 
     __pyx_t_2 = (__pyx_t_3 != 0);
     __pyx_t_1 = __pyx_t_2;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 63, __pyx_L1_error)
+      __PYX_ERR(0, 65, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":64
+  /* "borg/item.pyx":66
  *     """make sure we have a list of correct chunkentries"""
  *     assert isinstance(v, (tuple, list))
  *     chunks = []             # <<<<<<<<<<<<<<
  *     for ce in v:
  *         assert isinstance(ce, (tuple, list))
  */
-  __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 66, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_v_chunks = ((PyObject*)__pyx_t_4);
   __pyx_t_4 = 0;
 
-  /* "borg/item.pyx":65
+  /* "borg/item.pyx":67
  *     assert isinstance(v, (tuple, list))
  *     chunks = []
  *     for ce in v:             # <<<<<<<<<<<<<<
  *         assert isinstance(ce, (tuple, list))
  *         assert len(ce) in (2, 3)  # id, size[, csize]
  */
   if (likely(PyList_CheckExact(__pyx_v_v)) || PyTuple_CheckExact(__pyx_v_v)) {
     __pyx_t_4 = __pyx_v_v; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
     __pyx_t_6 = NULL;
   } else {
-    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_v); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 65, __pyx_L1_error)
+    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_v); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 67, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 65, __pyx_L1_error)
+    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 67, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_6)) {
       if (likely(PyList_CheckExact(__pyx_t_4))) {
         if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 65, __pyx_L1_error)
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 67, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 65, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 67, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       } else {
         if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 65, __pyx_L1_error)
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 67, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 65, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 67, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       }
     } else {
       __pyx_t_7 = __pyx_t_6(__pyx_t_4);
       if (unlikely(!__pyx_t_7)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 65, __pyx_L1_error)
+          else __PYX_ERR(0, 67, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_7);
     }
     __Pyx_XDECREF_SET(__pyx_v_ce, __pyx_t_7);
     __pyx_t_7 = 0;
 
-    /* "borg/item.pyx":66
+    /* "borg/item.pyx":68
  *     chunks = []
  *     for ce in v:
  *         assert isinstance(ce, (tuple, list))             # <<<<<<<<<<<<<<
  *         assert len(ce) in (2, 3)  # id, size[, csize]
  *         assert isinstance(ce[1], int)
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -3941,167 +4008,167 @@
       }
       __pyx_t_3 = PyList_Check(__pyx_v_ce); 
       __pyx_t_2 = (__pyx_t_3 != 0);
       __pyx_t_1 = __pyx_t_2;
       __pyx_L7_bool_binop_done:;
       if (unlikely(!(__pyx_t_1 != 0))) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 66, __pyx_L1_error)
+        __PYX_ERR(0, 68, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/item.pyx":67
+    /* "borg/item.pyx":69
  *     for ce in v:
  *         assert isinstance(ce, (tuple, list))
  *         assert len(ce) in (2, 3)  # id, size[, csize]             # <<<<<<<<<<<<<<
  *         assert isinstance(ce[1], int)
  *         assert len(ce) == 2 or isinstance(ce[2], int)
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
-      __pyx_t_8 = PyObject_Length(__pyx_v_ce); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 67, __pyx_L1_error)
+      __pyx_t_8 = PyObject_Length(__pyx_v_ce); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 69, __pyx_L1_error)
       __pyx_t_2 = ((__pyx_t_8 == 2) != 0);
       if (!__pyx_t_2) {
       } else {
         __pyx_t_1 = __pyx_t_2;
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_2 = ((__pyx_t_8 == 3) != 0);
       __pyx_t_1 = __pyx_t_2;
       __pyx_L9_bool_binop_done:;
       if (unlikely(!(__pyx_t_1 != 0))) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 67, __pyx_L1_error)
+        __PYX_ERR(0, 69, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/item.pyx":68
+    /* "borg/item.pyx":70
  *         assert isinstance(ce, (tuple, list))
  *         assert len(ce) in (2, 3)  # id, size[, csize]
  *         assert isinstance(ce[1], int)             # <<<<<<<<<<<<<<
  *         assert len(ce) == 2 or isinstance(ce[2], int)
  *         ce_fixed = [want_bytes(ce[0]), ce[1]]  # list! id, size only, drop csize
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
-      __pyx_t_7 = __Pyx_GetItemInt(__pyx_v_ce, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 68, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_GetItemInt(__pyx_v_ce, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 70, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_7);
       __pyx_t_1 = PyInt_Check(__pyx_t_7); 
       __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       if (unlikely(!(__pyx_t_1 != 0))) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 68, __pyx_L1_error)
+        __PYX_ERR(0, 70, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/item.pyx":69
+    /* "borg/item.pyx":71
  *         assert len(ce) in (2, 3)  # id, size[, csize]
  *         assert isinstance(ce[1], int)
  *         assert len(ce) == 2 or isinstance(ce[2], int)             # <<<<<<<<<<<<<<
  *         ce_fixed = [want_bytes(ce[0]), ce[1]]  # list! id, size only, drop csize
  *         chunks.append(ce_fixed)  # create a list of lists
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
-      __pyx_t_8 = PyObject_Length(__pyx_v_ce); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 69, __pyx_L1_error)
+      __pyx_t_8 = PyObject_Length(__pyx_v_ce); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 71, __pyx_L1_error)
       __pyx_t_2 = ((__pyx_t_8 == 2) != 0);
       if (!__pyx_t_2) {
       } else {
         __pyx_t_1 = __pyx_t_2;
         goto __pyx_L11_bool_binop_done;
       }
-      __pyx_t_7 = __Pyx_GetItemInt(__pyx_v_ce, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 69, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_GetItemInt(__pyx_v_ce, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 71, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_7);
       __pyx_t_2 = PyInt_Check(__pyx_t_7); 
       __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       __pyx_t_3 = (__pyx_t_2 != 0);
       __pyx_t_1 = __pyx_t_3;
       __pyx_L11_bool_binop_done:;
       if (unlikely(!__pyx_t_1)) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 69, __pyx_L1_error)
+        __PYX_ERR(0, 71, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/item.pyx":70
+    /* "borg/item.pyx":72
  *         assert isinstance(ce[1], int)
  *         assert len(ce) == 2 or isinstance(ce[2], int)
  *         ce_fixed = [want_bytes(ce[0]), ce[1]]  # list! id, size only, drop csize             # <<<<<<<<<<<<<<
  *         chunks.append(ce_fixed)  # create a list of lists
  *     return chunks
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 70, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 72, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_9);
-    __pyx_t_10 = __Pyx_GetItemInt(__pyx_v_ce, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 70, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_GetItemInt(__pyx_v_ce, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 72, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __pyx_t_11 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
       __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_9);
       if (likely(__pyx_t_11)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
         __Pyx_INCREF(__pyx_t_11);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_9, function);
       }
     }
     __pyx_t_7 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_11, __pyx_t_10) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_t_10);
     __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 70, __pyx_L1_error)
+    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 72, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __pyx_t_9 = __Pyx_GetItemInt(__pyx_v_ce, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 70, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_GetItemInt(__pyx_v_ce, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 72, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_9);
-    __pyx_t_10 = PyList_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 70, __pyx_L1_error)
+    __pyx_t_10 = PyList_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 72, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_GIVEREF(__pyx_t_7);
     PyList_SET_ITEM(__pyx_t_10, 0, __pyx_t_7);
     __Pyx_GIVEREF(__pyx_t_9);
     PyList_SET_ITEM(__pyx_t_10, 1, __pyx_t_9);
     __pyx_t_7 = 0;
     __pyx_t_9 = 0;
     __Pyx_XDECREF_SET(__pyx_v_ce_fixed, ((PyObject*)__pyx_t_10));
     __pyx_t_10 = 0;
 
-    /* "borg/item.pyx":71
+    /* "borg/item.pyx":73
  *         assert len(ce) == 2 or isinstance(ce[2], int)
  *         ce_fixed = [want_bytes(ce[0]), ce[1]]  # list! id, size only, drop csize
  *         chunks.append(ce_fixed)  # create a list of lists             # <<<<<<<<<<<<<<
  *     return chunks
  * 
  */
-    __pyx_t_12 = __Pyx_PyList_Append(__pyx_v_chunks, __pyx_v_ce_fixed); if (unlikely(__pyx_t_12 == ((int)-1))) __PYX_ERR(0, 71, __pyx_L1_error)
+    __pyx_t_12 = __Pyx_PyList_Append(__pyx_v_chunks, __pyx_v_ce_fixed); if (unlikely(__pyx_t_12 == ((int)-1))) __PYX_ERR(0, 73, __pyx_L1_error)
 
-    /* "borg/item.pyx":65
+    /* "borg/item.pyx":67
  *     assert isinstance(v, (tuple, list))
  *     chunks = []
  *     for ce in v:             # <<<<<<<<<<<<<<
  *         assert isinstance(ce, (tuple, list))
  *         assert len(ce) in (2, 3)  # id, size[, csize]
  */
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "borg/item.pyx":72
+  /* "borg/item.pyx":74
  *         ce_fixed = [want_bytes(ce[0]), ce[1]]  # list! id, size only, drop csize
  *         chunks.append(ce_fixed)  # create a list of lists
  *     return chunks             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_chunks);
   __pyx_r = __pyx_v_chunks;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":61
+  /* "borg/item.pyx":63
  * 
  * 
  * def fix_list_of_chunkentries(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of correct chunkentries"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -4119,15 +4186,15 @@
   __Pyx_XDECREF(__pyx_v_ce);
   __Pyx_XDECREF(__pyx_v_ce_fixed);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":75
+/* "borg/item.pyx":77
  * 
  * 
  * def fix_tuple_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -4143,15 +4210,15 @@
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 static PyObject *__pyx_gb_4borg_4item_16fix_tuple_of_str_2generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
 
-/* "borg/item.pyx":78
+/* "borg/item.pyx":80
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))
  *     return tuple(want_str(e) for e in v)             # <<<<<<<<<<<<<<
  * 
  * 
  */
 
@@ -4163,23 +4230,23 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("genexpr", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_1_genexpr *)__pyx_tp_new_4borg_4item___pyx_scope_struct_1_genexpr(__pyx_ptype_4borg_4item___pyx_scope_struct_1_genexpr, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_1_genexpr *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 78, __pyx_L1_error)
+    __PYX_ERR(0, 80, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct__fix_tuple_of_str *) __pyx_self;
   __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
   {
-    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_16fix_tuple_of_str_2generator, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_fix_tuple_of_str_locals_genexpr, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 78, __pyx_L1_error)
+    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_16fix_tuple_of_str_2generator, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_fix_tuple_of_str_locals_genexpr, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 80, __pyx_L1_error)
     __Pyx_DECREF(__pyx_cur_scope);
     __Pyx_RefNannyFinishContext();
     return (PyObject *) gen;
   }
 
   /* function exit code */
   __pyx_L1_error:;
@@ -4210,74 +4277,74 @@
     case 0: goto __pyx_L3_first_run;
     case 1: goto __pyx_L6_resume_from_yield;
     default: /* CPython raises the right error here */
     __Pyx_RefNannyFinishContext();
     return NULL;
   }
   __pyx_L3_first_run:;
-  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 78, __pyx_L1_error)
-  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v)) { __Pyx_RaiseClosureNameError("v"); __PYX_ERR(0, 78, __pyx_L1_error) }
+  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v)) { __Pyx_RaiseClosureNameError("v"); __PYX_ERR(0, 80, __pyx_L1_error) }
   if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v)) {
     __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_v; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 78, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 80, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 78, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 80, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 78, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 80, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 78, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 80, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 78, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 80, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 78, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 80, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 78, __pyx_L1_error)
+          else __PYX_ERR(0, 80, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_e);
     __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_e, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_4);
     __pyx_t_4 = 0;
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_want_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 78, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_want_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 80, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_6 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_6);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_cur_scope->__pyx_v_e) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_cur_scope->__pyx_v_e);
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 78, __pyx_L1_error)
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 80, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     __Pyx_XGIVEREF(__pyx_t_1);
     __pyx_cur_scope->__pyx_t_0 = __pyx_t_1;
     __pyx_cur_scope->__pyx_t_1 = __pyx_t_2;
@@ -4290,15 +4357,15 @@
     return __pyx_r;
     __pyx_L6_resume_from_yield:;
     __pyx_t_1 = __pyx_cur_scope->__pyx_t_0;
     __pyx_cur_scope->__pyx_t_0 = 0;
     __Pyx_XGOTREF(__pyx_t_1);
     __pyx_t_2 = __pyx_cur_scope->__pyx_t_1;
     __pyx_t_3 = __pyx_cur_scope->__pyx_t_2;
-    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 78, __pyx_L1_error)
+    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 80, __pyx_L1_error)
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);
 
   /* function exit code */
   PyErr_SetNone(PyExc_StopIteration);
   goto __pyx_L0;
@@ -4315,15 +4382,15 @@
   #endif
   __pyx_generator->resume_label = -1;
   __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":75
+/* "borg/item.pyx":77
  * 
  * 
  * def fix_tuple_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -4341,23 +4408,23 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fix_tuple_of_str", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct__fix_tuple_of_str *)__pyx_tp_new_4borg_4item___pyx_scope_struct__fix_tuple_of_str(__pyx_ptype_4borg_4item___pyx_scope_struct__fix_tuple_of_str, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct__fix_tuple_of_str *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 75, __pyx_L1_error)
+    __PYX_ERR(0, 77, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_v_v = __pyx_v_v;
   __Pyx_INCREF(__pyx_cur_scope->__pyx_v_v);
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_v);
 
-  /* "borg/item.pyx":77
+  /* "borg/item.pyx":79
  * def fix_tuple_of_str(v):
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))             # <<<<<<<<<<<<<<
  *     return tuple(want_str(e) for e in v)
  * 
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -4377,37 +4444,37 @@
     __pyx_t_4 = PyList_Check(__pyx_t_2); 
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_3 = (__pyx_t_4 != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 77, __pyx_L1_error)
+      __PYX_ERR(0, 79, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":78
+  /* "borg/item.pyx":80
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))
  *     return tuple(want_str(e) for e in v)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_pf_4borg_4item_16fix_tuple_of_str_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 78, __pyx_L1_error)
+  __pyx_t_2 = __pyx_pf_4borg_4item_16fix_tuple_of_str_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 80, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PySequence_Tuple(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 78, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PySequence_Tuple(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 80, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":75
+  /* "borg/item.pyx":77
  * 
  * 
  * def fix_tuple_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -4421,15 +4488,15 @@
   __Pyx_XDECREF(__pyx_gb_4borg_4item_16fix_tuple_of_str_2generator);
   __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":81
+/* "borg/item.pyx":83
  * 
  * 
  * def fix_tuple_of_str_and_int(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -4445,15 +4512,15 @@
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 static PyObject *__pyx_gb_4borg_4item_24fix_tuple_of_str_and_int_2generator1(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
 
-/* "borg/item.pyx":84
+/* "borg/item.pyx":86
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))
  *     t = tuple(e.decode() if isinstance(e, bytes) else e for e in v)             # <<<<<<<<<<<<<<
  *     assert all(isinstance(e, (str, int)) for e in t), repr(t)
  *     return t
  */
 
@@ -4465,23 +4532,23 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("genexpr", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_3_genexpr *)__pyx_tp_new_4borg_4item___pyx_scope_struct_3_genexpr(__pyx_ptype_4borg_4item___pyx_scope_struct_3_genexpr, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_3_genexpr *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 84, __pyx_L1_error)
+    __PYX_ERR(0, 86, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int *) __pyx_self;
   __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
   {
-    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_24fix_tuple_of_str_and_int_2generator1, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_fix_tuple_of_str_and_int_locals, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 84, __pyx_L1_error)
+    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_24fix_tuple_of_str_and_int_2generator1, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_fix_tuple_of_str_and_int_locals, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 86, __pyx_L1_error)
     __Pyx_DECREF(__pyx_cur_scope);
     __Pyx_RefNannyFinishContext();
     return (PyObject *) gen;
   }
 
   /* function exit code */
   __pyx_L1_error:;
@@ -4514,76 +4581,76 @@
     case 0: goto __pyx_L3_first_run;
     case 1: goto __pyx_L6_resume_from_yield;
     default: /* CPython raises the right error here */
     __Pyx_RefNannyFinishContext();
     return NULL;
   }
   __pyx_L3_first_run:;
-  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 84, __pyx_L1_error)
-  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v)) { __Pyx_RaiseClosureNameError("v"); __PYX_ERR(0, 84, __pyx_L1_error) }
+  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 86, __pyx_L1_error)
+  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v)) { __Pyx_RaiseClosureNameError("v"); __PYX_ERR(0, 86, __pyx_L1_error) }
   if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v)) {
     __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_v; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 84, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_v); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 86, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 84, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 86, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 84, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 86, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 84, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 86, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 84, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 86, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 84, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 86, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 84, __pyx_L1_error)
+          else __PYX_ERR(0, 86, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_e);
     __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_e, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_4);
     __pyx_t_4 = 0;
     __pyx_t_5 = PyBytes_Check(__pyx_cur_scope->__pyx_v_e); 
     if ((__pyx_t_5 != 0)) {
-      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_e, __pyx_n_s_decode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 84, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_e, __pyx_n_s_decode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 86, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_7);
       __pyx_t_8 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
         __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
         if (likely(__pyx_t_8)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
           __Pyx_INCREF(__pyx_t_8);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_7, function);
         }
       }
       __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_7);
       __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-      if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 84, __pyx_L1_error)
+      if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 86, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       __pyx_t_4 = __pyx_t_6;
       __pyx_t_6 = 0;
     } else {
       __Pyx_INCREF(__pyx_cur_scope->__pyx_v_e);
       __pyx_t_4 = __pyx_cur_scope->__pyx_v_e;
@@ -4602,15 +4669,15 @@
     return __pyx_r;
     __pyx_L6_resume_from_yield:;
     __pyx_t_1 = __pyx_cur_scope->__pyx_t_0;
     __pyx_cur_scope->__pyx_t_0 = 0;
     __Pyx_XGOTREF(__pyx_t_1);
     __pyx_t_2 = __pyx_cur_scope->__pyx_t_1;
     __pyx_t_3 = __pyx_cur_scope->__pyx_t_2;
-    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 84, __pyx_L1_error)
+    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 86, __pyx_L1_error)
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);
 
   /* function exit code */
   PyErr_SetNone(PyExc_StopIteration);
   goto __pyx_L0;
@@ -4629,15 +4696,15 @@
   __pyx_generator->resume_label = -1;
   __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 static PyObject *__pyx_gb_4borg_4item_24fix_tuple_of_str_and_int_5generator2(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
 
-/* "borg/item.pyx":85
+/* "borg/item.pyx":87
  *     assert isinstance(v, (tuple, list))
  *     t = tuple(e.decode() if isinstance(e, bytes) else e for e in v)
  *     assert all(isinstance(e, (str, int)) for e in t), repr(t)             # <<<<<<<<<<<<<<
  *     return t
  * 
  */
 
@@ -4649,23 +4716,23 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("genexpr", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_4_genexpr *)__pyx_tp_new_4borg_4item___pyx_scope_struct_4_genexpr(__pyx_ptype_4borg_4item___pyx_scope_struct_4_genexpr, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_4_genexpr *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 85, __pyx_L1_error)
+    __PYX_ERR(0, 87, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int *) __pyx_self;
   __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
   {
-    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_24fix_tuple_of_str_and_int_5generator2, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_fix_tuple_of_str_and_int_locals, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_24fix_tuple_of_str_and_int_5generator2, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_fix_tuple_of_str_and_int_locals, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 87, __pyx_L1_error)
     __Pyx_DECREF(__pyx_cur_scope);
     __Pyx_RefNannyFinishContext();
     return (PyObject *) gen;
   }
 
   /* function exit code */
   __pyx_L1_error:;
@@ -4695,27 +4762,27 @@
   switch (__pyx_generator->resume_label) {
     case 0: goto __pyx_L3_first_run;
     default: /* CPython raises the right error here */
     __Pyx_RefNannyFinishContext();
     return NULL;
   }
   __pyx_L3_first_run:;
-  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 85, __pyx_L1_error)
-  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_t)) { __Pyx_RaiseClosureNameError("t"); __PYX_ERR(0, 85, __pyx_L1_error) }
+  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 87, __pyx_L1_error)
+  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_t)) { __Pyx_RaiseClosureNameError("t"); __PYX_ERR(0, 87, __pyx_L1_error) }
   if (unlikely(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_t == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    __PYX_ERR(0, 85, __pyx_L1_error)
+    __PYX_ERR(0, 87, __pyx_L1_error)
   }
   __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_t; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 87, __pyx_L1_error)
     #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 87, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_e);
     __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_e, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_3);
     __pyx_t_3 = 0;
     __pyx_t_5 = PyString_Check(__pyx_cur_scope->__pyx_v_e); 
@@ -4761,15 +4828,15 @@
   #endif
   __pyx_generator->resume_label = -1;
   __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":81
+/* "borg/item.pyx":83
  * 
  * 
  * def fix_tuple_of_str_and_int(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -4788,23 +4855,23 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fix_tuple_of_str_and_int", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int *)__pyx_tp_new_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int(__pyx_ptype_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 81, __pyx_L1_error)
+    __PYX_ERR(0, 83, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_v_v = __pyx_v_v;
   __Pyx_INCREF(__pyx_cur_scope->__pyx_v_v);
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_v);
 
-  /* "borg/item.pyx":83
+  /* "borg/item.pyx":85
  * def fix_tuple_of_str_and_int(v):
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))             # <<<<<<<<<<<<<<
  *     t = tuple(e.decode() if isinstance(e, bytes) else e for e in v)
  *     assert all(isinstance(e, (str, int)) for e in t), repr(t)
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -4824,80 +4891,80 @@
     __pyx_t_4 = PyList_Check(__pyx_t_2); 
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_3 = (__pyx_t_4 != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 83, __pyx_L1_error)
+      __PYX_ERR(0, 85, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":84
+  /* "borg/item.pyx":86
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))
  *     t = tuple(e.decode() if isinstance(e, bytes) else e for e in v)             # <<<<<<<<<<<<<<
  *     assert all(isinstance(e, (str, int)) for e in t), repr(t)
  *     return t
  */
-  __pyx_t_2 = __pyx_pf_4borg_4item_24fix_tuple_of_str_and_int_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 84, __pyx_L1_error)
+  __pyx_t_2 = __pyx_pf_4borg_4item_24fix_tuple_of_str_and_int_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PySequence_Tuple(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 84, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PySequence_Tuple(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_GIVEREF(__pyx_t_5);
   __pyx_cur_scope->__pyx_v_t = ((PyObject*)__pyx_t_5);
   __pyx_t_5 = 0;
 
-  /* "borg/item.pyx":85
+  /* "borg/item.pyx":87
  *     assert isinstance(v, (tuple, list))
  *     t = tuple(e.decode() if isinstance(e, bytes) else e for e in v)
  *     assert all(isinstance(e, (str, int)) for e in t), repr(t)             # <<<<<<<<<<<<<<
  *     return t
  * 
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
-    __pyx_t_5 = __pyx_pf_4borg_4item_24fix_tuple_of_str_and_int_3genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __pyx_t_5 = __pyx_pf_4borg_4item_24fix_tuple_of_str_and_int_3genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 87, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_2 = __Pyx_Generator_Next(__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_Generator_Next(__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 87, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 87, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     if (unlikely(!__pyx_t_1)) {
       __pyx_t_2 = __pyx_cur_scope->__pyx_v_t;
       __Pyx_INCREF(__pyx_t_2);
-      __pyx_t_5 = PyObject_Repr(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 85, __pyx_L1_error)
+      __pyx_t_5 = PyObject_Repr(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 87, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __pyx_t_2 = PyTuple_Pack(1, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 85, __pyx_L1_error)
+      __pyx_t_2 = PyTuple_Pack(1, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 87, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       PyErr_SetObject(PyExc_AssertionError, __pyx_t_2);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __PYX_ERR(0, 85, __pyx_L1_error)
+      __PYX_ERR(0, 87, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":86
+  /* "borg/item.pyx":88
  *     t = tuple(e.decode() if isinstance(e, bytes) else e for e in v)
  *     assert all(isinstance(e, (str, int)) for e in t), repr(t)
  *     return t             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_cur_scope->__pyx_v_t);
   __pyx_r = __pyx_cur_scope->__pyx_v_t;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":81
+  /* "borg/item.pyx":83
  * 
  * 
  * def fix_tuple_of_str_and_int(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))
  */
 
@@ -4912,15 +4979,15 @@
   __Pyx_XDECREF(__pyx_gb_4borg_4item_24fix_tuple_of_str_and_int_5generator2);
   __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":89
+/* "borg/item.pyx":91
  * 
  * 
  * def fix_timestamp(v):             # <<<<<<<<<<<<<<
  *     """make sure v is a Timestamp"""
  *     if isinstance(v, Timestamp):
  */
 
@@ -4950,144 +5017,144 @@
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fix_timestamp", 0);
   __Pyx_INCREF(__pyx_v_v);
 
-  /* "borg/item.pyx":91
+  /* "borg/item.pyx":93
  * def fix_timestamp(v):
  *     """make sure v is a Timestamp"""
  *     if isinstance(v, Timestamp):             # <<<<<<<<<<<<<<
  *         return v
  *     # legacy support
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_Timestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_Timestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyObject_IsInstance(__pyx_v_v, __pyx_t_1); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 91, __pyx_L1_error)
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_v, __pyx_t_1); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
-    /* "borg/item.pyx":92
+    /* "borg/item.pyx":94
  *     """make sure v is a Timestamp"""
  *     if isinstance(v, Timestamp):
  *         return v             # <<<<<<<<<<<<<<
  *     # legacy support
  *     if isinstance(v, bytes):  # was: bigint_to_int()
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_v_v);
     __pyx_r = __pyx_v_v;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":91
+    /* "borg/item.pyx":93
  * def fix_timestamp(v):
  *     """make sure v is a Timestamp"""
  *     if isinstance(v, Timestamp):             # <<<<<<<<<<<<<<
  *         return v
  *     # legacy support
  */
   }
 
-  /* "borg/item.pyx":94
+  /* "borg/item.pyx":96
  *         return v
  *     # legacy support
  *     if isinstance(v, bytes):  # was: bigint_to_int()             # <<<<<<<<<<<<<<
  *         v = int.from_bytes(v, 'little', signed=True)
  *     assert isinstance(v, int)
  */
   __pyx_t_3 = PyBytes_Check(__pyx_v_v); 
   __pyx_t_2 = (__pyx_t_3 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/item.pyx":95
+    /* "borg/item.pyx":97
  *     # legacy support
  *     if isinstance(v, bytes):  # was: bigint_to_int()
  *         v = int.from_bytes(v, 'little', signed=True)             # <<<<<<<<<<<<<<
  *     assert isinstance(v, int)
  *     return int_to_timestamp(v)
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)(&PyInt_Type)), __pyx_n_s_from_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 95, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)(&PyInt_Type)), __pyx_n_s_from_bytes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 97, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 95, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 97, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_v_v);
     __Pyx_GIVEREF(__pyx_v_v);
     PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_v);
     __Pyx_INCREF(__pyx_n_s_little);
     __Pyx_GIVEREF(__pyx_n_s_little);
     PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_n_s_little);
-    __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 95, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 97, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_signed, Py_True) < 0) __PYX_ERR(0, 95, __pyx_L1_error)
-    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 95, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_signed, Py_True) < 0) __PYX_ERR(0, 97, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 97, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_6);
     __pyx_t_6 = 0;
 
-    /* "borg/item.pyx":94
+    /* "borg/item.pyx":96
  *         return v
  *     # legacy support
  *     if isinstance(v, bytes):  # was: bigint_to_int()             # <<<<<<<<<<<<<<
  *         v = int.from_bytes(v, 'little', signed=True)
  *     assert isinstance(v, int)
  */
   }
 
-  /* "borg/item.pyx":96
+  /* "borg/item.pyx":98
  *     if isinstance(v, bytes):  # was: bigint_to_int()
  *         v = int.from_bytes(v, 'little', signed=True)
  *     assert isinstance(v, int)             # <<<<<<<<<<<<<<
  *     return int_to_timestamp(v)
  * 
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_2 = PyInt_Check(__pyx_v_v); 
     if (unlikely(!(__pyx_t_2 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 96, __pyx_L1_error)
+      __PYX_ERR(0, 98, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":97
+  /* "borg/item.pyx":99
  *         v = int.from_bytes(v, 'little', signed=True)
  *     assert isinstance(v, int)
  *     return int_to_timestamp(v)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 97, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
     }
   }
   __pyx_t_6 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_v) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_v);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 97, __pyx_L1_error)
+  if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_r = __pyx_t_6;
   __pyx_t_6 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":89
+  /* "borg/item.pyx":91
  * 
  * 
  * def fix_timestamp(v):             # <<<<<<<<<<<<<<
  *     """make sure v is a Timestamp"""
  *     if isinstance(v, Timestamp):
  */
 
@@ -5102,15 +5169,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_v);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":100
+/* "borg/item.pyx":102
  * 
  * 
  * def want_bytes(v, *, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """we know that we want bytes and the value should be bytes"""
  *     # legacy support: it being str can be caused by msgpack unpack decoding old data that was packed with use_bin_type=False
  */
 
@@ -5148,27 +5215,27 @@
       }
       if (kw_args == 1) {
         const Py_ssize_t index = 1;
         PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
         if (value) { values[index] = value; kw_args--; }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "want_bytes") < 0)) __PYX_ERR(0, 100, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "want_bytes") < 0)) __PYX_ERR(0, 102, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_v = values[0];
     __pyx_v_errors = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("want_bytes", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 100, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("want_bytes", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 102, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.want_bytes", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_18want_bytes(__pyx_self, __pyx_v_v, __pyx_v_errors);
 
@@ -5187,89 +5254,89 @@
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("want_bytes", 0);
   __Pyx_INCREF(__pyx_v_v);
 
-  /* "borg/item.pyx":103
+  /* "borg/item.pyx":105
  *     """we know that we want bytes and the value should be bytes"""
  *     # legacy support: it being str can be caused by msgpack unpack decoding old data that was packed with use_bin_type=False
  *     if isinstance(v, str):             # <<<<<<<<<<<<<<
  *         v = v.encode('utf-8', errors=errors)
  *     assert isinstance(v, bytes), f'not a bytes object, but {v!r}'
  */
   __pyx_t_1 = PyString_Check(__pyx_v_v); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/item.pyx":104
+    /* "borg/item.pyx":106
  *     # legacy support: it being str can be caused by msgpack unpack decoding old data that was packed with use_bin_type=False
  *     if isinstance(v, str):
  *         v = v.encode('utf-8', errors=errors)             # <<<<<<<<<<<<<<
  *     assert isinstance(v, bytes), f'not a bytes object, but {v!r}'
  *     return v
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_v, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 104, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_v, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 106, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 104, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 106, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_errors, __pyx_v_errors) < 0) __PYX_ERR(0, 104, __pyx_L1_error)
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 104, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_errors, __pyx_v_errors) < 0) __PYX_ERR(0, 106, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 106, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "borg/item.pyx":103
+    /* "borg/item.pyx":105
  *     """we know that we want bytes and the value should be bytes"""
  *     # legacy support: it being str can be caused by msgpack unpack decoding old data that was packed with use_bin_type=False
  *     if isinstance(v, str):             # <<<<<<<<<<<<<<
  *         v = v.encode('utf-8', errors=errors)
  *     assert isinstance(v, bytes), f'not a bytes object, but {v!r}'
  */
   }
 
-  /* "borg/item.pyx":105
+  /* "borg/item.pyx":107
  *     if isinstance(v, str):
  *         v = v.encode('utf-8', errors=errors)
  *     assert isinstance(v, bytes), f'not a bytes object, but {v!r}'             # <<<<<<<<<<<<<<
  *     return v
  * 
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_2 = PyBytes_Check(__pyx_v_v); 
     if (unlikely(!(__pyx_t_2 != 0))) {
-      __pyx_t_5 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_v), __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 105, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_v), __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 107, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_kp_u_not_a_bytes_object_but, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 105, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_kp_u_not_a_bytes_object_but, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 107, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       PyErr_SetObject(PyExc_AssertionError, __pyx_t_4);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __PYX_ERR(0, 105, __pyx_L1_error)
+      __PYX_ERR(0, 107, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":106
+  /* "borg/item.pyx":108
  *         v = v.encode('utf-8', errors=errors)
  *     assert isinstance(v, bytes), f'not a bytes object, but {v!r}'
  *     return v             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_v);
   __pyx_r = __pyx_v_v;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":100
+  /* "borg/item.pyx":102
  * 
  * 
  * def want_bytes(v, *, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """we know that we want bytes and the value should be bytes"""
  *     # legacy support: it being str can be caused by msgpack unpack decoding old data that was packed with use_bin_type=False
  */
 
@@ -5283,15 +5350,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_v);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":109
+/* "borg/item.pyx":111
  * 
  * 
  * def want_str(v, *, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """we know that we want str and the value should be str"""
  *     if isinstance(v, bytes):
  */
 
@@ -5329,27 +5396,27 @@
       }
       if (kw_args == 1) {
         const Py_ssize_t index = 1;
         PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
         if (value) { values[index] = value; kw_args--; }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "want_str") < 0)) __PYX_ERR(0, 109, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "want_str") < 0)) __PYX_ERR(0, 111, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_v = values[0];
     __pyx_v_errors = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("want_str", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 109, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("want_str", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 111, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.want_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_20want_str(__pyx_self, __pyx_v_v, __pyx_v_errors);
 
@@ -5368,89 +5435,89 @@
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("want_str", 0);
   __Pyx_INCREF(__pyx_v_v);
 
-  /* "borg/item.pyx":111
+  /* "borg/item.pyx":113
  * def want_str(v, *, errors='surrogateescape'):
  *     """we know that we want str and the value should be str"""
  *     if isinstance(v, bytes):             # <<<<<<<<<<<<<<
  *         v = v.decode('utf-8', errors=errors)
  *     assert isinstance(v, str), f'not a str object, but {v!r}'
  */
   __pyx_t_1 = PyBytes_Check(__pyx_v_v); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/item.pyx":112
+    /* "borg/item.pyx":114
  *     """we know that we want str and the value should be str"""
  *     if isinstance(v, bytes):
  *         v = v.decode('utf-8', errors=errors)             # <<<<<<<<<<<<<<
  *     assert isinstance(v, str), f'not a str object, but {v!r}'
  *     return v
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_v, __pyx_n_s_decode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 112, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_v, __pyx_n_s_decode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 114, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 112, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 114, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_errors, __pyx_v_errors) < 0) __PYX_ERR(0, 112, __pyx_L1_error)
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 112, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_errors, __pyx_v_errors) < 0) __PYX_ERR(0, 114, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 114, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "borg/item.pyx":111
+    /* "borg/item.pyx":113
  * def want_str(v, *, errors='surrogateescape'):
  *     """we know that we want str and the value should be str"""
  *     if isinstance(v, bytes):             # <<<<<<<<<<<<<<
  *         v = v.decode('utf-8', errors=errors)
  *     assert isinstance(v, str), f'not a str object, but {v!r}'
  */
   }
 
-  /* "borg/item.pyx":113
+  /* "borg/item.pyx":115
  *     if isinstance(v, bytes):
  *         v = v.decode('utf-8', errors=errors)
  *     assert isinstance(v, str), f'not a str object, but {v!r}'             # <<<<<<<<<<<<<<
  *     return v
  * 
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_2 = PyString_Check(__pyx_v_v); 
     if (unlikely(!(__pyx_t_2 != 0))) {
-      __pyx_t_5 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_v), __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 113, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_v), __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 115, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_kp_u_not_a_str_object_but, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 113, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_kp_u_not_a_str_object_but, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 115, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       PyErr_SetObject(PyExc_AssertionError, __pyx_t_4);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __PYX_ERR(0, 113, __pyx_L1_error)
+      __PYX_ERR(0, 115, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":114
+  /* "borg/item.pyx":116
  *         v = v.decode('utf-8', errors=errors)
  *     assert isinstance(v, str), f'not a str object, but {v!r}'
  *     return v             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_v);
   __pyx_r = __pyx_v_v;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":109
+  /* "borg/item.pyx":111
  * 
  * 
  * def want_str(v, *, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """we know that we want str and the value should be str"""
  *     if isinstance(v, bytes):
  */
 
@@ -5464,15 +5531,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_v);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":141
+/* "borg/item.pyx":143
  *     cdef object _dict
  * 
  *     def __cinit__(self, data_dict=None, internal_dict=None, **kw):             # <<<<<<<<<<<<<<
  *         self._dict = {}
  *         if internal_dict is None:
  */
 
@@ -5517,15 +5584,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_internal_dict);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kw, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 141, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kw, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 143, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
@@ -5534,15 +5601,15 @@
       }
     }
     __pyx_v_data_dict = values[0];
     __pyx_v_internal_dict = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 141, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 143, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_kw); __pyx_v_kw = 0;
   __Pyx_AddTraceback("borg.item.PropDict.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_8PropDict___cinit__(((struct __pyx_obj_4borg_4item_PropDict *)__pyx_v_self), __pyx_v_data_dict, __pyx_v_internal_dict, __pyx_v_kw);
@@ -5563,229 +5630,229 @@
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "borg/item.pyx":142
+  /* "borg/item.pyx":144
  * 
  *     def __cinit__(self, data_dict=None, internal_dict=None, **kw):
  *         self._dict = {}             # <<<<<<<<<<<<<<
  *         if internal_dict is None:
  *             pass  # nothing to do
  */
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 142, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 144, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->_dict);
   __Pyx_DECREF(__pyx_v_self->_dict);
   __pyx_v_self->_dict = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":143
+  /* "borg/item.pyx":145
  *     def __cinit__(self, data_dict=None, internal_dict=None, **kw):
  *         self._dict = {}
  *         if internal_dict is None:             # <<<<<<<<<<<<<<
  *             pass  # nothing to do
  *         elif isinstance(internal_dict, dict):
  */
   __pyx_t_2 = (__pyx_v_internal_dict == Py_None);
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
     goto __pyx_L3;
   }
 
-  /* "borg/item.pyx":145
+  /* "borg/item.pyx":147
  *         if internal_dict is None:
  *             pass  # nothing to do
  *         elif isinstance(internal_dict, dict):             # <<<<<<<<<<<<<<
  *             self.update_internal(internal_dict)
  *         else:
  */
   __pyx_t_3 = PyDict_Check(__pyx_v_internal_dict); 
   __pyx_t_2 = (__pyx_t_3 != 0);
   if (likely(__pyx_t_2)) {
 
-    /* "borg/item.pyx":146
+    /* "borg/item.pyx":148
  *             pass  # nothing to do
  *         elif isinstance(internal_dict, dict):
  *             self.update_internal(internal_dict)             # <<<<<<<<<<<<<<
  *         else:
  *             raise TypeError("internal_dict must be a dict")
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_update_internal); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 146, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_update_internal); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 148, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_internal_dict) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_internal_dict);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 146, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 148, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":145
+    /* "borg/item.pyx":147
  *         if internal_dict is None:
  *             pass  # nothing to do
  *         elif isinstance(internal_dict, dict):             # <<<<<<<<<<<<<<
  *             self.update_internal(internal_dict)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "borg/item.pyx":148
+  /* "borg/item.pyx":150
  *             self.update_internal(internal_dict)
  *         else:
  *             raise TypeError("internal_dict must be a dict")             # <<<<<<<<<<<<<<
  *         if data_dict is None:
  *             data = kw
  */
   /*else*/ {
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 148, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 150, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_Raise(__pyx_t_1, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 148, __pyx_L1_error)
+    __PYX_ERR(0, 150, __pyx_L1_error)
   }
   __pyx_L3:;
 
-  /* "borg/item.pyx":149
+  /* "borg/item.pyx":151
  *         else:
  *             raise TypeError("internal_dict must be a dict")
  *         if data_dict is None:             # <<<<<<<<<<<<<<
  *             data = kw
  *         elif isinstance(data_dict, dict):
  */
   __pyx_t_2 = (__pyx_v_data_dict == Py_None);
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
-    /* "borg/item.pyx":150
+    /* "borg/item.pyx":152
  *             raise TypeError("internal_dict must be a dict")
  *         if data_dict is None:
  *             data = kw             # <<<<<<<<<<<<<<
  *         elif isinstance(data_dict, dict):
  *             data = data_dict
  */
     __Pyx_INCREF(__pyx_v_kw);
     __pyx_v_data = __pyx_v_kw;
 
-    /* "borg/item.pyx":149
+    /* "borg/item.pyx":151
  *         else:
  *             raise TypeError("internal_dict must be a dict")
  *         if data_dict is None:             # <<<<<<<<<<<<<<
  *             data = kw
  *         elif isinstance(data_dict, dict):
  */
     goto __pyx_L4;
   }
 
-  /* "borg/item.pyx":151
+  /* "borg/item.pyx":153
  *         if data_dict is None:
  *             data = kw
  *         elif isinstance(data_dict, dict):             # <<<<<<<<<<<<<<
  *             data = data_dict
  *         else:
  */
   __pyx_t_3 = PyDict_Check(__pyx_v_data_dict); 
   __pyx_t_2 = (__pyx_t_3 != 0);
   if (likely(__pyx_t_2)) {
 
-    /* "borg/item.pyx":152
+    /* "borg/item.pyx":154
  *             data = kw
  *         elif isinstance(data_dict, dict):
  *             data = data_dict             # <<<<<<<<<<<<<<
  *         else:
  *             raise TypeError("data_dict must be a dict")
  */
     __Pyx_INCREF(__pyx_v_data_dict);
     __pyx_v_data = __pyx_v_data_dict;
 
-    /* "borg/item.pyx":151
+    /* "borg/item.pyx":153
  *         if data_dict is None:
  *             data = kw
  *         elif isinstance(data_dict, dict):             # <<<<<<<<<<<<<<
  *             data = data_dict
  *         else:
  */
     goto __pyx_L4;
   }
 
-  /* "borg/item.pyx":154
+  /* "borg/item.pyx":156
  *             data = data_dict
  *         else:
  *             raise TypeError("data_dict must be a dict")             # <<<<<<<<<<<<<<
  *         if data:
  *             self.update(data)
  */
   /*else*/ {
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 154, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 156, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_Raise(__pyx_t_1, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 154, __pyx_L1_error)
+    __PYX_ERR(0, 156, __pyx_L1_error)
   }
   __pyx_L4:;
 
-  /* "borg/item.pyx":155
+  /* "borg/item.pyx":157
  *         else:
  *             raise TypeError("data_dict must be a dict")
  *         if data:             # <<<<<<<<<<<<<<
  *             self.update(data)
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_data); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_data); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 157, __pyx_L1_error)
   if (__pyx_t_2) {
 
-    /* "borg/item.pyx":156
+    /* "borg/item.pyx":158
  *             raise TypeError("data_dict must be a dict")
  *         if data:
  *             self.update(data)             # <<<<<<<<<<<<<<
  * 
  *     def update(self, d):
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_update); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 156, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_update); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 158, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_data);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 156, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 158, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":155
+    /* "borg/item.pyx":157
  *         else:
  *             raise TypeError("data_dict must be a dict")
  *         if data:             # <<<<<<<<<<<<<<
  *             self.update(data)
  * 
  */
   }
 
-  /* "borg/item.pyx":141
+  /* "borg/item.pyx":143
  *     cdef object _dict
  * 
  *     def __cinit__(self, data_dict=None, internal_dict=None, **kw):             # <<<<<<<<<<<<<<
  *         self._dict = {}
  *         if internal_dict is None:
  */
 
@@ -5800,15 +5867,15 @@
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":158
+/* "borg/item.pyx":160
  *             self.update(data)
  * 
  *     def update(self, d):             # <<<<<<<<<<<<<<
  *         for k, v in d.items():
  *             if isinstance(k, bytes):
  */
 
@@ -5842,119 +5909,119 @@
   PyObject *__pyx_t_10 = NULL;
   int __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("update", 0);
 
-  /* "borg/item.pyx":159
+  /* "borg/item.pyx":161
  * 
  *     def update(self, d):
  *         for k, v in d.items():             # <<<<<<<<<<<<<<
  *             if isinstance(k, bytes):
  *                 k = k.decode()
  */
   __pyx_t_2 = 0;
   if (unlikely(__pyx_v_d == Py_None)) {
     PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "items");
-    __PYX_ERR(0, 159, __pyx_L1_error)
+    __PYX_ERR(0, 161, __pyx_L1_error)
   }
-  __pyx_t_5 = __Pyx_dict_iterator(__pyx_v_d, 0, __pyx_n_s_items, (&__pyx_t_3), (&__pyx_t_4)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 159, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_dict_iterator(__pyx_v_d, 0, __pyx_n_s_items, (&__pyx_t_3), (&__pyx_t_4)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_1);
   __pyx_t_1 = __pyx_t_5;
   __pyx_t_5 = 0;
   while (1) {
     __pyx_t_7 = __Pyx_dict_iter_next(__pyx_t_1, __pyx_t_3, &__pyx_t_2, &__pyx_t_5, &__pyx_t_6, NULL, __pyx_t_4);
     if (unlikely(__pyx_t_7 == 0)) break;
-    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 159, __pyx_L1_error)
+    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 161, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_5);
     __pyx_t_5 = 0;
     __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_6);
     __pyx_t_6 = 0;
 
-    /* "borg/item.pyx":160
+    /* "borg/item.pyx":162
  *     def update(self, d):
  *         for k, v in d.items():
  *             if isinstance(k, bytes):             # <<<<<<<<<<<<<<
  *                 k = k.decode()
  *             setattr(self, self._check_key(k), v)
  */
     __pyx_t_8 = PyBytes_Check(__pyx_v_k); 
     __pyx_t_9 = (__pyx_t_8 != 0);
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":161
+      /* "borg/item.pyx":163
  *         for k, v in d.items():
  *             if isinstance(k, bytes):
  *                 k = k.decode()             # <<<<<<<<<<<<<<
  *             setattr(self, self._check_key(k), v)
  * 
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_k, __pyx_n_s_decode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 161, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_k, __pyx_n_s_decode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 163, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_10 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_10)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_10);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_6 = (__pyx_t_10) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_10) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
       __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
-      if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 161, __pyx_L1_error)
+      if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 163, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_k, __pyx_t_6);
       __pyx_t_6 = 0;
 
-      /* "borg/item.pyx":160
+      /* "borg/item.pyx":162
  *     def update(self, d):
  *         for k, v in d.items():
  *             if isinstance(k, bytes):             # <<<<<<<<<<<<<<
  *                 k = k.decode()
  *             setattr(self, self._check_key(k), v)
  */
     }
 
-    /* "borg/item.pyx":162
+    /* "borg/item.pyx":164
  *             if isinstance(k, bytes):
  *                 k = k.decode()
  *             setattr(self, self._check_key(k), v)             # <<<<<<<<<<<<<<
  * 
  *     def update_internal(self, d):
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 162, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 164, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_10 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_10)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_10);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_6 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_10, __pyx_v_k) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_k);
     __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
-    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 162, __pyx_L1_error)
+    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 164, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_11 = PyObject_SetAttr(((PyObject *)__pyx_v_self), __pyx_t_6, __pyx_v_v); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 162, __pyx_L1_error)
+    __pyx_t_11 = PyObject_SetAttr(((PyObject *)__pyx_v_self), __pyx_t_6, __pyx_v_v); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 164, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":158
+  /* "borg/item.pyx":160
  *             self.update(data)
  * 
  *     def update(self, d):             # <<<<<<<<<<<<<<
  *         for k, v in d.items():
  *             if isinstance(k, bytes):
  */
 
@@ -5972,15 +6039,15 @@
   __Pyx_XDECREF(__pyx_v_k);
   __Pyx_XDECREF(__pyx_v_v);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":164
+/* "borg/item.pyx":166
  *             setattr(self, self._check_key(k), v)
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         for k, v in d.items():
  *             if isinstance(k, bytes):
  */
 
@@ -6013,101 +6080,101 @@
   int __pyx_t_9;
   PyObject *__pyx_t_10 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("update_internal", 0);
 
-  /* "borg/item.pyx":165
+  /* "borg/item.pyx":167
  * 
  *     def update_internal(self, d):
  *         for k, v in d.items():             # <<<<<<<<<<<<<<
  *             if isinstance(k, bytes):
  *                 k = k.decode()
  */
   __pyx_t_2 = 0;
   if (unlikely(__pyx_v_d == Py_None)) {
     PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "items");
-    __PYX_ERR(0, 165, __pyx_L1_error)
+    __PYX_ERR(0, 167, __pyx_L1_error)
   }
-  __pyx_t_5 = __Pyx_dict_iterator(__pyx_v_d, 0, __pyx_n_s_items, (&__pyx_t_3), (&__pyx_t_4)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 165, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_dict_iterator(__pyx_v_d, 0, __pyx_n_s_items, (&__pyx_t_3), (&__pyx_t_4)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_1);
   __pyx_t_1 = __pyx_t_5;
   __pyx_t_5 = 0;
   while (1) {
     __pyx_t_7 = __Pyx_dict_iter_next(__pyx_t_1, __pyx_t_3, &__pyx_t_2, &__pyx_t_5, &__pyx_t_6, NULL, __pyx_t_4);
     if (unlikely(__pyx_t_7 == 0)) break;
-    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 165, __pyx_L1_error)
+    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 167, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_5);
     __pyx_t_5 = 0;
     __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_6);
     __pyx_t_6 = 0;
 
-    /* "borg/item.pyx":166
+    /* "borg/item.pyx":168
  *     def update_internal(self, d):
  *         for k, v in d.items():
  *             if isinstance(k, bytes):             # <<<<<<<<<<<<<<
  *                 k = k.decode()
  *             self._dict[k] = v
  */
     __pyx_t_8 = PyBytes_Check(__pyx_v_k); 
     __pyx_t_9 = (__pyx_t_8 != 0);
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":167
+      /* "borg/item.pyx":169
  *         for k, v in d.items():
  *             if isinstance(k, bytes):
  *                 k = k.decode()             # <<<<<<<<<<<<<<
  *             self._dict[k] = v
  * 
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_k, __pyx_n_s_decode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 167, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_k, __pyx_n_s_decode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 169, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_10 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_10)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_10);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_6 = (__pyx_t_10) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_10) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
       __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
-      if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 167, __pyx_L1_error)
+      if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 169, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_k, __pyx_t_6);
       __pyx_t_6 = 0;
 
-      /* "borg/item.pyx":166
+      /* "borg/item.pyx":168
  *     def update_internal(self, d):
  *         for k, v in d.items():
  *             if isinstance(k, bytes):             # <<<<<<<<<<<<<<
  *                 k = k.decode()
  *             self._dict[k] = v
  */
     }
 
-    /* "borg/item.pyx":168
+    /* "borg/item.pyx":170
  *             if isinstance(k, bytes):
  *                 k = k.decode()
  *             self._dict[k] = v             # <<<<<<<<<<<<<<
  * 
  *     def __eq__(self, other):
  */
-    if (unlikely(PyObject_SetItem(__pyx_v_self->_dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 168, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_self->_dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 170, __pyx_L1_error)
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":164
+  /* "borg/item.pyx":166
  *             setattr(self, self._check_key(k), v)
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         for k, v in d.items():
  *             if isinstance(k, bytes):
  */
 
@@ -6125,15 +6192,15 @@
   __Pyx_XDECREF(__pyx_v_k);
   __Pyx_XDECREF(__pyx_v_v);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":170
+/* "borg/item.pyx":172
  *             self._dict[k] = v
  * 
  *     def __eq__(self, other):             # <<<<<<<<<<<<<<
  *         return self.as_dict() == other.as_dict()
  * 
  */
 
@@ -6158,64 +6225,64 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__eq__", 0);
 
-  /* "borg/item.pyx":171
+  /* "borg/item.pyx":173
  * 
  *     def __eq__(self, other):
  *         return self.as_dict() == other.as_dict()             # <<<<<<<<<<<<<<
  * 
  *     def __repr__(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_as_dict); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 171, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_as_dict); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 173, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 173, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_other, __pyx_n_s_as_dict); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 171, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_other, __pyx_n_s_as_dict); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 173, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 171, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 173, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = PyObject_RichCompare(__pyx_t_1, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 171, __pyx_L1_error)
+  __pyx_t_3 = PyObject_RichCompare(__pyx_t_1, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 173, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":170
+  /* "borg/item.pyx":172
  *             self._dict[k] = v
  * 
  *     def __eq__(self, other):             # <<<<<<<<<<<<<<
  *         return self.as_dict() == other.as_dict()
  * 
  */
 
@@ -6229,15 +6296,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":173
+/* "borg/item.pyx":175
  *         return self.as_dict() == other.as_dict()
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return '%s(internal_dict=%r)' % (self.__class__.__name__, self._dict)
  * 
  */
 
@@ -6260,43 +6327,43 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "borg/item.pyx":174
+  /* "borg/item.pyx":176
  * 
  *     def __repr__(self):
  *         return '%s(internal_dict=%r)' % (self.__class__.__name__, self._dict)             # <<<<<<<<<<<<<<
  * 
  *     def as_dict(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_class); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 174, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_class); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 176, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 174, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 176, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 174, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 176, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
   __Pyx_INCREF(__pyx_v_self->_dict);
   __Pyx_GIVEREF(__pyx_v_self->_dict);
   PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_self->_dict);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_s_internal_dict_r, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 174, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_s_internal_dict_r, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 176, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":173
+  /* "borg/item.pyx":175
  *         return self.as_dict() == other.as_dict()
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return '%s(internal_dict=%r)' % (self.__class__.__name__, self._dict)
  * 
  */
 
@@ -6308,15 +6375,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":176
+/* "borg/item.pyx":178
  *         return '%s(internal_dict=%r)' % (self.__class__.__name__, self._dict)
  * 
  *     def as_dict(self):             # <<<<<<<<<<<<<<
  *         """return the internal dictionary"""
  *         return StableDict(self._dict)
  */
 
@@ -6341,44 +6408,44 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("as_dict", 0);
 
-  /* "borg/item.pyx":178
+  /* "borg/item.pyx":180
  *     def as_dict(self):
  *         """return the internal dictionary"""
  *         return StableDict(self._dict)             # <<<<<<<<<<<<<<
  * 
  *     def _check_key(self, key):
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 178, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 180, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_self->_dict) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_self->_dict);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 178, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 180, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":176
+  /* "borg/item.pyx":178
  *         return '%s(internal_dict=%r)' % (self.__class__.__name__, self._dict)
  * 
  *     def as_dict(self):             # <<<<<<<<<<<<<<
  *         """return the internal dictionary"""
  *         return StableDict(self._dict)
  */
 
@@ -6391,15 +6458,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":180
+/* "borg/item.pyx":182
  *         return StableDict(self._dict)
  * 
  *     def _check_key(self, key):             # <<<<<<<<<<<<<<
  *         """make sure key is of type str and known"""
  *         if not isinstance(key, str):
  */
 
@@ -6425,99 +6492,99 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_check_key", 0);
 
-  /* "borg/item.pyx":182
+  /* "borg/item.pyx":184
  *     def _check_key(self, key):
  *         """make sure key is of type str and known"""
  *         if not isinstance(key, str):             # <<<<<<<<<<<<<<
  *             raise TypeError("key must be str")
  *         if key not in self.VALID_KEYS:
  */
   __pyx_t_1 = PyString_Check(__pyx_v_key); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (unlikely(__pyx_t_2)) {
 
-    /* "borg/item.pyx":183
+    /* "borg/item.pyx":185
  *         """make sure key is of type str and known"""
  *         if not isinstance(key, str):
  *             raise TypeError("key must be str")             # <<<<<<<<<<<<<<
  *         if key not in self.VALID_KEYS:
  *             raise ValueError("key '%s' is not a valid key" % key)
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 183, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 185, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 183, __pyx_L1_error)
+    __PYX_ERR(0, 185, __pyx_L1_error)
 
-    /* "borg/item.pyx":182
+    /* "borg/item.pyx":184
  *     def _check_key(self, key):
  *         """make sure key is of type str and known"""
  *         if not isinstance(key, str):             # <<<<<<<<<<<<<<
  *             raise TypeError("key must be str")
  *         if key not in self.VALID_KEYS:
  */
   }
 
-  /* "borg/item.pyx":184
+  /* "borg/item.pyx":186
  *         if not isinstance(key, str):
  *             raise TypeError("key must be str")
  *         if key not in self.VALID_KEYS:             # <<<<<<<<<<<<<<
  *             raise ValueError("key '%s' is not a valid key" % key)
  *         return key
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_VALID_KEYS); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 184, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_VALID_KEYS); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_key, __pyx_t_3, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 184, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_key, __pyx_t_3, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_1 = (__pyx_t_2 != 0);
   if (unlikely(__pyx_t_1)) {
 
-    /* "borg/item.pyx":185
+    /* "borg/item.pyx":187
  *             raise TypeError("key must be str")
  *         if key not in self.VALID_KEYS:
  *             raise ValueError("key '%s' is not a valid key" % key)             # <<<<<<<<<<<<<<
  *         return key
  * 
  */
-    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_key_s_is_not_a_valid_key, __pyx_v_key); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 185, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_key_s_is_not_a_valid_key, __pyx_v_key); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 187, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 185, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 187, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __PYX_ERR(0, 185, __pyx_L1_error)
+    __PYX_ERR(0, 187, __pyx_L1_error)
 
-    /* "borg/item.pyx":184
+    /* "borg/item.pyx":186
  *         if not isinstance(key, str):
  *             raise TypeError("key must be str")
  *         if key not in self.VALID_KEYS:             # <<<<<<<<<<<<<<
  *             raise ValueError("key '%s' is not a valid key" % key)
  *         return key
  */
   }
 
-  /* "borg/item.pyx":186
+  /* "borg/item.pyx":188
  *         if key not in self.VALID_KEYS:
  *             raise ValueError("key '%s' is not a valid key" % key)
  *         return key             # <<<<<<<<<<<<<<
  * 
  *     def __contains__(self, key):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_key);
   __pyx_r = __pyx_v_key;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":180
+  /* "borg/item.pyx":182
  *         return StableDict(self._dict)
  * 
  *     def _check_key(self, key):             # <<<<<<<<<<<<<<
  *         """make sure key is of type str and known"""
  *         if not isinstance(key, str):
  */
 
@@ -6529,15 +6596,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":188
+/* "borg/item.pyx":190
  *         return key
  * 
  *     def __contains__(self, key):             # <<<<<<<<<<<<<<
  *         """do we have this key?"""
  *         return self._check_key(key) in self._dict
  */
 
@@ -6566,44 +6633,44 @@
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__contains__", 0);
 
-  /* "borg/item.pyx":190
+  /* "borg/item.pyx":192
  *     def __contains__(self, key):
  *         """do we have this key?"""
  *         return self._check_key(key) in self._dict             # <<<<<<<<<<<<<<
  * 
  *     def get(self, key, default=None):
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 192, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_key) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_key);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 190, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_4 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_v_self->_dict, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __pyx_t_4 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_v_self->_dict, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 192, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_4;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":188
+  /* "borg/item.pyx":190
  *         return key
  * 
  *     def __contains__(self, key):             # <<<<<<<<<<<<<<
  *         """do we have this key?"""
  *         return self._check_key(key) in self._dict
  */
 
@@ -6615,15 +6682,15 @@
   __Pyx_AddTraceback("borg.item.PropDict.__contains__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":192
+/* "borg/item.pyx":194
  *         return self._check_key(key) in self._dict
  * 
  *     def get(self, key, default=None):             # <<<<<<<<<<<<<<
  *         """get value for key, return default if key does not exist"""
  *         return getattr(self, self._check_key(key), default)
  */
 
@@ -6663,15 +6730,15 @@
         case  1:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_default);
           if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get") < 0)) __PYX_ERR(0, 192, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get") < 0)) __PYX_ERR(0, 194, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
@@ -6679,15 +6746,15 @@
       }
     }
     __pyx_v_key = values[0];
     __pyx_v_default = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("get", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 192, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("get", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 194, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.PropDict.get", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_8PropDict_16get(((struct __pyx_obj_4borg_4item_PropDict *)__pyx_v_self), __pyx_v_key, __pyx_v_default);
 
@@ -6703,47 +6770,47 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get", 0);
 
-  /* "borg/item.pyx":194
+  /* "borg/item.pyx":196
  *     def get(self, key, default=None):
  *         """get value for key, return default if key does not exist"""
  *         return getattr(self, self._check_key(key), default)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 194, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 196, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_key) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_key);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 196, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_t_1, __pyx_v_default); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 194, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_t_1, __pyx_v_default); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 196, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":192
+  /* "borg/item.pyx":194
  *         return self._check_key(key) in self._dict
  * 
  *     def get(self, key, default=None):             # <<<<<<<<<<<<<<
  *         """get value for key, return default if key does not exist"""
  *         return getattr(self, self._check_key(key), default)
  */
 
@@ -6869,15 +6936,15 @@
   __Pyx_AddTraceback("borg.item.PropDict.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":208
+/* "borg/item.pyx":210
  *     cdef str attr_error_msg
  * 
  *     def __cinit__(self, value_type, value_type_name=None, encode=None, decode=None):             # <<<<<<<<<<<<<<
  *        self.key = None
  *        self.value_type = value_type
  */
 
@@ -6936,15 +7003,15 @@
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_decode);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 208, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 210, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -6958,15 +7025,15 @@
     __pyx_v_value_type = values[0];
     __pyx_v_value_type_name = values[1];
     __pyx_v_encode = values[2];
     __pyx_v_decode = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 208, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 210, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.PropDictProperty.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_16PropDictProperty___cinit__(((struct __pyx_obj_4borg_4item_PropDictProperty *)__pyx_v_self), __pyx_v_value_type, __pyx_v_value_type_name, __pyx_v_encode, __pyx_v_decode);
 
@@ -6982,92 +7049,92 @@
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "borg/item.pyx":209
+  /* "borg/item.pyx":211
  * 
  *     def __cinit__(self, value_type, value_type_name=None, encode=None, decode=None):
  *        self.key = None             # <<<<<<<<<<<<<<
  *        self.value_type = value_type
  *        self.value_type_name = value_type_name if value_type_name is not None else value_type.__name__
  */
   __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(Py_None);
   __Pyx_GOTREF(__pyx_v_self->key);
   __Pyx_DECREF(__pyx_v_self->key);
   __pyx_v_self->key = ((PyObject*)Py_None);
 
-  /* "borg/item.pyx":210
+  /* "borg/item.pyx":212
  *     def __cinit__(self, value_type, value_type_name=None, encode=None, decode=None):
  *        self.key = None
  *        self.value_type = value_type             # <<<<<<<<<<<<<<
  *        self.value_type_name = value_type_name if value_type_name is not None else value_type.__name__
  *        self.encode = encode
  */
   __Pyx_INCREF(__pyx_v_value_type);
   __Pyx_GIVEREF(__pyx_v_value_type);
   __Pyx_GOTREF(__pyx_v_self->value_type);
   __Pyx_DECREF(__pyx_v_self->value_type);
   __pyx_v_self->value_type = __pyx_v_value_type;
 
-  /* "borg/item.pyx":211
+  /* "borg/item.pyx":213
  *        self.key = None
  *        self.value_type = value_type
  *        self.value_type_name = value_type_name if value_type_name is not None else value_type.__name__             # <<<<<<<<<<<<<<
  *        self.encode = encode
  *        self.decode = decode
  */
   __pyx_t_2 = (__pyx_v_value_type_name != Py_None);
   if ((__pyx_t_2 != 0)) {
-    if (!(likely(PyString_CheckExact(__pyx_v_value_type_name))||((__pyx_v_value_type_name) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_value_type_name)->tp_name), 0))) __PYX_ERR(0, 211, __pyx_L1_error)
+    if (!(likely(PyString_CheckExact(__pyx_v_value_type_name))||((__pyx_v_value_type_name) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_value_type_name)->tp_name), 0))) __PYX_ERR(0, 213, __pyx_L1_error)
     __Pyx_INCREF(__pyx_v_value_type_name);
     __pyx_t_1 = __pyx_v_value_type_name;
   } else {
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_value_type, __pyx_n_s_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 211, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_value_type, __pyx_n_s_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 213, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (!(likely(PyString_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_3)->tp_name), 0))) __PYX_ERR(0, 211, __pyx_L1_error)
+    if (!(likely(PyString_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_3)->tp_name), 0))) __PYX_ERR(0, 213, __pyx_L1_error)
     __pyx_t_1 = __pyx_t_3;
     __pyx_t_3 = 0;
   }
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->value_type_name);
   __Pyx_DECREF(__pyx_v_self->value_type_name);
   __pyx_v_self->value_type_name = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":212
+  /* "borg/item.pyx":214
  *        self.value_type = value_type
  *        self.value_type_name = value_type_name if value_type_name is not None else value_type.__name__
  *        self.encode = encode             # <<<<<<<<<<<<<<
  *        self.decode = decode
  * 
  */
   __Pyx_INCREF(__pyx_v_encode);
   __Pyx_GIVEREF(__pyx_v_encode);
   __Pyx_GOTREF(__pyx_v_self->encode);
   __Pyx_DECREF(__pyx_v_self->encode);
   __pyx_v_self->encode = __pyx_v_encode;
 
-  /* "borg/item.pyx":213
+  /* "borg/item.pyx":215
  *        self.value_type_name = value_type_name if value_type_name is not None else value_type.__name__
  *        self.encode = encode
  *        self.decode = decode             # <<<<<<<<<<<<<<
  * 
  *     def __get__(self, PropDict instance, owner):
  */
   __Pyx_INCREF(__pyx_v_decode);
   __Pyx_GIVEREF(__pyx_v_decode);
   __Pyx_GOTREF(__pyx_v_self->decode);
   __Pyx_DECREF(__pyx_v_self->decode);
   __pyx_v_self->decode = __pyx_v_decode;
 
-  /* "borg/item.pyx":208
+  /* "borg/item.pyx":210
  *     cdef str attr_error_msg
  * 
  *     def __cinit__(self, value_type, value_type_name=None, encode=None, decode=None):             # <<<<<<<<<<<<<<
  *        self.key = None
  *        self.value_type = value_type
  */
 
@@ -7080,15 +7147,15 @@
   __Pyx_AddTraceback("borg.item.PropDictProperty.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":215
+/* "borg/item.pyx":217
  *        self.decode = decode
  * 
  *     def __get__(self, PropDict instance, owner):             # <<<<<<<<<<<<<<
  *         try:
  *             value = instance._dict[self.key]
  */
 
@@ -7097,15 +7164,15 @@
 static PyObject *__pyx_pw_4borg_4item_16PropDictProperty_3__get__(PyObject *__pyx_v_self, PyObject *__pyx_v_instance, PyObject *__pyx_v_owner) {
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_instance), __pyx_ptype_4borg_4item_PropDict, 1, "instance", 0))) __PYX_ERR(0, 215, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_instance), __pyx_ptype_4borg_4item_PropDict, 1, "instance", 0))) __PYX_ERR(0, 217, __pyx_L1_error)
   __pyx_r = __pyx_pf_4borg_4item_16PropDictProperty_2__get__(((struct __pyx_obj_4borg_4item_PropDictProperty *)__pyx_v_self), ((struct __pyx_obj_4borg_4item_PropDict *)__pyx_v_instance), ((PyObject *)__pyx_v_owner));
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
@@ -7128,15 +7195,15 @@
   int __pyx_t_9;
   int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "borg/item.pyx":216
+  /* "borg/item.pyx":218
  * 
  *     def __get__(self, PropDict instance, owner):
  *         try:             # <<<<<<<<<<<<<<
  *             value = instance._dict[self.key]
  *         except KeyError:
  */
   {
@@ -7144,99 +7211,99 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "borg/item.pyx":217
+      /* "borg/item.pyx":219
  *     def __get__(self, PropDict instance, owner):
  *         try:
  *             value = instance._dict[self.key]             # <<<<<<<<<<<<<<
  *         except KeyError:
  *             raise AttributeError(self.attr_error_msg) from None
  */
-      __pyx_t_4 = __Pyx_PyObject_Dict_GetItem(__pyx_v_instance->_dict, __pyx_v_self->key); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 217, __pyx_L3_error)
+      __pyx_t_4 = __Pyx_PyObject_Dict_GetItem(__pyx_v_instance->_dict, __pyx_v_self->key); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 219, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_v_value = __pyx_t_4;
       __pyx_t_4 = 0;
 
-      /* "borg/item.pyx":216
+      /* "borg/item.pyx":218
  * 
  *     def __get__(self, PropDict instance, owner):
  *         try:             # <<<<<<<<<<<<<<
  *             value = instance._dict[self.key]
  *         except KeyError:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "borg/item.pyx":218
+    /* "borg/item.pyx":220
  *         try:
  *             value = instance._dict[self.key]
  *         except KeyError:             # <<<<<<<<<<<<<<
  *             raise AttributeError(self.attr_error_msg) from None
  *         if self.decode is not None:
  */
     __pyx_t_5 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_KeyError);
     if (__pyx_t_5) {
       __Pyx_AddTraceback("borg.item.PropDictProperty.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_4, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(0, 218, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_4, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(0, 220, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "borg/item.pyx":219
+      /* "borg/item.pyx":221
  *             value = instance._dict[self.key]
  *         except KeyError:
  *             raise AttributeError(self.attr_error_msg) from None             # <<<<<<<<<<<<<<
  *         if self.decode is not None:
  *             value = self.decode(value)
  */
-      __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_builtin_AttributeError, __pyx_v_self->attr_error_msg); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 219, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_builtin_AttributeError, __pyx_v_self->attr_error_msg); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 221, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, Py_None);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(0, 219, __pyx_L5_except_error)
+      __PYX_ERR(0, 221, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "borg/item.pyx":216
+    /* "borg/item.pyx":218
  * 
  *     def __get__(self, PropDict instance, owner):
  *         try:             # <<<<<<<<<<<<<<
  *             value = instance._dict[self.key]
  *         except KeyError:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "borg/item.pyx":220
+  /* "borg/item.pyx":222
  *         except KeyError:
  *             raise AttributeError(self.attr_error_msg) from None
  *         if self.decode is not None:             # <<<<<<<<<<<<<<
  *             value = self.decode(value)
  *         if not isinstance(value, self.value_type):
  */
   __pyx_t_9 = (__pyx_v_self->decode != Py_None);
   __pyx_t_10 = (__pyx_t_9 != 0);
   if (__pyx_t_10) {
 
-    /* "borg/item.pyx":221
+    /* "borg/item.pyx":223
  *             raise AttributeError(self.attr_error_msg) from None
  *         if self.decode is not None:
  *             value = self.decode(value)             # <<<<<<<<<<<<<<
  *         if not isinstance(value, self.value_type):
  *             raise TypeError(self.type_error_msg)
  */
     __Pyx_INCREF(__pyx_v_self->decode);
@@ -7248,78 +7315,78 @@
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_6, function);
       }
     }
     __pyx_t_7 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_4, __pyx_v_value) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_value);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 221, __pyx_L1_error)
+    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 223, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_7);
     __pyx_t_7 = 0;
 
-    /* "borg/item.pyx":220
+    /* "borg/item.pyx":222
  *         except KeyError:
  *             raise AttributeError(self.attr_error_msg) from None
  *         if self.decode is not None:             # <<<<<<<<<<<<<<
  *             value = self.decode(value)
  *         if not isinstance(value, self.value_type):
  */
   }
 
-  /* "borg/item.pyx":222
+  /* "borg/item.pyx":224
  *         if self.decode is not None:
  *             value = self.decode(value)
  *         if not isinstance(value, self.value_type):             # <<<<<<<<<<<<<<
  *             raise TypeError(self.type_error_msg)
  *         return value
  */
   __pyx_t_7 = __pyx_v_self->value_type;
   __Pyx_INCREF(__pyx_t_7);
-  __pyx_t_10 = PyObject_IsInstance(__pyx_v_value, __pyx_t_7); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 222, __pyx_L1_error)
+  __pyx_t_10 = PyObject_IsInstance(__pyx_v_value, __pyx_t_7); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 224, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_t_9 = ((!(__pyx_t_10 != 0)) != 0);
   if (unlikely(__pyx_t_9)) {
 
-    /* "borg/item.pyx":223
+    /* "borg/item.pyx":225
  *             value = self.decode(value)
  *         if not isinstance(value, self.value_type):
  *             raise TypeError(self.type_error_msg)             # <<<<<<<<<<<<<<
  *         return value
  * 
  */
-    __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_self->type_error_msg); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 223, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_self->type_error_msg); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 225, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_Raise(__pyx_t_7, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __PYX_ERR(0, 223, __pyx_L1_error)
+    __PYX_ERR(0, 225, __pyx_L1_error)
 
-    /* "borg/item.pyx":222
+    /* "borg/item.pyx":224
  *         if self.decode is not None:
  *             value = self.decode(value)
  *         if not isinstance(value, self.value_type):             # <<<<<<<<<<<<<<
  *             raise TypeError(self.type_error_msg)
  *         return value
  */
   }
 
-  /* "borg/item.pyx":224
+  /* "borg/item.pyx":226
  *         if not isinstance(value, self.value_type):
  *             raise TypeError(self.type_error_msg)
  *         return value             # <<<<<<<<<<<<<<
  * 
  *     def __set__(self, PropDict instance, value):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_value);
   __pyx_r = __pyx_v_value;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":215
+  /* "borg/item.pyx":217
  *        self.decode = decode
  * 
  *     def __get__(self, PropDict instance, owner):             # <<<<<<<<<<<<<<
  *         try:
  *             value = instance._dict[self.key]
  */
 
@@ -7334,15 +7401,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_value);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":226
+/* "borg/item.pyx":228
  *         return value
  * 
  *     def __set__(self, PropDict instance, value):             # <<<<<<<<<<<<<<
  *         if not isinstance(value, self.value_type):
  *             raise TypeError(self.type_error_msg)
  */
 
@@ -7351,15 +7418,15 @@
 static int __pyx_pw_4borg_4item_16PropDictProperty_5__set__(PyObject *__pyx_v_self, PyObject *__pyx_v_instance, PyObject *__pyx_v_value) {
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__set__ (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_instance), __pyx_ptype_4borg_4item_PropDict, 1, "instance", 0))) __PYX_ERR(0, 226, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_instance), __pyx_ptype_4borg_4item_PropDict, 1, "instance", 0))) __PYX_ERR(0, 228, __pyx_L1_error)
   __pyx_r = __pyx_pf_4borg_4item_16PropDictProperty_4__set__(((struct __pyx_obj_4borg_4item_PropDictProperty *)__pyx_v_self), ((struct __pyx_obj_4borg_4item_PropDict *)__pyx_v_instance), ((PyObject *)__pyx_v_value));
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = -1;
   __pyx_L0:;
@@ -7377,62 +7444,62 @@
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__set__", 0);
   __Pyx_INCREF(__pyx_v_value);
 
-  /* "borg/item.pyx":227
+  /* "borg/item.pyx":229
  * 
  *     def __set__(self, PropDict instance, value):
  *         if not isinstance(value, self.value_type):             # <<<<<<<<<<<<<<
  *             raise TypeError(self.type_error_msg)
  *         if self.encode is not None:
  */
   __pyx_t_1 = __pyx_v_self->value_type;
   __Pyx_INCREF(__pyx_t_1);
-  __pyx_t_2 = PyObject_IsInstance(__pyx_v_value, __pyx_t_1); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 227, __pyx_L1_error)
+  __pyx_t_2 = PyObject_IsInstance(__pyx_v_value, __pyx_t_1); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 229, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_3 = ((!(__pyx_t_2 != 0)) != 0);
   if (unlikely(__pyx_t_3)) {
 
-    /* "borg/item.pyx":228
+    /* "borg/item.pyx":230
  *     def __set__(self, PropDict instance, value):
  *         if not isinstance(value, self.value_type):
  *             raise TypeError(self.type_error_msg)             # <<<<<<<<<<<<<<
  *         if self.encode is not None:
  *             value = self.encode(value)
  */
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_self->type_error_msg); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 228, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_self->type_error_msg); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 230, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_Raise(__pyx_t_1, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 228, __pyx_L1_error)
+    __PYX_ERR(0, 230, __pyx_L1_error)
 
-    /* "borg/item.pyx":227
+    /* "borg/item.pyx":229
  * 
  *     def __set__(self, PropDict instance, value):
  *         if not isinstance(value, self.value_type):             # <<<<<<<<<<<<<<
  *             raise TypeError(self.type_error_msg)
  *         if self.encode is not None:
  */
   }
 
-  /* "borg/item.pyx":229
+  /* "borg/item.pyx":231
  *         if not isinstance(value, self.value_type):
  *             raise TypeError(self.type_error_msg)
  *         if self.encode is not None:             # <<<<<<<<<<<<<<
  *             value = self.encode(value)
  *         instance._dict[self.key] = value
  */
   __pyx_t_3 = (__pyx_v_self->encode != Py_None);
   __pyx_t_2 = (__pyx_t_3 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/item.pyx":230
+    /* "borg/item.pyx":232
  *             raise TypeError(self.type_error_msg)
  *         if self.encode is not None:
  *             value = self.encode(value)             # <<<<<<<<<<<<<<
  *         instance._dict[self.key] = value
  * 
  */
     __Pyx_INCREF(__pyx_v_self->encode);
@@ -7444,39 +7511,39 @@
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
     __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_value) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_value);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 230, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 232, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_1);
     __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":229
+    /* "borg/item.pyx":231
  *         if not isinstance(value, self.value_type):
  *             raise TypeError(self.type_error_msg)
  *         if self.encode is not None:             # <<<<<<<<<<<<<<
  *             value = self.encode(value)
  *         instance._dict[self.key] = value
  */
   }
 
-  /* "borg/item.pyx":231
+  /* "borg/item.pyx":233
  *         if self.encode is not None:
  *             value = self.encode(value)
  *         instance._dict[self.key] = value             # <<<<<<<<<<<<<<
  * 
  *     def __delete__(self, PropDict instance):
  */
-  if (unlikely(PyObject_SetItem(__pyx_v_instance->_dict, __pyx_v_self->key, __pyx_v_value) < 0)) __PYX_ERR(0, 231, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_v_instance->_dict, __pyx_v_self->key, __pyx_v_value) < 0)) __PYX_ERR(0, 233, __pyx_L1_error)
 
-  /* "borg/item.pyx":226
+  /* "borg/item.pyx":228
  *         return value
  * 
  *     def __set__(self, PropDict instance, value):             # <<<<<<<<<<<<<<
  *         if not isinstance(value, self.value_type):
  *             raise TypeError(self.type_error_msg)
  */
 
@@ -7491,15 +7558,15 @@
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_value);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":233
+/* "borg/item.pyx":235
  *         instance._dict[self.key] = value
  * 
  *     def __delete__(self, PropDict instance):             # <<<<<<<<<<<<<<
  *         try:
  *             del instance._dict[self.key]
  */
 
@@ -7508,15 +7575,15 @@
 static int __pyx_pw_4borg_4item_16PropDictProperty_7__delete__(PyObject *__pyx_v_self, PyObject *__pyx_v_instance) {
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__delete__ (wrapper)", 0);
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_instance), __pyx_ptype_4borg_4item_PropDict, 1, "instance", 0))) __PYX_ERR(0, 233, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_instance), __pyx_ptype_4borg_4item_PropDict, 1, "instance", 0))) __PYX_ERR(0, 235, __pyx_L1_error)
   __pyx_r = __pyx_pf_4borg_4item_16PropDictProperty_6__delete__(((struct __pyx_obj_4borg_4item_PropDictProperty *)__pyx_v_self), ((struct __pyx_obj_4borg_4item_PropDict *)__pyx_v_instance));
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = -1;
   __pyx_L0:;
@@ -7536,15 +7603,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__delete__", 0);
 
-  /* "borg/item.pyx":234
+  /* "borg/item.pyx":236
  * 
  *     def __delete__(self, PropDict instance):
  *         try:             # <<<<<<<<<<<<<<
  *             del instance._dict[self.key]
  *         except KeyError:
  */
   {
@@ -7552,84 +7619,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "borg/item.pyx":235
+      /* "borg/item.pyx":237
  *     def __delete__(self, PropDict instance):
  *         try:
  *             del instance._dict[self.key]             # <<<<<<<<<<<<<<
  *         except KeyError:
  *             raise AttributeError(self.attr_error_msg) from None
  */
-      if (unlikely(PyObject_DelItem(__pyx_v_instance->_dict, __pyx_v_self->key) < 0)) __PYX_ERR(0, 235, __pyx_L3_error)
+      if (unlikely(PyObject_DelItem(__pyx_v_instance->_dict, __pyx_v_self->key) < 0)) __PYX_ERR(0, 237, __pyx_L3_error)
 
-      /* "borg/item.pyx":234
+      /* "borg/item.pyx":236
  * 
  *     def __delete__(self, PropDict instance):
  *         try:             # <<<<<<<<<<<<<<
  *             del instance._dict[self.key]
  *         except KeyError:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "borg/item.pyx":236
+    /* "borg/item.pyx":238
  *         try:
  *             del instance._dict[self.key]
  *         except KeyError:             # <<<<<<<<<<<<<<
  *             raise AttributeError(self.attr_error_msg) from None
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_KeyError);
     if (__pyx_t_4) {
       __Pyx_AddTraceback("borg.item.PropDictProperty.__delete__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(0, 236, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(0, 238, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "borg/item.pyx":237
+      /* "borg/item.pyx":239
  *             del instance._dict[self.key]
  *         except KeyError:
  *             raise AttributeError(self.attr_error_msg) from None             # <<<<<<<<<<<<<<
  * 
  *     cpdef __set_name__(self, name):
  */
-      __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_builtin_AttributeError, __pyx_v_self->attr_error_msg); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 237, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_builtin_AttributeError, __pyx_v_self->attr_error_msg); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 239, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, Py_None);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(0, 237, __pyx_L5_except_error)
+      __PYX_ERR(0, 239, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "borg/item.pyx":234
+    /* "borg/item.pyx":236
  * 
  *     def __delete__(self, PropDict instance):
  *         try:             # <<<<<<<<<<<<<<
  *             del instance._dict[self.key]
  *         except KeyError:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "borg/item.pyx":233
+  /* "borg/item.pyx":235
  *         instance._dict[self.key] = value
  * 
  *     def __delete__(self, PropDict instance):             # <<<<<<<<<<<<<<
  *         try:
  *             del instance._dict[self.key]
  */
 
@@ -7644,15 +7711,15 @@
   __Pyx_AddTraceback("borg.item.PropDictProperty.__delete__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":239
+/* "borg/item.pyx":241
  *             raise AttributeError(self.attr_error_msg) from None
  * 
  *     cpdef __set_name__(self, name):             # <<<<<<<<<<<<<<
  *        self.key = name
  *        self.__doc__ = "%s (%s)" % (name, self.value_type_name)
  */
 
@@ -7673,15 +7740,15 @@
   /* Check if overridden in Python */
   else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
     #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
     if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
       PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
       #endif
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_set_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_4borg_4item_16PropDictProperty_9__set_name__)) {
         __Pyx_XDECREF(__pyx_r);
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
         if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
           __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
@@ -7690,15 +7757,15 @@
             __Pyx_INCREF(__pyx_t_4);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_3, function);
           }
         }
         __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_name) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_name);
         __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 239, __pyx_L1_error)
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 241, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         __pyx_r = __pyx_t_2;
         __pyx_t_2 = 0;
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         goto __pyx_L0;
       }
@@ -7711,97 +7778,97 @@
       #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     }
     #endif
   }
 
-  /* "borg/item.pyx":240
+  /* "borg/item.pyx":242
  * 
  *     cpdef __set_name__(self, name):
  *        self.key = name             # <<<<<<<<<<<<<<
  *        self.__doc__ = "%s (%s)" % (name, self.value_type_name)
  *        self.type_error_msg = "%s value must be %s" % (name, self.value_type_name)
  */
-  if (!(likely(PyString_CheckExact(__pyx_v_name))||((__pyx_v_name) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_name)->tp_name), 0))) __PYX_ERR(0, 240, __pyx_L1_error)
+  if (!(likely(PyString_CheckExact(__pyx_v_name))||((__pyx_v_name) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_v_name)->tp_name), 0))) __PYX_ERR(0, 242, __pyx_L1_error)
   __pyx_t_1 = __pyx_v_name;
   __Pyx_INCREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->key);
   __Pyx_DECREF(__pyx_v_self->key);
   __pyx_v_self->key = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":241
+  /* "borg/item.pyx":243
  *     cpdef __set_name__(self, name):
  *        self.key = name
  *        self.__doc__ = "%s (%s)" % (name, self.value_type_name)             # <<<<<<<<<<<<<<
  *        self.type_error_msg = "%s value must be %s" % (name, self.value_type_name)
  *        self.attr_error_msg = "attribute %s not found" % name
  */
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 243, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_v_name);
   __Pyx_GIVEREF(__pyx_v_name);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_name);
   __Pyx_INCREF(__pyx_v_self->value_type_name);
   __Pyx_GIVEREF(__pyx_v_self->value_type_name);
   PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_self->value_type_name);
-  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_s_s, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 241, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_s_s, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 243, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (!(likely(PyString_CheckExact(__pyx_t_2))||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 241, __pyx_L1_error)
+  if (!(likely(PyString_CheckExact(__pyx_t_2))||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 243, __pyx_L1_error)
   __Pyx_GIVEREF(__pyx_t_2);
   __Pyx_GOTREF(__pyx_v_self->__doc__);
   __Pyx_DECREF(__pyx_v_self->__doc__);
   __pyx_v_self->__doc__ = ((PyObject*)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":242
+  /* "borg/item.pyx":244
  *        self.key = name
  *        self.__doc__ = "%s (%s)" % (name, self.value_type_name)
  *        self.type_error_msg = "%s value must be %s" % (name, self.value_type_name)             # <<<<<<<<<<<<<<
  *        self.attr_error_msg = "attribute %s not found" % name
  * 
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 242, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 244, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_v_name);
   __Pyx_GIVEREF(__pyx_v_name);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_name);
   __Pyx_INCREF(__pyx_v_self->value_type_name);
   __Pyx_GIVEREF(__pyx_v_self->value_type_name);
   PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self->value_type_name);
-  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_s_value_must_be_s, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_s_value_must_be_s, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 244, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (!(likely(PyString_CheckExact(__pyx_t_1))||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(0, 242, __pyx_L1_error)
+  if (!(likely(PyString_CheckExact(__pyx_t_1))||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(0, 244, __pyx_L1_error)
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->type_error_msg);
   __Pyx_DECREF(__pyx_v_self->type_error_msg);
   __pyx_v_self->type_error_msg = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":243
+  /* "borg/item.pyx":245
  *        self.__doc__ = "%s (%s)" % (name, self.value_type_name)
  *        self.type_error_msg = "%s value must be %s" % (name, self.value_type_name)
  *        self.attr_error_msg = "attribute %s not found" % name             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyString_FormatSafe(__pyx_kp_s_attribute_s_not_found, __pyx_v_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 243, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyString_FormatSafe(__pyx_kp_s_attribute_s_not_found, __pyx_v_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 245, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (!(likely(PyString_CheckExact(__pyx_t_1))||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(0, 243, __pyx_L1_error)
+  if (!(likely(PyString_CheckExact(__pyx_t_1))||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(0, 245, __pyx_L1_error)
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->attr_error_msg);
   __Pyx_DECREF(__pyx_v_self->attr_error_msg);
   __pyx_v_self->attr_error_msg = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":239
+  /* "borg/item.pyx":241
  *             raise AttributeError(self.attr_error_msg) from None
  * 
  *     cpdef __set_name__(self, name):             # <<<<<<<<<<<<<<
  *        self.key = name
  *        self.__doc__ = "%s (%s)" % (name, self.value_type_name)
  */
 
@@ -7839,15 +7906,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__set_name__", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_4borg_4item_16PropDictProperty___set_name__(__pyx_v_self, __pyx_v_name, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_4borg_4item_16PropDictProperty___set_name__(__pyx_v_self, __pyx_v_name, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 241, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -7856,15 +7923,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":199
+/* "borg/item.pyx":201
  * cdef class PropDictProperty:
  *     """return a property that deals with self._dict[key] of PropDict"""
  *     cdef readonly str key             # <<<<<<<<<<<<<<
  *     cdef readonly object value_type
  *     cdef str value_type_name
  */
 
@@ -7893,15 +7960,15 @@
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":200
+/* "borg/item.pyx":202
  *     """return a property that deals with self._dict[key] of PropDict"""
  *     cdef readonly str key
  *     cdef readonly object value_type             # <<<<<<<<<<<<<<
  *     cdef str value_type_name
  *     cdef readonly str __doc__
  */
 
@@ -7930,15 +7997,15 @@
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":202
+/* "borg/item.pyx":204
  *     cdef readonly object value_type
  *     cdef str value_type_name
  *     cdef readonly str __doc__             # <<<<<<<<<<<<<<
  *     cdef object encode
  *     cdef object decode
  */
 
@@ -8080,15 +8147,15 @@
   __Pyx_AddTraceback("borg.item.PropDictProperty.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":302
+/* "borg/item.pyx":304
  *     part = PropDictProperty(int)  # legacy only
  * 
  *     def get_size(self, *, memorize=False, from_chunks=False, consider_ids=None):             # <<<<<<<<<<<<<<
  *         """
  *         Determine the uncompressed size of this item.
  */
 
@@ -8123,41 +8190,41 @@
         Py_ssize_t index;
         for (index = 0; index < 3 && kw_args > 0; index++) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
           if (value) { values[index] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, 0, "get_size") < 0)) __PYX_ERR(0, 302, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, 0, "get_size") < 0)) __PYX_ERR(0, 304, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 0) {
       goto __pyx_L5_argtuple_error;
     } else {
     }
     __pyx_v_memorize = values[0];
     __pyx_v_from_chunks = values[1];
     __pyx_v_consider_ids = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("get_size", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 302, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("get_size", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 304, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.Item.get_size", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_4Item_get_size(((struct __pyx_obj_4borg_4item_Item *)__pyx_v_self), __pyx_v_memorize, __pyx_v_from_chunks, __pyx_v_consider_ids);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 static PyObject *__pyx_gb_4borg_4item_4Item_8get_size_2generator3(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
 
-/* "borg/item.pyx":328
+/* "borg/item.pyx":330
  *                 return 0
  *             if consider_ids is not None:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks if chunk.id in consider_ids)             # <<<<<<<<<<<<<<
  *             else:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks)
  */
 
@@ -8169,23 +8236,23 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("genexpr", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_6_genexpr *)__pyx_tp_new_4borg_4item___pyx_scope_struct_6_genexpr(__pyx_ptype_4borg_4item___pyx_scope_struct_6_genexpr, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_6_genexpr *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 328, __pyx_L1_error)
+    __PYX_ERR(0, 330, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_5_get_size *) __pyx_self;
   __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
   {
-    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_4Item_8get_size_2generator3, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_get_size_locals_genexpr, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 328, __pyx_L1_error)
+    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_4Item_8get_size_2generator3, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_get_size_locals_genexpr, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 330, __pyx_L1_error)
     __Pyx_DECREF(__pyx_cur_scope);
     __Pyx_RefNannyFinishContext();
     return (PyObject *) gen;
   }
 
   /* function exit code */
   __pyx_L1_error:;
@@ -8218,78 +8285,78 @@
     case 0: goto __pyx_L3_first_run;
     case 1: goto __pyx_L7_resume_from_yield;
     default: /* CPython raises the right error here */
     __Pyx_RefNannyFinishContext();
     return NULL;
   }
   __pyx_L3_first_run:;
-  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 328, __pyx_L1_error)
-  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks)) { __Pyx_RaiseClosureNameError("chunks"); __PYX_ERR(0, 328, __pyx_L1_error) }
+  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 330, __pyx_L1_error)
+  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks)) { __Pyx_RaiseClosureNameError("chunks"); __PYX_ERR(0, 330, __pyx_L1_error) }
   if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks)) {
     __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 328, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 330, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 328, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 330, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 328, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 330, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 328, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 328, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 330, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 328, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 328, __pyx_L1_error)
+          else __PYX_ERR(0, 330, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_chunk);
     __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_chunk, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_chunk, __pyx_n_s_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 328, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_chunk, __pyx_n_s_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_consider_ids)) { __Pyx_RaiseClosureNameError("consider_ids"); __PYX_ERR(0, 328, __pyx_L1_error) }
-    __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_t_4, __pyx_cur_scope->__pyx_outer_scope->__pyx_v_consider_ids, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 328, __pyx_L1_error)
+    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_consider_ids)) { __Pyx_RaiseClosureNameError("consider_ids"); __PYX_ERR(0, 330, __pyx_L1_error) }
+    __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_t_4, __pyx_cur_scope->__pyx_outer_scope->__pyx_v_consider_ids, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 330, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_6 = (__pyx_t_5 != 0);
     if (__pyx_t_6) {
-      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_ChunkListEntry); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 328, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_ChunkListEntry); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_7 = __Pyx_PySequence_Tuple(__pyx_cur_scope->__pyx_v_chunk); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 328, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PySequence_Tuple(__pyx_cur_scope->__pyx_v_chunk); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 330, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_7);
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 328, __pyx_L1_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 330, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_attr)) { __Pyx_RaiseClosureNameError("attr"); __PYX_ERR(0, 328, __pyx_L1_error) }
+      if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_attr)) { __Pyx_RaiseClosureNameError("attr"); __PYX_ERR(0, 330, __pyx_L1_error) }
       __pyx_t_7 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_attr;
       __Pyx_INCREF(__pyx_t_7);
-      __pyx_t_4 = __Pyx_GetAttr(__pyx_t_8, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 328, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_GetAttr(__pyx_t_8, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       __pyx_r = __pyx_t_4;
       __pyx_t_4 = 0;
       __Pyx_XGIVEREF(__pyx_t_1);
       __pyx_cur_scope->__pyx_t_0 = __pyx_t_1;
@@ -8303,15 +8370,15 @@
       return __pyx_r;
       __pyx_L7_resume_from_yield:;
       __pyx_t_1 = __pyx_cur_scope->__pyx_t_0;
       __pyx_cur_scope->__pyx_t_0 = 0;
       __Pyx_XGOTREF(__pyx_t_1);
       __pyx_t_2 = __pyx_cur_scope->__pyx_t_1;
       __pyx_t_3 = __pyx_cur_scope->__pyx_t_2;
-      if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 328, __pyx_L1_error)
+      if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 330, __pyx_L1_error)
     }
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);
 
   /* function exit code */
   PyErr_SetNone(PyExc_StopIteration);
@@ -8330,15 +8397,15 @@
   __pyx_generator->resume_label = -1;
   __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 static PyObject *__pyx_gb_4borg_4item_4Item_8get_size_5generator4(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
 
-/* "borg/item.pyx":330
+/* "borg/item.pyx":332
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks if chunk.id in consider_ids)
  *             else:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks)             # <<<<<<<<<<<<<<
  *             # if requested, memorize the precomputed (c)size for items that have an own chunks list:
  *             if memorize:
  */
 
@@ -8350,23 +8417,23 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("genexpr", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_7_genexpr *)__pyx_tp_new_4borg_4item___pyx_scope_struct_7_genexpr(__pyx_ptype_4borg_4item___pyx_scope_struct_7_genexpr, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_7_genexpr *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 330, __pyx_L1_error)
+    __PYX_ERR(0, 332, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_5_get_size *) __pyx_self;
   __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
   {
-    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_4Item_8get_size_5generator4, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_get_size_locals_genexpr, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 330, __pyx_L1_error)
+    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_4Item_8get_size_5generator4, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_get_size_locals_genexpr, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 332, __pyx_L1_error)
     __Pyx_DECREF(__pyx_cur_scope);
     __Pyx_RefNannyFinishContext();
     return (PyObject *) gen;
   }
 
   /* function exit code */
   __pyx_L1_error:;
@@ -8397,71 +8464,71 @@
     case 0: goto __pyx_L3_first_run;
     case 1: goto __pyx_L6_resume_from_yield;
     default: /* CPython raises the right error here */
     __Pyx_RefNannyFinishContext();
     return NULL;
   }
   __pyx_L3_first_run:;
-  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 330, __pyx_L1_error)
-  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks)) { __Pyx_RaiseClosureNameError("chunks"); __PYX_ERR(0, 330, __pyx_L1_error) }
+  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 332, __pyx_L1_error)
+  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks)) { __Pyx_RaiseClosureNameError("chunks"); __PYX_ERR(0, 332, __pyx_L1_error) }
   if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks)) {
     __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
     __pyx_t_3 = NULL;
   } else {
-    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 330, __pyx_L1_error)
+    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_chunks); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 332, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 330, __pyx_L1_error)
+    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 332, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_3)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 330, __pyx_L1_error)
+        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 332, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 332, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       } else {
         if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 330, __pyx_L1_error)
+        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 332, __pyx_L1_error)
         #else
-        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
+        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 332, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         #endif
       }
     } else {
       __pyx_t_4 = __pyx_t_3(__pyx_t_1);
       if (unlikely(!__pyx_t_4)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 330, __pyx_L1_error)
+          else __PYX_ERR(0, 332, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_4);
     }
     __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_chunk);
     __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_chunk, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_4);
     __pyx_t_4 = 0;
-    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_ChunkListEntry); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_ChunkListEntry); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 332, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PySequence_Tuple(__pyx_cur_scope->__pyx_v_chunk); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 330, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PySequence_Tuple(__pyx_cur_scope->__pyx_v_chunk); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 332, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 330, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 332, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_attr)) { __Pyx_RaiseClosureNameError("attr"); __PYX_ERR(0, 330, __pyx_L1_error) }
+    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_attr)) { __Pyx_RaiseClosureNameError("attr"); __PYX_ERR(0, 332, __pyx_L1_error) }
     __pyx_t_5 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_attr;
     __Pyx_INCREF(__pyx_t_5);
-    __pyx_t_4 = __Pyx_GetAttr(__pyx_t_6, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_GetAttr(__pyx_t_6, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 332, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     __Pyx_XGIVEREF(__pyx_t_1);
     __pyx_cur_scope->__pyx_t_0 = __pyx_t_1;
@@ -8475,15 +8542,15 @@
     return __pyx_r;
     __pyx_L6_resume_from_yield:;
     __pyx_t_1 = __pyx_cur_scope->__pyx_t_0;
     __pyx_cur_scope->__pyx_t_0 = 0;
     __Pyx_XGOTREF(__pyx_t_1);
     __pyx_t_2 = __pyx_cur_scope->__pyx_t_1;
     __pyx_t_3 = __pyx_cur_scope->__pyx_t_2;
-    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 330, __pyx_L1_error)
+    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 332, __pyx_L1_error)
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);
 
   /* function exit code */
   PyErr_SetNone(PyExc_StopIteration);
   goto __pyx_L0;
@@ -8500,15 +8567,15 @@
   #endif
   __pyx_generator->resume_label = -1;
   __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":302
+/* "borg/item.pyx":304
  *     part = PropDictProperty(int)  # legacy only
  * 
  *     def get_size(self, *, memorize=False, from_chunks=False, consider_ids=None):             # <<<<<<<<<<<<<<
  *         """
  *         Determine the uncompressed size of this item.
  */
 
@@ -8542,34 +8609,34 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_size", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_5_get_size *)__pyx_tp_new_4borg_4item___pyx_scope_struct_5_get_size(__pyx_ptype_4borg_4item___pyx_scope_struct_5_get_size, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_5_get_size *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 302, __pyx_L1_error)
+    __PYX_ERR(0, 304, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_v_consider_ids = __pyx_v_consider_ids;
   __Pyx_INCREF(__pyx_cur_scope->__pyx_v_consider_ids);
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_consider_ids);
 
-  /* "borg/item.pyx":310
+  /* "borg/item.pyx":312
  *         :param consider_ids: Returns the size of the given ids only.
  *         """
  *         attr = 'size'             # <<<<<<<<<<<<<<
  *         assert not (consider_ids is not None and memorize), "Can't store size when considering only certain ids"
  *         try:
  */
   __Pyx_INCREF(__pyx_n_s_size);
   __Pyx_GIVEREF(__pyx_n_s_size);
   __pyx_cur_scope->__pyx_v_attr = __pyx_n_s_size;
 
-  /* "borg/item.pyx":311
+  /* "borg/item.pyx":313
  *         """
  *         attr = 'size'
  *         assert not (consider_ids is not None and memorize), "Can't store size when considering only certain ids"             # <<<<<<<<<<<<<<
  *         try:
  *             if from_chunks or consider_ids is not None:
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
@@ -8577,25 +8644,25 @@
     __pyx_t_2 = (__pyx_cur_scope->__pyx_v_consider_ids != Py_None);
     __pyx_t_3 = (__pyx_t_2 != 0);
     if (__pyx_t_3) {
     } else {
       __pyx_t_1 = __pyx_t_3;
       goto __pyx_L3_bool_binop_done;
     }
-    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_memorize); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 311, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_memorize); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 313, __pyx_L1_error)
     __pyx_t_1 = __pyx_t_3;
     __pyx_L3_bool_binop_done:;
     if (unlikely(!((!__pyx_t_1) != 0))) {
       PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_Can_t_store_size_when_considerin);
-      __PYX_ERR(0, 311, __pyx_L1_error)
+      __PYX_ERR(0, 313, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/item.pyx":312
+  /* "borg/item.pyx":314
  *         attr = 'size'
  *         assert not (consider_ids is not None and memorize), "Can't store size when considering only certain ids"
  *         try:             # <<<<<<<<<<<<<<
  *             if from_chunks or consider_ids is not None:
  *                 raise AttributeError
  */
   {
@@ -8603,68 +8670,68 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_4, &__pyx_t_5, &__pyx_t_6);
     __Pyx_XGOTREF(__pyx_t_4);
     __Pyx_XGOTREF(__pyx_t_5);
     __Pyx_XGOTREF(__pyx_t_6);
     /*try:*/ {
 
-      /* "borg/item.pyx":313
+      /* "borg/item.pyx":315
  *         assert not (consider_ids is not None and memorize), "Can't store size when considering only certain ids"
  *         try:
  *             if from_chunks or consider_ids is not None:             # <<<<<<<<<<<<<<
  *                 raise AttributeError
  *             size = getattr(self, attr)
  */
-      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_from_chunks); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 313, __pyx_L5_error)
+      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_from_chunks); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 315, __pyx_L5_error)
       if (!__pyx_t_3) {
       } else {
         __pyx_t_1 = __pyx_t_3;
         goto __pyx_L12_bool_binop_done;
       }
       __pyx_t_3 = (__pyx_cur_scope->__pyx_v_consider_ids != Py_None);
       __pyx_t_2 = (__pyx_t_3 != 0);
       __pyx_t_1 = __pyx_t_2;
       __pyx_L12_bool_binop_done:;
       if (unlikely(__pyx_t_1)) {
 
-        /* "borg/item.pyx":314
+        /* "borg/item.pyx":316
  *         try:
  *             if from_chunks or consider_ids is not None:
  *                 raise AttributeError             # <<<<<<<<<<<<<<
  *             size = getattr(self, attr)
  *         except AttributeError:
  */
         __Pyx_Raise(__pyx_builtin_AttributeError, 0, 0, 0);
-        __PYX_ERR(0, 314, __pyx_L5_error)
+        __PYX_ERR(0, 316, __pyx_L5_error)
 
-        /* "borg/item.pyx":313
+        /* "borg/item.pyx":315
  *         assert not (consider_ids is not None and memorize), "Can't store size when considering only certain ids"
  *         try:
  *             if from_chunks or consider_ids is not None:             # <<<<<<<<<<<<<<
  *                 raise AttributeError
  *             size = getattr(self, attr)
  */
       }
 
-      /* "borg/item.pyx":315
+      /* "borg/item.pyx":317
  *             if from_chunks or consider_ids is not None:
  *                 raise AttributeError
  *             size = getattr(self, attr)             # <<<<<<<<<<<<<<
  *         except AttributeError:
  *             if stat.S_ISLNK(self.mode):
  */
       __pyx_t_7 = __pyx_cur_scope->__pyx_v_attr;
       __Pyx_INCREF(__pyx_t_7);
-      __pyx_t_8 = __Pyx_GetAttr(((PyObject *)__pyx_v_self), __pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 315, __pyx_L5_error)
+      __pyx_t_8 = __Pyx_GetAttr(((PyObject *)__pyx_v_self), __pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 317, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       __pyx_v_size = __pyx_t_8;
       __pyx_t_8 = 0;
 
-      /* "borg/item.pyx":312
+      /* "borg/item.pyx":314
  *         attr = 'size'
  *         assert not (consider_ids is not None and memorize), "Can't store size when considering only certain ids"
  *         try:             # <<<<<<<<<<<<<<
  *             if from_chunks or consider_ids is not None:
  *                 raise AttributeError
  */
     }
@@ -8672,135 +8739,135 @@
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     goto __pyx_L10_try_end;
     __pyx_L5_error:;
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
 
-    /* "borg/item.pyx":316
+    /* "borg/item.pyx":318
  *                 raise AttributeError
  *             size = getattr(self, attr)
  *         except AttributeError:             # <<<<<<<<<<<<<<
  *             if stat.S_ISLNK(self.mode):
  *                 # get out of here quickly. symlinks have no own chunks, their fs size is the length of the target name.
  */
     __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
     if (__pyx_t_9) {
       __Pyx_AddTraceback("borg.item.Item.get_size", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_8, &__pyx_t_7, &__pyx_t_10) < 0) __PYX_ERR(0, 316, __pyx_L7_except_error)
+      if (__Pyx_GetException(&__pyx_t_8, &__pyx_t_7, &__pyx_t_10) < 0) __PYX_ERR(0, 318, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_GOTREF(__pyx_t_7);
       __Pyx_GOTREF(__pyx_t_10);
 
-      /* "borg/item.pyx":317
+      /* "borg/item.pyx":319
  *             size = getattr(self, attr)
  *         except AttributeError:
  *             if stat.S_ISLNK(self.mode):             # <<<<<<<<<<<<<<
  *                 # get out of here quickly. symlinks have no own chunks, their fs size is the length of the target name.
  *                 if 'source' in self:  # legacy borg 1.x archives
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_12, __pyx_n_s_stat); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 317, __pyx_L7_except_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_12, __pyx_n_s_stat); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 319, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_12);
-      __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_12, __pyx_n_s_S_ISLNK); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 317, __pyx_L7_except_error)
+      __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_12, __pyx_n_s_S_ISLNK); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 319, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_13);
       __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_mode); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 317, __pyx_L7_except_error)
+      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_mode); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 319, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_12);
       __pyx_t_14 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_13))) {
         __pyx_t_14 = PyMethod_GET_SELF(__pyx_t_13);
         if (likely(__pyx_t_14)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
           __Pyx_INCREF(__pyx_t_14);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_13, function);
         }
       }
       __pyx_t_11 = (__pyx_t_14) ? __Pyx_PyObject_Call2Args(__pyx_t_13, __pyx_t_14, __pyx_t_12) : __Pyx_PyObject_CallOneArg(__pyx_t_13, __pyx_t_12);
       __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
       __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-      if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 317, __pyx_L7_except_error)
+      if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 319, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_11);
       __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_11); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 317, __pyx_L7_except_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_11); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 319, __pyx_L7_except_error)
       __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
       if (__pyx_t_1) {
 
-        /* "borg/item.pyx":319
+        /* "borg/item.pyx":321
  *             if stat.S_ISLNK(self.mode):
  *                 # get out of here quickly. symlinks have no own chunks, their fs size is the length of the target name.
  *                 if 'source' in self:  # legacy borg 1.x archives             # <<<<<<<<<<<<<<
  *                     return len(self.source)
  *                 return len(self.target)
  */
-        __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_source, ((PyObject *)__pyx_v_self), Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 319, __pyx_L7_except_error)
+        __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_source, ((PyObject *)__pyx_v_self), Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 321, __pyx_L7_except_error)
         __pyx_t_2 = (__pyx_t_1 != 0);
         if (__pyx_t_2) {
 
-          /* "borg/item.pyx":320
+          /* "borg/item.pyx":322
  *                 # get out of here quickly. symlinks have no own chunks, their fs size is the length of the target name.
  *                 if 'source' in self:  # legacy borg 1.x archives
  *                     return len(self.source)             # <<<<<<<<<<<<<<
  *                 return len(self.target)
  *             # no precomputed (c)size value available, compute it:
  */
           __Pyx_XDECREF(__pyx_r);
-          __pyx_t_11 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_source); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 320, __pyx_L7_except_error)
+          __pyx_t_11 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_source); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 322, __pyx_L7_except_error)
           __Pyx_GOTREF(__pyx_t_11);
-          __pyx_t_15 = PyObject_Length(__pyx_t_11); if (unlikely(__pyx_t_15 == ((Py_ssize_t)-1))) __PYX_ERR(0, 320, __pyx_L7_except_error)
+          __pyx_t_15 = PyObject_Length(__pyx_t_11); if (unlikely(__pyx_t_15 == ((Py_ssize_t)-1))) __PYX_ERR(0, 322, __pyx_L7_except_error)
           __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-          __pyx_t_11 = PyInt_FromSsize_t(__pyx_t_15); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 320, __pyx_L7_except_error)
+          __pyx_t_11 = PyInt_FromSsize_t(__pyx_t_15); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 322, __pyx_L7_except_error)
           __Pyx_GOTREF(__pyx_t_11);
           __pyx_r = __pyx_t_11;
           __pyx_t_11 = 0;
           __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
           __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
           __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
           goto __pyx_L8_except_return;
 
-          /* "borg/item.pyx":319
+          /* "borg/item.pyx":321
  *             if stat.S_ISLNK(self.mode):
  *                 # get out of here quickly. symlinks have no own chunks, their fs size is the length of the target name.
  *                 if 'source' in self:  # legacy borg 1.x archives             # <<<<<<<<<<<<<<
  *                     return len(self.source)
  *                 return len(self.target)
  */
         }
 
-        /* "borg/item.pyx":321
+        /* "borg/item.pyx":323
  *                 if 'source' in self:  # legacy borg 1.x archives
  *                     return len(self.source)
  *                 return len(self.target)             # <<<<<<<<<<<<<<
  *             # no precomputed (c)size value available, compute it:
  *             try:
  */
         __Pyx_XDECREF(__pyx_r);
-        __pyx_t_11 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_target); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 321, __pyx_L7_except_error)
+        __pyx_t_11 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_target); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 323, __pyx_L7_except_error)
         __Pyx_GOTREF(__pyx_t_11);
-        __pyx_t_15 = PyObject_Length(__pyx_t_11); if (unlikely(__pyx_t_15 == ((Py_ssize_t)-1))) __PYX_ERR(0, 321, __pyx_L7_except_error)
+        __pyx_t_15 = PyObject_Length(__pyx_t_11); if (unlikely(__pyx_t_15 == ((Py_ssize_t)-1))) __PYX_ERR(0, 323, __pyx_L7_except_error)
         __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        __pyx_t_11 = PyInt_FromSsize_t(__pyx_t_15); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 321, __pyx_L7_except_error)
+        __pyx_t_11 = PyInt_FromSsize_t(__pyx_t_15); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 323, __pyx_L7_except_error)
         __Pyx_GOTREF(__pyx_t_11);
         __pyx_r = __pyx_t_11;
         __pyx_t_11 = 0;
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
         goto __pyx_L8_except_return;
 
-        /* "borg/item.pyx":317
+        /* "borg/item.pyx":319
  *             size = getattr(self, attr)
  *         except AttributeError:
  *             if stat.S_ISLNK(self.mode):             # <<<<<<<<<<<<<<
  *                 # get out of here quickly. symlinks have no own chunks, their fs size is the length of the target name.
  *                 if 'source' in self:  # legacy borg 1.x archives
  */
       }
 
-      /* "borg/item.pyx":323
+      /* "borg/item.pyx":325
  *                 return len(self.target)
  *             # no precomputed (c)size value available, compute it:
  *             try:             # <<<<<<<<<<<<<<
  *                 chunks = getattr(self, 'chunks')
  *             except AttributeError:
  */
       {
@@ -8808,28 +8875,28 @@
         __Pyx_PyThreadState_assign
         __Pyx_ExceptionSave(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18);
         __Pyx_XGOTREF(__pyx_t_16);
         __Pyx_XGOTREF(__pyx_t_17);
         __Pyx_XGOTREF(__pyx_t_18);
         /*try:*/ {
 
-          /* "borg/item.pyx":324
+          /* "borg/item.pyx":326
  *             # no precomputed (c)size value available, compute it:
  *             try:
  *                 chunks = getattr(self, 'chunks')             # <<<<<<<<<<<<<<
  *             except AttributeError:
  *                 return 0
  */
-          __pyx_t_11 = __Pyx_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s_chunks); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 324, __pyx_L18_error)
+          __pyx_t_11 = __Pyx_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s_chunks); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 326, __pyx_L18_error)
           __Pyx_GOTREF(__pyx_t_11);
           __Pyx_GIVEREF(__pyx_t_11);
           __pyx_cur_scope->__pyx_v_chunks = __pyx_t_11;
           __pyx_t_11 = 0;
 
-          /* "borg/item.pyx":323
+          /* "borg/item.pyx":325
  *                 return len(self.target)
  *             # no precomputed (c)size value available, compute it:
  *             try:             # <<<<<<<<<<<<<<
  *                 chunks = getattr(self, 'chunks')
  *             except AttributeError:
  */
         }
@@ -8839,30 +8906,30 @@
         goto __pyx_L25_try_end;
         __pyx_L18_error:;
         __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
         __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
         __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
         __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
 
-        /* "borg/item.pyx":325
+        /* "borg/item.pyx":327
  *             try:
  *                 chunks = getattr(self, 'chunks')
  *             except AttributeError:             # <<<<<<<<<<<<<<
  *                 return 0
  *             if consider_ids is not None:
  */
         __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
         if (__pyx_t_9) {
           __Pyx_AddTraceback("borg.item.Item.get_size", __pyx_clineno, __pyx_lineno, __pyx_filename);
-          if (__Pyx_GetException(&__pyx_t_11, &__pyx_t_13, &__pyx_t_12) < 0) __PYX_ERR(0, 325, __pyx_L20_except_error)
+          if (__Pyx_GetException(&__pyx_t_11, &__pyx_t_13, &__pyx_t_12) < 0) __PYX_ERR(0, 327, __pyx_L20_except_error)
           __Pyx_GOTREF(__pyx_t_11);
           __Pyx_GOTREF(__pyx_t_13);
           __Pyx_GOTREF(__pyx_t_12);
 
-          /* "borg/item.pyx":326
+          /* "borg/item.pyx":328
  *                 chunks = getattr(self, 'chunks')
  *             except AttributeError:
  *                 return 0             # <<<<<<<<<<<<<<
  *             if consider_ids is not None:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks if chunk.id in consider_ids)
  */
           __Pyx_XDECREF(__pyx_r);
@@ -8875,15 +8942,15 @@
           __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
           __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
           goto __pyx_L21_except_return;
         }
         goto __pyx_L20_except_error;
         __pyx_L20_except_error:;
 
-        /* "borg/item.pyx":323
+        /* "borg/item.pyx":325
  *                 return len(self.target)
  *             # no precomputed (c)size value available, compute it:
  *             try:             # <<<<<<<<<<<<<<
  *                 chunks = getattr(self, 'chunks')
  *             except AttributeError:
  */
         __Pyx_XGIVEREF(__pyx_t_16);
@@ -8896,91 +8963,91 @@
         __Pyx_XGIVEREF(__pyx_t_17);
         __Pyx_XGIVEREF(__pyx_t_18);
         __Pyx_ExceptionReset(__pyx_t_16, __pyx_t_17, __pyx_t_18);
         goto __pyx_L8_except_return;
         __pyx_L25_try_end:;
       }
 
-      /* "borg/item.pyx":327
+      /* "borg/item.pyx":329
  *             except AttributeError:
  *                 return 0
  *             if consider_ids is not None:             # <<<<<<<<<<<<<<
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks if chunk.id in consider_ids)
  *             else:
  */
       __pyx_t_2 = (__pyx_cur_scope->__pyx_v_consider_ids != Py_None);
       __pyx_t_1 = (__pyx_t_2 != 0);
       if (__pyx_t_1) {
 
-        /* "borg/item.pyx":328
+        /* "borg/item.pyx":330
  *                 return 0
  *             if consider_ids is not None:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks if chunk.id in consider_ids)             # <<<<<<<<<<<<<<
  *             else:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks)
  */
-        __pyx_t_12 = __pyx_pf_4borg_4item_4Item_8get_size_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 328, __pyx_L7_except_error)
+        __pyx_t_12 = __pyx_pf_4borg_4item_4Item_8get_size_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 330, __pyx_L7_except_error)
         __Pyx_GOTREF(__pyx_t_12);
-        __pyx_t_13 = __Pyx_PyObject_CallOneArg(__pyx_builtin_sum, __pyx_t_12); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 328, __pyx_L7_except_error)
+        __pyx_t_13 = __Pyx_PyObject_CallOneArg(__pyx_builtin_sum, __pyx_t_12); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 330, __pyx_L7_except_error)
         __Pyx_GOTREF(__pyx_t_13);
         __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
         __Pyx_XDECREF_SET(__pyx_v_size, __pyx_t_13);
         __pyx_t_13 = 0;
 
-        /* "borg/item.pyx":327
+        /* "borg/item.pyx":329
  *             except AttributeError:
  *                 return 0
  *             if consider_ids is not None:             # <<<<<<<<<<<<<<
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks if chunk.id in consider_ids)
  *             else:
  */
         goto __pyx_L28;
       }
 
-      /* "borg/item.pyx":330
+      /* "borg/item.pyx":332
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks if chunk.id in consider_ids)
  *             else:
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks)             # <<<<<<<<<<<<<<
  *             # if requested, memorize the precomputed (c)size for items that have an own chunks list:
  *             if memorize:
  */
       /*else*/ {
-        __pyx_t_13 = __pyx_pf_4borg_4item_4Item_8get_size_3genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 330, __pyx_L7_except_error)
+        __pyx_t_13 = __pyx_pf_4borg_4item_4Item_8get_size_3genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 332, __pyx_L7_except_error)
         __Pyx_GOTREF(__pyx_t_13);
-        __pyx_t_12 = __Pyx_PyObject_CallOneArg(__pyx_builtin_sum, __pyx_t_13); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 330, __pyx_L7_except_error)
+        __pyx_t_12 = __Pyx_PyObject_CallOneArg(__pyx_builtin_sum, __pyx_t_13); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 332, __pyx_L7_except_error)
         __Pyx_GOTREF(__pyx_t_12);
         __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
         __Pyx_XDECREF_SET(__pyx_v_size, __pyx_t_12);
         __pyx_t_12 = 0;
       }
       __pyx_L28:;
 
-      /* "borg/item.pyx":332
+      /* "borg/item.pyx":334
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks)
  *             # if requested, memorize the precomputed (c)size for items that have an own chunks list:
  *             if memorize:             # <<<<<<<<<<<<<<
  *                 setattr(self, attr, size)
  *         return size
  */
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_memorize); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 332, __pyx_L7_except_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_memorize); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 334, __pyx_L7_except_error)
       if (__pyx_t_1) {
 
-        /* "borg/item.pyx":333
+        /* "borg/item.pyx":335
  *             # if requested, memorize the precomputed (c)size for items that have an own chunks list:
  *             if memorize:
  *                 setattr(self, attr, size)             # <<<<<<<<<<<<<<
  *         return size
  * 
  */
         __pyx_t_12 = __pyx_cur_scope->__pyx_v_attr;
         __Pyx_INCREF(__pyx_t_12);
-        __pyx_t_19 = PyObject_SetAttr(((PyObject *)__pyx_v_self), __pyx_t_12, __pyx_v_size); if (unlikely(__pyx_t_19 == ((int)-1))) __PYX_ERR(0, 333, __pyx_L7_except_error)
+        __pyx_t_19 = PyObject_SetAttr(((PyObject *)__pyx_v_self), __pyx_t_12, __pyx_v_size); if (unlikely(__pyx_t_19 == ((int)-1))) __PYX_ERR(0, 335, __pyx_L7_except_error)
         __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
 
-        /* "borg/item.pyx":332
+        /* "borg/item.pyx":334
  *                 size = sum(getattr(ChunkListEntry(*chunk), attr) for chunk in chunks)
  *             # if requested, memorize the precomputed (c)size for items that have an own chunks list:
  *             if memorize:             # <<<<<<<<<<<<<<
  *                 setattr(self, attr, size)
  *         return size
  */
       }
@@ -8988,15 +9055,15 @@
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
       goto __pyx_L6_exception_handled;
     }
     goto __pyx_L7_except_error;
     __pyx_L7_except_error:;
 
-    /* "borg/item.pyx":312
+    /* "borg/item.pyx":314
  *         attr = 'size'
  *         assert not (consider_ids is not None and memorize), "Can't store size when considering only certain ids"
  *         try:             # <<<<<<<<<<<<<<
  *             if from_chunks or consider_ids is not None:
  *                 raise AttributeError
  */
     __Pyx_XGIVEREF(__pyx_t_4);
@@ -9014,27 +9081,27 @@
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_XGIVEREF(__pyx_t_5);
     __Pyx_XGIVEREF(__pyx_t_6);
     __Pyx_ExceptionReset(__pyx_t_4, __pyx_t_5, __pyx_t_6);
     __pyx_L10_try_end:;
   }
 
-  /* "borg/item.pyx":334
+  /* "borg/item.pyx":336
  *             if memorize:
  *                 setattr(self, attr, size)
  *         return size             # <<<<<<<<<<<<<<
  * 
  *     def to_optr(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_size);
   __pyx_r = __pyx_v_size;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":302
+  /* "borg/item.pyx":304
  *     part = PropDictProperty(int)  # legacy only
  * 
  *     def get_size(self, *, memorize=False, from_chunks=False, consider_ids=None):             # <<<<<<<<<<<<<<
  *         """
  *         Determine the uncompressed size of this item.
  */
 
@@ -9055,15 +9122,15 @@
   __Pyx_XDECREF(__pyx_gb_4borg_4item_4Item_8get_size_5generator4);
   __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":336
+/* "borg/item.pyx":338
  *         return size
  * 
  *     def to_optr(self):             # <<<<<<<<<<<<<<
  *         """
  *         Return an "object pointer" (optr), an opaque bag of bytes.
  */
 
@@ -9086,29 +9153,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("to_optr", 0);
 
-  /* "borg/item.pyx":349
+  /* "borg/item.pyx":351
  *         until from_optr() is called.
  *         """
  *         return _object_to_optr(self)             # <<<<<<<<<<<<<<
  * 
  *     @classmethod
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = _object_to_optr(((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 349, __pyx_L1_error)
+  __pyx_t_1 = _object_to_optr(((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 351, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":336
+  /* "borg/item.pyx":338
  *         return size
  * 
  *     def to_optr(self):             # <<<<<<<<<<<<<<
  *         """
  *         Return an "object pointer" (optr), an opaque bag of bytes.
  */
 
@@ -9119,15 +9186,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":352
+/* "borg/item.pyx":354
  * 
  *     @classmethod
  *     def from_optr(self, optr):             # <<<<<<<<<<<<<<
  *         return _optr_to_object(optr)
  * 
  */
 
@@ -9149,29 +9216,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("from_optr", 0);
 
-  /* "borg/item.pyx":353
+  /* "borg/item.pyx":355
  *     @classmethod
  *     def from_optr(self, optr):
  *         return _optr_to_object(optr)             # <<<<<<<<<<<<<<
  * 
  *     @classmethod
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = _optr_to_object(__pyx_v_optr); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 353, __pyx_L1_error)
+  __pyx_t_1 = _optr_to_object(__pyx_v_optr); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 355, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":352
+  /* "borg/item.pyx":354
  * 
  *     @classmethod
  *     def from_optr(self, optr):             # <<<<<<<<<<<<<<
  *         return _optr_to_object(optr)
  * 
  */
 
@@ -9182,15 +9249,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":356
+/* "borg/item.pyx":358
  * 
  *     @classmethod
  *     def create_deleted(cls, path):             # <<<<<<<<<<<<<<
  *         return cls(deleted=True, chunks=[], mode=0, path=path)
  * 
  */
 
@@ -9213,39 +9280,39 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("create_deleted", 0);
 
-  /* "borg/item.pyx":357
+  /* "borg/item.pyx":359
  *     @classmethod
  *     def create_deleted(cls, path):
  *         return cls(deleted=True, chunks=[], mode=0, path=path)             # <<<<<<<<<<<<<<
  * 
  *     def is_link(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 357, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 359, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_deleted, Py_True) < 0) __PYX_ERR(0, 357, __pyx_L1_error)
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 357, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_deleted, Py_True) < 0) __PYX_ERR(0, 359, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 359, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_chunks, __pyx_t_2) < 0) __PYX_ERR(0, 357, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_chunks, __pyx_t_2) < 0) __PYX_ERR(0, 359, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_mode, __pyx_int_0) < 0) __PYX_ERR(0, 357, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_path, __pyx_v_path) < 0) __PYX_ERR(0, 357, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_v_cls), __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 357, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_mode, __pyx_int_0) < 0) __PYX_ERR(0, 359, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_path, __pyx_v_path) < 0) __PYX_ERR(0, 359, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_v_cls), __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 359, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":356
+  /* "borg/item.pyx":358
  * 
  *     @classmethod
  *     def create_deleted(cls, path):             # <<<<<<<<<<<<<<
  *         return cls(deleted=True, chunks=[], mode=0, path=path)
  * 
  */
 
@@ -9257,15 +9324,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":359
+/* "borg/item.pyx":361
  *         return cls(deleted=True, chunks=[], mode=0, path=path)
  * 
  *     def is_link(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISLNK)
  * 
  */
 
@@ -9290,27 +9357,27 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_link", 0);
 
-  /* "borg/item.pyx":360
+  /* "borg/item.pyx":362
  * 
  *     def is_link(self):
  *         return self._is_type(stat.S_ISLNK)             # <<<<<<<<<<<<<<
  * 
  *     def is_dir(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 360, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 362, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 360, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 362, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISLNK); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 360, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISLNK); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 362, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -9318,22 +9385,22 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 360, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 362, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":359
+  /* "borg/item.pyx":361
  *         return cls(deleted=True, chunks=[], mode=0, path=path)
  * 
  *     def is_link(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISLNK)
  * 
  */
 
@@ -9347,15 +9414,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":362
+/* "borg/item.pyx":364
  *         return self._is_type(stat.S_ISLNK)
  * 
  *     def is_dir(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISDIR)
  * 
  */
 
@@ -9380,27 +9447,27 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_dir", 0);
 
-  /* "borg/item.pyx":363
+  /* "borg/item.pyx":365
  * 
  *     def is_dir(self):
  *         return self._is_type(stat.S_ISDIR)             # <<<<<<<<<<<<<<
  * 
  *     def is_fifo(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 363, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 365, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 363, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 365, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISDIR); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 363, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISDIR); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 365, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -9408,22 +9475,22 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 363, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 365, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":362
+  /* "borg/item.pyx":364
  *         return self._is_type(stat.S_ISLNK)
  * 
  *     def is_dir(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISDIR)
  * 
  */
 
@@ -9437,15 +9504,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":365
+/* "borg/item.pyx":367
  *         return self._is_type(stat.S_ISDIR)
  * 
  *     def is_fifo(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISFIFO)
  * 
  */
 
@@ -9470,27 +9537,27 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_fifo", 0);
 
-  /* "borg/item.pyx":366
+  /* "borg/item.pyx":368
  * 
  *     def is_fifo(self):
  *         return self._is_type(stat.S_ISFIFO)             # <<<<<<<<<<<<<<
  * 
  *     def is_blk(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 366, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 368, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 366, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 368, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISFIFO); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 366, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISFIFO); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 368, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -9498,22 +9565,22 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 366, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 368, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":365
+  /* "borg/item.pyx":367
  *         return self._is_type(stat.S_ISDIR)
  * 
  *     def is_fifo(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISFIFO)
  * 
  */
 
@@ -9527,15 +9594,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":368
+/* "borg/item.pyx":370
  *         return self._is_type(stat.S_ISFIFO)
  * 
  *     def is_blk(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISBLK)
  * 
  */
 
@@ -9560,27 +9627,27 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_blk", 0);
 
-  /* "borg/item.pyx":369
+  /* "borg/item.pyx":371
  * 
  *     def is_blk(self):
  *         return self._is_type(stat.S_ISBLK)             # <<<<<<<<<<<<<<
  * 
  *     def is_chr(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 369, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 371, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 369, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 371, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISBLK); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 369, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISBLK); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 371, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -9588,22 +9655,22 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 369, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 371, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":368
+  /* "borg/item.pyx":370
  *         return self._is_type(stat.S_ISFIFO)
  * 
  *     def is_blk(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISBLK)
  * 
  */
 
@@ -9617,15 +9684,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":371
+/* "borg/item.pyx":373
  *         return self._is_type(stat.S_ISBLK)
  * 
  *     def is_chr(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISCHR)
  * 
  */
 
@@ -9650,27 +9717,27 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_chr", 0);
 
-  /* "borg/item.pyx":372
+  /* "borg/item.pyx":374
  * 
  *     def is_chr(self):
  *         return self._is_type(stat.S_ISCHR)             # <<<<<<<<<<<<<<
  * 
  *     def _is_type(self, typetest):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 372, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 374, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 372, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_stat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 374, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISCHR); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 372, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_S_ISCHR); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 374, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -9678,22 +9745,22 @@
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 372, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 374, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":371
+  /* "borg/item.pyx":373
  *         return self._is_type(stat.S_ISBLK)
  * 
  *     def is_chr(self):             # <<<<<<<<<<<<<<
  *         return self._is_type(stat.S_ISCHR)
  * 
  */
 
@@ -9707,15 +9774,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":374
+/* "borg/item.pyx":376
  *         return self._is_type(stat.S_ISCHR)
  * 
  *     def _is_type(self, typetest):             # <<<<<<<<<<<<<<
  *         try:
  *             return typetest(self.mode)
  */
 
@@ -9744,15 +9811,15 @@
   PyObject *__pyx_t_7 = NULL;
   int __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_is_type", 0);
 
-  /* "borg/item.pyx":375
+  /* "borg/item.pyx":377
  * 
  *     def _is_type(self, typetest):
  *         try:             # <<<<<<<<<<<<<<
  *             return typetest(self.mode)
  *         except AttributeError:
  */
   {
@@ -9760,23 +9827,23 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "borg/item.pyx":376
+      /* "borg/item.pyx":378
  *     def _is_type(self, typetest):
  *         try:
  *             return typetest(self.mode)             # <<<<<<<<<<<<<<
  *         except AttributeError:
  *             return False
  */
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_mode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 376, __pyx_L3_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_mode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 378, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_INCREF(__pyx_v_typetest);
       __pyx_t_6 = __pyx_v_typetest; __pyx_t_7 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
@@ -9784,51 +9851,51 @@
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_6, function);
         }
       }
       __pyx_t_4 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_5);
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 376, __pyx_L3_error)
+      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 378, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __pyx_r = __pyx_t_4;
       __pyx_t_4 = 0;
       goto __pyx_L7_try_return;
 
-      /* "borg/item.pyx":375
+      /* "borg/item.pyx":377
  * 
  *     def _is_type(self, typetest):
  *         try:             # <<<<<<<<<<<<<<
  *             return typetest(self.mode)
  *         except AttributeError:
  */
     }
     __pyx_L3_error:;
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-    /* "borg/item.pyx":377
+    /* "borg/item.pyx":379
  *         try:
  *             return typetest(self.mode)
  *         except AttributeError:             # <<<<<<<<<<<<<<
  *             return False
  * 
  */
     __pyx_t_8 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
     if (__pyx_t_8) {
       __Pyx_AddTraceback("borg.item.Item._is_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_4, &__pyx_t_6, &__pyx_t_5) < 0) __PYX_ERR(0, 377, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_4, &__pyx_t_6, &__pyx_t_5) < 0) __PYX_ERR(0, 379, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_5);
 
-      /* "borg/item.pyx":378
+      /* "borg/item.pyx":380
  *             return typetest(self.mode)
  *         except AttributeError:
  *             return False             # <<<<<<<<<<<<<<
  * 
  *     def update_internal(self, d):
  */
       __Pyx_XDECREF(__pyx_r);
@@ -9838,15 +9905,15 @@
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       goto __pyx_L6_except_return;
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "borg/item.pyx":375
+    /* "borg/item.pyx":377
  * 
  *     def _is_type(self, typetest):
  *         try:             # <<<<<<<<<<<<<<
  *             return typetest(self.mode)
  *         except AttributeError:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
@@ -9864,15 +9931,15 @@
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L0;
   }
 
-  /* "borg/item.pyx":374
+  /* "borg/item.pyx":376
  *         return self._is_type(stat.S_ISCHR)
  * 
  *     def _is_type(self, typetest):             # <<<<<<<<<<<<<<
  *         try:
  *             return typetest(self.mode)
  */
 
@@ -9886,15 +9953,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":380
+/* "borg/item.pyx":382
  *             return False
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str),
  *         # also need to fix old timestamp data types.
  */
 
@@ -9933,110 +10000,110 @@
   Py_ssize_t __pyx_t_12;
   PyObject *__pyx_t_13 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("update_internal", 0);
 
-  /* "borg/item.pyx":383
+  /* "borg/item.pyx":385
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str),
  *         # also need to fix old timestamp data types.
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k in ('user', 'group') and d[k] is None:
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 383, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 383, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 383, __pyx_L1_error)
+  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 385, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 383, __pyx_L1_error)
+    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 385, __pyx_L1_error)
     #else
-    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 383, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 385, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
       PyObject* sequence = __pyx_t_2;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 2)) {
         if (size > 2) __Pyx_RaiseTooManyValuesError(2);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 383, __pyx_L1_error)
+        __PYX_ERR(0, 385, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
         __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
       } else {
         __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
       }
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_5);
       #else
-      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 383, __pyx_L1_error)
+      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 385, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 383, __pyx_L1_error)
+      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 385, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       #endif
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     } else {
       Py_ssize_t index = -1;
-      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 383, __pyx_L1_error)
+      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 385, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_7 = Py_TYPE(__pyx_t_6)->tp_iternext;
       index = 0; __pyx_t_3 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_3);
       index = 1; __pyx_t_5 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_5)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_5);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 383, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 385, __pyx_L1_error)
       __pyx_t_7 = NULL;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __pyx_t_7 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 383, __pyx_L1_error)
+      __PYX_ERR(0, 385, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
     __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_3);
     __pyx_t_3 = 0;
     __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "borg/item.pyx":384
+    /* "borg/item.pyx":386
  *         # also need to fix old timestamp data types.
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)             # <<<<<<<<<<<<<<
  *             if k in ('user', 'group') and d[k] is None:
  *                 # borg 1 stored some "not known" values with a None value.
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 384, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 386, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_3 = NULL;
     __pyx_t_8 = 0;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -10045,147 +10112,147 @@
         __Pyx_DECREF_SET(__pyx_t_5, function);
         __pyx_t_8 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 384, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 386, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 384, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 386, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     {
-      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 384, __pyx_L1_error)
+      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 386, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       if (__pyx_t_3) {
         __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
       }
       __Pyx_INCREF(__pyx_v_d);
       __Pyx_GIVEREF(__pyx_v_d);
       PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_d);
       __Pyx_INCREF(__pyx_v_k);
       __Pyx_GIVEREF(__pyx_v_k);
       PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_v_k);
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 384, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 386, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     }
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_k, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":385
+    /* "borg/item.pyx":387
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k in ('user', 'group') and d[k] is None:             # <<<<<<<<<<<<<<
  *                 # borg 1 stored some "not known" values with a None value.
  *                 # borg 2 policy for such cases is to just not have the key/value pair.
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_11 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_user, Py_EQ)); if (unlikely(__pyx_t_11 < 0)) __PYX_ERR(0, 385, __pyx_L1_error)
+    __pyx_t_11 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_user, Py_EQ)); if (unlikely(__pyx_t_11 < 0)) __PYX_ERR(0, 387, __pyx_L1_error)
     if (!__pyx_t_11) {
     } else {
       __pyx_t_10 = __pyx_t_11;
       goto __pyx_L10_bool_binop_done;
     }
-    __pyx_t_11 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_group, Py_EQ)); if (unlikely(__pyx_t_11 < 0)) __PYX_ERR(0, 385, __pyx_L1_error)
+    __pyx_t_11 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_group, Py_EQ)); if (unlikely(__pyx_t_11 < 0)) __PYX_ERR(0, 387, __pyx_L1_error)
     __pyx_t_10 = __pyx_t_11;
     __pyx_L10_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_11 = (__pyx_t_10 != 0);
     if (__pyx_t_11) {
     } else {
       __pyx_t_9 = __pyx_t_11;
       goto __pyx_L8_bool_binop_done;
     }
-    __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_v_d, __pyx_v_k); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 385, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_v_d, __pyx_v_k); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 387, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_t_11 = (__pyx_t_2 == Py_None);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_10 = (__pyx_t_11 != 0);
     __pyx_t_9 = __pyx_t_10;
     __pyx_L8_bool_binop_done:;
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":388
+      /* "borg/item.pyx":390
  *                 # borg 1 stored some "not known" values with a None value.
  *                 # borg 2 policy for such cases is to just not have the key/value pair.
  *                 continue             # <<<<<<<<<<<<<<
  *             if k in ('path', 'source', 'target', 'user', 'group'):
  *                 v = fix_str_value(d, k)
  */
       goto __pyx_L3_continue;
 
-      /* "borg/item.pyx":385
+      /* "borg/item.pyx":387
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k in ('user', 'group') and d[k] is None:             # <<<<<<<<<<<<<<
  *                 # borg 1 stored some "not known" values with a None value.
  *                 # borg 2 policy for such cases is to just not have the key/value pair.
  */
     }
 
-    /* "borg/item.pyx":389
+    /* "borg/item.pyx":391
  *                 # borg 2 policy for such cases is to just not have the key/value pair.
  *                 continue
  *             if k in ('path', 'source', 'target', 'user', 'group'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k)
  *             if k in ('chunks', 'chunks_healthy'):
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_path, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 389, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_path, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 391, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L13_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_source, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 389, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_source, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 391, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L13_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_target, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 389, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_target, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 391, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L13_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_user, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 389, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_user, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 391, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L13_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_group, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 389, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_group, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 391, __pyx_L1_error)
     __pyx_t_9 = __pyx_t_10;
     __pyx_L13_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_10 = (__pyx_t_9 != 0);
     if (__pyx_t_10) {
 
-      /* "borg/item.pyx":390
+      /* "borg/item.pyx":392
  *                 continue
  *             if k in ('path', 'source', 'target', 'user', 'group'):
  *                 v = fix_str_value(d, k)             # <<<<<<<<<<<<<<
  *             if k in ('chunks', 'chunks_healthy'):
  *                 v = fix_list_of_chunkentries(v)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 390, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 392, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -10194,226 +10261,226 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 390, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 392, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 390, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 392, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       {
-        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 390, __pyx_L1_error)
+        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 392, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         if (__pyx_t_6) {
           __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_6); __pyx_t_6 = NULL;
         }
         __Pyx_INCREF(__pyx_v_d);
         __Pyx_GIVEREF(__pyx_v_d);
         PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_v_d);
         __Pyx_INCREF(__pyx_v_k);
         __Pyx_GIVEREF(__pyx_v_k);
         PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_v_k);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 390, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 392, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":389
+      /* "borg/item.pyx":391
  *                 # borg 2 policy for such cases is to just not have the key/value pair.
  *                 continue
  *             if k in ('path', 'source', 'target', 'user', 'group'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k)
  *             if k in ('chunks', 'chunks_healthy'):
  */
     }
 
-    /* "borg/item.pyx":391
+    /* "borg/item.pyx":393
  *             if k in ('path', 'source', 'target', 'user', 'group'):
  *                 v = fix_str_value(d, k)
  *             if k in ('chunks', 'chunks_healthy'):             # <<<<<<<<<<<<<<
  *                 v = fix_list_of_chunkentries(v)
  *             if k in ('atime', 'ctime', 'mtime', 'birthtime'):
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_chunks, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 391, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_chunks, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 393, __pyx_L1_error)
     if (!__pyx_t_9) {
     } else {
       __pyx_t_10 = __pyx_t_9;
       goto __pyx_L19_bool_binop_done;
     }
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_chunks_healthy, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 391, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_chunks_healthy, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 393, __pyx_L1_error)
     __pyx_t_10 = __pyx_t_9;
     __pyx_L19_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_9 = (__pyx_t_10 != 0);
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":392
+      /* "borg/item.pyx":394
  *                 v = fix_str_value(d, k)
  *             if k in ('chunks', 'chunks_healthy'):
  *                 v = fix_list_of_chunkentries(v)             # <<<<<<<<<<<<<<
  *             if k in ('atime', 'ctime', 'mtime', 'birthtime'):
  *                 v = fix_timestamp(v)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_list_of_chunkentries); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 392, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_list_of_chunkentries); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 394, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_3 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_3)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_3);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_3, __pyx_v_v) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_v);
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 392, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 394, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":391
+      /* "borg/item.pyx":393
  *             if k in ('path', 'source', 'target', 'user', 'group'):
  *                 v = fix_str_value(d, k)
  *             if k in ('chunks', 'chunks_healthy'):             # <<<<<<<<<<<<<<
  *                 v = fix_list_of_chunkentries(v)
  *             if k in ('atime', 'ctime', 'mtime', 'birthtime'):
  */
     }
 
-    /* "borg/item.pyx":393
+    /* "borg/item.pyx":395
  *             if k in ('chunks', 'chunks_healthy'):
  *                 v = fix_list_of_chunkentries(v)
  *             if k in ('atime', 'ctime', 'mtime', 'birthtime'):             # <<<<<<<<<<<<<<
  *                 v = fix_timestamp(v)
  *             if k in ('acl_access', 'acl_default', 'acl_extended', 'acl_nfs4'):
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_atime, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 393, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_atime, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 395, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L22_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_ctime, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 393, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_ctime, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 395, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L22_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_mtime, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 393, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_mtime, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 395, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L22_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_birthtime, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 393, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_birthtime, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 395, __pyx_L1_error)
     __pyx_t_9 = __pyx_t_10;
     __pyx_L22_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_10 = (__pyx_t_9 != 0);
     if (__pyx_t_10) {
 
-      /* "borg/item.pyx":394
+      /* "borg/item.pyx":396
  *                 v = fix_list_of_chunkentries(v)
  *             if k in ('atime', 'ctime', 'mtime', 'birthtime'):
  *                 v = fix_timestamp(v)             # <<<<<<<<<<<<<<
  *             if k in ('acl_access', 'acl_default', 'acl_extended', 'acl_nfs4'):
  *                 v = fix_bytes_value(d, k)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_timestamp); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 394, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_timestamp); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 396, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_3 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_3)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_3);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_3, __pyx_v_v) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_v);
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 394, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 396, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":393
+      /* "borg/item.pyx":395
  *             if k in ('chunks', 'chunks_healthy'):
  *                 v = fix_list_of_chunkentries(v)
  *             if k in ('atime', 'ctime', 'mtime', 'birthtime'):             # <<<<<<<<<<<<<<
  *                 v = fix_timestamp(v)
  *             if k in ('acl_access', 'acl_default', 'acl_extended', 'acl_nfs4'):
  */
     }
 
-    /* "borg/item.pyx":395
+    /* "borg/item.pyx":397
  *             if k in ('atime', 'ctime', 'mtime', 'birthtime'):
  *                 v = fix_timestamp(v)
  *             if k in ('acl_access', 'acl_default', 'acl_extended', 'acl_nfs4'):             # <<<<<<<<<<<<<<
  *                 v = fix_bytes_value(d, k)
  *             if k == 'xattrs':
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_acl_access, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 395, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_acl_access, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 397, __pyx_L1_error)
     if (!__pyx_t_9) {
     } else {
       __pyx_t_10 = __pyx_t_9;
       goto __pyx_L27_bool_binop_done;
     }
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_acl_default, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 395, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_acl_default, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 397, __pyx_L1_error)
     if (!__pyx_t_9) {
     } else {
       __pyx_t_10 = __pyx_t_9;
       goto __pyx_L27_bool_binop_done;
     }
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_acl_extended, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 395, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_acl_extended, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 397, __pyx_L1_error)
     if (!__pyx_t_9) {
     } else {
       __pyx_t_10 = __pyx_t_9;
       goto __pyx_L27_bool_binop_done;
     }
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_acl_nfs4, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 395, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_acl_nfs4, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 397, __pyx_L1_error)
     __pyx_t_10 = __pyx_t_9;
     __pyx_L27_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_9 = (__pyx_t_10 != 0);
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":396
+      /* "borg/item.pyx":398
  *                 v = fix_timestamp(v)
  *             if k in ('acl_access', 'acl_default', 'acl_extended', 'acl_nfs4'):
  *                 v = fix_bytes_value(d, k)             # <<<<<<<<<<<<<<
  *             if k == 'xattrs':
  *                 if not isinstance(v, StableDict):
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 396, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 398, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_3 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_3)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -10422,352 +10489,352 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 396, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 398, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 396, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 398, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       {
-        __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 396, __pyx_L1_error)
+        __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 398, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_6);
         if (__pyx_t_3) {
           __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
         }
         __Pyx_INCREF(__pyx_v_d);
         __Pyx_GIVEREF(__pyx_v_d);
         PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_d);
         __Pyx_INCREF(__pyx_v_k);
         __Pyx_GIVEREF(__pyx_v_k);
         PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_v_k);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 396, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 398, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":395
+      /* "borg/item.pyx":397
  *             if k in ('atime', 'ctime', 'mtime', 'birthtime'):
  *                 v = fix_timestamp(v)
  *             if k in ('acl_access', 'acl_default', 'acl_extended', 'acl_nfs4'):             # <<<<<<<<<<<<<<
  *                 v = fix_bytes_value(d, k)
  *             if k == 'xattrs':
  */
     }
 
-    /* "borg/item.pyx":397
+    /* "borg/item.pyx":399
  *             if k in ('acl_access', 'acl_default', 'acl_extended', 'acl_nfs4'):
  *                 v = fix_bytes_value(d, k)
  *             if k == 'xattrs':             # <<<<<<<<<<<<<<
  *                 if not isinstance(v, StableDict):
  *                     v = StableDict(v)
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_xattrs, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 397, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_xattrs, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 399, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":398
+      /* "borg/item.pyx":400
  *                 v = fix_bytes_value(d, k)
  *             if k == 'xattrs':
  *                 if not isinstance(v, StableDict):             # <<<<<<<<<<<<<<
  *                     v = StableDict(v)
  *                 v_new = StableDict()
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 398, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 400, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_9 = PyObject_IsInstance(__pyx_v_v, __pyx_t_2); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 398, __pyx_L1_error)
+      __pyx_t_9 = PyObject_IsInstance(__pyx_v_v, __pyx_t_2); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 400, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_10 = ((!(__pyx_t_9 != 0)) != 0);
       if (__pyx_t_10) {
 
-        /* "borg/item.pyx":399
+        /* "borg/item.pyx":401
  *             if k == 'xattrs':
  *                 if not isinstance(v, StableDict):
  *                     v = StableDict(v)             # <<<<<<<<<<<<<<
  *                 v_new = StableDict()
  *                 for xk, xv in list(v.items()):
  */
-        __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 399, __pyx_L1_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 401, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         __pyx_t_6 = NULL;
         if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
           __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
           if (likely(__pyx_t_6)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
             __Pyx_INCREF(__pyx_t_6);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_5, function);
           }
         }
         __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_v) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_v);
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 399, __pyx_L1_error)
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 401, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
         __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
         __pyx_t_2 = 0;
 
-        /* "borg/item.pyx":398
+        /* "borg/item.pyx":400
  *                 v = fix_bytes_value(d, k)
  *             if k == 'xattrs':
  *                 if not isinstance(v, StableDict):             # <<<<<<<<<<<<<<
  *                     v = StableDict(v)
  *                 v_new = StableDict()
  */
       }
 
-      /* "borg/item.pyx":400
+      /* "borg/item.pyx":402
  *                 if not isinstance(v, StableDict):
  *                     v = StableDict(v)
  *                 v_new = StableDict()             # <<<<<<<<<<<<<<
  *                 for xk, xv in list(v.items()):
  *                     xk = want_bytes(xk)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 400, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 402, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 400, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 402, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_XDECREF_SET(__pyx_v_v_new, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":401
+      /* "borg/item.pyx":403
  *                     v = StableDict(v)
  *                 v_new = StableDict()
  *                 for xk, xv in list(v.items()):             # <<<<<<<<<<<<<<
  *                     xk = want_bytes(xk)
  *                     # old borg used to store None instead of a b'' value
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_v, __pyx_n_s_items); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 401, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_v, __pyx_n_s_items); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 403, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 401, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 403, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_5 = PySequence_List(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 401, __pyx_L1_error)
+      __pyx_t_5 = PySequence_List(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 403, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_2 = __pyx_t_5; __Pyx_INCREF(__pyx_t_2); __pyx_t_12 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       for (;;) {
         if (__pyx_t_12 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_12); __Pyx_INCREF(__pyx_t_5); __pyx_t_12++; if (unlikely(0 < 0)) __PYX_ERR(0, 401, __pyx_L1_error)
+        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_12); __Pyx_INCREF(__pyx_t_5); __pyx_t_12++; if (unlikely(0 < 0)) __PYX_ERR(0, 403, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_12); __pyx_t_12++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 401, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_12); __pyx_t_12++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 403, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
         if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
           PyObject* sequence = __pyx_t_5;
           Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
           if (unlikely(size != 2)) {
             if (size > 2) __Pyx_RaiseTooManyValuesError(2);
             else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-            __PYX_ERR(0, 401, __pyx_L1_error)
+            __PYX_ERR(0, 403, __pyx_L1_error)
           }
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
           if (likely(PyTuple_CheckExact(sequence))) {
             __pyx_t_6 = PyTuple_GET_ITEM(sequence, 0); 
             __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
           } else {
             __pyx_t_6 = PyList_GET_ITEM(sequence, 0); 
             __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
           }
           __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(__pyx_t_3);
           #else
-          __pyx_t_6 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 401, __pyx_L1_error)
+          __pyx_t_6 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 403, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_6);
-          __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 401, __pyx_L1_error)
+          __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 403, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_3);
           #endif
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
         } else {
           Py_ssize_t index = -1;
-          __pyx_t_13 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 401, __pyx_L1_error)
+          __pyx_t_13 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 403, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_13);
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
           __pyx_t_7 = Py_TYPE(__pyx_t_13)->tp_iternext;
           index = 0; __pyx_t_6 = __pyx_t_7(__pyx_t_13); if (unlikely(!__pyx_t_6)) goto __pyx_L35_unpacking_failed;
           __Pyx_GOTREF(__pyx_t_6);
           index = 1; __pyx_t_3 = __pyx_t_7(__pyx_t_13); if (unlikely(!__pyx_t_3)) goto __pyx_L35_unpacking_failed;
           __Pyx_GOTREF(__pyx_t_3);
-          if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_13), 2) < 0) __PYX_ERR(0, 401, __pyx_L1_error)
+          if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_13), 2) < 0) __PYX_ERR(0, 403, __pyx_L1_error)
           __pyx_t_7 = NULL;
           __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
           goto __pyx_L36_unpacking_done;
           __pyx_L35_unpacking_failed:;
           __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
           __pyx_t_7 = NULL;
           if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-          __PYX_ERR(0, 401, __pyx_L1_error)
+          __PYX_ERR(0, 403, __pyx_L1_error)
           __pyx_L36_unpacking_done:;
         }
         __Pyx_XDECREF_SET(__pyx_v_xk, __pyx_t_6);
         __pyx_t_6 = 0;
         __Pyx_XDECREF_SET(__pyx_v_xv, __pyx_t_3);
         __pyx_t_3 = 0;
 
-        /* "borg/item.pyx":402
+        /* "borg/item.pyx":404
  *                 v_new = StableDict()
  *                 for xk, xv in list(v.items()):
  *                     xk = want_bytes(xk)             # <<<<<<<<<<<<<<
  *                     # old borg used to store None instead of a b'' value
  *                     xv = b'' if xv is None else want_bytes(xv)
  */
-        __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 402, __pyx_L1_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 404, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __pyx_t_6 = NULL;
         if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
           __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
           if (likely(__pyx_t_6)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
             __Pyx_INCREF(__pyx_t_6);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_3, function);
           }
         }
         __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_v_xk) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_xk);
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-        if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 402, __pyx_L1_error)
+        if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 404, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_DECREF_SET(__pyx_v_xk, __pyx_t_5);
         __pyx_t_5 = 0;
 
-        /* "borg/item.pyx":404
+        /* "borg/item.pyx":406
  *                     xk = want_bytes(xk)
  *                     # old borg used to store None instead of a b'' value
  *                     xv = b'' if xv is None else want_bytes(xv)             # <<<<<<<<<<<<<<
  *                     v_new[xk] = xv
  *                 v = v_new  # xattrs is a StableDict(bytes keys -> bytes values)
  */
         __pyx_t_10 = (__pyx_v_xv == Py_None);
         if ((__pyx_t_10 != 0)) {
           __Pyx_INCREF(__pyx_kp_b__9);
           __pyx_t_5 = __pyx_kp_b__9;
         } else {
-          __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 404, __pyx_L1_error)
+          __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_want_bytes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 406, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_6);
           __pyx_t_13 = NULL;
           if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
             __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_6);
             if (likely(__pyx_t_13)) {
               PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
               __Pyx_INCREF(__pyx_t_13);
               __Pyx_INCREF(function);
               __Pyx_DECREF_SET(__pyx_t_6, function);
             }
           }
           __pyx_t_3 = (__pyx_t_13) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_13, __pyx_v_xv) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_xv);
           __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
-          if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 404, __pyx_L1_error)
+          if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 406, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
           __pyx_t_5 = __pyx_t_3;
           __pyx_t_3 = 0;
         }
         __Pyx_DECREF_SET(__pyx_v_xv, __pyx_t_5);
         __pyx_t_5 = 0;
 
-        /* "borg/item.pyx":405
+        /* "borg/item.pyx":407
  *                     # old borg used to store None instead of a b'' value
  *                     xv = b'' if xv is None else want_bytes(xv)
  *                     v_new[xk] = xv             # <<<<<<<<<<<<<<
  *                 v = v_new  # xattrs is a StableDict(bytes keys -> bytes values)
  *             self._dict[k] = v
  */
-        if (unlikely(PyObject_SetItem(__pyx_v_v_new, __pyx_v_xk, __pyx_v_xv) < 0)) __PYX_ERR(0, 405, __pyx_L1_error)
+        if (unlikely(PyObject_SetItem(__pyx_v_v_new, __pyx_v_xk, __pyx_v_xv) < 0)) __PYX_ERR(0, 407, __pyx_L1_error)
 
-        /* "borg/item.pyx":401
+        /* "borg/item.pyx":403
  *                     v = StableDict(v)
  *                 v_new = StableDict()
  *                 for xk, xv in list(v.items()):             # <<<<<<<<<<<<<<
  *                     xk = want_bytes(xk)
  *                     # old borg used to store None instead of a b'' value
  */
       }
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":406
+      /* "borg/item.pyx":408
  *                     xv = b'' if xv is None else want_bytes(xv)
  *                     v_new[xk] = xv
  *                 v = v_new  # xattrs is a StableDict(bytes keys -> bytes values)             # <<<<<<<<<<<<<<
  *             self._dict[k] = v
  * 
  */
       __Pyx_INCREF(__pyx_v_v_new);
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_v_v_new);
 
-      /* "borg/item.pyx":397
+      /* "borg/item.pyx":399
  *             if k in ('acl_access', 'acl_default', 'acl_extended', 'acl_nfs4'):
  *                 v = fix_bytes_value(d, k)
  *             if k == 'xattrs':             # <<<<<<<<<<<<<<
  *                 if not isinstance(v, StableDict):
  *                     v = StableDict(v)
  */
     }
 
-    /* "borg/item.pyx":407
+    /* "borg/item.pyx":409
  *                     v_new[xk] = xv
  *                 v = v_new  # xattrs is a StableDict(bytes keys -> bytes values)
  *             self._dict[k] = v             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 407, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 409, __pyx_L1_error)
 
-    /* "borg/item.pyx":383
+    /* "borg/item.pyx":385
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str),
  *         # also need to fix old timestamp data types.
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k in ('user', 'group') and d[k] is None:
  */
     __pyx_L3_continue:;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":380
+  /* "borg/item.pyx":382
  *             return False
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str),
  *         # also need to fix old timestamp data types.
  */
 
@@ -10903,15 +10970,15 @@
   __Pyx_AddTraceback("borg.item.Item.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":436
+/* "borg/item.pyx":438
  *     argon2_type = PropDictProperty(str)
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  */
 
@@ -10944,110 +11011,110 @@
   int __pyx_t_9;
   int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("update_internal", 0);
 
-  /* "borg/item.pyx":438
+  /* "borg/item.pyx":440
  *     def update_internal(self, d):
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k == 'version':
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 438, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 440, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 438, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 440, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 438, __pyx_L1_error)
+  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 440, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 438, __pyx_L1_error)
+    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 440, __pyx_L1_error)
     #else
-    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 438, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 440, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
       PyObject* sequence = __pyx_t_2;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 2)) {
         if (size > 2) __Pyx_RaiseTooManyValuesError(2);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 438, __pyx_L1_error)
+        __PYX_ERR(0, 440, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
         __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
       } else {
         __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
       }
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_5);
       #else
-      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 438, __pyx_L1_error)
+      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 440, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 438, __pyx_L1_error)
+      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 440, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       #endif
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     } else {
       Py_ssize_t index = -1;
-      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 438, __pyx_L1_error)
+      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 440, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_7 = Py_TYPE(__pyx_t_6)->tp_iternext;
       index = 0; __pyx_t_3 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_3);
       index = 1; __pyx_t_5 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_5)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_5);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 438, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 440, __pyx_L1_error)
       __pyx_t_7 = NULL;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __pyx_t_7 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 438, __pyx_L1_error)
+      __PYX_ERR(0, 440, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
     __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_3);
     __pyx_t_3 = 0;
     __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "borg/item.pyx":439
+    /* "borg/item.pyx":441
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)             # <<<<<<<<<<<<<<
  *             if k == 'version':
  *                 assert isinstance(v, int)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 439, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 441, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_3 = NULL;
     __pyx_t_8 = 0;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -11056,113 +11123,113 @@
         __Pyx_DECREF_SET(__pyx_t_5, function);
         __pyx_t_8 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 439, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 441, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 439, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 441, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     {
-      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 439, __pyx_L1_error)
+      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 441, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       if (__pyx_t_3) {
         __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
       }
       __Pyx_INCREF(__pyx_v_d);
       __Pyx_GIVEREF(__pyx_v_d);
       PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_d);
       __Pyx_INCREF(__pyx_v_k);
       __Pyx_GIVEREF(__pyx_v_k);
       PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_v_k);
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 439, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 441, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     }
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_k, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":440
+    /* "borg/item.pyx":442
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k == 'version':             # <<<<<<<<<<<<<<
  *                 assert isinstance(v, int)
  *             if k in ('algorithm', 'argon2_type'):
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_version, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 440, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_version, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 442, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":441
+      /* "borg/item.pyx":443
  *             k = fix_key(d, k)
  *             if k == 'version':
  *                 assert isinstance(v, int)             # <<<<<<<<<<<<<<
  *             if k in ('algorithm', 'argon2_type'):
  *                 v = fix_str_value(d, k)
  */
       #ifndef CYTHON_WITHOUT_ASSERTIONS
       if (unlikely(!Py_OptimizeFlag)) {
         __pyx_t_9 = PyInt_Check(__pyx_v_v); 
         if (unlikely(!(__pyx_t_9 != 0))) {
           PyErr_SetNone(PyExc_AssertionError);
-          __PYX_ERR(0, 441, __pyx_L1_error)
+          __PYX_ERR(0, 443, __pyx_L1_error)
         }
       }
       #endif
 
-      /* "borg/item.pyx":440
+      /* "borg/item.pyx":442
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k == 'version':             # <<<<<<<<<<<<<<
  *                 assert isinstance(v, int)
  *             if k in ('algorithm', 'argon2_type'):
  */
     }
 
-    /* "borg/item.pyx":442
+    /* "borg/item.pyx":444
  *             if k == 'version':
  *                 assert isinstance(v, int)
  *             if k in ('algorithm', 'argon2_type'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k)
  *             if k in ('salt', 'hash', 'data'):
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_algorithm, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 442, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_algorithm, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 444, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L9_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_argon2_type, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 442, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_argon2_type, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 444, __pyx_L1_error)
     __pyx_t_9 = __pyx_t_10;
     __pyx_L9_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_10 = (__pyx_t_9 != 0);
     if (__pyx_t_10) {
 
-      /* "borg/item.pyx":443
+      /* "borg/item.pyx":445
  *                 assert isinstance(v, int)
  *             if k in ('algorithm', 'argon2_type'):
  *                 v = fix_str_value(d, k)             # <<<<<<<<<<<<<<
  *             if k in ('salt', 'hash', 'data'):
  *                 v = fix_bytes_value(d, k)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 443, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 445, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -11171,92 +11238,92 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 443, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 445, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 443, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 445, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       {
-        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 443, __pyx_L1_error)
+        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 445, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         if (__pyx_t_6) {
           __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_6); __pyx_t_6 = NULL;
         }
         __Pyx_INCREF(__pyx_v_d);
         __Pyx_GIVEREF(__pyx_v_d);
         PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_v_d);
         __Pyx_INCREF(__pyx_v_k);
         __Pyx_GIVEREF(__pyx_v_k);
         PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_v_k);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 443, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 445, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":442
+      /* "borg/item.pyx":444
  *             if k == 'version':
  *                 assert isinstance(v, int)
  *             if k in ('algorithm', 'argon2_type'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k)
  *             if k in ('salt', 'hash', 'data'):
  */
     }
 
-    /* "borg/item.pyx":444
+    /* "borg/item.pyx":446
  *             if k in ('algorithm', 'argon2_type'):
  *                 v = fix_str_value(d, k)
  *             if k in ('salt', 'hash', 'data'):             # <<<<<<<<<<<<<<
  *                 v = fix_bytes_value(d, k)
  *             self._dict[k] = v
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_salt, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 444, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_salt, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 446, __pyx_L1_error)
     if (!__pyx_t_9) {
     } else {
       __pyx_t_10 = __pyx_t_9;
       goto __pyx_L12_bool_binop_done;
     }
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_hash, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 444, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_hash, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 446, __pyx_L1_error)
     if (!__pyx_t_9) {
     } else {
       __pyx_t_10 = __pyx_t_9;
       goto __pyx_L12_bool_binop_done;
     }
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_data, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 444, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_data, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 446, __pyx_L1_error)
     __pyx_t_10 = __pyx_t_9;
     __pyx_L12_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_9 = (__pyx_t_10 != 0);
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":445
+      /* "borg/item.pyx":447
  *                 v = fix_str_value(d, k)
  *             if k in ('salt', 'hash', 'data'):
  *                 v = fix_bytes_value(d, k)             # <<<<<<<<<<<<<<
  *             self._dict[k] = v
  * 
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 445, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 447, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_3 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_3)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -11265,76 +11332,76 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 445, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 447, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 445, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 447, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       {
-        __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 445, __pyx_L1_error)
+        __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 447, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_6);
         if (__pyx_t_3) {
           __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
         }
         __Pyx_INCREF(__pyx_v_d);
         __Pyx_GIVEREF(__pyx_v_d);
         PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_d);
         __Pyx_INCREF(__pyx_v_k);
         __Pyx_GIVEREF(__pyx_v_k);
         PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_v_k);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 445, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 447, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":444
+      /* "borg/item.pyx":446
  *             if k in ('algorithm', 'argon2_type'):
  *                 v = fix_str_value(d, k)
  *             if k in ('salt', 'hash', 'data'):             # <<<<<<<<<<<<<<
  *                 v = fix_bytes_value(d, k)
  *             self._dict[k] = v
  */
     }
 
-    /* "borg/item.pyx":446
+    /* "borg/item.pyx":448
  *             if k in ('salt', 'hash', 'data'):
  *                 v = fix_bytes_value(d, k)
  *             self._dict[k] = v             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 446, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 448, __pyx_L1_error)
 
-    /* "borg/item.pyx":438
+    /* "borg/item.pyx":440
  *     def update_internal(self, d):
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k == 'version':
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":436
+  /* "borg/item.pyx":438
  *     argon2_type = PropDictProperty(str)
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  */
 
@@ -11466,15 +11533,15 @@
   __Pyx_AddTraceback("borg.item.EncryptedKey.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":470
+/* "borg/item.pyx":472
  *     tam_required = PropDictProperty(bool)
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  */
 
@@ -11507,110 +11574,110 @@
   int __pyx_t_9;
   int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("update_internal", 0);
 
-  /* "borg/item.pyx":472
+  /* "borg/item.pyx":474
  *     def update_internal(self, d):
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k == 'version':
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 472, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 474, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 472, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 474, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 472, __pyx_L1_error)
+  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 474, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 472, __pyx_L1_error)
+    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 474, __pyx_L1_error)
     #else
-    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 472, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 474, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
       PyObject* sequence = __pyx_t_2;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 2)) {
         if (size > 2) __Pyx_RaiseTooManyValuesError(2);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 472, __pyx_L1_error)
+        __PYX_ERR(0, 474, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
         __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
       } else {
         __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
       }
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_5);
       #else
-      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 472, __pyx_L1_error)
+      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 474, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 472, __pyx_L1_error)
+      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 474, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       #endif
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     } else {
       Py_ssize_t index = -1;
-      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 472, __pyx_L1_error)
+      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 474, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_7 = Py_TYPE(__pyx_t_6)->tp_iternext;
       index = 0; __pyx_t_3 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_3);
       index = 1; __pyx_t_5 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_5)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_5);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 472, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 474, __pyx_L1_error)
       __pyx_t_7 = NULL;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __pyx_t_7 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 472, __pyx_L1_error)
+      __PYX_ERR(0, 474, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
     __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_3);
     __pyx_t_3 = 0;
     __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "borg/item.pyx":473
+    /* "borg/item.pyx":475
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)             # <<<<<<<<<<<<<<
  *             if k == 'version':
  *                 assert isinstance(v, int)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 473, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 475, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_3 = NULL;
     __pyx_t_8 = 0;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -11619,119 +11686,119 @@
         __Pyx_DECREF_SET(__pyx_t_5, function);
         __pyx_t_8 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 473, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 475, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 473, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 475, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     {
-      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 473, __pyx_L1_error)
+      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 475, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       if (__pyx_t_3) {
         __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
       }
       __Pyx_INCREF(__pyx_v_d);
       __Pyx_GIVEREF(__pyx_v_d);
       PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_d);
       __Pyx_INCREF(__pyx_v_k);
       __Pyx_GIVEREF(__pyx_v_k);
       PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_v_k);
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 473, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 475, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     }
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_k, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":474
+    /* "borg/item.pyx":476
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k == 'version':             # <<<<<<<<<<<<<<
  *                 assert isinstance(v, int)
  *             if k in ('repository_id', 'crypt_key', 'id_key'):
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_version, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 474, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_version, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 476, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":475
+      /* "borg/item.pyx":477
  *             k = fix_key(d, k)
  *             if k == 'version':
  *                 assert isinstance(v, int)             # <<<<<<<<<<<<<<
  *             if k in ('repository_id', 'crypt_key', 'id_key'):
  *                 v = fix_bytes_value(d, k)
  */
       #ifndef CYTHON_WITHOUT_ASSERTIONS
       if (unlikely(!Py_OptimizeFlag)) {
         __pyx_t_9 = PyInt_Check(__pyx_v_v); 
         if (unlikely(!(__pyx_t_9 != 0))) {
           PyErr_SetNone(PyExc_AssertionError);
-          __PYX_ERR(0, 475, __pyx_L1_error)
+          __PYX_ERR(0, 477, __pyx_L1_error)
         }
       }
       #endif
 
-      /* "borg/item.pyx":474
+      /* "borg/item.pyx":476
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k == 'version':             # <<<<<<<<<<<<<<
  *                 assert isinstance(v, int)
  *             if k in ('repository_id', 'crypt_key', 'id_key'):
  */
     }
 
-    /* "borg/item.pyx":476
+    /* "borg/item.pyx":478
  *             if k == 'version':
  *                 assert isinstance(v, int)
  *             if k in ('repository_id', 'crypt_key', 'id_key'):             # <<<<<<<<<<<<<<
  *                 v = fix_bytes_value(d, k)
  *             self._dict[k] = v
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_repository_id, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 476, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_repository_id, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 478, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L9_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_crypt_key, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 476, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_crypt_key, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 478, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L9_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_id_key, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 476, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_id_key, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 478, __pyx_L1_error)
     __pyx_t_9 = __pyx_t_10;
     __pyx_L9_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_10 = (__pyx_t_9 != 0);
     if (__pyx_t_10) {
 
-      /* "borg/item.pyx":477
+      /* "borg/item.pyx":479
  *                 assert isinstance(v, int)
  *             if k in ('repository_id', 'crypt_key', 'id_key'):
  *                 v = fix_bytes_value(d, k)             # <<<<<<<<<<<<<<
  *             self._dict[k] = v
  *         if 'crypt_key' not in self._dict:  # legacy, we're loading an old v1 key
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 477, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 479, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -11740,94 +11807,94 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 477, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 479, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 477, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 479, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       {
-        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 477, __pyx_L1_error)
+        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 479, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         if (__pyx_t_6) {
           __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_6); __pyx_t_6 = NULL;
         }
         __Pyx_INCREF(__pyx_v_d);
         __Pyx_GIVEREF(__pyx_v_d);
         PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_v_d);
         __Pyx_INCREF(__pyx_v_k);
         __Pyx_GIVEREF(__pyx_v_k);
         PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_v_k);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 477, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 479, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":476
+      /* "borg/item.pyx":478
  *             if k == 'version':
  *                 assert isinstance(v, int)
  *             if k in ('repository_id', 'crypt_key', 'id_key'):             # <<<<<<<<<<<<<<
  *                 v = fix_bytes_value(d, k)
  *             self._dict[k] = v
  */
     }
 
-    /* "borg/item.pyx":478
+    /* "borg/item.pyx":480
  *             if k in ('repository_id', 'crypt_key', 'id_key'):
  *                 v = fix_bytes_value(d, k)
  *             self._dict[k] = v             # <<<<<<<<<<<<<<
  *         if 'crypt_key' not in self._dict:  # legacy, we're loading an old v1 key
  *             k = fix_bytes_value(d, 'enc_key') + fix_bytes_value(d, 'enc_hmac_key')
  */
-    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 478, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 480, __pyx_L1_error)
 
-    /* "borg/item.pyx":472
+    /* "borg/item.pyx":474
  *     def update_internal(self, d):
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k == 'version':
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":479
+  /* "borg/item.pyx":481
  *                 v = fix_bytes_value(d, k)
  *             self._dict[k] = v
  *         if 'crypt_key' not in self._dict:  # legacy, we're loading an old v1 key             # <<<<<<<<<<<<<<
  *             k = fix_bytes_value(d, 'enc_key') + fix_bytes_value(d, 'enc_hmac_key')
  *             assert isinstance(k, bytes), "k == %r" % k
  */
-  __pyx_t_10 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_crypt_key, __pyx_v_self->__pyx_base._dict, Py_NE)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 479, __pyx_L1_error)
+  __pyx_t_10 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_crypt_key, __pyx_v_self->__pyx_base._dict, Py_NE)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 481, __pyx_L1_error)
   __pyx_t_9 = (__pyx_t_10 != 0);
   if (__pyx_t_9) {
 
-    /* "borg/item.pyx":480
+    /* "borg/item.pyx":482
  *             self._dict[k] = v
  *         if 'crypt_key' not in self._dict:  # legacy, we're loading an old v1 key
  *             k = fix_bytes_value(d, 'enc_key') + fix_bytes_value(d, 'enc_hmac_key')             # <<<<<<<<<<<<<<
  *             assert isinstance(k, bytes), "k == %r" % k
  *             assert len(k) in (32 + 32, 32 + 128)  # 256+256 or 256+1024 bits
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 480, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 482, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_t_5 = NULL;
     __pyx_t_8 = 0;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -11836,45 +11903,45 @@
         __Pyx_DECREF_SET(__pyx_t_2, function);
         __pyx_t_8 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_2)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_d, __pyx_n_s_enc_key};
-      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 480, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 482, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_1);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_d, __pyx_n_s_enc_key};
-      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 480, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 482, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_1);
     } else
     #endif
     {
-      __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 480, __pyx_L1_error)
+      __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 482, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       if (__pyx_t_5) {
         __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
       __Pyx_INCREF(__pyx_v_d);
       __Pyx_GIVEREF(__pyx_v_d);
       PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_v_d);
       __Pyx_INCREF(__pyx_n_s_enc_key);
       __Pyx_GIVEREF(__pyx_n_s_enc_key);
       PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_n_s_enc_key);
-      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 480, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 482, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     }
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 480, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 482, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_5 = NULL;
     __pyx_t_8 = 0;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -11883,116 +11950,116 @@
         __Pyx_DECREF_SET(__pyx_t_3, function);
         __pyx_t_8 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_3)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_d, __pyx_n_s_enc_hmac_key};
-      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 480, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 482, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_d, __pyx_n_s_enc_hmac_key};
-      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 480, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 482, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     {
-      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 480, __pyx_L1_error)
+      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 482, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       if (__pyx_t_5) {
         __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
       __Pyx_INCREF(__pyx_v_d);
       __Pyx_GIVEREF(__pyx_v_d);
       PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_d);
       __Pyx_INCREF(__pyx_n_s_enc_hmac_key);
       __Pyx_GIVEREF(__pyx_n_s_enc_hmac_key);
       PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_n_s_enc_hmac_key);
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 480, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 482, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     }
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 480, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 482, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "borg/item.pyx":481
+    /* "borg/item.pyx":483
  *         if 'crypt_key' not in self._dict:  # legacy, we're loading an old v1 key
  *             k = fix_bytes_value(d, 'enc_key') + fix_bytes_value(d, 'enc_hmac_key')
  *             assert isinstance(k, bytes), "k == %r" % k             # <<<<<<<<<<<<<<
  *             assert len(k) in (32 + 32, 32 + 128)  # 256+256 or 256+1024 bits
  *             self._dict['crypt_key'] = k
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
       __pyx_t_9 = PyBytes_Check(__pyx_v_k); 
       if (unlikely(!(__pyx_t_9 != 0))) {
-        __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_k_r, __pyx_v_k); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 481, __pyx_L1_error)
+        __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_k_r, __pyx_v_k); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 483, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         PyErr_SetObject(PyExc_AssertionError, __pyx_t_3);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __PYX_ERR(0, 481, __pyx_L1_error)
+        __PYX_ERR(0, 483, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/item.pyx":482
+    /* "borg/item.pyx":484
  *             k = fix_bytes_value(d, 'enc_key') + fix_bytes_value(d, 'enc_hmac_key')
  *             assert isinstance(k, bytes), "k == %r" % k
  *             assert len(k) in (32 + 32, 32 + 128)  # 256+256 or 256+1024 bits             # <<<<<<<<<<<<<<
  *             self._dict['crypt_key'] = k
  * 
  */
     #ifndef CYTHON_WITHOUT_ASSERTIONS
     if (unlikely(!Py_OptimizeFlag)) {
-      __pyx_t_4 = PyObject_Length(__pyx_v_k); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 482, __pyx_L1_error)
+      __pyx_t_4 = PyObject_Length(__pyx_v_k); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 484, __pyx_L1_error)
       __pyx_t_10 = ((__pyx_t_4 == 64) != 0);
       if (!__pyx_t_10) {
       } else {
         __pyx_t_9 = __pyx_t_10;
         goto __pyx_L13_bool_binop_done;
       }
       __pyx_t_10 = ((__pyx_t_4 == 0xA0) != 0);
       __pyx_t_9 = __pyx_t_10;
       __pyx_L13_bool_binop_done:;
       if (unlikely(!(__pyx_t_9 != 0))) {
         PyErr_SetNone(PyExc_AssertionError);
-        __PYX_ERR(0, 482, __pyx_L1_error)
+        __PYX_ERR(0, 484, __pyx_L1_error)
       }
     }
     #endif
 
-    /* "borg/item.pyx":483
+    /* "borg/item.pyx":485
  *             assert isinstance(k, bytes), "k == %r" % k
  *             assert len(k) in (32 + 32, 32 + 128)  # 256+256 or 256+1024 bits
  *             self._dict['crypt_key'] = k             # <<<<<<<<<<<<<<
  * 
  * cdef class ArchiveItem(PropDict):
  */
-    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_n_s_crypt_key, __pyx_v_k) < 0)) __PYX_ERR(0, 483, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_n_s_crypt_key, __pyx_v_k) < 0)) __PYX_ERR(0, 485, __pyx_L1_error)
 
-    /* "borg/item.pyx":479
+    /* "borg/item.pyx":481
  *                 v = fix_bytes_value(d, k)
  *             self._dict[k] = v
  *         if 'crypt_key' not in self._dict:  # legacy, we're loading an old v1 key             # <<<<<<<<<<<<<<
  *             k = fix_bytes_value(d, 'enc_key') + fix_bytes_value(d, 'enc_hmac_key')
  *             assert isinstance(k, bytes), "k == %r" % k
  */
   }
 
-  /* "borg/item.pyx":470
+  /* "borg/item.pyx":472
  *     tam_required = PropDictProperty(bool)
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  */
 
@@ -12124,15 +12191,15 @@
   __Pyx_AddTraceback("borg.item.Key.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":522
+/* "borg/item.pyx":524
  *     nfiles_parts = PropDictProperty(int)  # legacy only
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  */
 
@@ -12165,110 +12232,110 @@
   int __pyx_t_9;
   int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("update_internal", 0);
 
-  /* "borg/item.pyx":524
+  /* "borg/item.pyx":526
  *     def update_internal(self, d):
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k == 'version':
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 524, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 526, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 524, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 526, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 524, __pyx_L1_error)
+  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 526, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 524, __pyx_L1_error)
+    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 526, __pyx_L1_error)
     #else
-    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 524, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 526, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
       PyObject* sequence = __pyx_t_2;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 2)) {
         if (size > 2) __Pyx_RaiseTooManyValuesError(2);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 524, __pyx_L1_error)
+        __PYX_ERR(0, 526, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
         __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
       } else {
         __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
       }
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_5);
       #else
-      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 524, __pyx_L1_error)
+      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 526, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 524, __pyx_L1_error)
+      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 526, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       #endif
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     } else {
       Py_ssize_t index = -1;
-      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 524, __pyx_L1_error)
+      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 526, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_7 = Py_TYPE(__pyx_t_6)->tp_iternext;
       index = 0; __pyx_t_3 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_3);
       index = 1; __pyx_t_5 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_5)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_5);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 524, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 526, __pyx_L1_error)
       __pyx_t_7 = NULL;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __pyx_t_7 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 524, __pyx_L1_error)
+      __PYX_ERR(0, 526, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
     __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_3);
     __pyx_t_3 = 0;
     __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "borg/item.pyx":525
+    /* "borg/item.pyx":527
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)             # <<<<<<<<<<<<<<
  *             if k == 'version':
  *                 assert isinstance(v, int)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 525, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 527, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_3 = NULL;
     __pyx_t_8 = 0;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -12277,125 +12344,125 @@
         __Pyx_DECREF_SET(__pyx_t_5, function);
         __pyx_t_8 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 525, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 527, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 525, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 527, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     {
-      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 525, __pyx_L1_error)
+      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 527, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       if (__pyx_t_3) {
         __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
       }
       __Pyx_INCREF(__pyx_v_d);
       __Pyx_GIVEREF(__pyx_v_d);
       PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_d);
       __Pyx_INCREF(__pyx_v_k);
       __Pyx_GIVEREF(__pyx_v_k);
       PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_v_k);
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 525, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 527, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     }
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_k, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":526
+    /* "borg/item.pyx":528
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k == 'version':             # <<<<<<<<<<<<<<
  *                 assert isinstance(v, int)
  *             if k in ('name', 'hostname', 'username', 'comment'):
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_version, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 526, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_version, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 528, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":527
+      /* "borg/item.pyx":529
  *             k = fix_key(d, k)
  *             if k == 'version':
  *                 assert isinstance(v, int)             # <<<<<<<<<<<<<<
  *             if k in ('name', 'hostname', 'username', 'comment'):
  *                 v = fix_str_value(d, k)
  */
       #ifndef CYTHON_WITHOUT_ASSERTIONS
       if (unlikely(!Py_OptimizeFlag)) {
         __pyx_t_9 = PyInt_Check(__pyx_v_v); 
         if (unlikely(!(__pyx_t_9 != 0))) {
           PyErr_SetNone(PyExc_AssertionError);
-          __PYX_ERR(0, 527, __pyx_L1_error)
+          __PYX_ERR(0, 529, __pyx_L1_error)
         }
       }
       #endif
 
-      /* "borg/item.pyx":526
+      /* "borg/item.pyx":528
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k == 'version':             # <<<<<<<<<<<<<<
  *                 assert isinstance(v, int)
  *             if k in ('name', 'hostname', 'username', 'comment'):
  */
     }
 
-    /* "borg/item.pyx":528
+    /* "borg/item.pyx":530
  *             if k == 'version':
  *                 assert isinstance(v, int)
  *             if k in ('name', 'hostname', 'username', 'comment'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k)
  *             if k in ('time', 'time_end'):
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_name_2, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 528, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_name_2, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 530, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L9_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_hostname, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 528, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_hostname, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 530, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L9_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_username, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 528, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_username, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 530, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L9_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_comment, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 528, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_comment, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 530, __pyx_L1_error)
     __pyx_t_9 = __pyx_t_10;
     __pyx_L9_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_10 = (__pyx_t_9 != 0);
     if (__pyx_t_10) {
 
-      /* "borg/item.pyx":529
+      /* "borg/item.pyx":531
  *                 assert isinstance(v, int)
  *             if k in ('name', 'hostname', 'username', 'comment'):
  *                 v = fix_str_value(d, k)             # <<<<<<<<<<<<<<
  *             if k in ('time', 'time_end'):
  *                 v = fix_str_value(d, k, 'replace')
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 529, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 531, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -12404,86 +12471,86 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 529, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 531, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 529, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 531, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       {
-        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 529, __pyx_L1_error)
+        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 531, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         if (__pyx_t_6) {
           __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_6); __pyx_t_6 = NULL;
         }
         __Pyx_INCREF(__pyx_v_d);
         __Pyx_GIVEREF(__pyx_v_d);
         PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_v_d);
         __Pyx_INCREF(__pyx_v_k);
         __Pyx_GIVEREF(__pyx_v_k);
         PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_v_k);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 529, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 531, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":528
+      /* "borg/item.pyx":530
  *             if k == 'version':
  *                 assert isinstance(v, int)
  *             if k in ('name', 'hostname', 'username', 'comment'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k)
  *             if k in ('time', 'time_end'):
  */
     }
 
-    /* "borg/item.pyx":530
+    /* "borg/item.pyx":532
  *             if k in ('name', 'hostname', 'username', 'comment'):
  *                 v = fix_str_value(d, k)
  *             if k in ('time', 'time_end'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'chunker_params':
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_time, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 530, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_time, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 532, __pyx_L1_error)
     if (!__pyx_t_9) {
     } else {
       __pyx_t_10 = __pyx_t_9;
       goto __pyx_L14_bool_binop_done;
     }
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_time_end, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 530, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_time_end, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 532, __pyx_L1_error)
     __pyx_t_10 = __pyx_t_9;
     __pyx_L14_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_9 = (__pyx_t_10 != 0);
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":531
+      /* "borg/item.pyx":533
  *                 v = fix_str_value(d, k)
  *             if k in ('time', 'time_end'):
  *                 v = fix_str_value(d, k, 'replace')             # <<<<<<<<<<<<<<
  *             if k == 'chunker_params':
  *                 v = fix_tuple_of_str_and_int(v)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 531, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 533, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_3 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_3)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -12492,135 +12559,135 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[4] = {__pyx_t_3, __pyx_v_d, __pyx_v_k, __pyx_n_s_replace};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 531, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 533, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[4] = {__pyx_t_3, __pyx_v_d, __pyx_v_k, __pyx_n_s_replace};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 531, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 533, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       {
-        __pyx_t_6 = PyTuple_New(3+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 531, __pyx_L1_error)
+        __pyx_t_6 = PyTuple_New(3+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 533, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_6);
         if (__pyx_t_3) {
           __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
         }
         __Pyx_INCREF(__pyx_v_d);
         __Pyx_GIVEREF(__pyx_v_d);
         PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_d);
         __Pyx_INCREF(__pyx_v_k);
         __Pyx_GIVEREF(__pyx_v_k);
         PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_v_k);
         __Pyx_INCREF(__pyx_n_s_replace);
         __Pyx_GIVEREF(__pyx_n_s_replace);
         PyTuple_SET_ITEM(__pyx_t_6, 2+__pyx_t_8, __pyx_n_s_replace);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 531, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 533, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":530
+      /* "borg/item.pyx":532
  *             if k in ('name', 'hostname', 'username', 'comment'):
  *                 v = fix_str_value(d, k)
  *             if k in ('time', 'time_end'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'chunker_params':
  */
     }
 
-    /* "borg/item.pyx":532
+    /* "borg/item.pyx":534
  *             if k in ('time', 'time_end'):
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'chunker_params':             # <<<<<<<<<<<<<<
  *                 v = fix_tuple_of_str_and_int(v)
  *             if k in ('command_line', 'recreate_command_line'):
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_chunker_params, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 532, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_chunker_params, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 534, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":533
+      /* "borg/item.pyx":535
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'chunker_params':
  *                 v = fix_tuple_of_str_and_int(v)             # <<<<<<<<<<<<<<
  *             if k in ('command_line', 'recreate_command_line'):
  *                 v = fix_str_value(d, k)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_tuple_of_str_and_int); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 533, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_tuple_of_str_and_int); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 535, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_v) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_v);
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 533, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 535, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":532
+      /* "borg/item.pyx":534
  *             if k in ('time', 'time_end'):
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'chunker_params':             # <<<<<<<<<<<<<<
  *                 v = fix_tuple_of_str_and_int(v)
  *             if k in ('command_line', 'recreate_command_line'):
  */
     }
 
-    /* "borg/item.pyx":534
+    /* "borg/item.pyx":536
  *             if k == 'chunker_params':
  *                 v = fix_tuple_of_str_and_int(v)
  *             if k in ('command_line', 'recreate_command_line'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k)
  *             if k in ('cmdline', 'recreate_cmdline'):  # legacy
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_command_line, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 534, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_command_line, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 536, __pyx_L1_error)
     if (!__pyx_t_10) {
     } else {
       __pyx_t_9 = __pyx_t_10;
       goto __pyx_L18_bool_binop_done;
     }
-    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_recreate_command_line, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 534, __pyx_L1_error)
+    __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_recreate_command_line, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 536, __pyx_L1_error)
     __pyx_t_9 = __pyx_t_10;
     __pyx_L18_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_10 = (__pyx_t_9 != 0);
     if (__pyx_t_10) {
 
-      /* "borg/item.pyx":535
+      /* "borg/item.pyx":537
  *                 v = fix_tuple_of_str_and_int(v)
  *             if k in ('command_line', 'recreate_command_line'):
  *                 v = fix_str_value(d, k)             # <<<<<<<<<<<<<<
  *             if k in ('cmdline', 'recreate_cmdline'):  # legacy
  *                 v = fix_list_of_str(v)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 535, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 537, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -12629,226 +12696,226 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 535, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 537, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_d, __pyx_v_k};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 535, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 537, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       {
-        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 535, __pyx_L1_error)
+        __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 537, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         if (__pyx_t_6) {
           __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_6); __pyx_t_6 = NULL;
         }
         __Pyx_INCREF(__pyx_v_d);
         __Pyx_GIVEREF(__pyx_v_d);
         PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_v_d);
         __Pyx_INCREF(__pyx_v_k);
         __Pyx_GIVEREF(__pyx_v_k);
         PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_v_k);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 535, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 537, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":534
+      /* "borg/item.pyx":536
  *             if k == 'chunker_params':
  *                 v = fix_tuple_of_str_and_int(v)
  *             if k in ('command_line', 'recreate_command_line'):             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k)
  *             if k in ('cmdline', 'recreate_cmdline'):  # legacy
  */
     }
 
-    /* "borg/item.pyx":536
+    /* "borg/item.pyx":538
  *             if k in ('command_line', 'recreate_command_line'):
  *                 v = fix_str_value(d, k)
  *             if k in ('cmdline', 'recreate_cmdline'):  # legacy             # <<<<<<<<<<<<<<
  *                 v = fix_list_of_str(v)
  *             if k == 'items':  # legacy
  */
     __Pyx_INCREF(__pyx_v_k);
     __pyx_t_2 = __pyx_v_k;
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_cmdline, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 536, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_cmdline, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 538, __pyx_L1_error)
     if (!__pyx_t_9) {
     } else {
       __pyx_t_10 = __pyx_t_9;
       goto __pyx_L21_bool_binop_done;
     }
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_recreate_cmdline, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 536, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_recreate_cmdline, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 538, __pyx_L1_error)
     __pyx_t_10 = __pyx_t_9;
     __pyx_L21_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_9 = (__pyx_t_10 != 0);
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":537
+      /* "borg/item.pyx":539
  *                 v = fix_str_value(d, k)
  *             if k in ('cmdline', 'recreate_cmdline'):  # legacy
  *                 v = fix_list_of_str(v)             # <<<<<<<<<<<<<<
  *             if k == 'items':  # legacy
  *                 v = fix_list_of_bytes(v)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_list_of_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 537, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_list_of_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 539, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_3 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_3)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_3);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_3, __pyx_v_v) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_v);
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 537, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 539, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":536
+      /* "borg/item.pyx":538
  *             if k in ('command_line', 'recreate_command_line'):
  *                 v = fix_str_value(d, k)
  *             if k in ('cmdline', 'recreate_cmdline'):  # legacy             # <<<<<<<<<<<<<<
  *                 v = fix_list_of_str(v)
  *             if k == 'items':  # legacy
  */
     }
 
-    /* "borg/item.pyx":538
+    /* "borg/item.pyx":540
  *             if k in ('cmdline', 'recreate_cmdline'):  # legacy
  *                 v = fix_list_of_str(v)
  *             if k == 'items':  # legacy             # <<<<<<<<<<<<<<
  *                 v = fix_list_of_bytes(v)
  *             if k == 'item_ptrs':
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_items, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 538, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_items, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 540, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":539
+      /* "borg/item.pyx":541
  *                 v = fix_list_of_str(v)
  *             if k == 'items':  # legacy
  *                 v = fix_list_of_bytes(v)             # <<<<<<<<<<<<<<
  *             if k == 'item_ptrs':
  *                 v = fix_list_of_bytes(v)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_list_of_bytes); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 539, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_list_of_bytes); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 541, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_3 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_3)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_3);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_3, __pyx_v_v) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_v);
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 539, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 541, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":538
+      /* "borg/item.pyx":540
  *             if k in ('cmdline', 'recreate_cmdline'):  # legacy
  *                 v = fix_list_of_str(v)
  *             if k == 'items':  # legacy             # <<<<<<<<<<<<<<
  *                 v = fix_list_of_bytes(v)
  *             if k == 'item_ptrs':
  */
     }
 
-    /* "borg/item.pyx":540
+    /* "borg/item.pyx":542
  *             if k == 'items':  # legacy
  *                 v = fix_list_of_bytes(v)
  *             if k == 'item_ptrs':             # <<<<<<<<<<<<<<
  *                 v = fix_list_of_bytes(v)
  *             self._dict[k] = v
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_item_ptrs, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 540, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_item_ptrs, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 542, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":541
+      /* "borg/item.pyx":543
  *                 v = fix_list_of_bytes(v)
  *             if k == 'item_ptrs':
  *                 v = fix_list_of_bytes(v)             # <<<<<<<<<<<<<<
  *             self._dict[k] = v
  * 
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_list_of_bytes); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 541, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_list_of_bytes); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 543, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_3 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_3)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_3);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_3, __pyx_v_v) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_v);
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 541, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 543, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":540
+      /* "borg/item.pyx":542
  *             if k == 'items':  # legacy
  *                 v = fix_list_of_bytes(v)
  *             if k == 'item_ptrs':             # <<<<<<<<<<<<<<
  *                 v = fix_list_of_bytes(v)
  *             self._dict[k] = v
  */
     }
 
-    /* "borg/item.pyx":542
+    /* "borg/item.pyx":544
  *             if k == 'item_ptrs':
  *                 v = fix_list_of_bytes(v)
  *             self._dict[k] = v             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 542, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 544, __pyx_L1_error)
 
-    /* "borg/item.pyx":524
+    /* "borg/item.pyx":526
  *     def update_internal(self, d):
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k == 'version':
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":522
+  /* "borg/item.pyx":524
  *     nfiles_parts = PropDictProperty(int)  # legacy only
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  */
 
@@ -12980,15 +13047,15 @@
   __Pyx_AddTraceback("borg.item.ArchiveItem.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":565
+/* "borg/item.pyx":567
  *     item_keys = PropDictProperty(tuple, 'tuple of str')
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  */
 
@@ -13039,110 +13106,110 @@
   Py_ssize_t __pyx_t_14;
   PyObject *__pyx_t_15 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("update_internal", 0);
 
-  /* "borg/item.pyx":567
+  /* "borg/item.pyx":569
  *     def update_internal(self, d):
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k == 'version':
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 567, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_d, __pyx_n_s_items); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 569, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 567, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 569, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 567, __pyx_L1_error)
+  __pyx_t_2 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 569, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 567, __pyx_L1_error)
+    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 569, __pyx_L1_error)
     #else
-    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 567, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 569, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
       PyObject* sequence = __pyx_t_2;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 2)) {
         if (size > 2) __Pyx_RaiseTooManyValuesError(2);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 567, __pyx_L1_error)
+        __PYX_ERR(0, 569, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
         __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
       } else {
         __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
       }
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_5);
       #else
-      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 567, __pyx_L1_error)
+      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 569, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 567, __pyx_L1_error)
+      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 569, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       #endif
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     } else {
       Py_ssize_t index = -1;
-      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 567, __pyx_L1_error)
+      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 569, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_7 = Py_TYPE(__pyx_t_6)->tp_iternext;
       index = 0; __pyx_t_3 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_3);
       index = 1; __pyx_t_5 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_5)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_5);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 567, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 569, __pyx_L1_error)
       __pyx_t_7 = NULL;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __pyx_t_7 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 567, __pyx_L1_error)
+      __PYX_ERR(0, 569, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
     __Pyx_XDECREF_SET(__pyx_v_k, __pyx_t_3);
     __pyx_t_3 = 0;
     __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "borg/item.pyx":568
+    /* "borg/item.pyx":570
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)             # <<<<<<<<<<<<<<
  *             if k == 'version':
  *                 assert isinstance(v, int)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 568, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 570, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_3 = NULL;
     __pyx_t_8 = 0;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -13151,349 +13218,349 @@
         __Pyx_DECREF_SET(__pyx_t_5, function);
         __pyx_t_8 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 568, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 570, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
       PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_d, __pyx_v_k};
-      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 568, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 570, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_GOTREF(__pyx_t_2);
     } else
     #endif
     {
-      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 568, __pyx_L1_error)
+      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 570, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       if (__pyx_t_3) {
         __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
       }
       __Pyx_INCREF(__pyx_v_d);
       __Pyx_GIVEREF(__pyx_v_d);
       PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_d);
       __Pyx_INCREF(__pyx_v_k);
       __Pyx_GIVEREF(__pyx_v_k);
       PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_v_k);
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 568, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 570, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     }
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_k, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":569
+    /* "borg/item.pyx":571
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k == 'version':             # <<<<<<<<<<<<<<
  *                 assert isinstance(v, int)
  *             if k == 'archives':
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_version, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 569, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_version, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 571, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":570
+      /* "borg/item.pyx":572
  *             k = fix_key(d, k)
  *             if k == 'version':
  *                 assert isinstance(v, int)             # <<<<<<<<<<<<<<
  *             if k == 'archives':
  *                 ad = v
  */
       #ifndef CYTHON_WITHOUT_ASSERTIONS
       if (unlikely(!Py_OptimizeFlag)) {
         __pyx_t_9 = PyInt_Check(__pyx_v_v); 
         if (unlikely(!(__pyx_t_9 != 0))) {
           PyErr_SetNone(PyExc_AssertionError);
-          __PYX_ERR(0, 570, __pyx_L1_error)
+          __PYX_ERR(0, 572, __pyx_L1_error)
         }
       }
       #endif
 
-      /* "borg/item.pyx":569
+      /* "borg/item.pyx":571
  *         for k, v in list(d.items()):
  *             k = fix_key(d, k)
  *             if k == 'version':             # <<<<<<<<<<<<<<
  *                 assert isinstance(v, int)
  *             if k == 'archives':
  */
     }
 
-    /* "borg/item.pyx":571
+    /* "borg/item.pyx":573
  *             if k == 'version':
  *                 assert isinstance(v, int)
  *             if k == 'archives':             # <<<<<<<<<<<<<<
  *                 ad = v
  *                 assert isinstance(ad, dict)
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_archives, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 571, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_archives, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 573, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":572
+      /* "borg/item.pyx":574
  *                 assert isinstance(v, int)
  *             if k == 'archives':
  *                 ad = v             # <<<<<<<<<<<<<<
  *                 assert isinstance(ad, dict)
  *                 for ak, av in list(ad.items()):
  */
       __Pyx_INCREF(__pyx_v_v);
       __Pyx_XDECREF_SET(__pyx_v_ad, __pyx_v_v);
 
-      /* "borg/item.pyx":573
+      /* "borg/item.pyx":575
  *             if k == 'archives':
  *                 ad = v
  *                 assert isinstance(ad, dict)             # <<<<<<<<<<<<<<
  *                 for ak, av in list(ad.items()):
  *                     ak = fix_key(ad, ak, errors='surrogateescape')
  */
       #ifndef CYTHON_WITHOUT_ASSERTIONS
       if (unlikely(!Py_OptimizeFlag)) {
         __pyx_t_9 = PyDict_Check(__pyx_v_ad); 
         if (unlikely(!(__pyx_t_9 != 0))) {
           PyErr_SetNone(PyExc_AssertionError);
-          __PYX_ERR(0, 573, __pyx_L1_error)
+          __PYX_ERR(0, 575, __pyx_L1_error)
         }
       }
       #endif
 
-      /* "borg/item.pyx":574
+      /* "borg/item.pyx":576
  *                 ad = v
  *                 assert isinstance(ad, dict)
  *                 for ak, av in list(ad.items()):             # <<<<<<<<<<<<<<
  *                     ak = fix_key(ad, ak, errors='surrogateescape')
  *                     assert isinstance(av, dict)
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_ad, __pyx_n_s_items); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 574, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_ad, __pyx_n_s_items); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 576, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 574, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 576, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_5 = PySequence_List(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 574, __pyx_L1_error)
+      __pyx_t_5 = PySequence_List(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 576, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_2 = __pyx_t_5; __Pyx_INCREF(__pyx_t_2); __pyx_t_10 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       for (;;) {
         if (__pyx_t_10 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_10); __Pyx_INCREF(__pyx_t_5); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 574, __pyx_L1_error)
+        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_10); __Pyx_INCREF(__pyx_t_5); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 576, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 574, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 576, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
         if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
           PyObject* sequence = __pyx_t_5;
           Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
           if (unlikely(size != 2)) {
             if (size > 2) __Pyx_RaiseTooManyValuesError(2);
             else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-            __PYX_ERR(0, 574, __pyx_L1_error)
+            __PYX_ERR(0, 576, __pyx_L1_error)
           }
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
           if (likely(PyTuple_CheckExact(sequence))) {
             __pyx_t_6 = PyTuple_GET_ITEM(sequence, 0); 
             __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
           } else {
             __pyx_t_6 = PyList_GET_ITEM(sequence, 0); 
             __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
           }
           __Pyx_INCREF(__pyx_t_6);
           __Pyx_INCREF(__pyx_t_3);
           #else
-          __pyx_t_6 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 574, __pyx_L1_error)
+          __pyx_t_6 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 576, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_6);
-          __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 574, __pyx_L1_error)
+          __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 576, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_3);
           #endif
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
         } else {
           Py_ssize_t index = -1;
-          __pyx_t_11 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 574, __pyx_L1_error)
+          __pyx_t_11 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 576, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_11);
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
           __pyx_t_7 = Py_TYPE(__pyx_t_11)->tp_iternext;
           index = 0; __pyx_t_6 = __pyx_t_7(__pyx_t_11); if (unlikely(!__pyx_t_6)) goto __pyx_L11_unpacking_failed;
           __Pyx_GOTREF(__pyx_t_6);
           index = 1; __pyx_t_3 = __pyx_t_7(__pyx_t_11); if (unlikely(!__pyx_t_3)) goto __pyx_L11_unpacking_failed;
           __Pyx_GOTREF(__pyx_t_3);
-          if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_11), 2) < 0) __PYX_ERR(0, 574, __pyx_L1_error)
+          if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_11), 2) < 0) __PYX_ERR(0, 576, __pyx_L1_error)
           __pyx_t_7 = NULL;
           __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
           goto __pyx_L12_unpacking_done;
           __pyx_L11_unpacking_failed:;
           __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
           __pyx_t_7 = NULL;
           if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-          __PYX_ERR(0, 574, __pyx_L1_error)
+          __PYX_ERR(0, 576, __pyx_L1_error)
           __pyx_L12_unpacking_done:;
         }
         __Pyx_XDECREF_SET(__pyx_v_ak, __pyx_t_6);
         __pyx_t_6 = 0;
         __Pyx_XDECREF_SET(__pyx_v_av, __pyx_t_3);
         __pyx_t_3 = 0;
 
-        /* "borg/item.pyx":575
+        /* "borg/item.pyx":577
  *                 assert isinstance(ad, dict)
  *                 for ak, av in list(ad.items()):
  *                     ak = fix_key(ad, ak, errors='surrogateescape')             # <<<<<<<<<<<<<<
  *                     assert isinstance(av, dict)
  *                     for ik, iv in list(av.items()):
  */
-        __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 575, __pyx_L1_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 577, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
-        __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 575, __pyx_L1_error)
+        __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 577, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_INCREF(__pyx_v_ad);
         __Pyx_GIVEREF(__pyx_v_ad);
         PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_ad);
         __Pyx_INCREF(__pyx_v_ak);
         __Pyx_GIVEREF(__pyx_v_ak);
         PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_ak);
-        __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 575, __pyx_L1_error)
+        __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 577, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_6);
-        if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_errors, __pyx_n_s_surrogateescape) < 0) __PYX_ERR(0, 575, __pyx_L1_error)
-        __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, __pyx_t_6); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 575, __pyx_L1_error)
+        if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_errors, __pyx_n_s_surrogateescape) < 0) __PYX_ERR(0, 577, __pyx_L1_error)
+        __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, __pyx_t_6); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 577, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_11);
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_DECREF_SET(__pyx_v_ak, __pyx_t_11);
         __pyx_t_11 = 0;
 
-        /* "borg/item.pyx":576
+        /* "borg/item.pyx":578
  *                 for ak, av in list(ad.items()):
  *                     ak = fix_key(ad, ak, errors='surrogateescape')
  *                     assert isinstance(av, dict)             # <<<<<<<<<<<<<<
  *                     for ik, iv in list(av.items()):
  *                         ik = fix_key(av, ik)
  */
         #ifndef CYTHON_WITHOUT_ASSERTIONS
         if (unlikely(!Py_OptimizeFlag)) {
           __pyx_t_9 = PyDict_Check(__pyx_v_av); 
           if (unlikely(!(__pyx_t_9 != 0))) {
             PyErr_SetNone(PyExc_AssertionError);
-            __PYX_ERR(0, 576, __pyx_L1_error)
+            __PYX_ERR(0, 578, __pyx_L1_error)
           }
         }
         #endif
 
-        /* "borg/item.pyx":577
+        /* "borg/item.pyx":579
  *                     ak = fix_key(ad, ak, errors='surrogateescape')
  *                     assert isinstance(av, dict)
  *                     for ik, iv in list(av.items()):             # <<<<<<<<<<<<<<
  *                         ik = fix_key(av, ik)
  *                         if ik == 'id':
  */
-        __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_av, __pyx_n_s_items); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 577, __pyx_L1_error)
+        __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_av, __pyx_n_s_items); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 579, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_6);
         __pyx_t_3 = NULL;
         if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
           __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_6);
           if (likely(__pyx_t_3)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
             __Pyx_INCREF(__pyx_t_3);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_6, function);
           }
         }
         __pyx_t_11 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
         __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-        if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 577, __pyx_L1_error)
+        if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 579, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_11);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-        __pyx_t_6 = PySequence_List(__pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 577, __pyx_L1_error)
+        __pyx_t_6 = PySequence_List(__pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 579, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_6);
         __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
         __pyx_t_11 = __pyx_t_6; __Pyx_INCREF(__pyx_t_11); __pyx_t_12 = 0;
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
         for (;;) {
           if (__pyx_t_12 >= PyList_GET_SIZE(__pyx_t_11)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_6 = PyList_GET_ITEM(__pyx_t_11, __pyx_t_12); __Pyx_INCREF(__pyx_t_6); __pyx_t_12++; if (unlikely(0 < 0)) __PYX_ERR(0, 577, __pyx_L1_error)
+          __pyx_t_6 = PyList_GET_ITEM(__pyx_t_11, __pyx_t_12); __Pyx_INCREF(__pyx_t_6); __pyx_t_12++; if (unlikely(0 < 0)) __PYX_ERR(0, 579, __pyx_L1_error)
           #else
-          __pyx_t_6 = PySequence_ITEM(__pyx_t_11, __pyx_t_12); __pyx_t_12++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 577, __pyx_L1_error)
+          __pyx_t_6 = PySequence_ITEM(__pyx_t_11, __pyx_t_12); __pyx_t_12++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 579, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_6);
           #endif
           if ((likely(PyTuple_CheckExact(__pyx_t_6))) || (PyList_CheckExact(__pyx_t_6))) {
             PyObject* sequence = __pyx_t_6;
             Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
             if (unlikely(size != 2)) {
               if (size > 2) __Pyx_RaiseTooManyValuesError(2);
               else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-              __PYX_ERR(0, 577, __pyx_L1_error)
+              __PYX_ERR(0, 579, __pyx_L1_error)
             }
             #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
             if (likely(PyTuple_CheckExact(sequence))) {
               __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
               __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
             } else {
               __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
               __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
             }
             __Pyx_INCREF(__pyx_t_3);
             __Pyx_INCREF(__pyx_t_5);
             #else
-            __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 577, __pyx_L1_error)
+            __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 579, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_3);
-            __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 577, __pyx_L1_error)
+            __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 579, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_5);
             #endif
             __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
           } else {
             Py_ssize_t index = -1;
-            __pyx_t_13 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 577, __pyx_L1_error)
+            __pyx_t_13 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 579, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_13);
             __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
             __pyx_t_7 = Py_TYPE(__pyx_t_13)->tp_iternext;
             index = 0; __pyx_t_3 = __pyx_t_7(__pyx_t_13); if (unlikely(!__pyx_t_3)) goto __pyx_L15_unpacking_failed;
             __Pyx_GOTREF(__pyx_t_3);
             index = 1; __pyx_t_5 = __pyx_t_7(__pyx_t_13); if (unlikely(!__pyx_t_5)) goto __pyx_L15_unpacking_failed;
             __Pyx_GOTREF(__pyx_t_5);
-            if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_13), 2) < 0) __PYX_ERR(0, 577, __pyx_L1_error)
+            if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_13), 2) < 0) __PYX_ERR(0, 579, __pyx_L1_error)
             __pyx_t_7 = NULL;
             __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
             goto __pyx_L16_unpacking_done;
             __pyx_L15_unpacking_failed:;
             __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
             __pyx_t_7 = NULL;
             if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-            __PYX_ERR(0, 577, __pyx_L1_error)
+            __PYX_ERR(0, 579, __pyx_L1_error)
             __pyx_L16_unpacking_done:;
           }
           __Pyx_XDECREF_SET(__pyx_v_ik, __pyx_t_3);
           __pyx_t_3 = 0;
           __Pyx_XDECREF_SET(__pyx_v_iv, __pyx_t_5);
           __pyx_t_5 = 0;
 
-          /* "borg/item.pyx":578
+          /* "borg/item.pyx":580
  *                     assert isinstance(av, dict)
  *                     for ik, iv in list(av.items()):
  *                         ik = fix_key(av, ik)             # <<<<<<<<<<<<<<
  *                         if ik == 'id':
  *                             fix_bytes_value(av, 'id')
  */
-          __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 578, __pyx_L1_error)
+          __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 580, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_5);
           __pyx_t_3 = NULL;
           __pyx_t_8 = 0;
           if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
             __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
             if (likely(__pyx_t_3)) {
               PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -13502,65 +13569,65 @@
               __Pyx_DECREF_SET(__pyx_t_5, function);
               __pyx_t_8 = 1;
             }
           }
           #if CYTHON_FAST_PYCALL
           if (PyFunction_Check(__pyx_t_5)) {
             PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_av, __pyx_v_ik};
-            __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 578, __pyx_L1_error)
+            __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 580, __pyx_L1_error)
             __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
             __Pyx_GOTREF(__pyx_t_6);
           } else
           #endif
           #if CYTHON_FAST_PYCCALL
           if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
             PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_av, __pyx_v_ik};
-            __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 578, __pyx_L1_error)
+            __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 580, __pyx_L1_error)
             __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
             __Pyx_GOTREF(__pyx_t_6);
           } else
           #endif
           {
-            __pyx_t_13 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 578, __pyx_L1_error)
+            __pyx_t_13 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 580, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_13);
             if (__pyx_t_3) {
               __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_3); __pyx_t_3 = NULL;
             }
             __Pyx_INCREF(__pyx_v_av);
             __Pyx_GIVEREF(__pyx_v_av);
             PyTuple_SET_ITEM(__pyx_t_13, 0+__pyx_t_8, __pyx_v_av);
             __Pyx_INCREF(__pyx_v_ik);
             __Pyx_GIVEREF(__pyx_v_ik);
             PyTuple_SET_ITEM(__pyx_t_13, 1+__pyx_t_8, __pyx_v_ik);
-            __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_13, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 578, __pyx_L1_error)
+            __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_13, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 580, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_6);
             __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
           }
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
           __Pyx_DECREF_SET(__pyx_v_ik, __pyx_t_6);
           __pyx_t_6 = 0;
 
-          /* "borg/item.pyx":579
+          /* "borg/item.pyx":581
  *                     for ik, iv in list(av.items()):
  *                         ik = fix_key(av, ik)
  *                         if ik == 'id':             # <<<<<<<<<<<<<<
  *                             fix_bytes_value(av, 'id')
  *                         if ik == 'time':
  */
-          __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_ik, __pyx_n_s_id, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 579, __pyx_L1_error)
+          __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_ik, __pyx_n_s_id, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 581, __pyx_L1_error)
           if (__pyx_t_9) {
 
-            /* "borg/item.pyx":580
+            /* "borg/item.pyx":582
  *                         ik = fix_key(av, ik)
  *                         if ik == 'id':
  *                             fix_bytes_value(av, 'id')             # <<<<<<<<<<<<<<
  *                         if ik == 'time':
  *                             fix_str_value(av, 'time')
  */
-            __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 580, __pyx_L1_error)
+            __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_bytes_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 582, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_5);
             __pyx_t_13 = NULL;
             __pyx_t_8 = 0;
             if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
               __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_5);
               if (likely(__pyx_t_13)) {
                 PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -13569,73 +13636,73 @@
                 __Pyx_DECREF_SET(__pyx_t_5, function);
                 __pyx_t_8 = 1;
               }
             }
             #if CYTHON_FAST_PYCALL
             if (PyFunction_Check(__pyx_t_5)) {
               PyObject *__pyx_temp[3] = {__pyx_t_13, __pyx_v_av, __pyx_n_s_id};
-              __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 580, __pyx_L1_error)
+              __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 582, __pyx_L1_error)
               __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
               __Pyx_GOTREF(__pyx_t_6);
             } else
             #endif
             #if CYTHON_FAST_PYCCALL
             if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
               PyObject *__pyx_temp[3] = {__pyx_t_13, __pyx_v_av, __pyx_n_s_id};
-              __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 580, __pyx_L1_error)
+              __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 582, __pyx_L1_error)
               __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
               __Pyx_GOTREF(__pyx_t_6);
             } else
             #endif
             {
-              __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 580, __pyx_L1_error)
+              __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 582, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_3);
               if (__pyx_t_13) {
                 __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_13); __pyx_t_13 = NULL;
               }
               __Pyx_INCREF(__pyx_v_av);
               __Pyx_GIVEREF(__pyx_v_av);
               PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_v_av);
               __Pyx_INCREF(__pyx_n_s_id);
               __Pyx_GIVEREF(__pyx_n_s_id);
               PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_n_s_id);
-              __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 580, __pyx_L1_error)
+              __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 582, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_6);
               __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
             }
             __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
             __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-            /* "borg/item.pyx":579
+            /* "borg/item.pyx":581
  *                     for ik, iv in list(av.items()):
  *                         ik = fix_key(av, ik)
  *                         if ik == 'id':             # <<<<<<<<<<<<<<
  *                             fix_bytes_value(av, 'id')
  *                         if ik == 'time':
  */
           }
 
-          /* "borg/item.pyx":581
+          /* "borg/item.pyx":583
  *                         if ik == 'id':
  *                             fix_bytes_value(av, 'id')
  *                         if ik == 'time':             # <<<<<<<<<<<<<<
  *                             fix_str_value(av, 'time')
  *                     assert set(av) == {'id', 'time'}
  */
-          __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_ik, __pyx_n_s_time, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 581, __pyx_L1_error)
+          __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_ik, __pyx_n_s_time, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 583, __pyx_L1_error)
           if (__pyx_t_9) {
 
-            /* "borg/item.pyx":582
+            /* "borg/item.pyx":584
  *                             fix_bytes_value(av, 'id')
  *                         if ik == 'time':
  *                             fix_str_value(av, 'time')             # <<<<<<<<<<<<<<
  *                     assert set(av) == {'id', 'time'}
  *             if k == 'timestamp':
  */
-            __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 582, __pyx_L1_error)
+            __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 584, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_5);
             __pyx_t_3 = NULL;
             __pyx_t_8 = 0;
             if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
               __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
               if (likely(__pyx_t_3)) {
                 PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -13644,129 +13711,129 @@
                 __Pyx_DECREF_SET(__pyx_t_5, function);
                 __pyx_t_8 = 1;
               }
             }
             #if CYTHON_FAST_PYCALL
             if (PyFunction_Check(__pyx_t_5)) {
               PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_av, __pyx_n_s_time};
-              __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 582, __pyx_L1_error)
+              __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 584, __pyx_L1_error)
               __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
               __Pyx_GOTREF(__pyx_t_6);
             } else
             #endif
             #if CYTHON_FAST_PYCCALL
             if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
               PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_av, __pyx_n_s_time};
-              __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 582, __pyx_L1_error)
+              __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 584, __pyx_L1_error)
               __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
               __Pyx_GOTREF(__pyx_t_6);
             } else
             #endif
             {
-              __pyx_t_13 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 582, __pyx_L1_error)
+              __pyx_t_13 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 584, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_13);
               if (__pyx_t_3) {
                 __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_3); __pyx_t_3 = NULL;
               }
               __Pyx_INCREF(__pyx_v_av);
               __Pyx_GIVEREF(__pyx_v_av);
               PyTuple_SET_ITEM(__pyx_t_13, 0+__pyx_t_8, __pyx_v_av);
               __Pyx_INCREF(__pyx_n_s_time);
               __Pyx_GIVEREF(__pyx_n_s_time);
               PyTuple_SET_ITEM(__pyx_t_13, 1+__pyx_t_8, __pyx_n_s_time);
-              __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_13, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 582, __pyx_L1_error)
+              __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_13, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 584, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_6);
               __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
             }
             __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
             __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-            /* "borg/item.pyx":581
+            /* "borg/item.pyx":583
  *                         if ik == 'id':
  *                             fix_bytes_value(av, 'id')
  *                         if ik == 'time':             # <<<<<<<<<<<<<<
  *                             fix_str_value(av, 'time')
  *                     assert set(av) == {'id', 'time'}
  */
           }
 
-          /* "borg/item.pyx":577
+          /* "borg/item.pyx":579
  *                     ak = fix_key(ad, ak, errors='surrogateescape')
  *                     assert isinstance(av, dict)
  *                     for ik, iv in list(av.items()):             # <<<<<<<<<<<<<<
  *                         ik = fix_key(av, ik)
  *                         if ik == 'id':
  */
         }
         __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
 
-        /* "borg/item.pyx":583
+        /* "borg/item.pyx":585
  *                         if ik == 'time':
  *                             fix_str_value(av, 'time')
  *                     assert set(av) == {'id', 'time'}             # <<<<<<<<<<<<<<
  *             if k == 'timestamp':
  *                 v = fix_str_value(d, k, 'replace')
  */
         #ifndef CYTHON_WITHOUT_ASSERTIONS
         if (unlikely(!Py_OptimizeFlag)) {
-          __pyx_t_11 = PySet_New(__pyx_v_av); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 583, __pyx_L1_error)
+          __pyx_t_11 = PySet_New(__pyx_v_av); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 585, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_11);
-          __pyx_t_6 = PySet_New(0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 583, __pyx_L1_error)
+          __pyx_t_6 = PySet_New(0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 585, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_6);
-          if (PySet_Add(__pyx_t_6, __pyx_n_s_id) < 0) __PYX_ERR(0, 583, __pyx_L1_error)
-          if (PySet_Add(__pyx_t_6, __pyx_n_s_time) < 0) __PYX_ERR(0, 583, __pyx_L1_error)
-          __pyx_t_5 = PyObject_RichCompare(__pyx_t_11, __pyx_t_6, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 583, __pyx_L1_error)
+          if (PySet_Add(__pyx_t_6, __pyx_n_s_id) < 0) __PYX_ERR(0, 585, __pyx_L1_error)
+          if (PySet_Add(__pyx_t_6, __pyx_n_s_time) < 0) __PYX_ERR(0, 585, __pyx_L1_error)
+          __pyx_t_5 = PyObject_RichCompare(__pyx_t_11, __pyx_t_6, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 585, __pyx_L1_error)
           __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
           __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-          __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 583, __pyx_L1_error)
+          __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 585, __pyx_L1_error)
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
           if (unlikely(!__pyx_t_9)) {
             PyErr_SetNone(PyExc_AssertionError);
-            __PYX_ERR(0, 583, __pyx_L1_error)
+            __PYX_ERR(0, 585, __pyx_L1_error)
           }
         }
         #endif
 
-        /* "borg/item.pyx":574
+        /* "borg/item.pyx":576
  *                 ad = v
  *                 assert isinstance(ad, dict)
  *                 for ak, av in list(ad.items()):             # <<<<<<<<<<<<<<
  *                     ak = fix_key(ad, ak, errors='surrogateescape')
  *                     assert isinstance(av, dict)
  */
       }
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":571
+      /* "borg/item.pyx":573
  *             if k == 'version':
  *                 assert isinstance(v, int)
  *             if k == 'archives':             # <<<<<<<<<<<<<<
  *                 ad = v
  *                 assert isinstance(ad, dict)
  */
     }
 
-    /* "borg/item.pyx":584
+    /* "borg/item.pyx":586
  *                             fix_str_value(av, 'time')
  *                     assert set(av) == {'id', 'time'}
  *             if k == 'timestamp':             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'config':
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_timestamp, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 584, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_timestamp, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 586, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":585
+      /* "borg/item.pyx":587
  *                     assert set(av) == {'id', 'time'}
  *             if k == 'timestamp':
  *                 v = fix_str_value(d, k, 'replace')             # <<<<<<<<<<<<<<
  *             if k == 'config':
  *                 cd = v
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 585, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_str_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 587, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_6 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_6)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -13775,192 +13842,192 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[4] = {__pyx_t_6, __pyx_v_d, __pyx_v_k, __pyx_n_s_replace};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 585, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 587, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[4] = {__pyx_t_6, __pyx_v_d, __pyx_v_k, __pyx_n_s_replace};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 585, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 587, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_GOTREF(__pyx_t_2);
       } else
       #endif
       {
-        __pyx_t_11 = PyTuple_New(3+__pyx_t_8); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 585, __pyx_L1_error)
+        __pyx_t_11 = PyTuple_New(3+__pyx_t_8); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 587, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_11);
         if (__pyx_t_6) {
           __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_6); __pyx_t_6 = NULL;
         }
         __Pyx_INCREF(__pyx_v_d);
         __Pyx_GIVEREF(__pyx_v_d);
         PyTuple_SET_ITEM(__pyx_t_11, 0+__pyx_t_8, __pyx_v_d);
         __Pyx_INCREF(__pyx_v_k);
         __Pyx_GIVEREF(__pyx_v_k);
         PyTuple_SET_ITEM(__pyx_t_11, 1+__pyx_t_8, __pyx_v_k);
         __Pyx_INCREF(__pyx_n_s_replace);
         __Pyx_GIVEREF(__pyx_n_s_replace);
         PyTuple_SET_ITEM(__pyx_t_11, 2+__pyx_t_8, __pyx_n_s_replace);
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 585, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 587, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":584
+      /* "borg/item.pyx":586
  *                             fix_str_value(av, 'time')
  *                     assert set(av) == {'id', 'time'}
  *             if k == 'timestamp':             # <<<<<<<<<<<<<<
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'config':
  */
     }
 
-    /* "borg/item.pyx":586
+    /* "borg/item.pyx":588
  *             if k == 'timestamp':
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'config':             # <<<<<<<<<<<<<<
  *                 cd = v
  *                 assert isinstance(cd, dict)
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_config, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_config, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 588, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":587
+      /* "borg/item.pyx":589
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'config':
  *                 cd = v             # <<<<<<<<<<<<<<
  *                 assert isinstance(cd, dict)
  *                 for ck, cv in list(cd.items()):
  */
       __Pyx_INCREF(__pyx_v_v);
       __Pyx_XDECREF_SET(__pyx_v_cd, __pyx_v_v);
 
-      /* "borg/item.pyx":588
+      /* "borg/item.pyx":590
  *             if k == 'config':
  *                 cd = v
  *                 assert isinstance(cd, dict)             # <<<<<<<<<<<<<<
  *                 for ck, cv in list(cd.items()):
  *                     ck = fix_key(cd, ck)
  */
       #ifndef CYTHON_WITHOUT_ASSERTIONS
       if (unlikely(!Py_OptimizeFlag)) {
         __pyx_t_9 = PyDict_Check(__pyx_v_cd); 
         if (unlikely(!(__pyx_t_9 != 0))) {
           PyErr_SetNone(PyExc_AssertionError);
-          __PYX_ERR(0, 588, __pyx_L1_error)
+          __PYX_ERR(0, 590, __pyx_L1_error)
         }
       }
       #endif
 
-      /* "borg/item.pyx":589
+      /* "borg/item.pyx":591
  *                 cd = v
  *                 assert isinstance(cd, dict)
  *                 for ck, cv in list(cd.items()):             # <<<<<<<<<<<<<<
  *                     ck = fix_key(cd, ck)
  *                     if ck == 'tam_required':
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cd, __pyx_n_s_items); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 589, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cd, __pyx_n_s_items); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 591, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_11 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_11)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_11);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_11) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_11) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
       __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 589, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 591, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_5 = PySequence_List(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 589, __pyx_L1_error)
+      __pyx_t_5 = PySequence_List(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 591, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_2 = __pyx_t_5; __Pyx_INCREF(__pyx_t_2); __pyx_t_10 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       for (;;) {
         if (__pyx_t_10 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_10); __Pyx_INCREF(__pyx_t_5); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 589, __pyx_L1_error)
+        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_10); __Pyx_INCREF(__pyx_t_5); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 591, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 589, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 591, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
         if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
           PyObject* sequence = __pyx_t_5;
           Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
           if (unlikely(size != 2)) {
             if (size > 2) __Pyx_RaiseTooManyValuesError(2);
             else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-            __PYX_ERR(0, 589, __pyx_L1_error)
+            __PYX_ERR(0, 591, __pyx_L1_error)
           }
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
           if (likely(PyTuple_CheckExact(sequence))) {
             __pyx_t_11 = PyTuple_GET_ITEM(sequence, 0); 
             __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
           } else {
             __pyx_t_11 = PyList_GET_ITEM(sequence, 0); 
             __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
           }
           __Pyx_INCREF(__pyx_t_11);
           __Pyx_INCREF(__pyx_t_6);
           #else
-          __pyx_t_11 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 589, __pyx_L1_error)
+          __pyx_t_11 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 591, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_11);
-          __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 589, __pyx_L1_error)
+          __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 591, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_6);
           #endif
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
         } else {
           Py_ssize_t index = -1;
-          __pyx_t_13 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 589, __pyx_L1_error)
+          __pyx_t_13 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 591, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_13);
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
           __pyx_t_7 = Py_TYPE(__pyx_t_13)->tp_iternext;
           index = 0; __pyx_t_11 = __pyx_t_7(__pyx_t_13); if (unlikely(!__pyx_t_11)) goto __pyx_L23_unpacking_failed;
           __Pyx_GOTREF(__pyx_t_11);
           index = 1; __pyx_t_6 = __pyx_t_7(__pyx_t_13); if (unlikely(!__pyx_t_6)) goto __pyx_L23_unpacking_failed;
           __Pyx_GOTREF(__pyx_t_6);
-          if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_13), 2) < 0) __PYX_ERR(0, 589, __pyx_L1_error)
+          if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_13), 2) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
           __pyx_t_7 = NULL;
           __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
           goto __pyx_L24_unpacking_done;
           __pyx_L23_unpacking_failed:;
           __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
           __pyx_t_7 = NULL;
           if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-          __PYX_ERR(0, 589, __pyx_L1_error)
+          __PYX_ERR(0, 591, __pyx_L1_error)
           __pyx_L24_unpacking_done:;
         }
         __Pyx_XDECREF_SET(__pyx_v_ck, __pyx_t_11);
         __pyx_t_11 = 0;
         __Pyx_XDECREF_SET(__pyx_v_cv, __pyx_t_6);
         __pyx_t_6 = 0;
 
-        /* "borg/item.pyx":590
+        /* "borg/item.pyx":592
  *                 assert isinstance(cd, dict)
  *                 for ck, cv in list(cd.items()):
  *                     ck = fix_key(cd, ck)             # <<<<<<<<<<<<<<
  *                     if ck == 'tam_required':
  *                         assert isinstance(cv, bool)
  */
-        __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 590, __pyx_L1_error)
+        __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 592, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_6);
         __pyx_t_11 = NULL;
         __pyx_t_8 = 0;
         if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
           __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_6);
           if (likely(__pyx_t_11)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
@@ -13969,225 +14036,225 @@
             __Pyx_DECREF_SET(__pyx_t_6, function);
             __pyx_t_8 = 1;
           }
         }
         #if CYTHON_FAST_PYCALL
         if (PyFunction_Check(__pyx_t_6)) {
           PyObject *__pyx_temp[3] = {__pyx_t_11, __pyx_v_cd, __pyx_v_ck};
-          __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 590, __pyx_L1_error)
+          __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 592, __pyx_L1_error)
           __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
           __Pyx_GOTREF(__pyx_t_5);
         } else
         #endif
         #if CYTHON_FAST_PYCCALL
         if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
           PyObject *__pyx_temp[3] = {__pyx_t_11, __pyx_v_cd, __pyx_v_ck};
-          __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 590, __pyx_L1_error)
+          __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 592, __pyx_L1_error)
           __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
           __Pyx_GOTREF(__pyx_t_5);
         } else
         #endif
         {
-          __pyx_t_13 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 590, __pyx_L1_error)
+          __pyx_t_13 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 592, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_13);
           if (__pyx_t_11) {
             __Pyx_GIVEREF(__pyx_t_11); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_11); __pyx_t_11 = NULL;
           }
           __Pyx_INCREF(__pyx_v_cd);
           __Pyx_GIVEREF(__pyx_v_cd);
           PyTuple_SET_ITEM(__pyx_t_13, 0+__pyx_t_8, __pyx_v_cd);
           __Pyx_INCREF(__pyx_v_ck);
           __Pyx_GIVEREF(__pyx_v_ck);
           PyTuple_SET_ITEM(__pyx_t_13, 1+__pyx_t_8, __pyx_v_ck);
-          __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_13, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 590, __pyx_L1_error)
+          __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_13, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 592, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_5);
           __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
         }
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_DECREF_SET(__pyx_v_ck, __pyx_t_5);
         __pyx_t_5 = 0;
 
-        /* "borg/item.pyx":591
+        /* "borg/item.pyx":593
  *                 for ck, cv in list(cd.items()):
  *                     ck = fix_key(cd, ck)
  *                     if ck == 'tam_required':             # <<<<<<<<<<<<<<
  *                         assert isinstance(cv, bool)
  *                     if ck == 'feature_flags':
  */
-        __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_ck, __pyx_n_s_tam_required, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 591, __pyx_L1_error)
+        __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_ck, __pyx_n_s_tam_required, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 593, __pyx_L1_error)
         if (__pyx_t_9) {
 
-          /* "borg/item.pyx":592
+          /* "borg/item.pyx":594
  *                     ck = fix_key(cd, ck)
  *                     if ck == 'tam_required':
  *                         assert isinstance(cv, bool)             # <<<<<<<<<<<<<<
  *                     if ck == 'feature_flags':
  *                         assert isinstance(cv, dict)
  */
           #ifndef CYTHON_WITHOUT_ASSERTIONS
           if (unlikely(!Py_OptimizeFlag)) {
             __pyx_t_5 = ((PyObject*)&PyBool_Type);
             __Pyx_INCREF(__pyx_t_5);
-            __pyx_t_9 = PyObject_IsInstance(__pyx_v_cv, __pyx_t_5); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 592, __pyx_L1_error)
+            __pyx_t_9 = PyObject_IsInstance(__pyx_v_cv, __pyx_t_5); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 594, __pyx_L1_error)
             __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
             if (unlikely(!(__pyx_t_9 != 0))) {
               PyErr_SetNone(PyExc_AssertionError);
-              __PYX_ERR(0, 592, __pyx_L1_error)
+              __PYX_ERR(0, 594, __pyx_L1_error)
             }
           }
           #endif
 
-          /* "borg/item.pyx":591
+          /* "borg/item.pyx":593
  *                 for ck, cv in list(cd.items()):
  *                     ck = fix_key(cd, ck)
  *                     if ck == 'tam_required':             # <<<<<<<<<<<<<<
  *                         assert isinstance(cv, bool)
  *                     if ck == 'feature_flags':
  */
         }
 
-        /* "borg/item.pyx":593
+        /* "borg/item.pyx":595
  *                     if ck == 'tam_required':
  *                         assert isinstance(cv, bool)
  *                     if ck == 'feature_flags':             # <<<<<<<<<<<<<<
  *                         assert isinstance(cv, dict)
  *                         ops = {'read', 'check', 'write', 'delete'}
  */
-        __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_ck, __pyx_n_s_feature_flags, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 593, __pyx_L1_error)
+        __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_ck, __pyx_n_s_feature_flags, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 595, __pyx_L1_error)
         if (__pyx_t_9) {
 
-          /* "borg/item.pyx":594
+          /* "borg/item.pyx":596
  *                         assert isinstance(cv, bool)
  *                     if ck == 'feature_flags':
  *                         assert isinstance(cv, dict)             # <<<<<<<<<<<<<<
  *                         ops = {'read', 'check', 'write', 'delete'}
  *                         for op, specs in list(cv.items()):
  */
           #ifndef CYTHON_WITHOUT_ASSERTIONS
           if (unlikely(!Py_OptimizeFlag)) {
             __pyx_t_9 = PyDict_Check(__pyx_v_cv); 
             if (unlikely(!(__pyx_t_9 != 0))) {
               PyErr_SetNone(PyExc_AssertionError);
-              __PYX_ERR(0, 594, __pyx_L1_error)
+              __PYX_ERR(0, 596, __pyx_L1_error)
             }
           }
           #endif
 
-          /* "borg/item.pyx":595
+          /* "borg/item.pyx":597
  *                     if ck == 'feature_flags':
  *                         assert isinstance(cv, dict)
  *                         ops = {'read', 'check', 'write', 'delete'}             # <<<<<<<<<<<<<<
  *                         for op, specs in list(cv.items()):
  *                             op = fix_key(cv, op)
  */
-          __pyx_t_5 = PySet_New(0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 595, __pyx_L1_error)
+          __pyx_t_5 = PySet_New(0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 597, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_5);
-          if (PySet_Add(__pyx_t_5, __pyx_n_s_read) < 0) __PYX_ERR(0, 595, __pyx_L1_error)
-          if (PySet_Add(__pyx_t_5, __pyx_n_s_check) < 0) __PYX_ERR(0, 595, __pyx_L1_error)
-          if (PySet_Add(__pyx_t_5, __pyx_n_s_write) < 0) __PYX_ERR(0, 595, __pyx_L1_error)
-          if (PySet_Add(__pyx_t_5, __pyx_n_s_delete) < 0) __PYX_ERR(0, 595, __pyx_L1_error)
+          if (PySet_Add(__pyx_t_5, __pyx_n_s_read) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
+          if (PySet_Add(__pyx_t_5, __pyx_n_s_check) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
+          if (PySet_Add(__pyx_t_5, __pyx_n_s_write) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
+          if (PySet_Add(__pyx_t_5, __pyx_n_s_delete) < 0) __PYX_ERR(0, 597, __pyx_L1_error)
           __Pyx_XDECREF_SET(__pyx_v_ops, ((PyObject*)__pyx_t_5));
           __pyx_t_5 = 0;
 
-          /* "borg/item.pyx":596
+          /* "borg/item.pyx":598
  *                         assert isinstance(cv, dict)
  *                         ops = {'read', 'check', 'write', 'delete'}
  *                         for op, specs in list(cv.items()):             # <<<<<<<<<<<<<<
  *                             op = fix_key(cv, op)
  *                             assert op in ops
  */
-          __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_cv, __pyx_n_s_items); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 596, __pyx_L1_error)
+          __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_cv, __pyx_n_s_items); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 598, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_6);
           __pyx_t_13 = NULL;
           if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
             __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_6);
             if (likely(__pyx_t_13)) {
               PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
               __Pyx_INCREF(__pyx_t_13);
               __Pyx_INCREF(function);
               __Pyx_DECREF_SET(__pyx_t_6, function);
             }
           }
           __pyx_t_5 = (__pyx_t_13) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_13) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
           __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
-          if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 596, __pyx_L1_error)
+          if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 598, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_5);
           __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-          __pyx_t_6 = PySequence_List(__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 596, __pyx_L1_error)
+          __pyx_t_6 = PySequence_List(__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 598, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_6);
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
           __pyx_t_5 = __pyx_t_6; __Pyx_INCREF(__pyx_t_5); __pyx_t_12 = 0;
           __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
           for (;;) {
             if (__pyx_t_12 >= PyList_GET_SIZE(__pyx_t_5)) break;
             #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-            __pyx_t_6 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_12); __Pyx_INCREF(__pyx_t_6); __pyx_t_12++; if (unlikely(0 < 0)) __PYX_ERR(0, 596, __pyx_L1_error)
+            __pyx_t_6 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_12); __Pyx_INCREF(__pyx_t_6); __pyx_t_12++; if (unlikely(0 < 0)) __PYX_ERR(0, 598, __pyx_L1_error)
             #else
-            __pyx_t_6 = PySequence_ITEM(__pyx_t_5, __pyx_t_12); __pyx_t_12++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 596, __pyx_L1_error)
+            __pyx_t_6 = PySequence_ITEM(__pyx_t_5, __pyx_t_12); __pyx_t_12++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 598, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_6);
             #endif
             if ((likely(PyTuple_CheckExact(__pyx_t_6))) || (PyList_CheckExact(__pyx_t_6))) {
               PyObject* sequence = __pyx_t_6;
               Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
               if (unlikely(size != 2)) {
                 if (size > 2) __Pyx_RaiseTooManyValuesError(2);
                 else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-                __PYX_ERR(0, 596, __pyx_L1_error)
+                __PYX_ERR(0, 598, __pyx_L1_error)
               }
               #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
               if (likely(PyTuple_CheckExact(sequence))) {
                 __pyx_t_13 = PyTuple_GET_ITEM(sequence, 0); 
                 __pyx_t_11 = PyTuple_GET_ITEM(sequence, 1); 
               } else {
                 __pyx_t_13 = PyList_GET_ITEM(sequence, 0); 
                 __pyx_t_11 = PyList_GET_ITEM(sequence, 1); 
               }
               __Pyx_INCREF(__pyx_t_13);
               __Pyx_INCREF(__pyx_t_11);
               #else
-              __pyx_t_13 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 596, __pyx_L1_error)
+              __pyx_t_13 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 598, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_13);
-              __pyx_t_11 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 596, __pyx_L1_error)
+              __pyx_t_11 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 598, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_11);
               #endif
               __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
             } else {
               Py_ssize_t index = -1;
-              __pyx_t_3 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 596, __pyx_L1_error)
+              __pyx_t_3 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 598, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_3);
               __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
               __pyx_t_7 = Py_TYPE(__pyx_t_3)->tp_iternext;
               index = 0; __pyx_t_13 = __pyx_t_7(__pyx_t_3); if (unlikely(!__pyx_t_13)) goto __pyx_L29_unpacking_failed;
               __Pyx_GOTREF(__pyx_t_13);
               index = 1; __pyx_t_11 = __pyx_t_7(__pyx_t_3); if (unlikely(!__pyx_t_11)) goto __pyx_L29_unpacking_failed;
               __Pyx_GOTREF(__pyx_t_11);
-              if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_3), 2) < 0) __PYX_ERR(0, 596, __pyx_L1_error)
+              if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_3), 2) < 0) __PYX_ERR(0, 598, __pyx_L1_error)
               __pyx_t_7 = NULL;
               __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
               goto __pyx_L30_unpacking_done;
               __pyx_L29_unpacking_failed:;
               __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
               __pyx_t_7 = NULL;
               if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-              __PYX_ERR(0, 596, __pyx_L1_error)
+              __PYX_ERR(0, 598, __pyx_L1_error)
               __pyx_L30_unpacking_done:;
             }
             __Pyx_XDECREF_SET(__pyx_v_op, __pyx_t_13);
             __pyx_t_13 = 0;
             __Pyx_XDECREF_SET(__pyx_v_specs, __pyx_t_11);
             __pyx_t_11 = 0;
 
-            /* "borg/item.pyx":597
+            /* "borg/item.pyx":599
  *                         ops = {'read', 'check', 'write', 'delete'}
  *                         for op, specs in list(cv.items()):
  *                             op = fix_key(cv, op)             # <<<<<<<<<<<<<<
  *                             assert op in ops
  *                             for speck, specv in list(specs.items()):
  */
-            __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 597, __pyx_L1_error)
+            __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 599, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_11);
             __pyx_t_13 = NULL;
             __pyx_t_8 = 0;
             if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_11))) {
               __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_11);
               if (likely(__pyx_t_13)) {
                 PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
@@ -14196,160 +14263,160 @@
                 __Pyx_DECREF_SET(__pyx_t_11, function);
                 __pyx_t_8 = 1;
               }
             }
             #if CYTHON_FAST_PYCALL
             if (PyFunction_Check(__pyx_t_11)) {
               PyObject *__pyx_temp[3] = {__pyx_t_13, __pyx_v_cv, __pyx_v_op};
-              __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 597, __pyx_L1_error)
+              __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 599, __pyx_L1_error)
               __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
               __Pyx_GOTREF(__pyx_t_6);
             } else
             #endif
             #if CYTHON_FAST_PYCCALL
             if (__Pyx_PyFastCFunction_Check(__pyx_t_11)) {
               PyObject *__pyx_temp[3] = {__pyx_t_13, __pyx_v_cv, __pyx_v_op};
-              __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 597, __pyx_L1_error)
+              __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 599, __pyx_L1_error)
               __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
               __Pyx_GOTREF(__pyx_t_6);
             } else
             #endif
             {
-              __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 597, __pyx_L1_error)
+              __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 599, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_3);
               if (__pyx_t_13) {
                 __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_13); __pyx_t_13 = NULL;
               }
               __Pyx_INCREF(__pyx_v_cv);
               __Pyx_GIVEREF(__pyx_v_cv);
               PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_v_cv);
               __Pyx_INCREF(__pyx_v_op);
               __Pyx_GIVEREF(__pyx_v_op);
               PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_v_op);
-              __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_11, __pyx_t_3, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 597, __pyx_L1_error)
+              __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_11, __pyx_t_3, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 599, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_6);
               __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
             }
             __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
             __Pyx_DECREF_SET(__pyx_v_op, __pyx_t_6);
             __pyx_t_6 = 0;
 
-            /* "borg/item.pyx":598
+            /* "borg/item.pyx":600
  *                         for op, specs in list(cv.items()):
  *                             op = fix_key(cv, op)
  *                             assert op in ops             # <<<<<<<<<<<<<<
  *                             for speck, specv in list(specs.items()):
  *                                 speck = fix_key(specs, speck)
  */
             #ifndef CYTHON_WITHOUT_ASSERTIONS
             if (unlikely(!Py_OptimizeFlag)) {
-              __pyx_t_9 = (__Pyx_PySet_ContainsTF(__pyx_v_op, __pyx_v_ops, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 598, __pyx_L1_error)
+              __pyx_t_9 = (__Pyx_PySet_ContainsTF(__pyx_v_op, __pyx_v_ops, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 600, __pyx_L1_error)
               if (unlikely(!(__pyx_t_9 != 0))) {
                 PyErr_SetNone(PyExc_AssertionError);
-                __PYX_ERR(0, 598, __pyx_L1_error)
+                __PYX_ERR(0, 600, __pyx_L1_error)
               }
             }
             #endif
 
-            /* "borg/item.pyx":599
+            /* "borg/item.pyx":601
  *                             op = fix_key(cv, op)
  *                             assert op in ops
  *                             for speck, specv in list(specs.items()):             # <<<<<<<<<<<<<<
  *                                 speck = fix_key(specs, speck)
  *                                 if speck == 'mandatory':
  */
-            __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_specs, __pyx_n_s_items); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 599, __pyx_L1_error)
+            __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_specs, __pyx_n_s_items); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 601, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_11);
             __pyx_t_3 = NULL;
             if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_11))) {
               __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_11);
               if (likely(__pyx_t_3)) {
                 PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
                 __Pyx_INCREF(__pyx_t_3);
                 __Pyx_INCREF(function);
                 __Pyx_DECREF_SET(__pyx_t_11, function);
               }
             }
             __pyx_t_6 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_11, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_11);
             __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-            if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 599, __pyx_L1_error)
+            if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 601, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_6);
             __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-            __pyx_t_11 = PySequence_List(__pyx_t_6); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 599, __pyx_L1_error)
+            __pyx_t_11 = PySequence_List(__pyx_t_6); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 601, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_11);
             __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
             __pyx_t_6 = __pyx_t_11; __Pyx_INCREF(__pyx_t_6); __pyx_t_14 = 0;
             __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
             for (;;) {
               if (__pyx_t_14 >= PyList_GET_SIZE(__pyx_t_6)) break;
               #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-              __pyx_t_11 = PyList_GET_ITEM(__pyx_t_6, __pyx_t_14); __Pyx_INCREF(__pyx_t_11); __pyx_t_14++; if (unlikely(0 < 0)) __PYX_ERR(0, 599, __pyx_L1_error)
+              __pyx_t_11 = PyList_GET_ITEM(__pyx_t_6, __pyx_t_14); __Pyx_INCREF(__pyx_t_11); __pyx_t_14++; if (unlikely(0 < 0)) __PYX_ERR(0, 601, __pyx_L1_error)
               #else
-              __pyx_t_11 = PySequence_ITEM(__pyx_t_6, __pyx_t_14); __pyx_t_14++; if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 599, __pyx_L1_error)
+              __pyx_t_11 = PySequence_ITEM(__pyx_t_6, __pyx_t_14); __pyx_t_14++; if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 601, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_11);
               #endif
               if ((likely(PyTuple_CheckExact(__pyx_t_11))) || (PyList_CheckExact(__pyx_t_11))) {
                 PyObject* sequence = __pyx_t_11;
                 Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
                 if (unlikely(size != 2)) {
                   if (size > 2) __Pyx_RaiseTooManyValuesError(2);
                   else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-                  __PYX_ERR(0, 599, __pyx_L1_error)
+                  __PYX_ERR(0, 601, __pyx_L1_error)
                 }
                 #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
                 if (likely(PyTuple_CheckExact(sequence))) {
                   __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
                   __pyx_t_13 = PyTuple_GET_ITEM(sequence, 1); 
                 } else {
                   __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
                   __pyx_t_13 = PyList_GET_ITEM(sequence, 1); 
                 }
                 __Pyx_INCREF(__pyx_t_3);
                 __Pyx_INCREF(__pyx_t_13);
                 #else
-                __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 599, __pyx_L1_error)
+                __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 601, __pyx_L1_error)
                 __Pyx_GOTREF(__pyx_t_3);
-                __pyx_t_13 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 599, __pyx_L1_error)
+                __pyx_t_13 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 601, __pyx_L1_error)
                 __Pyx_GOTREF(__pyx_t_13);
                 #endif
                 __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
               } else {
                 Py_ssize_t index = -1;
-                __pyx_t_15 = PyObject_GetIter(__pyx_t_11); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 599, __pyx_L1_error)
+                __pyx_t_15 = PyObject_GetIter(__pyx_t_11); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 601, __pyx_L1_error)
                 __Pyx_GOTREF(__pyx_t_15);
                 __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
                 __pyx_t_7 = Py_TYPE(__pyx_t_15)->tp_iternext;
                 index = 0; __pyx_t_3 = __pyx_t_7(__pyx_t_15); if (unlikely(!__pyx_t_3)) goto __pyx_L33_unpacking_failed;
                 __Pyx_GOTREF(__pyx_t_3);
                 index = 1; __pyx_t_13 = __pyx_t_7(__pyx_t_15); if (unlikely(!__pyx_t_13)) goto __pyx_L33_unpacking_failed;
                 __Pyx_GOTREF(__pyx_t_13);
-                if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_15), 2) < 0) __PYX_ERR(0, 599, __pyx_L1_error)
+                if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_15), 2) < 0) __PYX_ERR(0, 601, __pyx_L1_error)
                 __pyx_t_7 = NULL;
                 __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
                 goto __pyx_L34_unpacking_done;
                 __pyx_L33_unpacking_failed:;
                 __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
                 __pyx_t_7 = NULL;
                 if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-                __PYX_ERR(0, 599, __pyx_L1_error)
+                __PYX_ERR(0, 601, __pyx_L1_error)
                 __pyx_L34_unpacking_done:;
               }
               __Pyx_XDECREF_SET(__pyx_v_speck, __pyx_t_3);
               __pyx_t_3 = 0;
               __Pyx_XDECREF_SET(__pyx_v_specv, __pyx_t_13);
               __pyx_t_13 = 0;
 
-              /* "borg/item.pyx":600
+              /* "borg/item.pyx":602
  *                             assert op in ops
  *                             for speck, specv in list(specs.items()):
  *                                 speck = fix_key(specs, speck)             # <<<<<<<<<<<<<<
  *                                 if speck == 'mandatory':
  *                                     specs[speck] = fix_tuple_of_str(specv)
  */
-              __Pyx_GetModuleGlobalName(__pyx_t_13, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 600, __pyx_L1_error)
+              __Pyx_GetModuleGlobalName(__pyx_t_13, __pyx_n_s_fix_key); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 602, __pyx_L1_error)
               __Pyx_GOTREF(__pyx_t_13);
               __pyx_t_3 = NULL;
               __pyx_t_8 = 0;
               if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_13))) {
                 __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_13);
                 if (likely(__pyx_t_3)) {
                   PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
@@ -14358,245 +14425,245 @@
                   __Pyx_DECREF_SET(__pyx_t_13, function);
                   __pyx_t_8 = 1;
                 }
               }
               #if CYTHON_FAST_PYCALL
               if (PyFunction_Check(__pyx_t_13)) {
                 PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_specs, __pyx_v_speck};
-                __pyx_t_11 = __Pyx_PyFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 600, __pyx_L1_error)
+                __pyx_t_11 = __Pyx_PyFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 602, __pyx_L1_error)
                 __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
                 __Pyx_GOTREF(__pyx_t_11);
               } else
               #endif
               #if CYTHON_FAST_PYCCALL
               if (__Pyx_PyFastCFunction_Check(__pyx_t_13)) {
                 PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_specs, __pyx_v_speck};
-                __pyx_t_11 = __Pyx_PyCFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 600, __pyx_L1_error)
+                __pyx_t_11 = __Pyx_PyCFunction_FastCall(__pyx_t_13, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 602, __pyx_L1_error)
                 __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
                 __Pyx_GOTREF(__pyx_t_11);
               } else
               #endif
               {
-                __pyx_t_15 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 600, __pyx_L1_error)
+                __pyx_t_15 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 602, __pyx_L1_error)
                 __Pyx_GOTREF(__pyx_t_15);
                 if (__pyx_t_3) {
                   __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_15, 0, __pyx_t_3); __pyx_t_3 = NULL;
                 }
                 __Pyx_INCREF(__pyx_v_specs);
                 __Pyx_GIVEREF(__pyx_v_specs);
                 PyTuple_SET_ITEM(__pyx_t_15, 0+__pyx_t_8, __pyx_v_specs);
                 __Pyx_INCREF(__pyx_v_speck);
                 __Pyx_GIVEREF(__pyx_v_speck);
                 PyTuple_SET_ITEM(__pyx_t_15, 1+__pyx_t_8, __pyx_v_speck);
-                __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_t_15, NULL); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 600, __pyx_L1_error)
+                __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_t_15, NULL); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 602, __pyx_L1_error)
                 __Pyx_GOTREF(__pyx_t_11);
                 __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
               }
               __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
               __Pyx_DECREF_SET(__pyx_v_speck, __pyx_t_11);
               __pyx_t_11 = 0;
 
-              /* "borg/item.pyx":601
+              /* "borg/item.pyx":603
  *                             for speck, specv in list(specs.items()):
  *                                 speck = fix_key(specs, speck)
  *                                 if speck == 'mandatory':             # <<<<<<<<<<<<<<
  *                                     specs[speck] = fix_tuple_of_str(specv)
  *                         assert set(cv).issubset(ops)
  */
-              __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_speck, __pyx_n_s_mandatory, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 601, __pyx_L1_error)
+              __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_speck, __pyx_n_s_mandatory, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 603, __pyx_L1_error)
               if (__pyx_t_9) {
 
-                /* "borg/item.pyx":602
+                /* "borg/item.pyx":604
  *                                 speck = fix_key(specs, speck)
  *                                 if speck == 'mandatory':
  *                                     specs[speck] = fix_tuple_of_str(specv)             # <<<<<<<<<<<<<<
  *                         assert set(cv).issubset(ops)
  *             if k == 'item_keys':
  */
-                __Pyx_GetModuleGlobalName(__pyx_t_13, __pyx_n_s_fix_tuple_of_str); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 602, __pyx_L1_error)
+                __Pyx_GetModuleGlobalName(__pyx_t_13, __pyx_n_s_fix_tuple_of_str); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 604, __pyx_L1_error)
                 __Pyx_GOTREF(__pyx_t_13);
                 __pyx_t_15 = NULL;
                 if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_13))) {
                   __pyx_t_15 = PyMethod_GET_SELF(__pyx_t_13);
                   if (likely(__pyx_t_15)) {
                     PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
                     __Pyx_INCREF(__pyx_t_15);
                     __Pyx_INCREF(function);
                     __Pyx_DECREF_SET(__pyx_t_13, function);
                   }
                 }
                 __pyx_t_11 = (__pyx_t_15) ? __Pyx_PyObject_Call2Args(__pyx_t_13, __pyx_t_15, __pyx_v_specv) : __Pyx_PyObject_CallOneArg(__pyx_t_13, __pyx_v_specv);
                 __Pyx_XDECREF(__pyx_t_15); __pyx_t_15 = 0;
-                if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 602, __pyx_L1_error)
+                if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 604, __pyx_L1_error)
                 __Pyx_GOTREF(__pyx_t_11);
                 __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-                if (unlikely(PyObject_SetItem(__pyx_v_specs, __pyx_v_speck, __pyx_t_11) < 0)) __PYX_ERR(0, 602, __pyx_L1_error)
+                if (unlikely(PyObject_SetItem(__pyx_v_specs, __pyx_v_speck, __pyx_t_11) < 0)) __PYX_ERR(0, 604, __pyx_L1_error)
                 __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
 
-                /* "borg/item.pyx":601
+                /* "borg/item.pyx":603
  *                             for speck, specv in list(specs.items()):
  *                                 speck = fix_key(specs, speck)
  *                                 if speck == 'mandatory':             # <<<<<<<<<<<<<<
  *                                     specs[speck] = fix_tuple_of_str(specv)
  *                         assert set(cv).issubset(ops)
  */
               }
 
-              /* "borg/item.pyx":599
+              /* "borg/item.pyx":601
  *                             op = fix_key(cv, op)
  *                             assert op in ops
  *                             for speck, specv in list(specs.items()):             # <<<<<<<<<<<<<<
  *                                 speck = fix_key(specs, speck)
  *                                 if speck == 'mandatory':
  */
             }
             __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-            /* "borg/item.pyx":596
+            /* "borg/item.pyx":598
  *                         assert isinstance(cv, dict)
  *                         ops = {'read', 'check', 'write', 'delete'}
  *                         for op, specs in list(cv.items()):             # <<<<<<<<<<<<<<
  *                             op = fix_key(cv, op)
  *                             assert op in ops
  */
           }
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-          /* "borg/item.pyx":603
+          /* "borg/item.pyx":605
  *                                 if speck == 'mandatory':
  *                                     specs[speck] = fix_tuple_of_str(specv)
  *                         assert set(cv).issubset(ops)             # <<<<<<<<<<<<<<
  *             if k == 'item_keys':
  *                 v = fix_tuple_of_str(v)
  */
           #ifndef CYTHON_WITHOUT_ASSERTIONS
           if (unlikely(!Py_OptimizeFlag)) {
-            __pyx_t_6 = PySet_New(__pyx_v_cv); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 603, __pyx_L1_error)
+            __pyx_t_6 = PySet_New(__pyx_v_cv); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 605, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_6);
-            __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_issubset); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 603, __pyx_L1_error)
+            __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_issubset); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 605, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_11);
             __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
             __pyx_t_6 = NULL;
             if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_11))) {
               __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_11);
               if (likely(__pyx_t_6)) {
                 PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
                 __Pyx_INCREF(__pyx_t_6);
                 __Pyx_INCREF(function);
                 __Pyx_DECREF_SET(__pyx_t_11, function);
               }
             }
             __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_11, __pyx_t_6, __pyx_v_ops) : __Pyx_PyObject_CallOneArg(__pyx_t_11, __pyx_v_ops);
             __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-            if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 603, __pyx_L1_error)
+            if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 605, __pyx_L1_error)
             __Pyx_GOTREF(__pyx_t_5);
             __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-            __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 603, __pyx_L1_error)
+            __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 605, __pyx_L1_error)
             __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
             if (unlikely(!__pyx_t_9)) {
               PyErr_SetNone(PyExc_AssertionError);
-              __PYX_ERR(0, 603, __pyx_L1_error)
+              __PYX_ERR(0, 605, __pyx_L1_error)
             }
           }
           #endif
 
-          /* "borg/item.pyx":593
+          /* "borg/item.pyx":595
  *                     if ck == 'tam_required':
  *                         assert isinstance(cv, bool)
  *                     if ck == 'feature_flags':             # <<<<<<<<<<<<<<
  *                         assert isinstance(cv, dict)
  *                         ops = {'read', 'check', 'write', 'delete'}
  */
         }
 
-        /* "borg/item.pyx":589
+        /* "borg/item.pyx":591
  *                 cd = v
  *                 assert isinstance(cd, dict)
  *                 for ck, cv in list(cd.items()):             # <<<<<<<<<<<<<<
  *                     ck = fix_key(cd, ck)
  *                     if ck == 'tam_required':
  */
       }
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":586
+      /* "borg/item.pyx":588
  *             if k == 'timestamp':
  *                 v = fix_str_value(d, k, 'replace')
  *             if k == 'config':             # <<<<<<<<<<<<<<
  *                 cd = v
  *                 assert isinstance(cd, dict)
  */
     }
 
-    /* "borg/item.pyx":604
+    /* "borg/item.pyx":606
  *                                     specs[speck] = fix_tuple_of_str(specv)
  *                         assert set(cv).issubset(ops)
  *             if k == 'item_keys':             # <<<<<<<<<<<<<<
  *                 v = fix_tuple_of_str(v)
  *             self._dict[k] = v
  */
-    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_item_keys, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 604, __pyx_L1_error)
+    __pyx_t_9 = (__Pyx_PyString_Equals(__pyx_v_k, __pyx_n_s_item_keys, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 606, __pyx_L1_error)
     if (__pyx_t_9) {
 
-      /* "borg/item.pyx":605
+      /* "borg/item.pyx":607
  *                         assert set(cv).issubset(ops)
  *             if k == 'item_keys':
  *                 v = fix_tuple_of_str(v)             # <<<<<<<<<<<<<<
  *             self._dict[k] = v
  * 
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_tuple_of_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 605, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_fix_tuple_of_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 607, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_11 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_11)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
           __Pyx_INCREF(__pyx_t_11);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_5, function);
         }
       }
       __pyx_t_2 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_11, __pyx_v_v) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_v);
       __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 605, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 607, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_DECREF_SET(__pyx_v_v, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":604
+      /* "borg/item.pyx":606
  *                                     specs[speck] = fix_tuple_of_str(specv)
  *                         assert set(cv).issubset(ops)
  *             if k == 'item_keys':             # <<<<<<<<<<<<<<
  *                 v = fix_tuple_of_str(v)
  *             self._dict[k] = v
  */
     }
 
-    /* "borg/item.pyx":606
+    /* "borg/item.pyx":608
  *             if k == 'item_keys':
  *                 v = fix_tuple_of_str(v)
  *             self._dict[k] = v             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 606, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_self->__pyx_base._dict, __pyx_v_k, __pyx_v_v) < 0)) __PYX_ERR(0, 608, __pyx_L1_error)
 
-    /* "borg/item.pyx":567
+    /* "borg/item.pyx":569
  *     def update_internal(self, d):
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):             # <<<<<<<<<<<<<<
  *             k = fix_key(d, k)
  *             if k == 'version':
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":565
+  /* "borg/item.pyx":567
  *     item_keys = PropDictProperty(tuple, 'tuple of str')
  * 
  *     def update_internal(self, d):             # <<<<<<<<<<<<<<
  *         # legacy support for migration (data from old msgpacks comes in as bytes always, but sometimes we want str)
  *         for k, v in list(d.items()):
  */
 
@@ -14744,15 +14811,15 @@
   __Pyx_AddTraceback("borg.item.ManifestItem.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":609
+/* "borg/item.pyx":611
  * 
  * 
  * cpdef _init_names():             # <<<<<<<<<<<<<<
  *     """
  *     re-implements python __set_name__
  */
 
@@ -14777,171 +14844,171 @@
   int __pyx_t_12;
   PyObject *__pyx_t_13 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_init_names", 0);
 
-  /* "borg/item.pyx":613
+  /* "borg/item.pyx":615
  *     re-implements python __set_name__
  *     """
  *     for cls in PropDict.__subclasses__():             # <<<<<<<<<<<<<<
  *         for name, value in vars(cls).items():
  *             if isinstance(value, PropDictProperty):
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_4borg_4item_PropDict), __pyx_n_s_subclasses); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 613, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_4borg_4item_PropDict), __pyx_n_s_subclasses); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 615, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 613, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 615, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
     __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_4 = 0;
     __pyx_t_5 = NULL;
   } else {
-    __pyx_t_4 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 613, __pyx_L1_error)
+    __pyx_t_4 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 615, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 613, __pyx_L1_error)
+    __pyx_t_5 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 615, __pyx_L1_error)
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   for (;;) {
     if (likely(!__pyx_t_5)) {
       if (likely(PyList_CheckExact(__pyx_t_2))) {
         if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 613, __pyx_L1_error)
+        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 615, __pyx_L1_error)
         #else
-        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 613, __pyx_L1_error)
+        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 615, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
         #endif
       } else {
         if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 613, __pyx_L1_error)
+        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_1); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 615, __pyx_L1_error)
         #else
-        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 613, __pyx_L1_error)
+        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 615, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_1);
         #endif
       }
     } else {
       __pyx_t_1 = __pyx_t_5(__pyx_t_2);
       if (unlikely(!__pyx_t_1)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 613, __pyx_L1_error)
+          else __PYX_ERR(0, 615, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_1);
     }
     __Pyx_XDECREF_SET(__pyx_v_cls, __pyx_t_1);
     __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":614
+    /* "borg/item.pyx":616
  *     """
  *     for cls in PropDict.__subclasses__():
  *         for name, value in vars(cls).items():             # <<<<<<<<<<<<<<
  *             if isinstance(value, PropDictProperty):
  *                 value.__set_name__(name)
  */
     __pyx_t_6 = 0;
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_vars, __pyx_v_cls); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 614, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_vars, __pyx_v_cls); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 616, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     if (unlikely(__pyx_t_3 == Py_None)) {
       PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "items");
-      __PYX_ERR(0, 614, __pyx_L1_error)
+      __PYX_ERR(0, 616, __pyx_L1_error)
     }
-    __pyx_t_9 = __Pyx_dict_iterator(__pyx_t_3, 0, __pyx_n_s_items, (&__pyx_t_7), (&__pyx_t_8)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 614, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_dict_iterator(__pyx_t_3, 0, __pyx_n_s_items, (&__pyx_t_7), (&__pyx_t_8)); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 616, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_9);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_XDECREF(__pyx_t_1);
     __pyx_t_1 = __pyx_t_9;
     __pyx_t_9 = 0;
     while (1) {
       __pyx_t_10 = __Pyx_dict_iter_next(__pyx_t_1, __pyx_t_7, &__pyx_t_6, &__pyx_t_9, &__pyx_t_3, NULL, __pyx_t_8);
       if (unlikely(__pyx_t_10 == 0)) break;
-      if (unlikely(__pyx_t_10 == -1)) __PYX_ERR(0, 614, __pyx_L1_error)
+      if (unlikely(__pyx_t_10 == -1)) __PYX_ERR(0, 616, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_XDECREF_SET(__pyx_v_name, __pyx_t_9);
       __pyx_t_9 = 0;
       __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_3);
       __pyx_t_3 = 0;
 
-      /* "borg/item.pyx":615
+      /* "borg/item.pyx":617
  *     for cls in PropDict.__subclasses__():
  *         for name, value in vars(cls).items():
  *             if isinstance(value, PropDictProperty):             # <<<<<<<<<<<<<<
  *                 value.__set_name__(name)
  * 
  */
       __pyx_t_11 = __Pyx_TypeCheck(__pyx_v_value, __pyx_ptype_4borg_4item_PropDictProperty); 
       __pyx_t_12 = (__pyx_t_11 != 0);
       if (__pyx_t_12) {
 
-        /* "borg/item.pyx":616
+        /* "borg/item.pyx":618
  *         for name, value in vars(cls).items():
  *             if isinstance(value, PropDictProperty):
  *                 value.__set_name__(name)             # <<<<<<<<<<<<<<
  * 
  * _init_names()
  */
-        __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_value, __pyx_n_s_set_name); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 616, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_value, __pyx_n_s_set_name); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 618, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         __pyx_t_13 = NULL;
         if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_9))) {
           __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_9);
           if (likely(__pyx_t_13)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
             __Pyx_INCREF(__pyx_t_13);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_9, function);
           }
         }
         __pyx_t_3 = (__pyx_t_13) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_13, __pyx_v_name) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_v_name);
         __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
-        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 616, __pyx_L1_error)
+        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 618, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-        /* "borg/item.pyx":615
+        /* "borg/item.pyx":617
  *     for cls in PropDict.__subclasses__():
  *         for name, value in vars(cls).items():
  *             if isinstance(value, PropDictProperty):             # <<<<<<<<<<<<<<
  *                 value.__set_name__(name)
  * 
  */
       }
     }
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":613
+    /* "borg/item.pyx":615
  *     re-implements python __set_name__
  *     """
  *     for cls in PropDict.__subclasses__():             # <<<<<<<<<<<<<<
  *         for name, value in vars(cls).items():
  *             if isinstance(value, PropDictProperty):
  */
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":609
+  /* "borg/item.pyx":611
  * 
  * 
  * cpdef _init_names():             # <<<<<<<<<<<<<<
  *     """
  *     re-implements python __set_name__
  */
 
@@ -14984,15 +15051,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_init_names", 0);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_4borg_4item__init_names(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 609, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_4borg_4item__init_names(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 611, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -15001,48 +15068,289 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":629
+/* "borg/item.pyx":630
+ *     The diff_data contains additional information about the change, e.g. the old and new mode.
+ *     """
+ *     def __init__(self, diff_type, diff_data=None):             # <<<<<<<<<<<<<<
+ *         self.diff_type = diff_type
+ *         self.diff_data = diff_data or {}
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_10DiffChange_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_10DiffChange_1__init__ = {"__init__", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_4item_10DiffChange_1__init__, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_4borg_4item_10DiffChange_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_self = 0;
+  PyObject *__pyx_v_diff_type = 0;
+  PyObject *__pyx_v_diff_data = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_diff_type,&__pyx_n_s_diff_data,0};
+    PyObject* values[3] = {0,0,0};
+    values[2] = ((PyObject *)((PyObject *)Py_None));
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_diff_type)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 3, 1); __PYX_ERR(0, 630, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (kw_args > 0) {
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_diff_data);
+          if (value) { values[2] = value; kw_args--; }
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 630, __pyx_L3_error)
+      }
+    } else {
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_self = values[0];
+    __pyx_v_diff_type = values[1];
+    __pyx_v_diff_data = values[2];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 630, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("borg.item.DiffChange.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_4borg_4item_10DiffChange___init__(__pyx_self, __pyx_v_self, __pyx_v_diff_type, __pyx_v_diff_data);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_10DiffChange___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_diff_type, PyObject *__pyx_v_diff_data) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__init__", 0);
+
+  /* "borg/item.pyx":631
+ *     """
+ *     def __init__(self, diff_type, diff_data=None):
+ *         self.diff_type = diff_type             # <<<<<<<<<<<<<<
+ *         self.diff_data = diff_data or {}
+ * 
+ */
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_diff_type, __pyx_v_diff_type) < 0) __PYX_ERR(0, 631, __pyx_L1_error)
+
+  /* "borg/item.pyx":632
+ *     def __init__(self, diff_type, diff_data=None):
+ *         self.diff_type = diff_type
+ *         self.diff_data = diff_data or {}             # <<<<<<<<<<<<<<
+ * 
+ *     def to_dict(self):
+ */
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_diff_data); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 632, __pyx_L1_error)
+  if (!__pyx_t_2) {
+  } else {
+    __Pyx_INCREF(__pyx_v_diff_data);
+    __pyx_t_1 = __pyx_v_diff_data;
+    goto __pyx_L3_bool_binop_done;
+  }
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 632, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_INCREF(__pyx_t_3);
+  __pyx_t_1 = __pyx_t_3;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_L3_bool_binop_done:;
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_diff_data, __pyx_t_1) < 0) __PYX_ERR(0, 632, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":630
+ *     The diff_data contains additional information about the change, e.g. the old and new mode.
+ *     """
+ *     def __init__(self, diff_type, diff_data=None):             # <<<<<<<<<<<<<<
+ *         self.diff_type = diff_type
+ *         self.diff_data = diff_data or {}
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.DiffChange.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":634
+ *         self.diff_data = diff_data or {}
+ * 
+ *     def to_dict(self):             # <<<<<<<<<<<<<<
+ *         return {"type": self.diff_type, **self.diff_data}
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_10DiffChange_3to_dict(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_10DiffChange_3to_dict = {"to_dict", (PyCFunction)__pyx_pw_4borg_4item_10DiffChange_3to_dict, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_10DiffChange_3to_dict(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("to_dict (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_10DiffChange_2to_dict(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_10DiffChange_2to_dict(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("to_dict", 0);
+
+  /* "borg/item.pyx":635
+ * 
+ *     def to_dict(self):
+ *         return {"type": self.diff_type, **self.diff_data}             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 635, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_diff_type); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 635, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, __pyx_t_3) < 0) __PYX_ERR(0, 635, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_1 = __pyx_t_2;
+  __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_diff_data); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 635, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (unlikely(__pyx_t_2 == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "argument after ** must be a mapping, not NoneType");
+    __PYX_ERR(0, 635, __pyx_L1_error)
+  }
+  if (unlikely(PyDict_Update(__pyx_t_1, __pyx_t_2) < 0)) {
+    if (PyErr_ExceptionMatches(PyExc_AttributeError)) __Pyx_RaiseMappingExpectedError(__pyx_t_2);
+    __PYX_ERR(0, 635, __pyx_L1_error)
+  }
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":634
+ *         self.diff_data = diff_data or {}
+ * 
+ *     def to_dict(self):             # <<<<<<<<<<<<<<
+ *         return {"type": self.diff_type, **self.diff_data}
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.DiffChange.to_dict", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":645
  *     """
  * 
- *     def __init__(self, item1, item2, chunk_iterator1, chunk_iterator2, numeric_ids=False, can_compare_chunk_ids=False):             # <<<<<<<<<<<<<<
+ *     def __init__(self, path, item1, item2, chunk_1, chunk_2, numeric_ids=False, can_compare_chunk_ids=False):             # <<<<<<<<<<<<<<
+ *         self.path = path
  *         self._item1 = item1
- *         self._item2 = item2
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_4borg_4item_8ItemDiff_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_1__init__ = {"__init__", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_4item_8ItemDiff_1__init__, METH_VARARGS|METH_KEYWORDS, 0};
 static PyObject *__pyx_pw_4borg_4item_8ItemDiff_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_self = 0;
+  PyObject *__pyx_v_path = 0;
   PyObject *__pyx_v_item1 = 0;
   PyObject *__pyx_v_item2 = 0;
-  PyObject *__pyx_v_chunk_iterator1 = 0;
-  PyObject *__pyx_v_chunk_iterator2 = 0;
+  PyObject *__pyx_v_chunk_1 = 0;
+  PyObject *__pyx_v_chunk_2 = 0;
   PyObject *__pyx_v_numeric_ids = 0;
   PyObject *__pyx_v_can_compare_chunk_ids = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_item1,&__pyx_n_s_item2,&__pyx_n_s_chunk_iterator1,&__pyx_n_s_chunk_iterator2,&__pyx_n_s_numeric_ids,&__pyx_n_s_can_compare_chunk_ids,0};
-    PyObject* values[7] = {0,0,0,0,0,0,0};
-    values[5] = ((PyObject *)((PyObject *)Py_False));
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_path,&__pyx_n_s_item1,&__pyx_n_s_item2,&__pyx_n_s_chunk_1,&__pyx_n_s_chunk_2,&__pyx_n_s_numeric_ids,&__pyx_n_s_can_compare_chunk_ids,0};
+    PyObject* values[8] = {0,0,0,0,0,0,0,0};
     values[6] = ((PyObject *)((PyObject *)Py_False));
+    values[7] = ((PyObject *)((PyObject *)Py_False));
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
       const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
       switch (pos_args) {
+        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
+        CYTHON_FALLTHROUGH;
         case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
         CYTHON_FALLTHROUGH;
         case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
         CYTHON_FALLTHROUGH;
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
@@ -15059,946 +15367,896 @@
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_item1)) != 0)) kw_args--;
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 5, 7, 1); __PYX_ERR(0, 629, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 6, 8, 1); __PYX_ERR(0, 645, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_item2)) != 0)) kw_args--;
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_item1)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 5, 7, 2); __PYX_ERR(0, 629, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 6, 8, 2); __PYX_ERR(0, 645, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
-        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunk_iterator1)) != 0)) kw_args--;
+        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_item2)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 5, 7, 3); __PYX_ERR(0, 629, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 6, 8, 3); __PYX_ERR(0, 645, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
-        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunk_iterator2)) != 0)) kw_args--;
+        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunk_1)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 5, 7, 4); __PYX_ERR(0, 629, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 6, 8, 4); __PYX_ERR(0, 645, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  5:
+        if (likely((values[5] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunk_2)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 6, 8, 5); __PYX_ERR(0, 645, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  6:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_numeric_ids);
-          if (value) { values[5] = value; kw_args--; }
+          if (value) { values[6] = value; kw_args--; }
         }
         CYTHON_FALLTHROUGH;
-        case  6:
+        case  7:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_can_compare_chunk_ids);
-          if (value) { values[6] = value; kw_args--; }
+          if (value) { values[7] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 629, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 645, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
+        CYTHON_FALLTHROUGH;
         case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
         CYTHON_FALLTHROUGH;
         case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
-        CYTHON_FALLTHROUGH;
-        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+        values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_self = values[0];
-    __pyx_v_item1 = values[1];
-    __pyx_v_item2 = values[2];
-    __pyx_v_chunk_iterator1 = values[3];
-    __pyx_v_chunk_iterator2 = values[4];
-    __pyx_v_numeric_ids = values[5];
-    __pyx_v_can_compare_chunk_ids = values[6];
+    __pyx_v_path = values[1];
+    __pyx_v_item1 = values[2];
+    __pyx_v_item2 = values[3];
+    __pyx_v_chunk_1 = values[4];
+    __pyx_v_chunk_2 = values[5];
+    __pyx_v_numeric_ids = values[6];
+    __pyx_v_can_compare_chunk_ids = values[7];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 5, 7, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 629, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 6, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 645, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.ItemDiff.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff___init__(__pyx_self, __pyx_v_self, __pyx_v_item1, __pyx_v_item2, __pyx_v_chunk_iterator1, __pyx_v_chunk_iterator2, __pyx_v_numeric_ids, __pyx_v_can_compare_chunk_ids);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff___init__(__pyx_self, __pyx_v_self, __pyx_v_path, __pyx_v_item1, __pyx_v_item2, __pyx_v_chunk_1, __pyx_v_chunk_2, __pyx_v_numeric_ids, __pyx_v_can_compare_chunk_ids);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4borg_4item_8ItemDiff___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_item1, PyObject *__pyx_v_item2, PyObject *__pyx_v_chunk_iterator1, PyObject *__pyx_v_chunk_iterator2, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_can_compare_chunk_ids) {
-  PyObject *__pyx_v_changes = NULL;
-  PyObject *__pyx_8genexpr7__pyx_v_ch = NULL;
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item1, PyObject *__pyx_v_item2, PyObject *__pyx_v_chunk_1, PyObject *__pyx_v_chunk_2, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_can_compare_chunk_ids) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
+  int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
   int __pyx_t_6;
-  int __pyx_t_7;
-  int __pyx_t_8;
-  int __pyx_t_9;
-  Py_ssize_t __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "borg/item.pyx":630
+  /* "borg/item.pyx":646
  * 
- *     def __init__(self, item1, item2, chunk_iterator1, chunk_iterator2, numeric_ids=False, can_compare_chunk_ids=False):
+ *     def __init__(self, path, item1, item2, chunk_1, chunk_2, numeric_ids=False, can_compare_chunk_ids=False):
+ *         self.path = path             # <<<<<<<<<<<<<<
+ *         self._item1 = item1
+ *         self._item2 = item2
+ */
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_path, __pyx_v_path) < 0) __PYX_ERR(0, 646, __pyx_L1_error)
+
+  /* "borg/item.pyx":647
+ *     def __init__(self, path, item1, item2, chunk_1, chunk_2, numeric_ids=False, can_compare_chunk_ids=False):
+ *         self.path = path
  *         self._item1 = item1             # <<<<<<<<<<<<<<
  *         self._item2 = item2
  *         self._numeric_ids = numeric_ids
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_item1_2, __pyx_v_item1) < 0) __PYX_ERR(0, 630, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_item1_2, __pyx_v_item1) < 0) __PYX_ERR(0, 647, __pyx_L1_error)
 
-  /* "borg/item.pyx":631
- *     def __init__(self, item1, item2, chunk_iterator1, chunk_iterator2, numeric_ids=False, can_compare_chunk_ids=False):
+  /* "borg/item.pyx":648
+ *         self.path = path
  *         self._item1 = item1
  *         self._item2 = item2             # <<<<<<<<<<<<<<
  *         self._numeric_ids = numeric_ids
  *         self._can_compare_chunk_ids = can_compare_chunk_ids
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_item2_2, __pyx_v_item2) < 0) __PYX_ERR(0, 631, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_item2_2, __pyx_v_item2) < 0) __PYX_ERR(0, 648, __pyx_L1_error)
 
-  /* "borg/item.pyx":632
+  /* "borg/item.pyx":649
  *         self._item1 = item1
  *         self._item2 = item2
  *         self._numeric_ids = numeric_ids             # <<<<<<<<<<<<<<
  *         self._can_compare_chunk_ids = can_compare_chunk_ids
- *         self.equal = self._equal(chunk_iterator1, chunk_iterator2)
+ *         self._chunk_1 = chunk_1
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_numeric_ids_2, __pyx_v_numeric_ids) < 0) __PYX_ERR(0, 632, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_numeric_ids_2, __pyx_v_numeric_ids) < 0) __PYX_ERR(0, 649, __pyx_L1_error)
 
-  /* "borg/item.pyx":633
+  /* "borg/item.pyx":650
  *         self._item2 = item2
  *         self._numeric_ids = numeric_ids
  *         self._can_compare_chunk_ids = can_compare_chunk_ids             # <<<<<<<<<<<<<<
- *         self.equal = self._equal(chunk_iterator1, chunk_iterator2)
- *         changes = []
+ *         self._chunk_1 = chunk_1
+ *         self._chunk_2 = chunk_2
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_can_compare_chunk_ids_2, __pyx_v_can_compare_chunk_ids) < 0) __PYX_ERR(0, 633, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_can_compare_chunk_ids_2, __pyx_v_can_compare_chunk_ids) < 0) __PYX_ERR(0, 650, __pyx_L1_error)
 
-  /* "borg/item.pyx":634
+  /* "borg/item.pyx":651
  *         self._numeric_ids = numeric_ids
  *         self._can_compare_chunk_ids = can_compare_chunk_ids
- *         self.equal = self._equal(chunk_iterator1, chunk_iterator2)             # <<<<<<<<<<<<<<
- *         changes = []
+ *         self._chunk_1 = chunk_1             # <<<<<<<<<<<<<<
+ *         self._chunk_2 = chunk_2
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_equal); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 634, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = NULL;
-  __pyx_t_4 = 0;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_3)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_3);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-      __pyx_t_4 = 1;
-    }
-  }
-  #if CYTHON_FAST_PYCALL
-  if (PyFunction_Check(__pyx_t_2)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_chunk_iterator1, __pyx_v_chunk_iterator2};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_GOTREF(__pyx_t_1);
-  } else
-  #endif
-  #if CYTHON_FAST_PYCCALL
-  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_chunk_iterator1, __pyx_v_chunk_iterator2};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_GOTREF(__pyx_t_1);
-  } else
-  #endif
-  {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 634, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    if (__pyx_t_3) {
-      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
-    }
-    __Pyx_INCREF(__pyx_v_chunk_iterator1);
-    __Pyx_GIVEREF(__pyx_v_chunk_iterator1);
-    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_chunk_iterator1);
-    __Pyx_INCREF(__pyx_v_chunk_iterator2);
-    __Pyx_GIVEREF(__pyx_v_chunk_iterator2);
-    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_chunk_iterator2);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_equal_2, __pyx_t_1) < 0) __PYX_ERR(0, 634, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_chunk_1_2, __pyx_v_chunk_1) < 0) __PYX_ERR(0, 651, __pyx_L1_error)
 
-  /* "borg/item.pyx":635
+  /* "borg/item.pyx":652
  *         self._can_compare_chunk_ids = can_compare_chunk_ids
- *         self.equal = self._equal(chunk_iterator1, chunk_iterator2)
- *         changes = []             # <<<<<<<<<<<<<<
+ *         self._chunk_1 = chunk_1
+ *         self._chunk_2 = chunk_2             # <<<<<<<<<<<<<<
+ * 
+ *         self._changes = {}
+ */
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_chunk_2_2, __pyx_v_chunk_2) < 0) __PYX_ERR(0, 652, __pyx_L1_error)
+
+  /* "borg/item.pyx":654
+ *         self._chunk_2 = chunk_2
+ * 
+ *         self._changes = {}             # <<<<<<<<<<<<<<
  * 
  *         if self._item1.is_link() or self._item2.is_link():
  */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 635, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 654, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_changes = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_changes, __pyx_t_1) < 0) __PYX_ERR(0, 654, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":637
- *         changes = []
+  /* "borg/item.pyx":656
+ *         self._changes = {}
  * 
  *         if self._item1.is_link() or self._item2.is_link():             # <<<<<<<<<<<<<<
- *             changes.append(self._link_diff())
+ *             self._link_diff()
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_is_link); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 637, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 656, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_is_link); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 656, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_5, function);
+      __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 656, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 637, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 656, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (!__pyx_t_7) {
+  if (!__pyx_t_5) {
   } else {
-    __pyx_t_6 = __pyx_t_7;
+    __pyx_t_2 = __pyx_t_5;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 637, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_is_link); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 637, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_5);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 656, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_is_link); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 656, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 656, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 637, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 656, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __pyx_t_7;
+  __pyx_t_2 = __pyx_t_5;
   __pyx_L4_bool_binop_done:;
-  if (__pyx_t_6) {
+  if (__pyx_t_2) {
 
-    /* "borg/item.pyx":638
+    /* "borg/item.pyx":657
  * 
  *         if self._item1.is_link() or self._item2.is_link():
- *             changes.append(self._link_diff())             # <<<<<<<<<<<<<<
+ *             self._link_diff()             # <<<<<<<<<<<<<<
  * 
  *         if 'chunks' in self._item1 and 'chunks' in self._item2:
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_link_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 638, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_link_diff); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 657, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 657, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_changes, __pyx_t_1); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 638, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":637
- *         changes = []
+    /* "borg/item.pyx":656
+ *         self._changes = {}
  * 
  *         if self._item1.is_link() or self._item2.is_link():             # <<<<<<<<<<<<<<
- *             changes.append(self._link_diff())
+ *             self._link_diff()
  * 
  */
   }
 
-  /* "borg/item.pyx":640
- *             changes.append(self._link_diff())
+  /* "borg/item.pyx":659
+ *             self._link_diff()
  * 
  *         if 'chunks' in self._item1 and 'chunks' in self._item2:             # <<<<<<<<<<<<<<
- *             changes.append(self._content_diff())
+ *             self._content_diff()
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 640, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 659, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_chunks, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 640, __pyx_L1_error)
+  __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_chunks, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 659, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_9 = (__pyx_t_7 != 0);
-  if (__pyx_t_9) {
+  __pyx_t_6 = (__pyx_t_5 != 0);
+  if (__pyx_t_6) {
   } else {
-    __pyx_t_6 = __pyx_t_9;
+    __pyx_t_2 = __pyx_t_6;
     goto __pyx_L7_bool_binop_done;
   }
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 640, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 659, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_9 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_chunks, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 640, __pyx_L1_error)
+  __pyx_t_6 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_chunks, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 659, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_7 = (__pyx_t_9 != 0);
-  __pyx_t_6 = __pyx_t_7;
+  __pyx_t_5 = (__pyx_t_6 != 0);
+  __pyx_t_2 = __pyx_t_5;
   __pyx_L7_bool_binop_done:;
-  if (__pyx_t_6) {
+  if (__pyx_t_2) {
 
-    /* "borg/item.pyx":641
+    /* "borg/item.pyx":660
  * 
  *         if 'chunks' in self._item1 and 'chunks' in self._item2:
- *             changes.append(self._content_diff())             # <<<<<<<<<<<<<<
+ *             self._content_diff()             # <<<<<<<<<<<<<<
  * 
  *         if self._item1.is_dir() or self._item2.is_dir():
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_content_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 641, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_content_diff); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 660, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 641, __pyx_L1_error)
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_changes, __pyx_t_1); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 641, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":640
- *             changes.append(self._link_diff())
+    /* "borg/item.pyx":659
+ *             self._link_diff()
  * 
  *         if 'chunks' in self._item1 and 'chunks' in self._item2:             # <<<<<<<<<<<<<<
- *             changes.append(self._content_diff())
+ *             self._content_diff()
  * 
  */
   }
 
-  /* "borg/item.pyx":643
- *             changes.append(self._content_diff())
+  /* "borg/item.pyx":662
+ *             self._content_diff()
  * 
  *         if self._item1.is_dir() or self._item2.is_dir():             # <<<<<<<<<<<<<<
- *             changes.append(self._presence_diff('directory'))
+ *             self._presence_diff('directory')
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 643, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_is_dir); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 643, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 662, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_is_dir); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 662, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_5, function);
+      __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 643, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 662, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 643, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 662, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (!__pyx_t_7) {
+  if (!__pyx_t_5) {
   } else {
-    __pyx_t_6 = __pyx_t_7;
+    __pyx_t_2 = __pyx_t_5;
     goto __pyx_L10_bool_binop_done;
   }
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 643, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_is_dir); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 643, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_5);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 662, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_is_dir); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 662, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 643, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 662, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 643, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 662, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __pyx_t_7;
+  __pyx_t_2 = __pyx_t_5;
   __pyx_L10_bool_binop_done:;
-  if (__pyx_t_6) {
+  if (__pyx_t_2) {
 
-    /* "borg/item.pyx":644
+    /* "borg/item.pyx":663
  * 
  *         if self._item1.is_dir() or self._item2.is_dir():
- *             changes.append(self._presence_diff('directory'))             # <<<<<<<<<<<<<<
+ *             self._presence_diff('directory')             # <<<<<<<<<<<<<<
  * 
  *         if self._item1.is_blk() or self._item2.is_blk():
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 644, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 663, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_n_s_directory) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_n_s_directory);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 644, __pyx_L1_error)
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_n_s_directory) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_directory);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 663, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_changes, __pyx_t_1); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 644, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":643
- *             changes.append(self._content_diff())
+    /* "borg/item.pyx":662
+ *             self._content_diff()
  * 
  *         if self._item1.is_dir() or self._item2.is_dir():             # <<<<<<<<<<<<<<
- *             changes.append(self._presence_diff('directory'))
+ *             self._presence_diff('directory')
  * 
  */
   }
 
-  /* "borg/item.pyx":646
- *             changes.append(self._presence_diff('directory'))
+  /* "borg/item.pyx":665
+ *             self._presence_diff('directory')
  * 
  *         if self._item1.is_blk() or self._item2.is_blk():             # <<<<<<<<<<<<<<
- *             changes.append(self._presence_diff('blkdev'))
+ *             self._presence_diff('blkdev')
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 646, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_is_blk); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 646, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 665, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_is_blk); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 665, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_5, function);
+      __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 646, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 665, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 646, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 665, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (!__pyx_t_7) {
+  if (!__pyx_t_5) {
   } else {
-    __pyx_t_6 = __pyx_t_7;
+    __pyx_t_2 = __pyx_t_5;
     goto __pyx_L13_bool_binop_done;
   }
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 646, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_is_blk); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 646, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_5);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 665, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_is_blk); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 665, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 646, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 665, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 646, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 665, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __pyx_t_7;
+  __pyx_t_2 = __pyx_t_5;
   __pyx_L13_bool_binop_done:;
-  if (__pyx_t_6) {
+  if (__pyx_t_2) {
 
-    /* "borg/item.pyx":647
+    /* "borg/item.pyx":666
  * 
  *         if self._item1.is_blk() or self._item2.is_blk():
- *             changes.append(self._presence_diff('blkdev'))             # <<<<<<<<<<<<<<
+ *             self._presence_diff('blkdev')             # <<<<<<<<<<<<<<
  * 
  *         if self._item1.is_chr() or self._item2.is_chr():
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 647, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 666, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_n_s_blkdev) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_n_s_blkdev);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 647, __pyx_L1_error)
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_n_s_blkdev) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_blkdev);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 666, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_changes, __pyx_t_1); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 647, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":646
- *             changes.append(self._presence_diff('directory'))
+    /* "borg/item.pyx":665
+ *             self._presence_diff('directory')
  * 
  *         if self._item1.is_blk() or self._item2.is_blk():             # <<<<<<<<<<<<<<
- *             changes.append(self._presence_diff('blkdev'))
+ *             self._presence_diff('blkdev')
  * 
  */
   }
 
-  /* "borg/item.pyx":649
- *             changes.append(self._presence_diff('blkdev'))
+  /* "borg/item.pyx":668
+ *             self._presence_diff('blkdev')
  * 
  *         if self._item1.is_chr() or self._item2.is_chr():             # <<<<<<<<<<<<<<
- *             changes.append(self._presence_diff('chrdev'))
+ *             self._presence_diff('chrdev')
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 649, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_is_chr); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 649, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 668, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_is_chr); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 668, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_5, function);
+      __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 649, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 668, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 649, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 668, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (!__pyx_t_7) {
+  if (!__pyx_t_5) {
   } else {
-    __pyx_t_6 = __pyx_t_7;
+    __pyx_t_2 = __pyx_t_5;
     goto __pyx_L16_bool_binop_done;
   }
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 649, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_is_chr); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 649, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_5);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 668, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_is_chr); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 668, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 649, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 668, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 649, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 668, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __pyx_t_7;
+  __pyx_t_2 = __pyx_t_5;
   __pyx_L16_bool_binop_done:;
-  if (__pyx_t_6) {
+  if (__pyx_t_2) {
 
-    /* "borg/item.pyx":650
+    /* "borg/item.pyx":669
  * 
  *         if self._item1.is_chr() or self._item2.is_chr():
- *             changes.append(self._presence_diff('chrdev'))             # <<<<<<<<<<<<<<
+ *             self._presence_diff('chrdev')             # <<<<<<<<<<<<<<
  * 
  *         if self._item1.is_fifo() or self._item2.is_fifo():
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 650, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 669, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_n_s_chrdev) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_n_s_chrdev);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 650, __pyx_L1_error)
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_n_s_chrdev) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_chrdev);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 669, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_changes, __pyx_t_1); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 650, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":649
- *             changes.append(self._presence_diff('blkdev'))
+    /* "borg/item.pyx":668
+ *             self._presence_diff('blkdev')
  * 
  *         if self._item1.is_chr() or self._item2.is_chr():             # <<<<<<<<<<<<<<
- *             changes.append(self._presence_diff('chrdev'))
+ *             self._presence_diff('chrdev')
  * 
  */
   }
 
-  /* "borg/item.pyx":652
- *             changes.append(self._presence_diff('chrdev'))
+  /* "borg/item.pyx":671
+ *             self._presence_diff('chrdev')
  * 
  *         if self._item1.is_fifo() or self._item2.is_fifo():             # <<<<<<<<<<<<<<
- *             changes.append(self._presence_diff('fifo'))
+ *             self._presence_diff('fifo')
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 652, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_is_fifo); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 652, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 671, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_is_fifo); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 671, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_5, function);
+      __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 652, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 671, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 652, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 671, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (!__pyx_t_7) {
+  if (!__pyx_t_5) {
   } else {
-    __pyx_t_6 = __pyx_t_7;
+    __pyx_t_2 = __pyx_t_5;
     goto __pyx_L19_bool_binop_done;
   }
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 652, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_is_fifo); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 652, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_5);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 671, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_is_fifo); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 671, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 652, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 671, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 652, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 671, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __pyx_t_7;
+  __pyx_t_2 = __pyx_t_5;
   __pyx_L19_bool_binop_done:;
-  if (__pyx_t_6) {
+  if (__pyx_t_2) {
 
-    /* "borg/item.pyx":653
+    /* "borg/item.pyx":672
  * 
  *         if self._item1.is_fifo() or self._item2.is_fifo():
- *             changes.append(self._presence_diff('fifo'))             # <<<<<<<<<<<<<<
+ *             self._presence_diff('fifo')             # <<<<<<<<<<<<<<
  * 
  *         if not (self._item1.get('deleted') or self._item2.get('deleted')):
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 653, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 672, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_n_s_fifo) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_n_s_fifo);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 653, __pyx_L1_error)
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_n_s_fifo) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_fifo);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 672, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_changes, __pyx_t_1); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 653, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":652
- *             changes.append(self._presence_diff('chrdev'))
+    /* "borg/item.pyx":671
+ *             self._presence_diff('chrdev')
  * 
  *         if self._item1.is_fifo() or self._item2.is_fifo():             # <<<<<<<<<<<<<<
- *             changes.append(self._presence_diff('fifo'))
+ *             self._presence_diff('fifo')
  * 
  */
   }
 
-  /* "borg/item.pyx":655
- *             changes.append(self._presence_diff('fifo'))
+  /* "borg/item.pyx":674
+ *             self._presence_diff('fifo')
  * 
  *         if not (self._item1.get('deleted') or self._item2.get('deleted')):             # <<<<<<<<<<<<<<
- *             changes.append(self._owner_diff())
- *             changes.append(self._mode_diff())
+ *             self._owner_diff()
+ *             self._mode_diff()
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 655, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 655, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 674, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 674, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_5, function);
+      __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_2, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_n_s_deleted);
-  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 655, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_n_s_deleted);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 674, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 655, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 674, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (!__pyx_t_7) {
+  if (!__pyx_t_5) {
   } else {
-    __pyx_t_6 = __pyx_t_7;
+    __pyx_t_2 = __pyx_t_5;
     goto __pyx_L22_bool_binop_done;
   }
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 655, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 655, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_5);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 674, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 674, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
-  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_n_s_deleted);
-  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 655, __pyx_L1_error)
+  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_deleted);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 674, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 655, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 674, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __pyx_t_7;
+  __pyx_t_2 = __pyx_t_5;
   __pyx_L22_bool_binop_done:;
-  __pyx_t_7 = ((!__pyx_t_6) != 0);
-  if (__pyx_t_7) {
+  __pyx_t_5 = ((!__pyx_t_2) != 0);
+  if (__pyx_t_5) {
 
-    /* "borg/item.pyx":656
+    /* "borg/item.pyx":675
  * 
  *         if not (self._item1.get('deleted') or self._item2.get('deleted')):
- *             changes.append(self._owner_diff())             # <<<<<<<<<<<<<<
- *             changes.append(self._mode_diff())
- * 
+ *             self._owner_diff()             # <<<<<<<<<<<<<<
+ *             self._mode_diff()
+ *             self._time_diffs()
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_owner_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 656, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_owner_diff); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 675, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 656, __pyx_L1_error)
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 675, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_changes, __pyx_t_1); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 656, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":657
+    /* "borg/item.pyx":676
  *         if not (self._item1.get('deleted') or self._item2.get('deleted')):
- *             changes.append(self._owner_diff())
- *             changes.append(self._mode_diff())             # <<<<<<<<<<<<<<
+ *             self._owner_diff()
+ *             self._mode_diff()             # <<<<<<<<<<<<<<
+ *             self._time_diffs()
  * 
- *         # filter out empty changes
  */
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_mode_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 657, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_5 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_5);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_mode_diff); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 676, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
-    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 657, __pyx_L1_error)
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 676, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_changes, __pyx_t_1); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 657, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":655
- *             changes.append(self._presence_diff('fifo'))
- * 
- *         if not (self._item1.get('deleted') or self._item2.get('deleted')):             # <<<<<<<<<<<<<<
- *             changes.append(self._owner_diff())
- *             changes.append(self._mode_diff())
- */
-  }
-
-  /* "borg/item.pyx":660
+    /* "borg/item.pyx":677
+ *             self._owner_diff()
+ *             self._mode_diff()
+ *             self._time_diffs()             # <<<<<<<<<<<<<<
  * 
- *         # filter out empty changes
- *         self._changes = [ch for ch in changes if ch]             # <<<<<<<<<<<<<<
  * 
- *     def changes(self):
  */
-  { /* enter inner scope */
-    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L26_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = __pyx_v_changes; __Pyx_INCREF(__pyx_t_2); __pyx_t_10 = 0;
-    for (;;) {
-      if (__pyx_t_10 >= PyList_GET_SIZE(__pyx_t_2)) break;
-      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-      __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_10); __Pyx_INCREF(__pyx_t_5); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 660, __pyx_L26_error)
-      #else
-      __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 660, __pyx_L26_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      #endif
-      __Pyx_XDECREF_SET(__pyx_8genexpr7__pyx_v_ch, __pyx_t_5);
-      __pyx_t_5 = 0;
-      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_8genexpr7__pyx_v_ch); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 660, __pyx_L26_error)
-      if (__pyx_t_7) {
-        if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_8genexpr7__pyx_v_ch))) __PYX_ERR(0, 660, __pyx_L26_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_time_diffs); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 677, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_ch); __pyx_8genexpr7__pyx_v_ch = 0;
-    goto __pyx_L30_exit_scope;
-    __pyx_L26_error:;
-    __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_ch); __pyx_8genexpr7__pyx_v_ch = 0;
-    goto __pyx_L1_error;
-    __pyx_L30_exit_scope:;
-  } /* exit inner scope */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_changes, __pyx_t_1) < 0) __PYX_ERR(0, 660, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 677, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":629
+    /* "borg/item.pyx":674
+ *             self._presence_diff('fifo')
+ * 
+ *         if not (self._item1.get('deleted') or self._item2.get('deleted')):             # <<<<<<<<<<<<<<
+ *             self._owner_diff()
+ *             self._mode_diff()
+ */
+  }
+
+  /* "borg/item.pyx":645
  *     """
  * 
- *     def __init__(self, item1, item2, chunk_iterator1, chunk_iterator2, numeric_ids=False, can_compare_chunk_ids=False):             # <<<<<<<<<<<<<<
+ *     def __init__(self, path, item1, item2, chunk_1, chunk_2, numeric_ids=False, can_compare_chunk_ids=False):             # <<<<<<<<<<<<<<
+ *         self.path = path
  *         self._item1 = item1
- *         self._item2 = item2
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("borg.item.ItemDiff.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_changes);
-  __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_ch);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":662
- *         self._changes = [ch for ch in changes if ch]
+/* "borg/item.pyx":680
+ * 
  * 
  *     def changes(self):             # <<<<<<<<<<<<<<
  *         return self._changes
  * 
  */
 
 /* Python wrapper */
@@ -16020,30 +16278,30 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("changes", 0);
 
-  /* "borg/item.pyx":663
+  /* "borg/item.pyx":681
  * 
  *     def changes(self):
  *         return self._changes             # <<<<<<<<<<<<<<
  * 
  *     def __repr__(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 681, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":662
- *         self._changes = [ch for ch in changes if ch]
+  /* "borg/item.pyx":680
+ * 
  * 
  *     def changes(self):             # <<<<<<<<<<<<<<
  *         return self._changes
  * 
  */
 
   /* function exit code */
@@ -16053,20 +16311,20 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":665
+/* "borg/item.pyx":683
  *         return self._changes
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
- *         if self.equal:
- *             return 'equal'
+ *         return (' '.join(self._changes.keys())) or 'equal'
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_4borg_4item_8ItemDiff_5__repr__(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
 static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_5__repr__ = {"__repr__", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_5__repr__, METH_O, 0};
 static PyObject *__pyx_pw_4borg_4item_8ItemDiff_5__repr__(PyObject *__pyx_self, PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
@@ -16074,969 +16332,737 @@
   __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
   __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_4__repr__(__pyx_self, ((PyObject *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
-static PyObject *__pyx_gb_4borg_4item_8ItemDiff_8__repr___2generator5(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
-
-/* "borg/item.pyx":668
- *         if self.equal:
- *             return 'equal'
- *         return ' '.join(str for d, str in self._changes)             # <<<<<<<<<<<<<<
- * 
- *     def _equal(self, chunk_iterator1, chunk_iterator2):
- */
-
-static PyObject *__pyx_pf_4borg_4item_8ItemDiff_8__repr___genexpr(PyObject *__pyx_self) {
-  struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *__pyx_cur_scope;
-  PyObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("genexpr", 0);
-  __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *)__pyx_tp_new_4borg_4item___pyx_scope_struct_9_genexpr(__pyx_ptype_4borg_4item___pyx_scope_struct_9_genexpr, __pyx_empty_tuple, NULL);
-  if (unlikely(!__pyx_cur_scope)) {
-    __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *)Py_None);
-    __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 668, __pyx_L1_error)
-  } else {
-    __Pyx_GOTREF(__pyx_cur_scope);
-  }
-  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *) __pyx_self;
-  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
-  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
-  {
-    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_4borg_4item_8ItemDiff_8__repr___2generator5, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_ItemDiff___repr___locals_genexpr, __pyx_n_s_borg_item); if (unlikely(!gen)) __PYX_ERR(0, 668, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_cur_scope);
-    __Pyx_RefNannyFinishContext();
-    return (PyObject *) gen;
-  }
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_AddTraceback("borg.item.ItemDiff.__repr__.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
-  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static PyObject *__pyx_gb_4borg_4item_8ItemDiff_8__repr___2generator5(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
-{
-  struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *__pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *)__pyx_generator->closure);
-  PyObject *__pyx_r = NULL;
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  Py_ssize_t __pyx_t_3;
-  PyObject *(*__pyx_t_4)(PyObject *);
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *(*__pyx_t_8)(PyObject *);
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("genexpr", 0);
-  switch (__pyx_generator->resume_label) {
-    case 0: goto __pyx_L3_first_run;
-    case 1: goto __pyx_L8_resume_from_yield;
-    default: /* CPython raises the right error here */
-    __Pyx_RefNannyFinishContext();
-    return NULL;
-  }
-  __pyx_L3_first_run:;
-  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 668, __pyx_L1_error)
-  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_self)) { __Pyx_RaiseClosureNameError("self"); __PYX_ERR(0, 668, __pyx_L1_error) }
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 668, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
-    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
-    __pyx_t_4 = NULL;
-  } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 668, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 668, __pyx_L1_error)
-  }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  for (;;) {
-    if (likely(!__pyx_t_4)) {
-      if (likely(PyList_CheckExact(__pyx_t_2))) {
-        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 668, __pyx_L1_error)
-        #else
-        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 668, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        #endif
-      } else {
-        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 668, __pyx_L1_error)
-        #else
-        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 668, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        #endif
-      }
-    } else {
-      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
-      if (unlikely(!__pyx_t_1)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 668, __pyx_L1_error)
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_1);
-    }
-    if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
-      PyObject* sequence = __pyx_t_1;
-      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
-      if (unlikely(size != 2)) {
-        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 668, __pyx_L1_error)
-      }
-      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-      if (likely(PyTuple_CheckExact(sequence))) {
-        __pyx_t_5 = PyTuple_GET_ITEM(sequence, 0); 
-        __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
-      } else {
-        __pyx_t_5 = PyList_GET_ITEM(sequence, 0); 
-        __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
-      }
-      __Pyx_INCREF(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_6);
-      #else
-      __pyx_t_5 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 668, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 668, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      #endif
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    } else {
-      Py_ssize_t index = -1;
-      __pyx_t_7 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 668, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_8 = Py_TYPE(__pyx_t_7)->tp_iternext;
-      index = 0; __pyx_t_5 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_5)) goto __pyx_L6_unpacking_failed;
-      __Pyx_GOTREF(__pyx_t_5);
-      index = 1; __pyx_t_6 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_6)) goto __pyx_L6_unpacking_failed;
-      __Pyx_GOTREF(__pyx_t_6);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_8(__pyx_t_7), 2) < 0) __PYX_ERR(0, 668, __pyx_L1_error)
-      __pyx_t_8 = NULL;
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      goto __pyx_L7_unpacking_done;
-      __pyx_L6_unpacking_failed:;
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __pyx_t_8 = NULL;
-      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 668, __pyx_L1_error)
-      __pyx_L7_unpacking_done:;
-    }
-    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_d);
-    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_d, __pyx_t_5);
-    __Pyx_GIVEREF(__pyx_t_5);
-    __pyx_t_5 = 0;
-    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_str);
-    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_str, __pyx_t_6);
-    __Pyx_GIVEREF(__pyx_t_6);
-    __pyx_t_6 = 0;
-    __Pyx_INCREF(__pyx_cur_scope->__pyx_v_str);
-    __pyx_r = __pyx_cur_scope->__pyx_v_str;
-    __Pyx_XGIVEREF(__pyx_t_2);
-    __pyx_cur_scope->__pyx_t_0 = __pyx_t_2;
-    __pyx_cur_scope->__pyx_t_1 = __pyx_t_3;
-    __pyx_cur_scope->__pyx_t_2 = __pyx_t_4;
-    __Pyx_XGIVEREF(__pyx_r);
-    __Pyx_RefNannyFinishContext();
-    __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
-    /* return from generator, yielding value */
-    __pyx_generator->resume_label = 1;
-    return __pyx_r;
-    __pyx_L8_resume_from_yield:;
-    __pyx_t_2 = __pyx_cur_scope->__pyx_t_0;
-    __pyx_cur_scope->__pyx_t_0 = 0;
-    __Pyx_XGOTREF(__pyx_t_2);
-    __pyx_t_3 = __pyx_cur_scope->__pyx_t_1;
-    __pyx_t_4 = __pyx_cur_scope->__pyx_t_2;
-    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 668, __pyx_L1_error)
-  }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);
-
-  /* function exit code */
-  PyErr_SetNone(PyExc_StopIteration);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_L0:;
-  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
-  #if !CYTHON_USE_EXC_INFO_STACK
-  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
-  #endif
-  __pyx_generator->resume_label = -1;
-  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "borg/item.pyx":665
- *         return self._changes
- * 
- *     def __repr__(self):             # <<<<<<<<<<<<<<
- *         if self.equal:
- *             return 'equal'
- */
 
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_4__repr__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
-  struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *__pyx_cur_scope;
-  PyObject *__pyx_gb_4borg_4item_8ItemDiff_8__repr___2generator5 = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
+  PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__repr__", 0);
-  __pyx_cur_scope = (struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *)__pyx_tp_new_4borg_4item___pyx_scope_struct_8___repr__(__pyx_ptype_4borg_4item___pyx_scope_struct_8___repr__, __pyx_empty_tuple, NULL);
-  if (unlikely(!__pyx_cur_scope)) {
-    __pyx_cur_scope = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *)Py_None);
-    __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 665, __pyx_L1_error)
-  } else {
-    __Pyx_GOTREF(__pyx_cur_scope);
-  }
-  __pyx_cur_scope->__pyx_v_self = __pyx_v_self;
-  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_self);
-  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_self);
 
-  /* "borg/item.pyx":666
+  /* "borg/item.pyx":684
  * 
  *     def __repr__(self):
- *         if self.equal:             # <<<<<<<<<<<<<<
- *             return 'equal'
- *         return ' '.join(str for d, str in self._changes)
- */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_self, __pyx_n_s_equal_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 666, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 666, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (__pyx_t_2) {
-
-    /* "borg/item.pyx":667
- *     def __repr__(self):
- *         if self.equal:
- *             return 'equal'             # <<<<<<<<<<<<<<
- *         return ' '.join(str for d, str in self._changes)
- * 
- */
-    __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF(__pyx_n_s_equal_2);
-    __pyx_r = __pyx_n_s_equal_2;
-    goto __pyx_L0;
-
-    /* "borg/item.pyx":666
+ *         return (' '.join(self._changes.keys())) or 'equal'             # <<<<<<<<<<<<<<
  * 
- *     def __repr__(self):
- *         if self.equal:             # <<<<<<<<<<<<<<
- *             return 'equal'
- *         return ' '.join(str for d, str in self._changes)
- */
-  }
-
-  /* "borg/item.pyx":668
- *         if self.equal:
- *             return 'equal'
- *         return ' '.join(str for d, str in self._changes)             # <<<<<<<<<<<<<<
- * 
- *     def _equal(self, chunk_iterator1, chunk_iterator2):
+ *     def equal(self, content_only=False):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_pf_4borg_4item_8ItemDiff_8__repr___genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 668, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyString_Join(__pyx_kp_s__20, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 668, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 684, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_r = __pyx_t_3;
-  __pyx_t_3 = 0;
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_keys); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 684, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+      __Pyx_INCREF(__pyx_t_3);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_4, function);
+    }
+  }
+  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 684, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = __Pyx_PyString_Join(__pyx_kp_s__20, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 684, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 684, __pyx_L1_error)
+  if (!__pyx_t_5) {
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  } else {
+    __Pyx_INCREF(__pyx_t_4);
+    __pyx_t_1 = __pyx_t_4;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    goto __pyx_L3_bool_binop_done;
+  }
+  __Pyx_INCREF(__pyx_n_s_equal);
+  __pyx_t_1 = __pyx_n_s_equal;
+  __pyx_L3_bool_binop_done:;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":665
+  /* "borg/item.pyx":683
  *         return self._changes
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
- *         if self.equal:
- *             return 'equal'
+ *         return (' '.join(self._changes.keys())) or 'equal'
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("borg.item.ItemDiff.__repr__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_gb_4borg_4item_8ItemDiff_8__repr___2generator5);
-  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":670
- *         return ' '.join(str for d, str in self._changes)
+/* "borg/item.pyx":686
+ *         return (' '.join(self._changes.keys())) or 'equal'
  * 
- *     def _equal(self, chunk_iterator1, chunk_iterator2):             # <<<<<<<<<<<<<<
+ *     def equal(self, content_only=False):             # <<<<<<<<<<<<<<
  *         # if both are deleted, there is nothing at path regardless of what was deleted
  *         if self._item1.get('deleted') and self._item2.get('deleted'):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4borg_4item_8ItemDiff_7_equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_7_equal = {"_equal", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_4item_8ItemDiff_7_equal, METH_VARARGS|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_4borg_4item_8ItemDiff_7_equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_7equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_7equal = {"equal", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_4item_8ItemDiff_7equal, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_7equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_self = 0;
-  PyObject *__pyx_v_chunk_iterator1 = 0;
-  PyObject *__pyx_v_chunk_iterator2 = 0;
+  PyObject *__pyx_v_content_only = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("_equal (wrapper)", 0);
+  __Pyx_RefNannySetupContext("equal (wrapper)", 0);
   {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_chunk_iterator1,&__pyx_n_s_chunk_iterator2,0};
-    PyObject* values[3] = {0,0,0};
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_content_only,0};
+    PyObject* values[2] = {0,0};
+    values[1] = ((PyObject *)((PyObject *)Py_False));
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
       const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
       switch (pos_args) {
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunk_iterator1)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("_equal", 1, 3, 3, 1); __PYX_ERR(0, 670, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunk_iterator2)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("_equal", 1, 3, 3, 2); __PYX_ERR(0, 670, __pyx_L3_error)
+        if (kw_args > 0) {
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_content_only);
+          if (value) { values[1] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_equal") < 0)) __PYX_ERR(0, 670, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "equal") < 0)) __PYX_ERR(0, 686, __pyx_L3_error)
       }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
-      goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      switch (PyTuple_GET_SIZE(__pyx_args)) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
     }
     __pyx_v_self = values[0];
-    __pyx_v_chunk_iterator1 = values[1];
-    __pyx_v_chunk_iterator2 = values[2];
+    __pyx_v_content_only = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_equal", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 670, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("equal", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 686, __pyx_L3_error)
   __pyx_L3_error:;
-  __Pyx_AddTraceback("borg.item.ItemDiff._equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("borg.item.ItemDiff.equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_6_equal(__pyx_self, __pyx_v_self, __pyx_v_chunk_iterator1, __pyx_v_chunk_iterator2);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_6equal(__pyx_self, __pyx_v_self, __pyx_v_content_only);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4borg_4item_8ItemDiff_6_equal(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_chunk_iterator1, PyObject *__pyx_v_chunk_iterator2) {
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_6equal(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_content_only) {
   PyObject *__pyx_v_attr_list = NULL;
   PyObject *__pyx_v_attr = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
   Py_ssize_t __pyx_t_6;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_t_9;
-  int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("_equal", 0);
+  __Pyx_RefNannySetupContext("equal", 0);
 
-  /* "borg/item.pyx":672
- *     def _equal(self, chunk_iterator1, chunk_iterator2):
+  /* "borg/item.pyx":688
+ *     def equal(self, content_only=False):
  *         # if both are deleted, there is nothing at path regardless of what was deleted
  *         if self._item1.get('deleted') and self._item2.get('deleted'):             # <<<<<<<<<<<<<<
  *             return True
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 672, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 688, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 672, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 688, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_n_s_deleted);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 672, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 688, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 672, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 688, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (__pyx_t_5) {
   } else {
     __pyx_t_1 = __pyx_t_5;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 672, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 688, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 672, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 688, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_deleted);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 672, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 688, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 672, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 688, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_1 = __pyx_t_5;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "borg/item.pyx":673
+    /* "borg/item.pyx":689
  *         # if both are deleted, there is nothing at path regardless of what was deleted
  *         if self._item1.get('deleted') and self._item2.get('deleted'):
  *             return True             # <<<<<<<<<<<<<<
  * 
- *         attr_list = ['deleted', 'mode', 'target']
+ *         attr_list = ['deleted', 'target']
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(Py_True);
     __pyx_r = Py_True;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":672
- *     def _equal(self, chunk_iterator1, chunk_iterator2):
+    /* "borg/item.pyx":688
+ *     def equal(self, content_only=False):
  *         # if both are deleted, there is nothing at path regardless of what was deleted
  *         if self._item1.get('deleted') and self._item2.get('deleted'):             # <<<<<<<<<<<<<<
  *             return True
  * 
  */
   }
 
-  /* "borg/item.pyx":675
+  /* "borg/item.pyx":691
  *             return True
  * 
- *         attr_list = ['deleted', 'mode', 'target']             # <<<<<<<<<<<<<<
- *         attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
- *         for attr in attr_list:
+ *         attr_list = ['deleted', 'target']             # <<<<<<<<<<<<<<
+ *         if not content_only:
+ *             attr_list += ['mode', 'ctime', 'mtime']
  */
-  __pyx_t_2 = PyList_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 675, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 691, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_deleted);
   __Pyx_GIVEREF(__pyx_n_s_deleted);
   PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_deleted);
-  __Pyx_INCREF(__pyx_n_s_mode);
-  __Pyx_GIVEREF(__pyx_n_s_mode);
-  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_mode);
   __Pyx_INCREF(__pyx_n_s_target);
   __Pyx_GIVEREF(__pyx_n_s_target);
-  PyList_SET_ITEM(__pyx_t_2, 2, __pyx_n_s_target);
+  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_target);
   __pyx_v_attr_list = ((PyObject*)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":676
+  /* "borg/item.pyx":692
  * 
- *         attr_list = ['deleted', 'mode', 'target']
- *         attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']             # <<<<<<<<<<<<<<
- *         for attr in attr_list:
- *             if self._item1.get(attr) != self._item2.get(attr):
+ *         attr_list = ['deleted', 'target']
+ *         if not content_only:             # <<<<<<<<<<<<<<
+ *             attr_list += ['mode', 'ctime', 'mtime']
+ *             attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_numeric_ids_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 676, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 676, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (__pyx_t_1) {
-    __pyx_t_3 = PyList_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 676, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_INCREF(__pyx_n_s_uid);
-    __Pyx_GIVEREF(__pyx_n_s_uid);
-    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_uid);
-    __Pyx_INCREF(__pyx_n_s_gid);
-    __Pyx_GIVEREF(__pyx_n_s_gid);
-    PyList_SET_ITEM(__pyx_t_3, 1, __pyx_n_s_gid);
-    __pyx_t_2 = __pyx_t_3;
-    __pyx_t_3 = 0;
-  } else {
-    __pyx_t_3 = PyList_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 676, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_content_only); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 692, __pyx_L1_error)
+  __pyx_t_5 = ((!__pyx_t_1) != 0);
+  if (__pyx_t_5) {
+
+    /* "borg/item.pyx":693
+ *         attr_list = ['deleted', 'target']
+ *         if not content_only:
+ *             attr_list += ['mode', 'ctime', 'mtime']             # <<<<<<<<<<<<<<
+ *             attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+ * 
+ */
+    __pyx_t_2 = PyList_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 693, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_INCREF(__pyx_n_s_mode);
+    __Pyx_GIVEREF(__pyx_n_s_mode);
+    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_mode);
+    __Pyx_INCREF(__pyx_n_s_ctime);
+    __Pyx_GIVEREF(__pyx_n_s_ctime);
+    PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_ctime);
+    __Pyx_INCREF(__pyx_n_s_mtime);
+    __Pyx_GIVEREF(__pyx_n_s_mtime);
+    PyList_SET_ITEM(__pyx_t_2, 2, __pyx_n_s_mtime);
+    __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_attr_list, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 693, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_INCREF(__pyx_n_s_user);
-    __Pyx_GIVEREF(__pyx_n_s_user);
-    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_user);
-    __Pyx_INCREF(__pyx_n_s_group);
-    __Pyx_GIVEREF(__pyx_n_s_group);
-    PyList_SET_ITEM(__pyx_t_3, 1, __pyx_n_s_group);
-    __pyx_t_2 = __pyx_t_3;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF_SET(__pyx_v_attr_list, ((PyObject*)__pyx_t_3));
     __pyx_t_3 = 0;
+
+    /* "borg/item.pyx":694
+ *         if not content_only:
+ *             attr_list += ['mode', 'ctime', 'mtime']
+ *             attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']             # <<<<<<<<<<<<<<
+ * 
+ *         for attr in attr_list:
+ */
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_numeric_ids_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 694, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 694, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (__pyx_t_5) {
+      __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 694, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_INCREF(__pyx_n_s_uid);
+      __Pyx_GIVEREF(__pyx_n_s_uid);
+      PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_uid);
+      __Pyx_INCREF(__pyx_n_s_gid);
+      __Pyx_GIVEREF(__pyx_n_s_gid);
+      PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_gid);
+      __pyx_t_3 = __pyx_t_2;
+      __pyx_t_2 = 0;
+    } else {
+      __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 694, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_INCREF(__pyx_n_s_user);
+      __Pyx_GIVEREF(__pyx_n_s_user);
+      PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_user);
+      __Pyx_INCREF(__pyx_n_s_group);
+      __Pyx_GIVEREF(__pyx_n_s_group);
+      PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_group);
+      __pyx_t_3 = __pyx_t_2;
+      __pyx_t_2 = 0;
+    }
+    __pyx_t_2 = PyNumber_InPlaceAdd(__pyx_v_attr_list, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 694, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF_SET(__pyx_v_attr_list, ((PyObject*)__pyx_t_2));
+    __pyx_t_2 = 0;
+
+    /* "borg/item.pyx":692
+ * 
+ *         attr_list = ['deleted', 'target']
+ *         if not content_only:             # <<<<<<<<<<<<<<
+ *             attr_list += ['mode', 'ctime', 'mtime']
+ *             attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+ */
   }
-  __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_attr_list, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 676, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF_SET(__pyx_v_attr_list, ((PyObject*)__pyx_t_3));
-  __pyx_t_3 = 0;
 
-  /* "borg/item.pyx":677
- *         attr_list = ['deleted', 'mode', 'target']
- *         attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+  /* "borg/item.pyx":696
+ *             attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+ * 
  *         for attr in attr_list:             # <<<<<<<<<<<<<<
  *             if self._item1.get(attr) != self._item2.get(attr):
  *                 return False
  */
-  __pyx_t_3 = __pyx_v_attr_list; __Pyx_INCREF(__pyx_t_3); __pyx_t_6 = 0;
+  __pyx_t_2 = __pyx_v_attr_list; __Pyx_INCREF(__pyx_t_2); __pyx_t_6 = 0;
   for (;;) {
-    if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_3)) break;
+    if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_2)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 677, __pyx_L1_error)
+    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_6); __Pyx_INCREF(__pyx_t_3); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 696, __pyx_L1_error)
     #else
-    __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 677, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_2, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 696, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     #endif
-    __Pyx_XDECREF_SET(__pyx_v_attr, __pyx_t_2);
-    __pyx_t_2 = 0;
+    __Pyx_XDECREF_SET(__pyx_v_attr, __pyx_t_3);
+    __pyx_t_3 = 0;
 
-    /* "borg/item.pyx":678
- *         attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+    /* "borg/item.pyx":697
+ * 
  *         for attr in attr_list:
  *             if self._item1.get(attr) != self._item2.get(attr):             # <<<<<<<<<<<<<<
  *                 return False
  * 
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 678, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 697, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 678, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 697, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
-    __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_4, __pyx_v_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_attr);
+    __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_4, __pyx_v_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_attr);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 678, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 697, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 678, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 697, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 678, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 697, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_8);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_8, function);
       }
     }
     __pyx_t_7 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_4, __pyx_v_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_v_attr);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 678, __pyx_L1_error)
+    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 697, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_8 = PyObject_RichCompare(__pyx_t_2, __pyx_t_7, Py_NE); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 678, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_8 = PyObject_RichCompare(__pyx_t_3, __pyx_t_7, Py_NE); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 697, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 678, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 697, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    if (__pyx_t_1) {
+    if (__pyx_t_5) {
 
-      /* "borg/item.pyx":679
+      /* "borg/item.pyx":698
  *         for attr in attr_list:
  *             if self._item1.get(attr) != self._item2.get(attr):
  *                 return False             # <<<<<<<<<<<<<<
  * 
  *         if 'mode' in self._item1:     # mode of item1 and item2 is equal
  */
       __Pyx_XDECREF(__pyx_r);
       __Pyx_INCREF(Py_False);
       __pyx_r = Py_False;
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       goto __pyx_L0;
 
-      /* "borg/item.pyx":678
- *         attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+      /* "borg/item.pyx":697
+ * 
  *         for attr in attr_list:
  *             if self._item1.get(attr) != self._item2.get(attr):             # <<<<<<<<<<<<<<
  *                 return False
  * 
  */
     }
 
-    /* "borg/item.pyx":677
- *         attr_list = ['deleted', 'mode', 'target']
- *         attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+    /* "borg/item.pyx":696
+ *             attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+ * 
  *         for attr in attr_list:             # <<<<<<<<<<<<<<
  *             if self._item1.get(attr) != self._item2.get(attr):
  *                 return False
  */
   }
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":681
+  /* "borg/item.pyx":700
  *                 return False
  * 
  *         if 'mode' in self._item1:     # mode of item1 and item2 is equal             # <<<<<<<<<<<<<<
  *             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2
  *                 and self._item1.target != self._item2.target):
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 681, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_mode, __pyx_t_3, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 681, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_5 = (__pyx_t_1 != 0);
-  if (__pyx_t_5) {
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 700, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_mode, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 700, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = (__pyx_t_5 != 0);
+  if (__pyx_t_1) {
 
-    /* "borg/item.pyx":682
+    /* "borg/item.pyx":701
  * 
  *         if 'mode' in self._item1:     # mode of item1 and item2 is equal
  *             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2             # <<<<<<<<<<<<<<
  *                 and self._item1.target != self._item2.target):
  *                 return False
  */
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 682, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 701, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_is_link); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 682, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_is_link); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 701, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __pyx_t_8 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
       __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_8)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
         __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
-    __pyx_t_3 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_7);
+    __pyx_t_2 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_7);
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 682, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 701, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 682, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (__pyx_t_1) {
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 701, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (__pyx_t_5) {
     } else {
-      __pyx_t_5 = __pyx_t_1;
-      goto __pyx_L11_bool_binop_done;
+      __pyx_t_1 = __pyx_t_5;
+      goto __pyx_L12_bool_binop_done;
     }
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 682, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_target, __pyx_t_3, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 682, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_9 = (__pyx_t_1 != 0);
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 701, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_target, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 701, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_9 = (__pyx_t_5 != 0);
     if (__pyx_t_9) {
     } else {
-      __pyx_t_5 = __pyx_t_9;
-      goto __pyx_L11_bool_binop_done;
+      __pyx_t_1 = __pyx_t_9;
+      goto __pyx_L12_bool_binop_done;
     }
 
-    /* "borg/item.pyx":683
+    /* "borg/item.pyx":702
  *         if 'mode' in self._item1:     # mode of item1 and item2 is equal
  *             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2
  *                 and self._item1.target != self._item2.target):             # <<<<<<<<<<<<<<
  *                 return False
  * 
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 682, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_9 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_target, __pyx_t_3, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 682, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 701, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_9 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_target, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 701, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":682
+    /* "borg/item.pyx":701
  * 
  *         if 'mode' in self._item1:     # mode of item1 and item2 is equal
  *             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2             # <<<<<<<<<<<<<<
  *                 and self._item1.target != self._item2.target):
  *                 return False
  */
-    __pyx_t_1 = (__pyx_t_9 != 0);
-    if (__pyx_t_1) {
+    __pyx_t_5 = (__pyx_t_9 != 0);
+    if (__pyx_t_5) {
     } else {
-      __pyx_t_5 = __pyx_t_1;
-      goto __pyx_L11_bool_binop_done;
+      __pyx_t_1 = __pyx_t_5;
+      goto __pyx_L12_bool_binop_done;
     }
 
-    /* "borg/item.pyx":683
+    /* "borg/item.pyx":702
  *         if 'mode' in self._item1:     # mode of item1 and item2 is equal
  *             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2
  *                 and self._item1.target != self._item2.target):             # <<<<<<<<<<<<<<
  *                 return False
  * 
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 683, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_target); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 683, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 702, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_target); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 702, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 683, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_target); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 683, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 702, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_target); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 702, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = PyObject_RichCompare(__pyx_t_7, __pyx_t_8, Py_NE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 683, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = PyObject_RichCompare(__pyx_t_7, __pyx_t_8, Py_NE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 702, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 683, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_5 = __pyx_t_1;
-    __pyx_L11_bool_binop_done:;
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 702, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_1 = __pyx_t_5;
+    __pyx_L12_bool_binop_done:;
 
-    /* "borg/item.pyx":682
+    /* "borg/item.pyx":701
  * 
  *         if 'mode' in self._item1:     # mode of item1 and item2 is equal
  *             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2             # <<<<<<<<<<<<<<
  *                 and self._item1.target != self._item2.target):
  *                 return False
  */
-    if (__pyx_t_5) {
+    if (__pyx_t_1) {
 
-      /* "borg/item.pyx":684
+      /* "borg/item.pyx":703
  *             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2
  *                 and self._item1.target != self._item2.target):
  *                 return False             # <<<<<<<<<<<<<<
  * 
  *         if 'chunks' in self._item1 and 'chunks' in self._item2:
  */
       __Pyx_XDECREF(__pyx_r);
       __Pyx_INCREF(Py_False);
       __pyx_r = Py_False;
       goto __pyx_L0;
 
-      /* "borg/item.pyx":682
+      /* "borg/item.pyx":701
  * 
  *         if 'mode' in self._item1:     # mode of item1 and item2 is equal
  *             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2             # <<<<<<<<<<<<<<
  *                 and self._item1.target != self._item2.target):
  *                 return False
  */
     }
 
-    /* "borg/item.pyx":681
+    /* "borg/item.pyx":700
  *                 return False
  * 
  *         if 'mode' in self._item1:     # mode of item1 and item2 is equal             # <<<<<<<<<<<<<<
  *             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2
  *                 and self._item1.target != self._item2.target):
  */
   }
 
-  /* "borg/item.pyx":686
+  /* "borg/item.pyx":705
  *                 return False
  * 
  *         if 'chunks' in self._item1 and 'chunks' in self._item2:             # <<<<<<<<<<<<<<
- *             return self._content_equal(chunk_iterator1, chunk_iterator2)
+ *             return self._content_equal()
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 686, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_chunks, __pyx_t_3, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 686, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_9 = (__pyx_t_1 != 0);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 705, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_chunks, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 705, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_9 = (__pyx_t_5 != 0);
   if (__pyx_t_9) {
   } else {
-    __pyx_t_5 = __pyx_t_9;
-    goto __pyx_L16_bool_binop_done;
+    __pyx_t_1 = __pyx_t_9;
+    goto __pyx_L17_bool_binop_done;
   }
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 686, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_9 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_chunks, __pyx_t_3, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 686, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_1 = (__pyx_t_9 != 0);
-  __pyx_t_5 = __pyx_t_1;
-  __pyx_L16_bool_binop_done:;
-  if (__pyx_t_5) {
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 705, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_9 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_chunks, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 705, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_5 = (__pyx_t_9 != 0);
+  __pyx_t_1 = __pyx_t_5;
+  __pyx_L17_bool_binop_done:;
+  if (__pyx_t_1) {
 
-    /* "borg/item.pyx":687
+    /* "borg/item.pyx":706
  * 
  *         if 'chunks' in self._item1 and 'chunks' in self._item2:
- *             return self._content_equal(chunk_iterator1, chunk_iterator2)             # <<<<<<<<<<<<<<
+ *             return self._content_equal()             # <<<<<<<<<<<<<<
  * 
  *         return True
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_content_equal); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 687, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_content_equal); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 706, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __pyx_t_7 = NULL;
-    __pyx_t_10 = 0;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
       __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_8);
       if (likely(__pyx_t_7)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
         __Pyx_INCREF(__pyx_t_7);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_8, function);
-        __pyx_t_10 = 1;
       }
     }
-    #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(__pyx_t_8)) {
-      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_chunk_iterator1, __pyx_v_chunk_iterator2};
-      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 687, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __Pyx_GOTREF(__pyx_t_3);
-    } else
-    #endif
-    #if CYTHON_FAST_PYCCALL
-    if (__Pyx_PyFastCFunction_Check(__pyx_t_8)) {
-      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_chunk_iterator1, __pyx_v_chunk_iterator2};
-      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 687, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-      __Pyx_GOTREF(__pyx_t_3);
-    } else
-    #endif
-    {
-      __pyx_t_2 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 687, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      if (__pyx_t_7) {
-        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_7); __pyx_t_7 = NULL;
-      }
-      __Pyx_INCREF(__pyx_v_chunk_iterator1);
-      __Pyx_GIVEREF(__pyx_v_chunk_iterator1);
-      PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_10, __pyx_v_chunk_iterator1);
-      __Pyx_INCREF(__pyx_v_chunk_iterator2);
-      __Pyx_GIVEREF(__pyx_v_chunk_iterator2);
-      PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_10, __pyx_v_chunk_iterator2);
-      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 687, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    }
+    __pyx_t_2 = (__pyx_t_7) ? __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallNoArg(__pyx_t_8);
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 706, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_r = __pyx_t_3;
-    __pyx_t_3 = 0;
+    __pyx_r = __pyx_t_2;
+    __pyx_t_2 = 0;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":686
+    /* "borg/item.pyx":705
  *                 return False
  * 
  *         if 'chunks' in self._item1 and 'chunks' in self._item2:             # <<<<<<<<<<<<<<
- *             return self._content_equal(chunk_iterator1, chunk_iterator2)
+ *             return self._content_equal()
  * 
  */
   }
 
-  /* "borg/item.pyx":689
- *             return self._content_equal(chunk_iterator1, chunk_iterator2)
+  /* "borg/item.pyx":708
+ *             return self._content_equal()
  * 
  *         return True             # <<<<<<<<<<<<<<
  * 
  *     def _presence_diff(self, item_type):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(Py_True);
   __pyx_r = Py_True;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":670
- *         return ' '.join(str for d, str in self._changes)
+  /* "borg/item.pyx":686
+ *         return (' '.join(self._changes.keys())) or 'equal'
  * 
- *     def _equal(self, chunk_iterator1, chunk_iterator2):             # <<<<<<<<<<<<<<
+ *     def equal(self, content_only=False):             # <<<<<<<<<<<<<<
  *         # if both are deleted, there is nothing at path regardless of what was deleted
  *         if self._item1.get('deleted') and self._item2.get('deleted'):
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_AddTraceback("borg.item.ItemDiff._equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("borg.item.ItemDiff.equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_attr_list);
   __Pyx_XDECREF(__pyx_v_attr);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":691
+/* "borg/item.pyx":710
  *         return True
  * 
  *     def _presence_diff(self, item_type):             # <<<<<<<<<<<<<<
  *         if not self._item1.get('deleted') and self._item2.get('deleted'):
- *             chg = 'removed ' + item_type
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_4borg_4item_8ItemDiff_9_presence_diff(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_9_presence_diff = {"_presence_diff", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_4item_8ItemDiff_9_presence_diff, METH_VARARGS|METH_KEYWORDS, 0};
 static PyObject *__pyx_pw_4borg_4item_8ItemDiff_9_presence_diff(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_self = 0;
@@ -17066,299 +17092,325 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_item_type)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_presence_diff", 1, 2, 2, 1); __PYX_ERR(0, 691, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_presence_diff", 1, 2, 2, 1); __PYX_ERR(0, 710, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_presence_diff") < 0)) __PYX_ERR(0, 691, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_presence_diff") < 0)) __PYX_ERR(0, 710, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_self = values[0];
     __pyx_v_item_type = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_presence_diff", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 691, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_presence_diff", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 710, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.ItemDiff._presence_diff", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_8_presence_diff(__pyx_self, __pyx_v_self, __pyx_v_item_type);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_8_presence_diff(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_item_type) {
-  PyObject *__pyx_v_chg = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
   int __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_presence_diff", 0);
 
-  /* "borg/item.pyx":692
+  /* "borg/item.pyx":711
  * 
  *     def _presence_diff(self, item_type):
  *         if not self._item1.get('deleted') and self._item2.get('deleted'):             # <<<<<<<<<<<<<<
- *             chg = 'removed ' + item_type
- *             return ({"type": chg}, chg)
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")
+ *             return True
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 692, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 692, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_n_s_deleted);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 692, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 692, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_6 = ((!__pyx_t_5) != 0);
   if (__pyx_t_6) {
   } else {
     __pyx_t_1 = __pyx_t_6;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 692, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 692, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_deleted);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 692, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 692, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 711, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_1 = __pyx_t_6;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "borg/item.pyx":693
+    /* "borg/item.pyx":712
  *     def _presence_diff(self, item_type):
  *         if not self._item1.get('deleted') and self._item2.get('deleted'):
- *             chg = 'removed ' + item_type             # <<<<<<<<<<<<<<
- *             return ({"type": chg}, chg)
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")             # <<<<<<<<<<<<<<
+ *             return True
  *         if self._item1.get('deleted') and not self._item2.get('deleted'):
  */
-    __pyx_t_2 = PyNumber_Add(__pyx_kp_s_removed, __pyx_v_item_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 693, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 712, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_item_type, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 712, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_7 = __Pyx_PyUnicode_Concat(__pyx_kp_u_removed, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 712, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_4);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
+      }
+    }
+    __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_7);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 712, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_v_chg = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 712, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (unlikely(PyObject_SetItem(__pyx_t_3, __pyx_v_item_type, __pyx_t_2) < 0)) __PYX_ERR(0, 712, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":694
+    /* "borg/item.pyx":713
  *         if not self._item1.get('deleted') and self._item2.get('deleted'):
- *             chg = 'removed ' + item_type
- *             return ({"type": chg}, chg)             # <<<<<<<<<<<<<<
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")
+ *             return True             # <<<<<<<<<<<<<<
  *         if self._item1.get('deleted') and not self._item2.get('deleted'):
- *             chg = 'added ' + item_type
+ *             self._changes[item_type] = DiffChange(f"added {item_type}")
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 694, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, __pyx_v_chg) < 0) __PYX_ERR(0, 694, __pyx_L1_error)
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 694, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
-    __Pyx_INCREF(__pyx_v_chg);
-    __Pyx_GIVEREF(__pyx_v_chg);
-    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_chg);
-    __pyx_t_2 = 0;
-    __pyx_r = __pyx_t_3;
-    __pyx_t_3 = 0;
+    __Pyx_INCREF(Py_True);
+    __pyx_r = Py_True;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":692
+    /* "borg/item.pyx":711
  * 
  *     def _presence_diff(self, item_type):
  *         if not self._item1.get('deleted') and self._item2.get('deleted'):             # <<<<<<<<<<<<<<
- *             chg = 'removed ' + item_type
- *             return ({"type": chg}, chg)
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")
+ *             return True
  */
   }
 
-  /* "borg/item.pyx":695
- *             chg = 'removed ' + item_type
- *             return ({"type": chg}, chg)
+  /* "borg/item.pyx":714
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")
+ *             return True
  *         if self._item1.get('deleted') and not self._item2.get('deleted'):             # <<<<<<<<<<<<<<
- *             chg = 'added ' + item_type
- *             return ({"type": chg}, chg)
+ *             self._changes[item_type] = DiffChange(f"added {item_type}")
+ *             return True
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 695, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 695, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-      __Pyx_INCREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 714, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 714, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_7);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_4, function);
+      __Pyx_DECREF_SET(__pyx_t_7, function);
     }
   }
-  __pyx_t_3 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_2, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_n_s_deleted);
-  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 695, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 695, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_3, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_n_s_deleted);
+  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 714, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 714, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (__pyx_t_6) {
   } else {
     __pyx_t_1 = __pyx_t_6;
     goto __pyx_L7_bool_binop_done;
   }
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 695, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 695, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_4);
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 714, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 714, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_7)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_7);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
-  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_n_s_deleted);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 695, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 695, __pyx_L1_error)
+  __pyx_t_2 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_7, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_deleted);
+  __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 714, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 714, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_5 = ((!__pyx_t_6) != 0);
   __pyx_t_1 = __pyx_t_5;
   __pyx_L7_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "borg/item.pyx":696
- *             return ({"type": chg}, chg)
+    /* "borg/item.pyx":715
+ *             return True
  *         if self._item1.get('deleted') and not self._item2.get('deleted'):
- *             chg = 'added ' + item_type             # <<<<<<<<<<<<<<
- *             return ({"type": chg}, chg)
+ *             self._changes[item_type] = DiffChange(f"added {item_type}")             # <<<<<<<<<<<<<<
+ *             return True
  * 
  */
-    __pyx_t_3 = PyNumber_Add(__pyx_kp_s_added, __pyx_v_item_type); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 696, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 715, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_v_chg = __pyx_t_3;
-    __pyx_t_3 = 0;
+    __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_item_type, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 715, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_kp_u_added, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 715, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __pyx_t_7 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_7)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_7);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
+      }
+    }
+    __pyx_t_2 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_7, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 715, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 715, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (unlikely(PyObject_SetItem(__pyx_t_3, __pyx_v_item_type, __pyx_t_2) < 0)) __PYX_ERR(0, 715, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":697
+    /* "borg/item.pyx":716
  *         if self._item1.get('deleted') and not self._item2.get('deleted'):
- *             chg = 'added ' + item_type
- *             return ({"type": chg}, chg)             # <<<<<<<<<<<<<<
+ *             self._changes[item_type] = DiffChange(f"added {item_type}")
+ *             return True             # <<<<<<<<<<<<<<
  * 
  *     def _link_diff(self):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 697, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_type, __pyx_v_chg) < 0) __PYX_ERR(0, 697, __pyx_L1_error)
-    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 697, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
-    __Pyx_INCREF(__pyx_v_chg);
-    __Pyx_GIVEREF(__pyx_v_chg);
-    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_chg);
-    __pyx_t_3 = 0;
-    __pyx_r = __pyx_t_2;
-    __pyx_t_2 = 0;
+    __Pyx_INCREF(Py_True);
+    __pyx_r = Py_True;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":695
- *             chg = 'removed ' + item_type
- *             return ({"type": chg}, chg)
+    /* "borg/item.pyx":714
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")
+ *             return True
  *         if self._item1.get('deleted') and not self._item2.get('deleted'):             # <<<<<<<<<<<<<<
- *             chg = 'added ' + item_type
- *             return ({"type": chg}, chg)
+ *             self._changes[item_type] = DiffChange(f"added {item_type}")
+ *             return True
  */
   }
 
-  /* "borg/item.pyx":691
+  /* "borg/item.pyx":710
  *         return True
  * 
  *     def _presence_diff(self, item_type):             # <<<<<<<<<<<<<<
  *         if not self._item1.get('deleted') and self._item2.get('deleted'):
- *             chg = 'removed ' + item_type
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_7);
   __Pyx_AddTraceback("borg.item.ItemDiff._presence_diff", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_chg);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":699
- *             return ({"type": chg}, chg)
+/* "borg/item.pyx":718
+ *             return True
  * 
  *     def _link_diff(self):             # <<<<<<<<<<<<<<
- *         pd = self._presence_diff('link')
- *         if pd is not None:
+ *         if self._presence_diff('link'):
+ *             return True
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_4borg_4item_8ItemDiff_11_link_diff(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
 static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_11_link_diff = {"_link_diff", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_11_link_diff, METH_O, 0};
 static PyObject *__pyx_pw_4borg_4item_8ItemDiff_11_link_diff(PyObject *__pyx_self, PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
@@ -17368,191 +17420,198 @@
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_4borg_4item_8ItemDiff_10_link_diff(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
-  PyObject *__pyx_v_pd = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_link_diff", 0);
 
-  /* "borg/item.pyx":700
+  /* "borg/item.pyx":719
  * 
  *     def _link_diff(self):
- *         pd = self._presence_diff('link')             # <<<<<<<<<<<<<<
- *         if pd is not None:
- *             return pd
+ *         if self._presence_diff('link'):             # <<<<<<<<<<<<<<
+ *             return True
+ *         if 'target' in self._item1 and 'target' in self._item2 and self._item1.target != self._item2.target:
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 700, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_presence_diff); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 719, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_n_s_link) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_n_s_link);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 700, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 719, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_pd = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 719, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_4) {
 
-  /* "borg/item.pyx":701
+    /* "borg/item.pyx":720
  *     def _link_diff(self):
- *         pd = self._presence_diff('link')
- *         if pd is not None:             # <<<<<<<<<<<<<<
- *             return pd
- *         if 'target' in self._item1 and 'target' in self._item2 and self._item1.target != self._item2.target:
- */
-  __pyx_t_4 = (__pyx_v_pd != Py_None);
-  __pyx_t_5 = (__pyx_t_4 != 0);
-  if (__pyx_t_5) {
-
-    /* "borg/item.pyx":702
- *         pd = self._presence_diff('link')
- *         if pd is not None:
- *             return pd             # <<<<<<<<<<<<<<
+ *         if self._presence_diff('link'):
+ *             return True             # <<<<<<<<<<<<<<
  *         if 'target' in self._item1 and 'target' in self._item2 and self._item1.target != self._item2.target:
- *             return ({"type": 'changed link'}, 'changed link')
+ *             self._changes['link'] = DiffChange('changed link')
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF(__pyx_v_pd);
-    __pyx_r = __pyx_v_pd;
+    __Pyx_INCREF(Py_True);
+    __pyx_r = Py_True;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":701
+    /* "borg/item.pyx":719
+ * 
  *     def _link_diff(self):
- *         pd = self._presence_diff('link')
- *         if pd is not None:             # <<<<<<<<<<<<<<
- *             return pd
+ *         if self._presence_diff('link'):             # <<<<<<<<<<<<<<
+ *             return True
  *         if 'target' in self._item1 and 'target' in self._item2 and self._item1.target != self._item2.target:
  */
   }
 
-  /* "borg/item.pyx":703
- *         if pd is not None:
- *             return pd
+  /* "borg/item.pyx":721
+ *         if self._presence_diff('link'):
+ *             return True
  *         if 'target' in self._item1 and 'target' in self._item2 and self._item1.target != self._item2.target:             # <<<<<<<<<<<<<<
- *             return ({"type": 'changed link'}, 'changed link')
- * 
+ *             self._changes['link'] = DiffChange('changed link')
+ *             return True
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_target, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_target, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = (__pyx_t_4 != 0);
+  __pyx_t_6 = (__pyx_t_5 != 0);
   if (__pyx_t_6) {
   } else {
-    __pyx_t_5 = __pyx_t_6;
+    __pyx_t_4 = __pyx_t_6;
     goto __pyx_L5_bool_binop_done;
   }
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_6 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_target, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_6 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_target, __pyx_t_1, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_4 = (__pyx_t_6 != 0);
-  if (__pyx_t_4) {
+  __pyx_t_5 = (__pyx_t_6 != 0);
+  if (__pyx_t_5) {
   } else {
-    __pyx_t_5 = __pyx_t_4;
+    __pyx_t_4 = __pyx_t_5;
     goto __pyx_L5_bool_binop_done;
   }
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_target); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_target); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_target); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_target); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyObject_RichCompare(__pyx_t_2, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_1 = PyObject_RichCompare(__pyx_t_2, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 703, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 721, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_5 = __pyx_t_4;
+  __pyx_t_4 = __pyx_t_5;
   __pyx_L5_bool_binop_done:;
-  if (__pyx_t_5) {
+  if (__pyx_t_4) {
 
-    /* "borg/item.pyx":704
- *             return pd
+    /* "borg/item.pyx":722
+ *             return True
  *         if 'target' in self._item1 and 'target' in self._item2 and self._item1.target != self._item2.target:
- *             return ({"type": 'changed link'}, 'changed link')             # <<<<<<<<<<<<<<
+ *             self._changes['link'] = DiffChange('changed link')             # <<<<<<<<<<<<<<
+ *             return True
  * 
- *     def _content_diff(self):
  */
-    __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 722, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
+      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+      if (likely(__pyx_t_2)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_2);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_3, function);
+      }
+    }
+    __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_kp_s_changed_link) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_changed_link);
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 722, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_type, __pyx_kp_s_changed_link) < 0) __PYX_ERR(0, 704, __pyx_L1_error)
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 704, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 722, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
-    __Pyx_INCREF(__pyx_kp_s_changed_link);
-    __Pyx_GIVEREF(__pyx_kp_s_changed_link);
-    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_changed_link);
-    __pyx_t_1 = 0;
-    __pyx_r = __pyx_t_3;
-    __pyx_t_3 = 0;
+    if (unlikely(PyObject_SetItem(__pyx_t_3, __pyx_n_s_link, __pyx_t_1) < 0)) __PYX_ERR(0, 722, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+    /* "borg/item.pyx":723
+ *         if 'target' in self._item1 and 'target' in self._item2 and self._item1.target != self._item2.target:
+ *             self._changes['link'] = DiffChange('changed link')
+ *             return True             # <<<<<<<<<<<<<<
+ * 
+ *     def _content_diff(self):
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_True);
+    __pyx_r = Py_True;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":703
- *         if pd is not None:
- *             return pd
+    /* "borg/item.pyx":721
+ *         if self._presence_diff('link'):
+ *             return True
  *         if 'target' in self._item1 and 'target' in self._item2 and self._item1.target != self._item2.target:             # <<<<<<<<<<<<<<
- *             return ({"type": 'changed link'}, 'changed link')
- * 
+ *             self._changes['link'] = DiffChange('changed link')
+ *             return True
  */
   }
 
-  /* "borg/item.pyx":699
- *             return ({"type": chg}, chg)
+  /* "borg/item.pyx":718
+ *             return True
  * 
  *     def _link_diff(self):             # <<<<<<<<<<<<<<
- *         pd = self._presence_diff('link')
- *         if pd is not None:
+ *         if self._presence_diff('link'):
+ *             return True
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("borg.item.ItemDiff._link_diff", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_pd);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":706
- *             return ({"type": 'changed link'}, 'changed link')
+/* "borg/item.pyx":725
+ *             return True
  * 
  *     def _content_diff(self):             # <<<<<<<<<<<<<<
  *         if self._item1.get('deleted'):
  *             sz = self._item2.get_size()
  */
 
 /* Python wrapper */
@@ -17573,725 +17632,720 @@
   PyObject *__pyx_v_sz = NULL;
   PyObject *__pyx_v_chunk_ids1 = NULL;
   PyObject *__pyx_v_chunk_ids2 = NULL;
   PyObject *__pyx_v_added_ids = NULL;
   PyObject *__pyx_v_removed_ids = NULL;
   PyObject *__pyx_v_added = NULL;
   PyObject *__pyx_v_removed = NULL;
-  PyObject *__pyx_8genexpr9__pyx_v_c = NULL;
-  PyObject *__pyx_9genexpr10__pyx_v_c = NULL;
+  PyObject *__pyx_8genexpr7__pyx_v_c = NULL;
+  PyObject *__pyx_8genexpr8__pyx_v_c = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_6;
   PyObject *__pyx_t_7 = NULL;
   int __pyx_t_8;
   Py_ssize_t __pyx_t_9;
   PyObject *(*__pyx_t_10)(PyObject *);
-  PyObject *__pyx_t_11 = NULL;
-  PyObject *__pyx_t_12 = NULL;
-  int __pyx_t_13;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_content_diff", 0);
 
-  /* "borg/item.pyx":707
+  /* "borg/item.pyx":726
  * 
  *     def _content_diff(self):
  *         if self._item1.get('deleted'):             # <<<<<<<<<<<<<<
  *             sz = self._item2.get_size()
- *             return ({"type": "added", "size": sz}, 'added {:>13}'.format(format_file_size(sz)))
+ *             self._changes['content'] = DiffChange("added", {"added": sz, "removed": 0})
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 707, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 726, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 707, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 726, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_deleted);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 707, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 726, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 707, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 726, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if (__pyx_t_4) {
 
-    /* "borg/item.pyx":708
+    /* "borg/item.pyx":727
  *     def _content_diff(self):
  *         if self._item1.get('deleted'):
  *             sz = self._item2.get_size()             # <<<<<<<<<<<<<<
- *             return ({"type": "added", "size": sz}, 'added {:>13}'.format(format_file_size(sz)))
- *         if self._item2.get('deleted'):
+ *             self._changes['content'] = DiffChange("added", {"added": sz, "removed": 0})
+ *             return True
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 727, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 708, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 727, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_3 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
       if (likely(__pyx_t_3)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
         __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_2, function);
       }
     }
     __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 708, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 727, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_v_sz = __pyx_t_1;
     __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":709
+    /* "borg/item.pyx":728
  *         if self._item1.get('deleted'):
  *             sz = self._item2.get_size()
- *             return ({"type": "added", "size": sz}, 'added {:>13}'.format(format_file_size(sz)))             # <<<<<<<<<<<<<<
+ *             self._changes['content'] = DiffChange("added", {"added": sz, "removed": 0})             # <<<<<<<<<<<<<<
+ *             return True
  *         if self._item2.get('deleted'):
- *             sz = self._item1.get_size()
  */
-    __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 709, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_type, __pyx_n_s_added_2) < 0) __PYX_ERR(0, 709, __pyx_L1_error)
-    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_size, __pyx_v_sz) < 0) __PYX_ERR(0, 709, __pyx_L1_error)
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_added_13, __pyx_n_s_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 709, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 728, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 728, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_format_file_size); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 709, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_7 = NULL;
-    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
-      if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
-        __Pyx_INCREF(__pyx_t_7);
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_added_2, __pyx_v_sz) < 0) __PYX_ERR(0, 728, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_removed_2, __pyx_int_0) < 0) __PYX_ERR(0, 728, __pyx_L1_error)
+    __pyx_t_5 = NULL;
+    __pyx_t_6 = 0;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_6, function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __pyx_t_6 = 1;
       }
     }
-    __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_v_sz) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_sz);
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 709, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
-      if (likely(__pyx_t_6)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-        __Pyx_INCREF(__pyx_t_6);
-        __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_3, function);
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_2)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_n_s_added_2, __pyx_t_3};
+      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 728, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    } else
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_n_s_added_2, __pyx_t_3};
+      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 728, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    } else
+    #endif
+    {
+      __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 728, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      if (__pyx_t_5) {
+        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
+      __Pyx_INCREF(__pyx_n_s_added_2);
+      __Pyx_GIVEREF(__pyx_n_s_added_2);
+      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_n_s_added_2);
+      __Pyx_GIVEREF(__pyx_t_3);
+      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_3);
+      __pyx_t_3 = 0;
+      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 728, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     }
-    __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5);
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 709, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 728, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 709, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
-    __pyx_t_1 = 0;
-    __pyx_t_2 = 0;
-    __pyx_r = __pyx_t_3;
-    __pyx_t_3 = 0;
+    if (unlikely(PyObject_SetItem(__pyx_t_2, __pyx_n_s_content, __pyx_t_1) < 0)) __PYX_ERR(0, 728, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+    /* "borg/item.pyx":729
+ *             sz = self._item2.get_size()
+ *             self._changes['content'] = DiffChange("added", {"added": sz, "removed": 0})
+ *             return True             # <<<<<<<<<<<<<<
+ *         if self._item2.get('deleted'):
+ *             sz = self._item1.get_size()
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_True);
+    __pyx_r = Py_True;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":707
+    /* "borg/item.pyx":726
  * 
  *     def _content_diff(self):
  *         if self._item1.get('deleted'):             # <<<<<<<<<<<<<<
  *             sz = self._item2.get_size()
- *             return ({"type": "added", "size": sz}, 'added {:>13}'.format(format_file_size(sz)))
+ *             self._changes['content'] = DiffChange("added", {"added": sz, "removed": 0})
  */
   }
 
-  /* "borg/item.pyx":710
- *             sz = self._item2.get_size()
- *             return ({"type": "added", "size": sz}, 'added {:>13}'.format(format_file_size(sz)))
+  /* "borg/item.pyx":730
+ *             self._changes['content'] = DiffChange("added", {"added": sz, "removed": 0})
+ *             return True
  *         if self._item2.get('deleted'):             # <<<<<<<<<<<<<<
  *             sz = self._item1.get_size()
- *             return ({"type": "removed", "size": sz}, 'removed {:>11}'.format(format_file_size(sz)))
+ *             self._changes['content'] = DiffChange("removed", {"added": 0, "removed": sz})
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 710, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 730, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 710, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 730, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_7);
     if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_1, function);
+      __Pyx_DECREF_SET(__pyx_t_7, function);
     }
   }
-  __pyx_t_3 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_2, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_n_s_deleted);
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_2, __pyx_n_s_deleted) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_n_s_deleted);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 710, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 730, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 730, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 710, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   if (__pyx_t_4) {
 
-    /* "borg/item.pyx":711
- *             return ({"type": "added", "size": sz}, 'added {:>13}'.format(format_file_size(sz)))
+    /* "borg/item.pyx":731
+ *             return True
  *         if self._item2.get('deleted'):
  *             sz = self._item1.get_size()             # <<<<<<<<<<<<<<
- *             return ({"type": "removed", "size": sz}, 'removed {:>11}'.format(format_file_size(sz)))
- *         if not self._can_compare_chunk_ids:
+ *             self._changes['content'] = DiffChange("removed", {"added": 0, "removed": sz})
+ *             return True
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 711, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 711, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 731, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_get_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 731, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = NULL;
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __pyx_t_7 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
-      if (likely(__pyx_t_1)) {
+      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_7)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-        __Pyx_INCREF(__pyx_t_1);
+        __Pyx_INCREF(__pyx_t_7);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_2, function);
       }
     }
-    __pyx_t_3 = (__pyx_t_1) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_1) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 711, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_1 = (__pyx_t_7) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_7) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 731, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_v_sz = __pyx_t_3;
-    __pyx_t_3 = 0;
+    __pyx_v_sz = __pyx_t_1;
+    __pyx_t_1 = 0;
 
-    /* "borg/item.pyx":712
+    /* "borg/item.pyx":732
  *         if self._item2.get('deleted'):
  *             sz = self._item1.get_size()
- *             return ({"type": "removed", "size": sz}, 'removed {:>11}'.format(format_file_size(sz)))             # <<<<<<<<<<<<<<
+ *             self._changes['content'] = DiffChange("removed", {"added": 0, "removed": sz})             # <<<<<<<<<<<<<<
+ *             return True
  *         if not self._can_compare_chunk_ids:
- *             return ({"type": "modified"}, "modified")
  */
-    __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 712, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_type, __pyx_n_s_removed_2) < 0) __PYX_ERR(0, 712, __pyx_L1_error)
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_size, __pyx_v_sz) < 0) __PYX_ERR(0, 712, __pyx_L1_error)
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_removed_11, __pyx_n_s_format); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 712, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_format_file_size); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 712, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_7 = NULL;
-    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
-      if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
-        __Pyx_INCREF(__pyx_t_7);
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 732, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_7 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 732, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_added_2, __pyx_int_0) < 0) __PYX_ERR(0, 732, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_removed_2, __pyx_v_sz) < 0) __PYX_ERR(0, 732, __pyx_L1_error)
+    __pyx_t_3 = NULL;
+    __pyx_t_6 = 0;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_3)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_3);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_6, function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __pyx_t_6 = 1;
       }
     }
-    __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_v_sz) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_sz);
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 712, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = NULL;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
-      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
-      if (likely(__pyx_t_6)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-        __Pyx_INCREF(__pyx_t_6);
-        __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_1, function);
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_2)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_n_s_removed_2, __pyx_t_7};
+      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 732, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    } else
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_n_s_removed_2, __pyx_t_7};
+      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 732, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    } else
+    #endif
+    {
+      __pyx_t_5 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 732, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      if (__pyx_t_3) {
+        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
       }
+      __Pyx_INCREF(__pyx_n_s_removed_2);
+      __Pyx_GIVEREF(__pyx_n_s_removed_2);
+      PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_6, __pyx_n_s_removed_2);
+      __Pyx_GIVEREF(__pyx_t_7);
+      PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_6, __pyx_t_7);
+      __pyx_t_7 = 0;
+      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 732, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     }
-    __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_5);
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 712, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 732, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
+    if (unlikely(PyObject_SetItem(__pyx_t_2, __pyx_n_s_content, __pyx_t_1) < 0)) __PYX_ERR(0, 732, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 712, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
-    __pyx_t_3 = 0;
-    __pyx_t_2 = 0;
-    __pyx_r = __pyx_t_1;
-    __pyx_t_1 = 0;
+
+    /* "borg/item.pyx":733
+ *             sz = self._item1.get_size()
+ *             self._changes['content'] = DiffChange("removed", {"added": 0, "removed": sz})
+ *             return True             # <<<<<<<<<<<<<<
+ *         if not self._can_compare_chunk_ids:
+ *             self._changes['content'] = DiffChange("modified")
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_True);
+    __pyx_r = Py_True;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":710
- *             sz = self._item2.get_size()
- *             return ({"type": "added", "size": sz}, 'added {:>13}'.format(format_file_size(sz)))
+    /* "borg/item.pyx":730
+ *             self._changes['content'] = DiffChange("added", {"added": sz, "removed": 0})
+ *             return True
  *         if self._item2.get('deleted'):             # <<<<<<<<<<<<<<
  *             sz = self._item1.get_size()
- *             return ({"type": "removed", "size": sz}, 'removed {:>11}'.format(format_file_size(sz)))
+ *             self._changes['content'] = DiffChange("removed", {"added": 0, "removed": sz})
  */
   }
 
-  /* "borg/item.pyx":713
- *             sz = self._item1.get_size()
- *             return ({"type": "removed", "size": sz}, 'removed {:>11}'.format(format_file_size(sz)))
+  /* "borg/item.pyx":734
+ *             self._changes['content'] = DiffChange("removed", {"added": 0, "removed": sz})
+ *             return True
  *         if not self._can_compare_chunk_ids:             # <<<<<<<<<<<<<<
- *             return ({"type": "modified"}, "modified")
- *         chunk_ids1 = {c.id for c in self._item1.chunks}
+ *             self._changes['content'] = DiffChange("modified")
+ *             return True
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_can_compare_chunk_ids_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 713, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_can_compare_chunk_ids_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 734, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 713, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 734, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_8 = ((!__pyx_t_4) != 0);
   if (__pyx_t_8) {
 
-    /* "borg/item.pyx":714
- *             return ({"type": "removed", "size": sz}, 'removed {:>11}'.format(format_file_size(sz)))
+    /* "borg/item.pyx":735
+ *             return True
  *         if not self._can_compare_chunk_ids:
- *             return ({"type": "modified"}, "modified")             # <<<<<<<<<<<<<<
+ *             self._changes['content'] = DiffChange("modified")             # <<<<<<<<<<<<<<
+ *             return True
  *         chunk_ids1 = {c.id for c in self._item1.chunks}
- *         chunk_ids2 = {c.id for c in self._item2.chunks}
  */
-    __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 714, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 735, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = NULL;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_5);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
+      }
+    }
+    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_n_s_modified) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_n_s_modified);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 735, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_type, __pyx_n_s_modified) < 0) __PYX_ERR(0, 714, __pyx_L1_error)
-    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 714, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 735, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_1);
-    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
-    __Pyx_INCREF(__pyx_n_s_modified);
-    __Pyx_GIVEREF(__pyx_n_s_modified);
-    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_modified);
-    __pyx_t_1 = 0;
-    __pyx_r = __pyx_t_2;
-    __pyx_t_2 = 0;
+    if (unlikely(PyObject_SetItem(__pyx_t_2, __pyx_n_s_content, __pyx_t_1) < 0)) __PYX_ERR(0, 735, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+    /* "borg/item.pyx":736
+ *         if not self._can_compare_chunk_ids:
+ *             self._changes['content'] = DiffChange("modified")
+ *             return True             # <<<<<<<<<<<<<<
+ *         chunk_ids1 = {c.id for c in self._item1.chunks}
+ *         chunk_ids2 = {c.id for c in self._item2.chunks}
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(Py_True);
+    __pyx_r = Py_True;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":713
- *             sz = self._item1.get_size()
- *             return ({"type": "removed", "size": sz}, 'removed {:>11}'.format(format_file_size(sz)))
+    /* "borg/item.pyx":734
+ *             self._changes['content'] = DiffChange("removed", {"added": 0, "removed": sz})
+ *             return True
  *         if not self._can_compare_chunk_ids:             # <<<<<<<<<<<<<<
- *             return ({"type": "modified"}, "modified")
- *         chunk_ids1 = {c.id for c in self._item1.chunks}
+ *             self._changes['content'] = DiffChange("modified")
+ *             return True
  */
   }
 
-  /* "borg/item.pyx":715
- *         if not self._can_compare_chunk_ids:
- *             return ({"type": "modified"}, "modified")
+  /* "borg/item.pyx":737
+ *             self._changes['content'] = DiffChange("modified")
+ *             return True
  *         chunk_ids1 = {c.id for c in self._item1.chunks}             # <<<<<<<<<<<<<<
  *         chunk_ids2 = {c.id for c in self._item2.chunks}
  *         added_ids = chunk_ids2 - chunk_ids1
  */
   { /* enter inner scope */
-    __pyx_t_2 = PySet_New(NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 715, __pyx_L8_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 715, __pyx_L8_error)
+    __pyx_t_1 = PySet_New(NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 737, __pyx_L8_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_chunks); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 715, __pyx_L8_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (likely(PyList_CheckExact(__pyx_t_3)) || PyTuple_CheckExact(__pyx_t_3)) {
-      __pyx_t_1 = __pyx_t_3; __Pyx_INCREF(__pyx_t_1); __pyx_t_9 = 0;
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 737, __pyx_L8_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_chunks); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 737, __pyx_L8_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (likely(PyList_CheckExact(__pyx_t_5)) || PyTuple_CheckExact(__pyx_t_5)) {
+      __pyx_t_2 = __pyx_t_5; __Pyx_INCREF(__pyx_t_2); __pyx_t_9 = 0;
       __pyx_t_10 = NULL;
     } else {
-      __pyx_t_9 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 715, __pyx_L8_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_10 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 715, __pyx_L8_error)
+      __pyx_t_9 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 737, __pyx_L8_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_10 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 737, __pyx_L8_error)
     }
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     for (;;) {
       if (likely(!__pyx_t_10)) {
-        if (likely(PyList_CheckExact(__pyx_t_1))) {
-          if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_1)) break;
+        if (likely(PyList_CheckExact(__pyx_t_2))) {
+          if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_2)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 715, __pyx_L8_error)
+          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_9); __Pyx_INCREF(__pyx_t_5); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 737, __pyx_L8_error)
           #else
-          __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 715, __pyx_L8_error)
-          __Pyx_GOTREF(__pyx_t_3);
+          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 737, __pyx_L8_error)
+          __Pyx_GOTREF(__pyx_t_5);
           #endif
         } else {
-          if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
+          if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 715, __pyx_L8_error)
+          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_9); __Pyx_INCREF(__pyx_t_5); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 737, __pyx_L8_error)
           #else
-          __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 715, __pyx_L8_error)
-          __Pyx_GOTREF(__pyx_t_3);
+          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 737, __pyx_L8_error)
+          __Pyx_GOTREF(__pyx_t_5);
           #endif
         }
       } else {
-        __pyx_t_3 = __pyx_t_10(__pyx_t_1);
-        if (unlikely(!__pyx_t_3)) {
+        __pyx_t_5 = __pyx_t_10(__pyx_t_2);
+        if (unlikely(!__pyx_t_5)) {
           PyObject* exc_type = PyErr_Occurred();
           if (exc_type) {
             if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 715, __pyx_L8_error)
+            else __PYX_ERR(0, 737, __pyx_L8_error)
           }
           break;
         }
-        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_GOTREF(__pyx_t_5);
       }
-      __Pyx_XDECREF_SET(__pyx_8genexpr9__pyx_v_c, __pyx_t_3);
-      __pyx_t_3 = 0;
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_8genexpr9__pyx_v_c, __pyx_n_s_id); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 715, __pyx_L8_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      if (unlikely(PySet_Add(__pyx_t_2, (PyObject*)__pyx_t_3))) __PYX_ERR(0, 715, __pyx_L8_error)
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_XDECREF_SET(__pyx_8genexpr7__pyx_v_c, __pyx_t_5);
+      __pyx_t_5 = 0;
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_8genexpr7__pyx_v_c, __pyx_n_s_id); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 737, __pyx_L8_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      if (unlikely(PySet_Add(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 737, __pyx_L8_error)
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     }
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_XDECREF(__pyx_8genexpr9__pyx_v_c); __pyx_8genexpr9__pyx_v_c = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_c); __pyx_8genexpr7__pyx_v_c = 0;
     goto __pyx_L11_exit_scope;
     __pyx_L8_error:;
-    __Pyx_XDECREF(__pyx_8genexpr9__pyx_v_c); __pyx_8genexpr9__pyx_v_c = 0;
+    __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_c); __pyx_8genexpr7__pyx_v_c = 0;
     goto __pyx_L1_error;
     __pyx_L11_exit_scope:;
   } /* exit inner scope */
-  __pyx_v_chunk_ids1 = ((PyObject*)__pyx_t_2);
-  __pyx_t_2 = 0;
+  __pyx_v_chunk_ids1 = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":716
- *             return ({"type": "modified"}, "modified")
+  /* "borg/item.pyx":738
+ *             return True
  *         chunk_ids1 = {c.id for c in self._item1.chunks}
  *         chunk_ids2 = {c.id for c in self._item2.chunks}             # <<<<<<<<<<<<<<
  *         added_ids = chunk_ids2 - chunk_ids1
  *         removed_ids = chunk_ids1 - chunk_ids2
  */
   { /* enter inner scope */
-    __pyx_t_2 = PySet_New(NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 716, __pyx_L14_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 716, __pyx_L14_error)
+    __pyx_t_1 = PySet_New(NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 738, __pyx_L14_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_chunks); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 716, __pyx_L14_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (likely(PyList_CheckExact(__pyx_t_3)) || PyTuple_CheckExact(__pyx_t_3)) {
-      __pyx_t_1 = __pyx_t_3; __Pyx_INCREF(__pyx_t_1); __pyx_t_9 = 0;
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 738, __pyx_L14_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_chunks); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 738, __pyx_L14_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (likely(PyList_CheckExact(__pyx_t_5)) || PyTuple_CheckExact(__pyx_t_5)) {
+      __pyx_t_2 = __pyx_t_5; __Pyx_INCREF(__pyx_t_2); __pyx_t_9 = 0;
       __pyx_t_10 = NULL;
     } else {
-      __pyx_t_9 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 716, __pyx_L14_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_10 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 716, __pyx_L14_error)
+      __pyx_t_9 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 738, __pyx_L14_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_10 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 738, __pyx_L14_error)
     }
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     for (;;) {
       if (likely(!__pyx_t_10)) {
-        if (likely(PyList_CheckExact(__pyx_t_1))) {
-          if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_1)) break;
+        if (likely(PyList_CheckExact(__pyx_t_2))) {
+          if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_2)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 716, __pyx_L14_error)
+          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_9); __Pyx_INCREF(__pyx_t_5); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 738, __pyx_L14_error)
           #else
-          __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 716, __pyx_L14_error)
-          __Pyx_GOTREF(__pyx_t_3);
+          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 738, __pyx_L14_error)
+          __Pyx_GOTREF(__pyx_t_5);
           #endif
         } else {
-          if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
+          if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_9); __Pyx_INCREF(__pyx_t_3); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 716, __pyx_L14_error)
+          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_9); __Pyx_INCREF(__pyx_t_5); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 738, __pyx_L14_error)
           #else
-          __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 716, __pyx_L14_error)
-          __Pyx_GOTREF(__pyx_t_3);
+          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 738, __pyx_L14_error)
+          __Pyx_GOTREF(__pyx_t_5);
           #endif
         }
       } else {
-        __pyx_t_3 = __pyx_t_10(__pyx_t_1);
-        if (unlikely(!__pyx_t_3)) {
+        __pyx_t_5 = __pyx_t_10(__pyx_t_2);
+        if (unlikely(!__pyx_t_5)) {
           PyObject* exc_type = PyErr_Occurred();
           if (exc_type) {
             if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 716, __pyx_L14_error)
+            else __PYX_ERR(0, 738, __pyx_L14_error)
           }
           break;
         }
-        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_GOTREF(__pyx_t_5);
       }
-      __Pyx_XDECREF_SET(__pyx_9genexpr10__pyx_v_c, __pyx_t_3);
-      __pyx_t_3 = 0;
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_9genexpr10__pyx_v_c, __pyx_n_s_id); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 716, __pyx_L14_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      if (unlikely(PySet_Add(__pyx_t_2, (PyObject*)__pyx_t_3))) __PYX_ERR(0, 716, __pyx_L14_error)
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_XDECREF_SET(__pyx_8genexpr8__pyx_v_c, __pyx_t_5);
+      __pyx_t_5 = 0;
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_8genexpr8__pyx_v_c, __pyx_n_s_id); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 738, __pyx_L14_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      if (unlikely(PySet_Add(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 738, __pyx_L14_error)
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     }
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_XDECREF(__pyx_9genexpr10__pyx_v_c); __pyx_9genexpr10__pyx_v_c = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_XDECREF(__pyx_8genexpr8__pyx_v_c); __pyx_8genexpr8__pyx_v_c = 0;
     goto __pyx_L17_exit_scope;
     __pyx_L14_error:;
-    __Pyx_XDECREF(__pyx_9genexpr10__pyx_v_c); __pyx_9genexpr10__pyx_v_c = 0;
+    __Pyx_XDECREF(__pyx_8genexpr8__pyx_v_c); __pyx_8genexpr8__pyx_v_c = 0;
     goto __pyx_L1_error;
     __pyx_L17_exit_scope:;
   } /* exit inner scope */
-  __pyx_v_chunk_ids2 = ((PyObject*)__pyx_t_2);
-  __pyx_t_2 = 0;
+  __pyx_v_chunk_ids2 = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":717
+  /* "borg/item.pyx":739
  *         chunk_ids1 = {c.id for c in self._item1.chunks}
  *         chunk_ids2 = {c.id for c in self._item2.chunks}
  *         added_ids = chunk_ids2 - chunk_ids1             # <<<<<<<<<<<<<<
  *         removed_ids = chunk_ids1 - chunk_ids2
  *         added = self._item2.get_size(consider_ids=added_ids)
  */
-  __pyx_t_2 = PyNumber_Subtract(__pyx_v_chunk_ids2, __pyx_v_chunk_ids1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 717, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_v_added_ids = __pyx_t_2;
-  __pyx_t_2 = 0;
+  __pyx_t_1 = PyNumber_Subtract(__pyx_v_chunk_ids2, __pyx_v_chunk_ids1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 739, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_added_ids = __pyx_t_1;
+  __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":718
+  /* "borg/item.pyx":740
  *         chunk_ids2 = {c.id for c in self._item2.chunks}
  *         added_ids = chunk_ids2 - chunk_ids1
  *         removed_ids = chunk_ids1 - chunk_ids2             # <<<<<<<<<<<<<<
  *         added = self._item2.get_size(consider_ids=added_ids)
  *         removed = self._item1.get_size(consider_ids=removed_ids)
  */
-  __pyx_t_2 = PyNumber_Subtract(__pyx_v_chunk_ids1, __pyx_v_chunk_ids2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 718, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_v_removed_ids = __pyx_t_2;
-  __pyx_t_2 = 0;
+  __pyx_t_1 = PyNumber_Subtract(__pyx_v_chunk_ids1, __pyx_v_chunk_ids2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 740, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_removed_ids = __pyx_t_1;
+  __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":719
+  /* "borg/item.pyx":741
  *         added_ids = chunk_ids2 - chunk_ids1
  *         removed_ids = chunk_ids1 - chunk_ids2
  *         added = self._item2.get_size(consider_ids=added_ids)             # <<<<<<<<<<<<<<
  *         removed = self._item1.get_size(consider_ids=removed_ids)
- *         return ({"type": "modified", "added": added, "removed": removed},
+ *         self._changes['content'] = DiffChange("modified", {"added": added, "removed": removed})
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 719, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 719, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 719, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 741, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_consider_ids, __pyx_v_added_ids) < 0) __PYX_ERR(0, 719, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_empty_tuple, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 719, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_consider_ids, __pyx_v_added_ids) < 0) __PYX_ERR(0, 741, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 741, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_v_added = __pyx_t_3;
-  __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_added = __pyx_t_5;
+  __pyx_t_5 = 0;
 
-  /* "borg/item.pyx":720
+  /* "borg/item.pyx":742
  *         removed_ids = chunk_ids1 - chunk_ids2
  *         added = self._item2.get_size(consider_ids=added_ids)
  *         removed = self._item1.get_size(consider_ids=removed_ids)             # <<<<<<<<<<<<<<
- *         return ({"type": "modified", "added": added, "removed": removed},
- *             '{:>9} {:>9}'.format(format_file_size(added, precision=1, sign=True),
- */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 720, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 720, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 720, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_consider_ids, __pyx_v_removed_ids) < 0) __PYX_ERR(0, 720, __pyx_L1_error)
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 720, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_v_removed = __pyx_t_1;
-  __pyx_t_1 = 0;
-
-  /* "borg/item.pyx":721
- *         added = self._item2.get_size(consider_ids=added_ids)
- *         removed = self._item1.get_size(consider_ids=removed_ids)
- *         return ({"type": "modified", "added": added, "removed": removed},             # <<<<<<<<<<<<<<
- *             '{:>9} {:>9}'.format(format_file_size(added, precision=1, sign=True),
- *             format_file_size(-removed, precision=1, sign=True)))
+ *         self._changes['content'] = DiffChange("modified", {"added": added, "removed": removed})
+ *         return True
  */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 721, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_get_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 742, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_type, __pyx_n_s_modified) < 0) __PYX_ERR(0, 721, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_added_2, __pyx_v_added) < 0) __PYX_ERR(0, 721, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_removed_2, __pyx_v_removed) < 0) __PYX_ERR(0, 721, __pyx_L1_error)
-
-  /* "borg/item.pyx":722
- *         removed = self._item1.get_size(consider_ids=removed_ids)
- *         return ({"type": "modified", "added": added, "removed": removed},
- *             '{:>9} {:>9}'.format(format_file_size(added, precision=1, sign=True),             # <<<<<<<<<<<<<<
- *             format_file_size(-removed, precision=1, sign=True)))
- * 
- */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_9_9, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 722, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_format_file_size); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 722, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 742, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 722, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __Pyx_INCREF(__pyx_v_added);
-  __Pyx_GIVEREF(__pyx_v_added);
-  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_added);
-  __pyx_t_7 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 722, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_precision, __pyx_int_1) < 0) __PYX_ERR(0, 722, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_sign, Py_True) < 0) __PYX_ERR(0, 722, __pyx_L1_error)
-  __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 722, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_11);
+  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_consider_ids, __pyx_v_removed_ids) < 0) __PYX_ERR(0, 742, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_empty_tuple, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_v_removed = __pyx_t_2;
+  __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":723
- *         return ({"type": "modified", "added": added, "removed": removed},
- *             '{:>9} {:>9}'.format(format_file_size(added, precision=1, sign=True),
- *             format_file_size(-removed, precision=1, sign=True)))             # <<<<<<<<<<<<<<
+  /* "borg/item.pyx":743
+ *         added = self._item2.get_size(consider_ids=added_ids)
+ *         removed = self._item1.get_size(consider_ids=removed_ids)
+ *         self._changes['content'] = DiffChange("modified", {"added": added, "removed": removed})             # <<<<<<<<<<<<<<
+ *         return True
  * 
- *     def _owner_diff(self):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_format_file_size); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 723, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_6 = PyNumber_Negative(__pyx_v_removed); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 723, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 723, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 743, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_GIVEREF(__pyx_t_6);
-  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6);
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 743, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_added_2, __pyx_v_added) < 0) __PYX_ERR(0, 743, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_removed_2, __pyx_v_removed) < 0) __PYX_ERR(0, 743, __pyx_L1_error)
+  __pyx_t_7 = NULL;
   __pyx_t_6 = 0;
-  __pyx_t_6 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 723, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_precision, __pyx_int_1) < 0) __PYX_ERR(0, 723, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_sign, Py_True) < 0) __PYX_ERR(0, 723, __pyx_L1_error)
-  __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 723, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_6 = NULL;
-  __pyx_t_13 = 0;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_6)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_6);
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
+    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
+    if (likely(__pyx_t_7)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+      __Pyx_INCREF(__pyx_t_7);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-      __pyx_t_13 = 1;
+      __Pyx_DECREF_SET(__pyx_t_5, function);
+      __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
-  if (PyFunction_Check(__pyx_t_2)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_11, __pyx_t_12};
-    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_13, 2+__pyx_t_13); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 722, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+  if (PyFunction_Check(__pyx_t_5)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_n_s_modified, __pyx_t_1};
+    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 743, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
-  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_11, __pyx_t_12};
-    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_13, 2+__pyx_t_13); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 722, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_n_s_modified, __pyx_t_1};
+    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 743, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_13); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 722, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    if (__pyx_t_6) {
-      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6); __pyx_t_6 = NULL;
-    }
-    __Pyx_GIVEREF(__pyx_t_11);
-    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_13, __pyx_t_11);
-    __Pyx_GIVEREF(__pyx_t_12);
-    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_13, __pyx_t_12);
-    __pyx_t_11 = 0;
-    __pyx_t_12 = 0;
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 722, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 743, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (__pyx_t_7) {
+      __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_7); __pyx_t_7 = NULL;
+    }
+    __Pyx_INCREF(__pyx_n_s_modified);
+    __Pyx_GIVEREF(__pyx_n_s_modified);
+    PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_6, __pyx_n_s_modified);
+    __Pyx_GIVEREF(__pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_6, __pyx_t_1);
+    __pyx_t_1 = 0;
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 743, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 743, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  if (unlikely(PyObject_SetItem(__pyx_t_5, __pyx_n_s_content, __pyx_t_2) < 0)) __PYX_ERR(0, 743, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":721
- *         added = self._item2.get_size(consider_ids=added_ids)
+  /* "borg/item.pyx":744
  *         removed = self._item1.get_size(consider_ids=removed_ids)
- *         return ({"type": "modified", "added": added, "removed": removed},             # <<<<<<<<<<<<<<
- *             '{:>9} {:>9}'.format(format_file_size(added, precision=1, sign=True),
- *             format_file_size(-removed, precision=1, sign=True)))
+ *         self._changes['content'] = DiffChange("modified", {"added": added, "removed": removed})
+ *         return True             # <<<<<<<<<<<<<<
+ * 
+ * 
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 721, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);
-  __pyx_t_1 = 0;
-  __pyx_t_3 = 0;
-  __pyx_r = __pyx_t_2;
-  __pyx_t_2 = 0;
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(Py_True);
+  __pyx_r = Py_True;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":706
- *             return ({"type": 'changed link'}, 'changed link')
+  /* "borg/item.pyx":725
+ *             return True
  * 
  *     def _content_diff(self):             # <<<<<<<<<<<<<<
  *         if self._item1.get('deleted'):
  *             sz = self._item2.get_size()
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_11);
-  __Pyx_XDECREF(__pyx_t_12);
   __Pyx_AddTraceback("borg.item.ItemDiff._content_diff", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_sz);
   __Pyx_XDECREF(__pyx_v_chunk_ids1);
   __Pyx_XDECREF(__pyx_v_chunk_ids2);
   __Pyx_XDECREF(__pyx_v_added_ids);
   __Pyx_XDECREF(__pyx_v_removed_ids);
   __Pyx_XDECREF(__pyx_v_added);
   __Pyx_XDECREF(__pyx_v_removed);
-  __Pyx_XDECREF(__pyx_8genexpr9__pyx_v_c);
-  __Pyx_XDECREF(__pyx_9genexpr10__pyx_v_c);
+  __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_c);
+  __Pyx_XDECREF(__pyx_8genexpr8__pyx_v_c);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":725
- *             format_file_size(-removed, precision=1, sign=True)))
+/* "borg/item.pyx":747
+ * 
  * 
  *     def _owner_diff(self):             # <<<<<<<<<<<<<<
  *         u_attr, g_attr = ('uid', 'gid') if self._numeric_ids else ('user', 'group')
  *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
  */
 
 /* Python wrapper */
@@ -18325,310 +18379,494 @@
   int __pyx_t_6;
   PyObject *__pyx_t_7 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_owner_diff", 0);
 
-  /* "borg/item.pyx":726
+  /* "borg/item.pyx":748
  * 
  *     def _owner_diff(self):
  *         u_attr, g_attr = ('uid', 'gid') if self._numeric_ids else ('user', 'group')             # <<<<<<<<<<<<<<
  *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
  *         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_numeric_ids_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 726, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_numeric_ids_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 748, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 726, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 748, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (__pyx_t_3) {
     __Pyx_INCREF(__pyx_tuple__21);
     __pyx_t_1 = __pyx_tuple__21;
   } else {
     __Pyx_INCREF(__pyx_tuple__22);
     __pyx_t_1 = __pyx_tuple__22;
   }
   if (likely(__pyx_t_1 != Py_None)) {
     PyObject* sequence = __pyx_t_1;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 726, __pyx_L1_error)
+      __PYX_ERR(0, 748, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
     __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_t_4);
     #else
-    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 726, __pyx_L1_error)
+    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 748, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 726, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 748, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     #endif
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(0, 726, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(0, 748, __pyx_L1_error)
   }
   __pyx_v_u_attr = __pyx_t_2;
   __pyx_t_2 = 0;
   __pyx_v_g_attr = __pyx_t_4;
   __pyx_t_4 = 0;
 
-  /* "borg/item.pyx":727
+  /* "borg/item.pyx":749
  *     def _owner_diff(self):
  *         u_attr, g_attr = ('uid', 'gid') if self._numeric_ids else ('user', 'group')
  *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)             # <<<<<<<<<<<<<<
  *         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)
- *         if (u1, g1) != (u2, g2):
+ *         if (u1, g1) == (u2, g2):
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 727, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 749, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 727, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 749, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v_u_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_u_attr);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 727, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 749, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 727, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 749, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 727, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 749, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
     }
   }
   __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_g_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_g_attr);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 727, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 749, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_v_u1 = __pyx_t_1;
   __pyx_t_1 = 0;
   __pyx_v_g1 = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":728
+  /* "borg/item.pyx":750
  *         u_attr, g_attr = ('uid', 'gid') if self._numeric_ids else ('user', 'group')
  *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
  *         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)             # <<<<<<<<<<<<<<
- *         if (u1, g1) != (u2, g2):
- *             return ({"type": "owner", "old_user": u1, "old_group": g1, "new_user": u2, "new_group": g2},
+ *         if (u1, g1) == (u2, g2):
+ *             return False
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 728, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 750, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 728, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 750, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_1)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_1);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
     }
   }
   __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_v_u_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_u_attr);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 728, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 750, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 728, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 750, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 728, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 750, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_1)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_1);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_5 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_1, __pyx_v_g_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_g_attr);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 728, __pyx_L1_error)
+  if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 750, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_v_u2 = __pyx_t_2;
   __pyx_t_2 = 0;
   __pyx_v_g2 = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "borg/item.pyx":729
+  /* "borg/item.pyx":751
  *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
  *         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)
- *         if (u1, g1) != (u2, g2):             # <<<<<<<<<<<<<<
- *             return ({"type": "owner", "old_user": u1, "old_group": g1, "new_user": u2, "new_group": g2},
- *                     '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))
+ *         if (u1, g1) == (u2, g2):             # <<<<<<<<<<<<<<
+ *             return False
+ *         self._changes['owner'] = DiffChange("changed owner", {"item1": (u1, g1), "item2": (u2, g2)})
  */
-  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 729, __pyx_L1_error)
+  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 751, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_INCREF(__pyx_v_u1);
   __Pyx_GIVEREF(__pyx_v_u1);
   PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_u1);
   __Pyx_INCREF(__pyx_v_g1);
   __Pyx_GIVEREF(__pyx_v_g1);
   PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_g1);
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 729, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 751, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_v_u2);
   __Pyx_GIVEREF(__pyx_v_u2);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_u2);
   __Pyx_INCREF(__pyx_v_g2);
   __Pyx_GIVEREF(__pyx_v_g2);
   PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_g2);
-  __pyx_t_4 = PyObject_RichCompare(__pyx_t_5, __pyx_t_2, Py_NE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 729, __pyx_L1_error)
+  __pyx_t_4 = PyObject_RichCompare(__pyx_t_5, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 751, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 729, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 751, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   if (__pyx_t_3) {
 
-    /* "borg/item.pyx":730
+    /* "borg/item.pyx":752
  *         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)
- *         if (u1, g1) != (u2, g2):
- *             return ({"type": "owner", "old_user": u1, "old_group": g1, "new_user": u2, "new_group": g2},             # <<<<<<<<<<<<<<
- *                     '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))
- * 
+ *         if (u1, g1) == (u2, g2):
+ *             return False             # <<<<<<<<<<<<<<
+ *         self._changes['owner'] = DiffChange("changed owner", {"item1": (u1, g1), "item2": (u2, g2)})
+ *         if u1 != u2:
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 730, __pyx_L1_error)
+    __Pyx_INCREF(Py_False);
+    __pyx_r = Py_False;
+    goto __pyx_L0;
+
+    /* "borg/item.pyx":751
+ *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
+ *         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)
+ *         if (u1, g1) == (u2, g2):             # <<<<<<<<<<<<<<
+ *             return False
+ *         self._changes['owner'] = DiffChange("changed owner", {"item1": (u1, g1), "item2": (u2, g2)})
+ */
+  }
+
+  /* "borg/item.pyx":753
+ *         if (u1, g1) == (u2, g2):
+ *             return False
+ *         self._changes['owner'] = DiffChange("changed owner", {"item1": (u1, g1), "item2": (u2, g2)})             # <<<<<<<<<<<<<<
+ *         if u1 != u2:
+ *             self._changes['user'] = DiffChange("changed user", {"item1": u1, "item2": u2})
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 753, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_5 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 753, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 753, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_v_u1);
+  __Pyx_GIVEREF(__pyx_v_u1);
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_u1);
+  __Pyx_INCREF(__pyx_v_g1);
+  __Pyx_GIVEREF(__pyx_v_g1);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_g1);
+  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_item1, __pyx_t_1) < 0) __PYX_ERR(0, 753, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 753, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_v_u2);
+  __Pyx_GIVEREF(__pyx_v_u2);
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_u2);
+  __Pyx_INCREF(__pyx_v_g2);
+  __Pyx_GIVEREF(__pyx_v_g2);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_g2);
+  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_item2, __pyx_t_1) < 0) __PYX_ERR(0, 753, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = NULL;
+  __pyx_t_6 = 0;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_1)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_1);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __pyx_t_6 = 1;
+    }
+  }
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_kp_s_changed_owner, __pyx_t_5};
+    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 753, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_type, __pyx_n_s_owner) < 0) __PYX_ERR(0, 730, __pyx_L1_error)
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_old_user, __pyx_v_u1) < 0) __PYX_ERR(0, 730, __pyx_L1_error)
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_old_group, __pyx_v_g1) < 0) __PYX_ERR(0, 730, __pyx_L1_error)
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_new_user, __pyx_v_u2) < 0) __PYX_ERR(0, 730, __pyx_L1_error)
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_new_group, __pyx_v_g2) < 0) __PYX_ERR(0, 730, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  } else
+  #endif
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_kp_s_changed_owner, __pyx_t_5};
+    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 753, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  } else
+  #endif
+  {
+    __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 753, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    if (__pyx_t_1) {
+      __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1); __pyx_t_1 = NULL;
+    }
+    __Pyx_INCREF(__pyx_kp_s_changed_owner);
+    __Pyx_GIVEREF(__pyx_kp_s_changed_owner);
+    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_kp_s_changed_owner);
+    __Pyx_GIVEREF(__pyx_t_5);
+    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_5);
+    __pyx_t_5 = 0;
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 753, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  }
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 753, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (unlikely(PyObject_SetItem(__pyx_t_2, __pyx_n_s_owner, __pyx_t_4) < 0)) __PYX_ERR(0, 753, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "borg/item.pyx":731
- *         if (u1, g1) != (u2, g2):
- *             return ({"type": "owner", "old_user": u1, "old_group": g1, "new_user": u2, "new_group": g2},
- *                     '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))             # <<<<<<<<<<<<<<
- * 
- *     def _mode_diff(self):
+  /* "borg/item.pyx":754
+ *             return False
+ *         self._changes['owner'] = DiffChange("changed owner", {"item1": (u1, g1), "item2": (u2, g2)})
+ *         if u1 != u2:             # <<<<<<<<<<<<<<
+ *             self._changes['user'] = DiffChange("changed user", {"item1": u1, "item2": u2})
+ *         if g1 != g2:
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s__23, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 731, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = NULL;
+  __pyx_t_4 = PyObject_RichCompare(__pyx_v_u1, __pyx_v_u2, Py_NE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 754, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 754, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (__pyx_t_3) {
+
+    /* "borg/item.pyx":755
+ *         self._changes['owner'] = DiffChange("changed owner", {"item1": (u1, g1), "item2": (u2, g2)})
+ *         if u1 != u2:
+ *             self._changes['user'] = DiffChange("changed user", {"item1": u1, "item2": u2})             # <<<<<<<<<<<<<<
+ *         if g1 != g2:
+ *             self._changes['group'] = DiffChange("changed group", {"item1": g1, "item2": g2})
+ */
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 755, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_7 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 755, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_item1, __pyx_v_u1) < 0) __PYX_ERR(0, 755, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_item2, __pyx_v_u2) < 0) __PYX_ERR(0, 755, __pyx_L1_error)
+    __pyx_t_5 = NULL;
     __pyx_t_6 = 0;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
-      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
-      if (likely(__pyx_t_1)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-        __Pyx_INCREF(__pyx_t_1);
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_5, function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
         __pyx_t_6 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(__pyx_t_5)) {
-      PyObject *__pyx_temp[5] = {__pyx_t_1, __pyx_v_u1, __pyx_v_g1, __pyx_v_u2, __pyx_v_g2};
-      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_6, 4+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 731, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_GOTREF(__pyx_t_2);
+    if (PyFunction_Check(__pyx_t_2)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_kp_s_changed_user, __pyx_t_7};
+      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 755, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
-    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
-      PyObject *__pyx_temp[5] = {__pyx_t_1, __pyx_v_u1, __pyx_v_g1, __pyx_v_u2, __pyx_v_g2};
-      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_6, 4+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 731, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_GOTREF(__pyx_t_2);
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_kp_s_changed_user, __pyx_t_7};
+      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 755, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     } else
     #endif
     {
-      __pyx_t_7 = PyTuple_New(4+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 731, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      if (__pyx_t_1) {
-        __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1); __pyx_t_1 = NULL;
+      __pyx_t_1 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 755, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (__pyx_t_5) {
+        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
-      __Pyx_INCREF(__pyx_v_u1);
-      __Pyx_GIVEREF(__pyx_v_u1);
-      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_u1);
-      __Pyx_INCREF(__pyx_v_g1);
-      __Pyx_GIVEREF(__pyx_v_g1);
-      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_g1);
-      __Pyx_INCREF(__pyx_v_u2);
-      __Pyx_GIVEREF(__pyx_v_u2);
-      PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_v_u2);
-      __Pyx_INCREF(__pyx_v_g2);
-      __Pyx_GIVEREF(__pyx_v_g2);
-      PyTuple_SET_ITEM(__pyx_t_7, 3+__pyx_t_6, __pyx_v_g2);
-      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 731, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __Pyx_INCREF(__pyx_kp_s_changed_user);
+      __Pyx_GIVEREF(__pyx_kp_s_changed_user);
+      PyTuple_SET_ITEM(__pyx_t_1, 0+__pyx_t_6, __pyx_kp_s_changed_user);
+      __Pyx_GIVEREF(__pyx_t_7);
+      PyTuple_SET_ITEM(__pyx_t_1, 1+__pyx_t_6, __pyx_t_7);
+      __pyx_t_7 = 0;
+      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 755, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     }
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 755, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    if (unlikely(PyObject_SetItem(__pyx_t_2, __pyx_n_s_user, __pyx_t_4) < 0)) __PYX_ERR(0, 755, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "borg/item.pyx":730
- *         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)
- *         if (u1, g1) != (u2, g2):
- *             return ({"type": "owner", "old_user": u1, "old_group": g1, "new_user": u2, "new_group": g2},             # <<<<<<<<<<<<<<
- *                     '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))
+    /* "borg/item.pyx":754
+ *             return False
+ *         self._changes['owner'] = DiffChange("changed owner", {"item1": (u1, g1), "item2": (u2, g2)})
+ *         if u1 != u2:             # <<<<<<<<<<<<<<
+ *             self._changes['user'] = DiffChange("changed user", {"item1": u1, "item2": u2})
+ *         if g1 != g2:
+ */
+  }
+
+  /* "borg/item.pyx":756
+ *         if u1 != u2:
+ *             self._changes['user'] = DiffChange("changed user", {"item1": u1, "item2": u2})
+ *         if g1 != g2:             # <<<<<<<<<<<<<<
+ *             self._changes['group'] = DiffChange("changed group", {"item1": g1, "item2": g2})
+ *         return True
+ */
+  __pyx_t_4 = PyObject_RichCompare(__pyx_v_g1, __pyx_v_g2, Py_NE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 756, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 756, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (__pyx_t_3) {
+
+    /* "borg/item.pyx":757
+ *             self._changes['user'] = DiffChange("changed user", {"item1": u1, "item2": u2})
+ *         if g1 != g2:
+ *             self._changes['group'] = DiffChange("changed group", {"item1": g1, "item2": g2})             # <<<<<<<<<<<<<<
+ *         return True
  * 
  */
-    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 730, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_GIVEREF(__pyx_t_4);
-    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
-    __pyx_t_4 = 0;
-    __pyx_t_2 = 0;
-    __pyx_r = __pyx_t_5;
-    __pyx_t_5 = 0;
-    goto __pyx_L0;
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 757, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_1 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 757, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_item1, __pyx_v_g1) < 0) __PYX_ERR(0, 757, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_item2, __pyx_v_g2) < 0) __PYX_ERR(0, 757, __pyx_L1_error)
+    __pyx_t_7 = NULL;
+    __pyx_t_6 = 0;
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
+      if (likely(__pyx_t_7)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+        __Pyx_INCREF(__pyx_t_7);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_2, function);
+        __pyx_t_6 = 1;
+      }
+    }
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(__pyx_t_2)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_kp_s_changed_group, __pyx_t_1};
+      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 757, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    } else
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_kp_s_changed_group, __pyx_t_1};
+      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 757, __pyx_L1_error)
+      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    } else
+    #endif
+    {
+      __pyx_t_5 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 757, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      if (__pyx_t_7) {
+        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_7); __pyx_t_7 = NULL;
+      }
+      __Pyx_INCREF(__pyx_kp_s_changed_group);
+      __Pyx_GIVEREF(__pyx_kp_s_changed_group);
+      PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_6, __pyx_kp_s_changed_group);
+      __Pyx_GIVEREF(__pyx_t_1);
+      PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_6, __pyx_t_1);
+      __pyx_t_1 = 0;
+      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 757, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    }
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 757, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    if (unlikely(PyObject_SetItem(__pyx_t_2, __pyx_n_s_group, __pyx_t_4) < 0)) __PYX_ERR(0, 757, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "borg/item.pyx":729
- *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
- *         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)
- *         if (u1, g1) != (u2, g2):             # <<<<<<<<<<<<<<
- *             return ({"type": "owner", "old_user": u1, "old_group": g1, "new_user": u2, "new_group": g2},
- *                     '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))
+    /* "borg/item.pyx":756
+ *         if u1 != u2:
+ *             self._changes['user'] = DiffChange("changed user", {"item1": u1, "item2": u2})
+ *         if g1 != g2:             # <<<<<<<<<<<<<<
+ *             self._changes['group'] = DiffChange("changed group", {"item1": g1, "item2": g2})
+ *         return True
  */
   }
 
-  /* "borg/item.pyx":725
- *             format_file_size(-removed, precision=1, sign=True)))
+  /* "borg/item.pyx":758
+ *         if g1 != g2:
+ *             self._changes['group'] = DiffChange("changed group", {"item1": g1, "item2": g2})
+ *         return True             # <<<<<<<<<<<<<<
+ * 
+ *     def _mode_diff(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(Py_True);
+  __pyx_r = Py_True;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":747
+ * 
  * 
  *     def _owner_diff(self):             # <<<<<<<<<<<<<<
  *         u_attr, g_attr = ('uid', 'gid') if self._numeric_ids else ('user', 'group')
  *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
  */
 
   /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_AddTraceback("borg.item.ItemDiff._owner_diff", __pyx_clineno, __pyx_lineno, __pyx_filename);
@@ -18641,16 +18879,16 @@
   __Pyx_XDECREF(__pyx_v_u2);
   __Pyx_XDECREF(__pyx_v_g2);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":733
- *                     '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))
+/* "borg/item.pyx":760
+ *         return True
  * 
  *     def _mode_diff(self):             # <<<<<<<<<<<<<<
  *         if 'mode' in self._item1 and 'mode' in self._item2 and self._item1.mode != self._item2.mode:
  *             mode1 = stat.filemode(self._item1.mode)
  */
 
 /* Python wrapper */
@@ -18682,75 +18920,75 @@
   int __pyx_t_8;
   PyObject *__pyx_t_9 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_mode_diff", 0);
 
-  /* "borg/item.pyx":734
+  /* "borg/item.pyx":761
  * 
  *     def _mode_diff(self):
  *         if 'mode' in self._item1 and 'mode' in self._item2 and self._item1.mode != self._item2.mode:             # <<<<<<<<<<<<<<
  *             mode1 = stat.filemode(self._item1.mode)
  *             mode2 = stat.filemode(self._item2.mode)
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_mode, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_3 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_mode, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_4 = (__pyx_t_3 != 0);
   if (__pyx_t_4) {
   } else {
     __pyx_t_1 = __pyx_t_4;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_mode, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_4 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_mode, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_3 = (__pyx_t_4 != 0);
   if (__pyx_t_3) {
   } else {
     __pyx_t_1 = __pyx_t_3;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_mode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_mode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_mode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_mode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyObject_RichCompare(__pyx_t_5, __pyx_t_6, Py_NE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_2 = PyObject_RichCompare(__pyx_t_5, __pyx_t_6, Py_NE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 734, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 761, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_1 = __pyx_t_3;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "borg/item.pyx":735
+    /* "borg/item.pyx":762
  *     def _mode_diff(self):
  *         if 'mode' in self._item1 and 'mode' in self._item2 and self._item1.mode != self._item2.mode:
  *             mode1 = stat.filemode(self._item1.mode)             # <<<<<<<<<<<<<<
  *             mode2 = stat.filemode(self._item2.mode)
- *             return ({"type": "mode", "old_mode": mode1, "new_mode": mode2}, '[{} -> {}]'.format(mode1, mode2))
+ *             self._changes['mode'] = DiffChange("changed mode", {"item1": mode1, "item2": mode2})
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_stat); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 735, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_stat); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 762, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_filemode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 735, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_filemode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 762, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 735, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 762, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_mode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 735, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_mode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 762, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     __pyx_t_6 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_6)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -18758,35 +18996,35 @@
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_7);
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 735, __pyx_L1_error)
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 762, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_mode1 = __pyx_t_2;
     __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":736
+    /* "borg/item.pyx":763
  *         if 'mode' in self._item1 and 'mode' in self._item2 and self._item1.mode != self._item2.mode:
  *             mode1 = stat.filemode(self._item1.mode)
  *             mode2 = stat.filemode(self._item2.mode)             # <<<<<<<<<<<<<<
- *             return ({"type": "mode", "old_mode": mode1, "new_mode": mode2}, '[{} -> {}]'.format(mode1, mode2))
- * 
+ *             self._changes['mode'] = DiffChange("changed mode", {"item1": mode1, "item2": mode2})
+ *             if mode1[0] != mode2[0]:
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_stat); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 736, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_stat); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 763, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_filemode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 736, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_filemode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 763, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 736, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 763, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_mode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 736, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_mode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 763, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
@@ -18794,103 +19032,196 @@
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
     __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_5, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 736, __pyx_L1_error)
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 763, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __pyx_v_mode2 = __pyx_t_2;
     __pyx_t_2 = 0;
 
-    /* "borg/item.pyx":737
+    /* "borg/item.pyx":764
  *             mode1 = stat.filemode(self._item1.mode)
  *             mode2 = stat.filemode(self._item2.mode)
- *             return ({"type": "mode", "old_mode": mode1, "new_mode": mode2}, '[{} -> {}]'.format(mode1, mode2))             # <<<<<<<<<<<<<<
- * 
- *     def _content_equal(self, chunk_iterator1, chunk_iterator2):
+ *             self._changes['mode'] = DiffChange("changed mode", {"item1": mode1, "item2": mode2})             # <<<<<<<<<<<<<<
+ *             if mode1[0] != mode2[0]:
+ *                 self._changes['type'] = DiffChange("changed type", {"item1": mode1[0], "item2": mode2[0]})
  */
-    __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 737, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, __pyx_n_s_mode) < 0) __PYX_ERR(0, 737, __pyx_L1_error)
-    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_old_mode, __pyx_v_mode1) < 0) __PYX_ERR(0, 737, __pyx_L1_error)
-    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_new_mode, __pyx_v_mode2) < 0) __PYX_ERR(0, 737, __pyx_L1_error)
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s__24, __pyx_n_s_format); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 737, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 764, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __pyx_t_6 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 764, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
+    if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_item1, __pyx_v_mode1) < 0) __PYX_ERR(0, 764, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_item2, __pyx_v_mode2) < 0) __PYX_ERR(0, 764, __pyx_L1_error)
     __pyx_t_5 = NULL;
     __pyx_t_8 = 0;
-    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
-      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_5)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_6, function);
+        __Pyx_DECREF_SET(__pyx_t_7, function);
         __pyx_t_8 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(__pyx_t_6)) {
-      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_mode1, __pyx_v_mode2};
-      __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 737, __pyx_L1_error)
+    if (PyFunction_Check(__pyx_t_7)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_kp_s_changed_mode, __pyx_t_6};
+      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 764, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_GOTREF(__pyx_t_7);
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
-    if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
-      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_mode1, __pyx_v_mode2};
-      __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 737, __pyx_L1_error)
+    if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
+      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_kp_s_changed_mode, __pyx_t_6};
+      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 764, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_GOTREF(__pyx_t_7);
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     } else
     #endif
     {
-      __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 737, __pyx_L1_error)
+      __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 764, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       if (__pyx_t_5) {
         __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
-      __Pyx_INCREF(__pyx_v_mode1);
-      __Pyx_GIVEREF(__pyx_v_mode1);
-      PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_v_mode1);
-      __Pyx_INCREF(__pyx_v_mode2);
-      __Pyx_GIVEREF(__pyx_v_mode2);
-      PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_v_mode2);
-      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_9, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 737, __pyx_L1_error)
+      __Pyx_INCREF(__pyx_kp_s_changed_mode);
+      __Pyx_GIVEREF(__pyx_kp_s_changed_mode);
+      PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_kp_s_changed_mode);
+      __Pyx_GIVEREF(__pyx_t_6);
+      PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_t_6);
+      __pyx_t_6 = 0;
+      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 764, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+    }
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 764, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    if (unlikely(PyObject_SetItem(__pyx_t_7, __pyx_n_s_mode, __pyx_t_2) < 0)) __PYX_ERR(0, 764, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+    /* "borg/item.pyx":765
+ *             mode2 = stat.filemode(self._item2.mode)
+ *             self._changes['mode'] = DiffChange("changed mode", {"item1": mode1, "item2": mode2})
+ *             if mode1[0] != mode2[0]:             # <<<<<<<<<<<<<<
+ *                 self._changes['type'] = DiffChange("changed type", {"item1": mode1[0], "item2": mode2[0]})
+ * 
+ */
+    __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_mode1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 765, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_7 = __Pyx_GetItemInt(__pyx_v_mode2, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 765, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __pyx_t_9 = PyObject_RichCompare(__pyx_t_2, __pyx_t_7, Py_NE); __Pyx_XGOTREF(__pyx_t_9); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 765, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 765, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+    if (__pyx_t_1) {
+
+      /* "borg/item.pyx":766
+ *             self._changes['mode'] = DiffChange("changed mode", {"item1": mode1, "item2": mode2})
+ *             if mode1[0] != mode2[0]:
+ *                 self._changes['type'] = DiffChange("changed type", {"item1": mode1[0], "item2": mode2[0]})             # <<<<<<<<<<<<<<
+ * 
+ *     def _time_diffs(self):
+ */
+      __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 766, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_t_2 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 766, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_6 = __Pyx_GetItemInt(__pyx_v_mode1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 766, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_item1, __pyx_t_6) < 0) __PYX_ERR(0, 766, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __pyx_t_6 = __Pyx_GetItemInt(__pyx_v_mode2, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 766, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_item2, __pyx_t_6) < 0) __PYX_ERR(0, 766, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __pyx_t_6 = NULL;
+      __pyx_t_8 = 0;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
+        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_7);
+        if (likely(__pyx_t_6)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+          __Pyx_INCREF(__pyx_t_6);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_7, function);
+          __pyx_t_8 = 1;
+        }
+      }
+      #if CYTHON_FAST_PYCALL
+      if (PyFunction_Check(__pyx_t_7)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_kp_s_changed_type, __pyx_t_2};
+        __pyx_t_9 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 766, __pyx_L1_error)
+        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+        __Pyx_GOTREF(__pyx_t_9);
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      } else
+      #endif
+      #if CYTHON_FAST_PYCCALL
+      if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_kp_s_changed_type, __pyx_t_2};
+        __pyx_t_9 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 766, __pyx_L1_error)
+        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+        __Pyx_GOTREF(__pyx_t_9);
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      } else
+      #endif
+      {
+        __pyx_t_5 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 766, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_5);
+        if (__pyx_t_6) {
+          __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_6); __pyx_t_6 = NULL;
+        }
+        __Pyx_INCREF(__pyx_kp_s_changed_type);
+        __Pyx_GIVEREF(__pyx_kp_s_changed_type);
+        PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_8, __pyx_kp_s_changed_type);
+        __Pyx_GIVEREF(__pyx_t_2);
+        PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_8, __pyx_t_2);
+        __pyx_t_2 = 0;
+        __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_5, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 766, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_9);
+        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      }
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 766, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_7);
+      if (unlikely(PyObject_SetItem(__pyx_t_7, __pyx_n_s_type, __pyx_t_9) < 0)) __PYX_ERR(0, 766, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+
+      /* "borg/item.pyx":765
+ *             mode2 = stat.filemode(self._item2.mode)
+ *             self._changes['mode'] = DiffChange("changed mode", {"item1": mode1, "item2": mode2})
+ *             if mode1[0] != mode2[0]:             # <<<<<<<<<<<<<<
+ *                 self._changes['type'] = DiffChange("changed type", {"item1": mode1[0], "item2": mode2[0]})
+ * 
+ */
     }
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 737, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_GIVEREF(__pyx_t_2);
-    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_2);
-    __Pyx_GIVEREF(__pyx_t_7);
-    PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_7);
-    __pyx_t_2 = 0;
-    __pyx_t_7 = 0;
-    __pyx_r = __pyx_t_6;
-    __pyx_t_6 = 0;
-    goto __pyx_L0;
 
-    /* "borg/item.pyx":734
+    /* "borg/item.pyx":761
  * 
  *     def _mode_diff(self):
  *         if 'mode' in self._item1 and 'mode' in self._item2 and self._item1.mode != self._item2.mode:             # <<<<<<<<<<<<<<
  *             mode1 = stat.filemode(self._item1.mode)
  *             mode2 = stat.filemode(self._item2.mode)
  */
   }
 
-  /* "borg/item.pyx":733
- *                     '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))
+  /* "borg/item.pyx":760
+ *         return True
  * 
  *     def _mode_diff(self):             # <<<<<<<<<<<<<<
  *         if 'mode' in self._item1 and 'mode' in self._item2 and self._item1.mode != self._item2.mode:
  *             mode1 = stat.filemode(self._item1.mode)
  */
 
   /* function exit code */
@@ -18908,316 +19239,1373 @@
   __Pyx_XDECREF(__pyx_v_mode1);
   __Pyx_XDECREF(__pyx_v_mode2);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":739
- *             return ({"type": "mode", "old_mode": mode1, "new_mode": mode2}, '[{} -> {}]'.format(mode1, mode2))
+/* "borg/item.pyx":768
+ *                 self._changes['type'] = DiffChange("changed type", {"item1": mode1[0], "item2": mode2[0]})
  * 
- *     def _content_equal(self, chunk_iterator1, chunk_iterator2):             # <<<<<<<<<<<<<<
- *         if self._can_compare_chunk_ids:
- *             return self._item1.chunks == self._item2.chunks
+ *     def _time_diffs(self):             # <<<<<<<<<<<<<<
+ *         attrs = ["ctime", "mtime"]
+ *         for attr in attrs:
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4borg_4item_8ItemDiff_19_content_equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_19_content_equal = {"_content_equal", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_4item_8ItemDiff_19_content_equal, METH_VARARGS|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_4borg_4item_8ItemDiff_19_content_equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  PyObject *__pyx_v_self = 0;
-  PyObject *__pyx_v_chunk_iterator1 = 0;
-  PyObject *__pyx_v_chunk_iterator2 = 0;
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_19_time_diffs(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_19_time_diffs = {"_time_diffs", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_19_time_diffs, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_19_time_diffs(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("_time_diffs (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_18_time_diffs(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_18_time_diffs(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_v_attrs = NULL;
+  PyObject *__pyx_v_attr = NULL;
+  PyObject *__pyx_v_ts1 = NULL;
+  PyObject *__pyx_v_ts2 = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  int __pyx_t_13;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  PyObject *__pyx_r = 0;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("_content_equal (wrapper)", 0);
-  {
-    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_chunk_iterator1,&__pyx_n_s_chunk_iterator2,0};
-    PyObject* values[3] = {0,0,0};
-    if (unlikely(__pyx_kwds)) {
-      Py_ssize_t kw_args;
-      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
-      switch (pos_args) {
-        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
+  __Pyx_RefNannySetupContext("_time_diffs", 0);
+
+  /* "borg/item.pyx":769
+ * 
+ *     def _time_diffs(self):
+ *         attrs = ["ctime", "mtime"]             # <<<<<<<<<<<<<<
+ *         for attr in attrs:
+ *             if attr in self._item1 and attr in self._item2 and self._item1.get(attr) != self._item2.get(attr):
+ */
+  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 769, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_n_s_ctime);
+  __Pyx_GIVEREF(__pyx_n_s_ctime);
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_ctime);
+  __Pyx_INCREF(__pyx_n_s_mtime);
+  __Pyx_GIVEREF(__pyx_n_s_mtime);
+  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_mtime);
+  __pyx_v_attrs = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":770
+ *     def _time_diffs(self):
+ *         attrs = ["ctime", "mtime"]
+ *         for attr in attrs:             # <<<<<<<<<<<<<<
+ *             if attr in self._item1 and attr in self._item2 and self._item1.get(attr) != self._item2.get(attr):
+ *                 ts1 = OutputTimestamp(safe_timestamp(self._item1.get(attr)))
+ */
+  __pyx_t_1 = __pyx_v_attrs; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
+  for (;;) {
+    if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
+    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 770, __pyx_L1_error)
+    #else
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 770, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    #endif
+    __Pyx_XDECREF_SET(__pyx_v_attr, __pyx_t_3);
+    __pyx_t_3 = 0;
+
+    /* "borg/item.pyx":771
+ *         attrs = ["ctime", "mtime"]
+ *         for attr in attrs:
+ *             if attr in self._item1 and attr in self._item2 and self._item1.get(attr) != self._item2.get(attr):             # <<<<<<<<<<<<<<
+ *                 ts1 = OutputTimestamp(safe_timestamp(self._item1.get(attr)))
+ *                 ts2 = OutputTimestamp(safe_timestamp(self._item2.get(attr)))
+ */
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_v_attr, __pyx_t_3, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_6 = (__pyx_t_5 != 0);
+    if (__pyx_t_6) {
+    } else {
+      __pyx_t_4 = __pyx_t_6;
+      goto __pyx_L6_bool_binop_done;
+    }
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_6 = (__Pyx_PySequence_ContainsTF(__pyx_v_attr, __pyx_t_3, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_5 = (__pyx_t_6 != 0);
+    if (__pyx_t_5) {
+    } else {
+      __pyx_t_4 = __pyx_t_5;
+      goto __pyx_L6_bool_binop_done;
+    }
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_get); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __pyx_t_7 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
+      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_8);
+      if (likely(__pyx_t_7)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
+        __Pyx_INCREF(__pyx_t_7);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_8, function);
       }
-      kw_args = PyDict_Size(__pyx_kwds);
-      switch (pos_args) {
-        case  0:
-        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunk_iterator1)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("_content_equal", 1, 3, 3, 1); __PYX_ERR(0, 739, __pyx_L3_error)
+    }
+    __pyx_t_3 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_7, __pyx_v_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_v_attr);
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_get); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_9);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __pyx_t_7 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_9))) {
+      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_9);
+      if (likely(__pyx_t_7)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
+        __Pyx_INCREF(__pyx_t_7);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_9, function);
+      }
+    }
+    __pyx_t_8 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_7, __pyx_v_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_v_attr);
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+    __pyx_t_9 = PyObject_RichCompare(__pyx_t_3, __pyx_t_8, Py_NE); __Pyx_XGOTREF(__pyx_t_9); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 771, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+    __pyx_t_4 = __pyx_t_5;
+    __pyx_L6_bool_binop_done:;
+    if (__pyx_t_4) {
+
+      /* "borg/item.pyx":772
+ *         for attr in attrs:
+ *             if attr in self._item1 and attr in self._item2 and self._item1.get(attr) != self._item2.get(attr):
+ *                 ts1 = OutputTimestamp(safe_timestamp(self._item1.get(attr)))             # <<<<<<<<<<<<<<
+ *                 ts2 = OutputTimestamp(safe_timestamp(self._item2.get(attr)))
+ *                 self._changes[attr] = DiffChange(attr, {"item1": ts1, "item2": ts2},)
+ */
+      __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_OutputTimestamp); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 772, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_safe_timestamp); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 772, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 772, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_11);
+      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_11, __pyx_n_s_get); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 772, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_12);
+      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+      __pyx_t_11 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_12))) {
+        __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_12);
+        if (likely(__pyx_t_11)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_12);
+          __Pyx_INCREF(__pyx_t_11);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_12, function);
         }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunk_iterator2)) != 0)) kw_args--;
-        else {
-          __Pyx_RaiseArgtupleInvalid("_content_equal", 1, 3, 3, 2); __PYX_ERR(0, 739, __pyx_L3_error)
+      }
+      __pyx_t_10 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_12, __pyx_t_11, __pyx_v_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_12, __pyx_v_attr);
+      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+      if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 772, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
+      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+      __pyx_t_12 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
+        __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_7);
+        if (likely(__pyx_t_12)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+          __Pyx_INCREF(__pyx_t_12);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_7, function);
         }
       }
-      if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_content_equal") < 0)) __PYX_ERR(0, 739, __pyx_L3_error)
+      __pyx_t_3 = (__pyx_t_12) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_12, __pyx_t_10) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_10);
+      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 772, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_t_7 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
+        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_8);
+        if (likely(__pyx_t_7)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
+          __Pyx_INCREF(__pyx_t_7);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_8, function);
+        }
       }
-    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
-      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
-      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      __pyx_t_9 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_7, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 772, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_XDECREF_SET(__pyx_v_ts1, __pyx_t_9);
+      __pyx_t_9 = 0;
+
+      /* "borg/item.pyx":773
+ *             if attr in self._item1 and attr in self._item2 and self._item1.get(attr) != self._item2.get(attr):
+ *                 ts1 = OutputTimestamp(safe_timestamp(self._item1.get(attr)))
+ *                 ts2 = OutputTimestamp(safe_timestamp(self._item2.get(attr)))             # <<<<<<<<<<<<<<
+ *                 self._changes[attr] = DiffChange(attr, {"item1": ts1, "item2": ts2},)
+ *         return True
+ */
+      __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_OutputTimestamp); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 773, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_safe_timestamp); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 773, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 773, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_12);
+      __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_12, __pyx_n_s_get); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 773, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_11);
+      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
+      __pyx_t_12 = NULL;
+      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_11))) {
+        __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_11);
+        if (likely(__pyx_t_12)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
+          __Pyx_INCREF(__pyx_t_12);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_11, function);
+        }
+      }
+      __pyx_t_10 = (__pyx_t_12) ? __Pyx_PyObject_Call2Args(__pyx_t_11, __pyx_t_12, __pyx_v_attr) : __Pyx_PyObject_CallOneArg(__pyx_t_11, __pyx_v_attr);
+      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
+      if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 773, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
+      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+      __pyx_t_11 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
+        __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_7);
+        if (likely(__pyx_t_11)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+          __Pyx_INCREF(__pyx_t_11);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_7, function);
+        }
+      }
+      __pyx_t_3 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_11, __pyx_t_10) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_10);
+      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 773, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_t_7 = NULL;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
+        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_8);
+        if (likely(__pyx_t_7)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
+          __Pyx_INCREF(__pyx_t_7);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_8, function);
+        }
+      }
+      __pyx_t_9 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_7, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_3);
+      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 773, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_9);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_XDECREF_SET(__pyx_v_ts2, __pyx_t_9);
+      __pyx_t_9 = 0;
+
+      /* "borg/item.pyx":774
+ *                 ts1 = OutputTimestamp(safe_timestamp(self._item1.get(attr)))
+ *                 ts2 = OutputTimestamp(safe_timestamp(self._item2.get(attr)))
+ *                 self._changes[attr] = DiffChange(attr, {"item1": ts1, "item2": ts2},)             # <<<<<<<<<<<<<<
+ *         return True
+ * 
+ */
+      __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_DiffChange); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 774, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 774, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_item1, __pyx_v_ts1) < 0) __PYX_ERR(0, 774, __pyx_L1_error)
+      if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_item2, __pyx_v_ts2) < 0) __PYX_ERR(0, 774, __pyx_L1_error)
+      __pyx_t_7 = NULL;
+      __pyx_t_13 = 0;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
+        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_8);
+        if (likely(__pyx_t_7)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
+          __Pyx_INCREF(__pyx_t_7);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_8, function);
+          __pyx_t_13 = 1;
+        }
+      }
+      #if CYTHON_FAST_PYCALL
+      if (PyFunction_Check(__pyx_t_8)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_attr, __pyx_t_3};
+        __pyx_t_9 = __Pyx_PyFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_13, 2+__pyx_t_13); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 774, __pyx_L1_error)
+        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_GOTREF(__pyx_t_9);
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      } else
+      #endif
+      #if CYTHON_FAST_PYCCALL
+      if (__Pyx_PyFastCFunction_Check(__pyx_t_8)) {
+        PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_attr, __pyx_t_3};
+        __pyx_t_9 = __Pyx_PyCFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_13, 2+__pyx_t_13); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 774, __pyx_L1_error)
+        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+        __Pyx_GOTREF(__pyx_t_9);
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      } else
+      #endif
+      {
+        __pyx_t_10 = PyTuple_New(2+__pyx_t_13); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 774, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_10);
+        if (__pyx_t_7) {
+          __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_7); __pyx_t_7 = NULL;
+        }
+        __Pyx_INCREF(__pyx_v_attr);
+        __Pyx_GIVEREF(__pyx_v_attr);
+        PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_13, __pyx_v_attr);
+        __Pyx_GIVEREF(__pyx_t_3);
+        PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_13, __pyx_t_3);
+        __pyx_t_3 = 0;
+        __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_10, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 774, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_9);
+        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      }
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 774, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      if (unlikely(PyObject_SetItem(__pyx_t_8, __pyx_v_attr, __pyx_t_9) < 0)) __PYX_ERR(0, 774, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
+
+      /* "borg/item.pyx":771
+ *         attrs = ["ctime", "mtime"]
+ *         for attr in attrs:
+ *             if attr in self._item1 and attr in self._item2 and self._item1.get(attr) != self._item2.get(attr):             # <<<<<<<<<<<<<<
+ *                 ts1 = OutputTimestamp(safe_timestamp(self._item1.get(attr)))
+ *                 ts2 = OutputTimestamp(safe_timestamp(self._item2.get(attr)))
+ */
     }
-    __pyx_v_self = values[0];
-    __pyx_v_chunk_iterator1 = values[1];
-    __pyx_v_chunk_iterator2 = values[2];
+
+    /* "borg/item.pyx":770
+ *     def _time_diffs(self):
+ *         attrs = ["ctime", "mtime"]
+ *         for attr in attrs:             # <<<<<<<<<<<<<<
+ *             if attr in self._item1 and attr in self._item2 and self._item1.get(attr) != self._item2.get(attr):
+ *                 ts1 = OutputTimestamp(safe_timestamp(self._item1.get(attr)))
+ */
   }
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_content_equal", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 739, __pyx_L3_error)
-  __pyx_L3_error:;
-  __Pyx_AddTraceback("borg.item.ItemDiff._content_equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":775
+ *                 ts2 = OutputTimestamp(safe_timestamp(self._item2.get(attr)))
+ *                 self._changes[attr] = DiffChange(attr, {"item1": ts1, "item2": ts2},)
+ *         return True             # <<<<<<<<<<<<<<
+ * 
+ *     def content(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(Py_True);
+  __pyx_r = Py_True;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":768
+ *                 self._changes['type'] = DiffChange("changed type", {"item1": mode1[0], "item2": mode2[0]})
+ * 
+ *     def _time_diffs(self):             # <<<<<<<<<<<<<<
+ *         attrs = ["ctime", "mtime"]
+ *         for attr in attrs:
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_9);
+  __Pyx_XDECREF(__pyx_t_10);
+  __Pyx_XDECREF(__pyx_t_11);
+  __Pyx_XDECREF(__pyx_t_12);
+  __Pyx_AddTraceback("borg.item.ItemDiff._time_diffs", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_attrs);
+  __Pyx_XDECREF(__pyx_v_attr);
+  __Pyx_XDECREF(__pyx_v_ts1);
+  __Pyx_XDECREF(__pyx_v_ts2);
+  __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
-  return NULL;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_18_content_equal(__pyx_self, __pyx_v_self, __pyx_v_chunk_iterator1, __pyx_v_chunk_iterator2);
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":777
+ *         return True
+ * 
+ *     def content(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('content')
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_21content(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_21content = {"content", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_21content, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_21content(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("content (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_20content(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_20content(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("content", 0);
+
+  /* "borg/item.pyx":778
+ * 
+ *     def content(self):
+ *         return self._changes.get('content')             # <<<<<<<<<<<<<<
+ * 
+ *     def ctime(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 778, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 778, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_n_s_content) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_content);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 778, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":777
+ *         return True
+ * 
+ *     def content(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('content')
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.ItemDiff.content", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":780
+ *         return self._changes.get('content')
+ * 
+ *     def ctime(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('ctime')
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_23ctime(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_23ctime = {"ctime", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_23ctime, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_23ctime(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("ctime (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_22ctime(__pyx_self, ((PyObject *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4borg_4item_8ItemDiff_18_content_equal(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_chunk_iterator1, PyObject *__pyx_v_chunk_iterator2) {
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_22ctime(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("ctime", 0);
+
+  /* "borg/item.pyx":781
+ * 
+ *     def ctime(self):
+ *         return self._changes.get('ctime')             # <<<<<<<<<<<<<<
+ * 
+ *     def mtime(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 781, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 781, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_n_s_ctime) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_ctime);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 781, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":780
+ *         return self._changes.get('content')
+ * 
+ *     def ctime(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('ctime')
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.ItemDiff.ctime", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":783
+ *         return self._changes.get('ctime')
+ * 
+ *     def mtime(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('mtime')
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_25mtime(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_25mtime = {"mtime", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_25mtime, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_25mtime(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("mtime (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_24mtime(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_24mtime(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("mtime", 0);
+
+  /* "borg/item.pyx":784
+ * 
+ *     def mtime(self):
+ *         return self._changes.get('mtime')             # <<<<<<<<<<<<<<
+ * 
+ *     def mode(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 784, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 784, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_n_s_mtime) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_mtime);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 784, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":783
+ *         return self._changes.get('ctime')
+ * 
+ *     def mtime(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('mtime')
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.ItemDiff.mtime", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":786
+ *         return self._changes.get('mtime')
+ * 
+ *     def mode(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('mode')
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_27mode(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_27mode = {"mode", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_27mode, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_27mode(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("mode (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_26mode(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_26mode(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("mode", 0);
+
+  /* "borg/item.pyx":787
+ * 
+ *     def mode(self):
+ *         return self._changes.get('mode')             # <<<<<<<<<<<<<<
+ * 
+ *     def type(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 787, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 787, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_n_s_mode) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_mode);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 787, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":786
+ *         return self._changes.get('mtime')
+ * 
+ *     def mode(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('mode')
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.ItemDiff.mode", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":789
+ *         return self._changes.get('mode')
+ * 
+ *     def type(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('type')
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_29type(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_29type = {"type", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_29type, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_29type(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("type (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_28type(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_28type(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("type", 0);
+
+  /* "borg/item.pyx":790
+ * 
+ *     def type(self):
+ *         return self._changes.get('type')             # <<<<<<<<<<<<<<
+ * 
+ *     def owner(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 790, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 790, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_n_s_type) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_type);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 790, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":789
+ *         return self._changes.get('mode')
+ * 
+ *     def type(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('type')
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.ItemDiff.type", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":792
+ *         return self._changes.get('type')
+ * 
+ *     def owner(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('owner')
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_31owner(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_31owner = {"owner", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_31owner, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_31owner(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("owner (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_30owner(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_30owner(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("owner", 0);
+
+  /* "borg/item.pyx":793
+ * 
+ *     def owner(self):
+ *         return self._changes.get('owner')             # <<<<<<<<<<<<<<
+ * 
+ *     def user(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 793, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 793, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_n_s_owner) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_owner);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 793, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":792
+ *         return self._changes.get('type')
+ * 
+ *     def owner(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('owner')
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.ItemDiff.owner", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":795
+ *         return self._changes.get('owner')
+ * 
+ *     def user(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('user')
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_33user(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_33user = {"user", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_33user, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_33user(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("user (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_32user(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_32user(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("user", 0);
+
+  /* "borg/item.pyx":796
+ * 
+ *     def user(self):
+ *         return self._changes.get('user')             # <<<<<<<<<<<<<<
+ * 
+ *     def group(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 796, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 796, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_n_s_user) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_user);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 796, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":795
+ *         return self._changes.get('owner')
+ * 
+ *     def user(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('user')
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.ItemDiff.user", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":798
+ *         return self._changes.get('user')
+ * 
+ *     def group(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('group')
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_35group(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_35group = {"group", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_35group, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_35group(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("group (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_34group(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_34group(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("group", 0);
+
+  /* "borg/item.pyx":799
+ * 
+ *     def group(self):
+ *         return self._changes.get('group')             # <<<<<<<<<<<<<<
+ * 
+ *     def _content_equal(self):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_changes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 799, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_get); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 799, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+    }
+  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_n_s_group) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_n_s_group);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 799, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* "borg/item.pyx":798
+ *         return self._changes.get('user')
+ * 
+ *     def group(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('group')
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("borg.item.ItemDiff.group", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/item.pyx":801
+ *         return self._changes.get('group')
+ * 
+ *     def _content_equal(self):             # <<<<<<<<<<<<<<
+ *         if self._can_compare_chunk_ids:
+ *             return self._item1.chunks == self._item2.chunks
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_37_content_equal(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_4item_8ItemDiff_37_content_equal = {"_content_equal", (PyCFunction)__pyx_pw_4borg_4item_8ItemDiff_37_content_equal, METH_O, 0};
+static PyObject *__pyx_pw_4borg_4item_8ItemDiff_37_content_equal(PyObject *__pyx_self, PyObject *__pyx_v_self) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("_content_equal (wrapper)", 0);
+  __pyx_r = __pyx_pf_4borg_4item_8ItemDiff_36_content_equal(__pyx_self, ((PyObject *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_4item_8ItemDiff_36_content_equal(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
+  PyObject *__pyx_t_6 = NULL;
+  int __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_content_equal", 0);
 
-  /* "borg/item.pyx":740
+  /* "borg/item.pyx":802
  * 
- *     def _content_equal(self, chunk_iterator1, chunk_iterator2):
+ *     def _content_equal(self):
  *         if self._can_compare_chunk_ids:             # <<<<<<<<<<<<<<
  *             return self._item1.chunks == self._item2.chunks
  *         if self._item1.get_size() != self._item2.get_size():
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_can_compare_chunk_ids_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 740, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_can_compare_chunk_ids_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 802, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 740, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 802, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if (__pyx_t_2) {
 
-    /* "borg/item.pyx":741
- *     def _content_equal(self, chunk_iterator1, chunk_iterator2):
+    /* "borg/item.pyx":803
+ *     def _content_equal(self):
  *         if self._can_compare_chunk_ids:
  *             return self._item1.chunks == self._item2.chunks             # <<<<<<<<<<<<<<
  *         if self._item1.get_size() != self._item2.get_size():
  *             return False
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 803, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_chunks); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 741, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_chunks); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 803, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 803, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_chunks); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 741, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_chunks); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 803, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = PyObject_RichCompare(__pyx_t_3, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
+    __pyx_t_1 = PyObject_RichCompare(__pyx_t_3, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 803, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":740
+    /* "borg/item.pyx":802
  * 
- *     def _content_equal(self, chunk_iterator1, chunk_iterator2):
+ *     def _content_equal(self):
  *         if self._can_compare_chunk_ids:             # <<<<<<<<<<<<<<
  *             return self._item1.chunks == self._item2.chunks
  *         if self._item1.get_size() != self._item2.get_size():
  */
   }
 
-  /* "borg/item.pyx":742
+  /* "borg/item.pyx":804
  *         if self._can_compare_chunk_ids:
  *             return self._item1.chunks == self._item2.chunks
  *         if self._item1.get_size() != self._item2.get_size():             # <<<<<<<<<<<<<<
  *             return False
- *         return chunks_contents_equal(chunk_iterator1, chunk_iterator2)
+ *         return chunks_contents_equal(self._chunk_1, self._chunk_2)
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item1_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 804, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 804, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 742, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 804, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_item2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 804, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get_size); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get_size); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 804, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
     }
   }
   __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 742, __pyx_L1_error)
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 804, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = PyObject_RichCompare(__pyx_t_1, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __pyx_t_5 = PyObject_RichCompare(__pyx_t_1, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 804, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 742, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 804, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   if (__pyx_t_2) {
 
-    /* "borg/item.pyx":743
+    /* "borg/item.pyx":805
  *             return self._item1.chunks == self._item2.chunks
  *         if self._item1.get_size() != self._item2.get_size():
  *             return False             # <<<<<<<<<<<<<<
- *         return chunks_contents_equal(chunk_iterator1, chunk_iterator2)
+ *         return chunks_contents_equal(self._chunk_1, self._chunk_2)
  * 
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(Py_False);
     __pyx_r = Py_False;
     goto __pyx_L0;
 
-    /* "borg/item.pyx":742
+    /* "borg/item.pyx":804
  *         if self._can_compare_chunk_ids:
  *             return self._item1.chunks == self._item2.chunks
  *         if self._item1.get_size() != self._item2.get_size():             # <<<<<<<<<<<<<<
  *             return False
- *         return chunks_contents_equal(chunk_iterator1, chunk_iterator2)
+ *         return chunks_contents_equal(self._chunk_1, self._chunk_2)
  */
   }
 
-  /* "borg/item.pyx":744
+  /* "borg/item.pyx":806
  *         if self._item1.get_size() != self._item2.get_size():
  *             return False
- *         return chunks_contents_equal(chunk_iterator1, chunk_iterator2)             # <<<<<<<<<<<<<<
+ *         return chunks_contents_equal(self._chunk_1, self._chunk_2)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_chunks_contents_equal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 744, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_chunks_contents_equal); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 806, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = NULL;
-  __pyx_t_6 = 0;
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_chunk_1_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 806, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_chunk_2_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 806, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_6 = NULL;
+  __pyx_t_7 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_1)) {
+    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_6)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_1);
+      __Pyx_INCREF(__pyx_t_6);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_6 = 1;
+      __pyx_t_7 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_chunk_iterator1, __pyx_v_chunk_iterator2};
-    __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 744, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_1, __pyx_t_4};
+    __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 806, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_chunk_iterator1, __pyx_v_chunk_iterator2};
-    __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 744, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_t_1, __pyx_t_4};
+    __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 806, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   } else
   #endif
   {
-    __pyx_t_4 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 744, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    if (__pyx_t_1) {
-      __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1); __pyx_t_1 = NULL;
+    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 806, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    if (__pyx_t_6) {
+      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
     }
-    __Pyx_INCREF(__pyx_v_chunk_iterator1);
-    __Pyx_GIVEREF(__pyx_v_chunk_iterator1);
-    PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_v_chunk_iterator1);
-    __Pyx_INCREF(__pyx_v_chunk_iterator2);
-    __Pyx_GIVEREF(__pyx_v_chunk_iterator2);
-    PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_v_chunk_iterator2);
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 744, __pyx_L1_error)
+    __Pyx_GIVEREF(__pyx_t_1);
+    PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_1);
+    __Pyx_GIVEREF(__pyx_t_4);
+    PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_4);
+    __pyx_t_1 = 0;
+    __pyx_t_4 = 0;
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 806, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "borg/item.pyx":739
- *             return ({"type": "mode", "old_mode": mode1, "new_mode": mode2}, '[{} -> {}]'.format(mode1, mode2))
+  /* "borg/item.pyx":801
+ *         return self._changes.get('group')
  * 
- *     def _content_equal(self, chunk_iterator1, chunk_iterator2):             # <<<<<<<<<<<<<<
+ *     def _content_equal(self):             # <<<<<<<<<<<<<<
  *         if self._can_compare_chunk_ids:
  *             return self._item1.chunks == self._item2.chunks
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("borg.item.ItemDiff._content_equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/item.pyx":747
+/* "borg/item.pyx":809
  * 
  * 
  * def chunks_contents_equal(chunks_a, chunks_b):             # <<<<<<<<<<<<<<
  *     """
  *     Compare chunk content and return True if they are identical.
  */
 
@@ -19253,32 +20641,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunks_a)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunks_b)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("chunks_contents_equal", 1, 2, 2, 1); __PYX_ERR(0, 747, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("chunks_contents_equal", 1, 2, 2, 1); __PYX_ERR(0, 809, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "chunks_contents_equal") < 0)) __PYX_ERR(0, 747, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "chunks_contents_equal") < 0)) __PYX_ERR(0, 809, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_chunks_a = values[0];
     __pyx_v_chunks_b = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("chunks_contents_equal", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 747, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("chunks_contents_equal", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 809, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.item.chunks_contents_equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_4item_24chunks_contents_equal(__pyx_self, __pyx_v_chunks_a, __pyx_v_chunks_b);
 
@@ -19306,233 +20694,233 @@
   Py_ssize_t __pyx_t_7;
   Py_ssize_t __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("chunks_contents_equal", 0);
 
-  /* "borg/item.pyx":757
+  /* "borg/item.pyx":819
  *         char * ap
  *         char * bp
  *         Py_ssize_t slicelen = 0             # <<<<<<<<<<<<<<
  *         Py_ssize_t alen = 0
  *         Py_ssize_t blen = 0
  */
   __pyx_v_slicelen = 0;
 
-  /* "borg/item.pyx":758
+  /* "borg/item.pyx":820
  *         char * bp
  *         Py_ssize_t slicelen = 0
  *         Py_ssize_t alen = 0             # <<<<<<<<<<<<<<
  *         Py_ssize_t blen = 0
  * 
  */
   __pyx_v_alen = 0;
 
-  /* "borg/item.pyx":759
+  /* "borg/item.pyx":821
  *         Py_ssize_t slicelen = 0
  *         Py_ssize_t alen = 0
  *         Py_ssize_t blen = 0             # <<<<<<<<<<<<<<
  * 
  *     while True:
  */
   __pyx_v_blen = 0;
 
-  /* "borg/item.pyx":761
+  /* "borg/item.pyx":823
  *         Py_ssize_t blen = 0
  * 
  *     while True:             # <<<<<<<<<<<<<<
  *         if not alen:
  *             a = next(chunks_a, None)
  */
   while (1) {
 
-    /* "borg/item.pyx":762
+    /* "borg/item.pyx":824
  * 
  *     while True:
  *         if not alen:             # <<<<<<<<<<<<<<
  *             a = next(chunks_a, None)
  *             if a is None:
  */
     __pyx_t_1 = ((!(__pyx_v_alen != 0)) != 0);
     if (__pyx_t_1) {
 
-      /* "borg/item.pyx":763
+      /* "borg/item.pyx":825
  *     while True:
  *         if not alen:
  *             a = next(chunks_a, None)             # <<<<<<<<<<<<<<
  *             if a is None:
  *                 return not blen and next(chunks_b, None) is None
  */
-      __pyx_t_2 = __Pyx_PyIter_Next2(__pyx_v_chunks_a, Py_None); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 763, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyIter_Next2(__pyx_v_chunks_a, Py_None); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 825, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 763, __pyx_L1_error)
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 825, __pyx_L1_error)
       __Pyx_XDECREF_SET(__pyx_v_a, ((PyObject*)__pyx_t_2));
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":764
+      /* "borg/item.pyx":826
  *         if not alen:
  *             a = next(chunks_a, None)
  *             if a is None:             # <<<<<<<<<<<<<<
  *                 return not blen and next(chunks_b, None) is None
  *             PyBytes_AsStringAndSize(a, &ap, &alen)
  */
       __pyx_t_1 = (__pyx_v_a == ((PyObject*)Py_None));
       __pyx_t_3 = (__pyx_t_1 != 0);
       if (__pyx_t_3) {
 
-        /* "borg/item.pyx":765
+        /* "borg/item.pyx":827
  *             a = next(chunks_a, None)
  *             if a is None:
  *                 return not blen and next(chunks_b, None) is None             # <<<<<<<<<<<<<<
  *             PyBytes_AsStringAndSize(a, &ap, &alen)
  *         if not blen:
  */
         __Pyx_XDECREF(__pyx_r);
         __pyx_t_3 = (!(__pyx_v_blen != 0));
         if (__pyx_t_3) {
         } else {
-          __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 765, __pyx_L1_error)
+          __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 827, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_4);
           __pyx_t_2 = __pyx_t_4;
           __pyx_t_4 = 0;
           goto __pyx_L7_bool_binop_done;
         }
-        __pyx_t_4 = __Pyx_PyIter_Next2(__pyx_v_chunks_b, Py_None); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 765, __pyx_L1_error)
+        __pyx_t_4 = __Pyx_PyIter_Next2(__pyx_v_chunks_b, Py_None); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 827, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         __pyx_t_3 = (__pyx_t_4 == Py_None);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 765, __pyx_L1_error)
+        __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 827, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         __pyx_t_2 = __pyx_t_4;
         __pyx_t_4 = 0;
         __pyx_L7_bool_binop_done:;
         __pyx_r = __pyx_t_2;
         __pyx_t_2 = 0;
         goto __pyx_L0;
 
-        /* "borg/item.pyx":764
+        /* "borg/item.pyx":826
  *         if not alen:
  *             a = next(chunks_a, None)
  *             if a is None:             # <<<<<<<<<<<<<<
  *                 return not blen and next(chunks_b, None) is None
  *             PyBytes_AsStringAndSize(a, &ap, &alen)
  */
       }
 
-      /* "borg/item.pyx":766
+      /* "borg/item.pyx":828
  *             if a is None:
  *                 return not blen and next(chunks_b, None) is None
  *             PyBytes_AsStringAndSize(a, &ap, &alen)             # <<<<<<<<<<<<<<
  *         if not blen:
  *             b = next(chunks_b, None)
  */
-      __pyx_t_5 = PyBytes_AsStringAndSize(__pyx_v_a, (&__pyx_v_ap), (&__pyx_v_alen)); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 766, __pyx_L1_error)
+      __pyx_t_5 = PyBytes_AsStringAndSize(__pyx_v_a, (&__pyx_v_ap), (&__pyx_v_alen)); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 828, __pyx_L1_error)
 
-      /* "borg/item.pyx":762
+      /* "borg/item.pyx":824
  * 
  *     while True:
  *         if not alen:             # <<<<<<<<<<<<<<
  *             a = next(chunks_a, None)
  *             if a is None:
  */
     }
 
-    /* "borg/item.pyx":767
+    /* "borg/item.pyx":829
  *                 return not blen and next(chunks_b, None) is None
  *             PyBytes_AsStringAndSize(a, &ap, &alen)
  *         if not blen:             # <<<<<<<<<<<<<<
  *             b = next(chunks_b, None)
  *             if b is None:
  */
     __pyx_t_3 = ((!(__pyx_v_blen != 0)) != 0);
     if (__pyx_t_3) {
 
-      /* "borg/item.pyx":768
+      /* "borg/item.pyx":830
  *             PyBytes_AsStringAndSize(a, &ap, &alen)
  *         if not blen:
  *             b = next(chunks_b, None)             # <<<<<<<<<<<<<<
  *             if b is None:
  *                 return not alen and next(chunks_a, None) is None
  */
-      __pyx_t_2 = __Pyx_PyIter_Next2(__pyx_v_chunks_b, Py_None); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 768, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyIter_Next2(__pyx_v_chunks_b, Py_None); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 830, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 768, __pyx_L1_error)
+      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||((void)PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 830, __pyx_L1_error)
       __Pyx_XDECREF_SET(__pyx_v_b, ((PyObject*)__pyx_t_2));
       __pyx_t_2 = 0;
 
-      /* "borg/item.pyx":769
+      /* "borg/item.pyx":831
  *         if not blen:
  *             b = next(chunks_b, None)
  *             if b is None:             # <<<<<<<<<<<<<<
  *                 return not alen and next(chunks_a, None) is None
  *             PyBytes_AsStringAndSize(b, &bp, &blen)
  */
       __pyx_t_3 = (__pyx_v_b == ((PyObject*)Py_None));
       __pyx_t_1 = (__pyx_t_3 != 0);
       if (__pyx_t_1) {
 
-        /* "borg/item.pyx":770
+        /* "borg/item.pyx":832
  *             b = next(chunks_b, None)
  *             if b is None:
  *                 return not alen and next(chunks_a, None) is None             # <<<<<<<<<<<<<<
  *             PyBytes_AsStringAndSize(b, &bp, &blen)
  *         slicelen = min(alen, blen)
  */
         __Pyx_XDECREF(__pyx_r);
         __pyx_t_1 = (!(__pyx_v_alen != 0));
         if (__pyx_t_1) {
         } else {
-          __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 770, __pyx_L1_error)
+          __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 832, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_4);
           __pyx_t_2 = __pyx_t_4;
           __pyx_t_4 = 0;
           goto __pyx_L11_bool_binop_done;
         }
-        __pyx_t_4 = __Pyx_PyIter_Next2(__pyx_v_chunks_a, Py_None); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 770, __pyx_L1_error)
+        __pyx_t_4 = __Pyx_PyIter_Next2(__pyx_v_chunks_a, Py_None); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 832, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         __pyx_t_1 = (__pyx_t_4 == Py_None);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 770, __pyx_L1_error)
+        __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 832, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         __pyx_t_2 = __pyx_t_4;
         __pyx_t_4 = 0;
         __pyx_L11_bool_binop_done:;
         __pyx_r = __pyx_t_2;
         __pyx_t_2 = 0;
         goto __pyx_L0;
 
-        /* "borg/item.pyx":769
+        /* "borg/item.pyx":831
  *         if not blen:
  *             b = next(chunks_b, None)
  *             if b is None:             # <<<<<<<<<<<<<<
  *                 return not alen and next(chunks_a, None) is None
  *             PyBytes_AsStringAndSize(b, &bp, &blen)
  */
       }
 
-      /* "borg/item.pyx":771
+      /* "borg/item.pyx":833
  *             if b is None:
  *                 return not alen and next(chunks_a, None) is None
  *             PyBytes_AsStringAndSize(b, &bp, &blen)             # <<<<<<<<<<<<<<
  *         slicelen = min(alen, blen)
  *         if memcmp(ap, bp, slicelen) != 0:
  */
-      __pyx_t_5 = PyBytes_AsStringAndSize(__pyx_v_b, (&__pyx_v_bp), (&__pyx_v_blen)); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 771, __pyx_L1_error)
+      __pyx_t_5 = PyBytes_AsStringAndSize(__pyx_v_b, (&__pyx_v_bp), (&__pyx_v_blen)); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 833, __pyx_L1_error)
 
-      /* "borg/item.pyx":767
+      /* "borg/item.pyx":829
  *                 return not blen and next(chunks_b, None) is None
  *             PyBytes_AsStringAndSize(a, &ap, &alen)
  *         if not blen:             # <<<<<<<<<<<<<<
  *             b = next(chunks_b, None)
  *             if b is None:
  */
     }
 
-    /* "borg/item.pyx":772
+    /* "borg/item.pyx":834
  *                 return not alen and next(chunks_a, None) is None
  *             PyBytes_AsStringAndSize(b, &bp, &blen)
  *         slicelen = min(alen, blen)             # <<<<<<<<<<<<<<
  *         if memcmp(ap, bp, slicelen) != 0:
  *             return False
  */
     __pyx_t_6 = __pyx_v_blen;
@@ -19540,80 +20928,80 @@
     if (((__pyx_t_6 < __pyx_t_7) != 0)) {
       __pyx_t_8 = __pyx_t_6;
     } else {
       __pyx_t_8 = __pyx_t_7;
     }
     __pyx_v_slicelen = __pyx_t_8;
 
-    /* "borg/item.pyx":773
+    /* "borg/item.pyx":835
  *             PyBytes_AsStringAndSize(b, &bp, &blen)
  *         slicelen = min(alen, blen)
  *         if memcmp(ap, bp, slicelen) != 0:             # <<<<<<<<<<<<<<
  *             return False
  *         ap += slicelen
  */
     __pyx_t_1 = ((memcmp(__pyx_v_ap, __pyx_v_bp, __pyx_v_slicelen) != 0) != 0);
     if (__pyx_t_1) {
 
-      /* "borg/item.pyx":774
+      /* "borg/item.pyx":836
  *         slicelen = min(alen, blen)
  *         if memcmp(ap, bp, slicelen) != 0:
  *             return False             # <<<<<<<<<<<<<<
  *         ap += slicelen
  *         bp += slicelen
  */
       __Pyx_XDECREF(__pyx_r);
       __Pyx_INCREF(Py_False);
       __pyx_r = Py_False;
       goto __pyx_L0;
 
-      /* "borg/item.pyx":773
+      /* "borg/item.pyx":835
  *             PyBytes_AsStringAndSize(b, &bp, &blen)
  *         slicelen = min(alen, blen)
  *         if memcmp(ap, bp, slicelen) != 0:             # <<<<<<<<<<<<<<
  *             return False
  *         ap += slicelen
  */
     }
 
-    /* "borg/item.pyx":775
+    /* "borg/item.pyx":837
  *         if memcmp(ap, bp, slicelen) != 0:
  *             return False
  *         ap += slicelen             # <<<<<<<<<<<<<<
  *         bp += slicelen
  *         alen -= slicelen
  */
     __pyx_v_ap = (__pyx_v_ap + __pyx_v_slicelen);
 
-    /* "borg/item.pyx":776
+    /* "borg/item.pyx":838
  *             return False
  *         ap += slicelen
  *         bp += slicelen             # <<<<<<<<<<<<<<
  *         alen -= slicelen
  *         blen -= slicelen
  */
     __pyx_v_bp = (__pyx_v_bp + __pyx_v_slicelen);
 
-    /* "borg/item.pyx":777
+    /* "borg/item.pyx":839
  *         ap += slicelen
  *         bp += slicelen
  *         alen -= slicelen             # <<<<<<<<<<<<<<
  *         blen -= slicelen
  */
     __pyx_v_alen = (__pyx_v_alen - __pyx_v_slicelen);
 
-    /* "borg/item.pyx":778
+    /* "borg/item.pyx":840
  *         bp += slicelen
  *         alen -= slicelen
  *         blen -= slicelen             # <<<<<<<<<<<<<<
  */
     __pyx_v_blen = (__pyx_v_blen - __pyx_v_slicelen);
   }
 
-  /* "borg/item.pyx":747
+  /* "borg/item.pyx":809
  * 
  * 
  * def chunks_contents_equal(chunks_a, chunks_b):             # <<<<<<<<<<<<<<
  *     """
  *     Compare chunk content and return True if they are identical.
  */
 
@@ -19790,15 +21178,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_4borg_4item_PropDictProperty __pyx_vtable_4borg_4item_PropDictProperty;
 
 static PyObject *__pyx_tp_new_4borg_4item_PropDictProperty(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_obj_4borg_4item_PropDictProperty *p;
@@ -19981,15 +21369,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_4item_Item(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_4item_PropDict(t, a, k);
   if (unlikely(!o)) return 0;
@@ -20080,15 +21468,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_4item_EncryptedKey(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_4item_PropDict(t, a, k);
   if (unlikely(!o)) return 0;
@@ -20169,15 +21557,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_4item_Key(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_4item_PropDict(t, a, k);
   if (unlikely(!o)) return 0;
@@ -20258,15 +21646,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_4item_ArchiveItem(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_4item_PropDict(t, a, k);
   if (unlikely(!o)) return 0;
@@ -20347,15 +21735,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_4borg_4item_ManifestItem(PyTypeObject *t, PyObject *a, PyObject *k) {
   PyObject *o = __pyx_tp_new_4borg_4item_PropDict(t, a, k);
   if (unlikely(!o)) return 0;
@@ -20436,15 +21824,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_4item___pyx_scope_struct__fix_tuple_of_str *__pyx_freelist_4borg_4item___pyx_scope_struct__fix_tuple_of_str[8];
 static int __pyx_freecount_4borg_4item___pyx_scope_struct__fix_tuple_of_str = 0;
 
@@ -20554,15 +21942,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_4item___pyx_scope_struct_1_genexpr *__pyx_freelist_4borg_4item___pyx_scope_struct_1_genexpr[8];
 static int __pyx_freecount_4borg_4item___pyx_scope_struct_1_genexpr = 0;
 
@@ -20671,15 +22059,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int *__pyx_freelist_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int[8];
 static int __pyx_freecount_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int = 0;
 
@@ -20796,15 +22184,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_4item___pyx_scope_struct_3_genexpr *__pyx_freelist_4borg_4item___pyx_scope_struct_3_genexpr[8];
 static int __pyx_freecount_4borg_4item___pyx_scope_struct_3_genexpr = 0;
 
@@ -20913,15 +22301,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_4item___pyx_scope_struct_4_genexpr *__pyx_freelist_4borg_4item___pyx_scope_struct_4_genexpr[8];
 static int __pyx_freecount_4borg_4item___pyx_scope_struct_4_genexpr = 0;
 
@@ -21026,15 +22414,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_4item___pyx_scope_struct_5_get_size *__pyx_freelist_4borg_4item___pyx_scope_struct_5_get_size[8];
 static int __pyx_freecount_4borg_4item___pyx_scope_struct_5_get_size = 0;
 
@@ -21158,15 +22546,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_4item___pyx_scope_struct_6_genexpr *__pyx_freelist_4borg_4item___pyx_scope_struct_6_genexpr[8];
 static int __pyx_freecount_4borg_4item___pyx_scope_struct_6_genexpr = 0;
 
@@ -21275,15 +22663,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_4item___pyx_scope_struct_7_genexpr *__pyx_freelist_4borg_4item___pyx_scope_struct_7_genexpr[8];
 static int __pyx_freecount_4borg_4item___pyx_scope_struct_7_genexpr = 0;
 
@@ -21392,254 +22780,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
-};
-
-static struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *__pyx_freelist_4borg_4item___pyx_scope_struct_8___repr__[8];
-static int __pyx_freecount_4borg_4item___pyx_scope_struct_8___repr__ = 0;
-
-static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_8___repr__(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
-  PyObject *o;
-  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_4borg_4item___pyx_scope_struct_8___repr__ > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__)))) {
-    o = (PyObject*)__pyx_freelist_4borg_4item___pyx_scope_struct_8___repr__[--__pyx_freecount_4borg_4item___pyx_scope_struct_8___repr__];
-    memset(o, 0, sizeof(struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__));
-    (void) PyObject_INIT(o, t);
-    PyObject_GC_Track(o);
-  } else {
-    o = (*t->tp_alloc)(t, 0);
-    if (unlikely(!o)) return 0;
-  }
-  return o;
-}
-
-static void __pyx_tp_dealloc_4borg_4item___pyx_scope_struct_8___repr__(PyObject *o) {
-  struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *p = (struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *)o;
-  PyObject_GC_UnTrack(o);
-  Py_CLEAR(p->__pyx_v_self);
-  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_4borg_4item___pyx_scope_struct_8___repr__ < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__)))) {
-    __pyx_freelist_4borg_4item___pyx_scope_struct_8___repr__[__pyx_freecount_4borg_4item___pyx_scope_struct_8___repr__++] = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *)o);
-  } else {
-    (*Py_TYPE(o)->tp_free)(o);
-  }
-}
-
-static int __pyx_tp_traverse_4borg_4item___pyx_scope_struct_8___repr__(PyObject *o, visitproc v, void *a) {
-  int e;
-  struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *p = (struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *)o;
-  if (p->__pyx_v_self) {
-    e = (*v)(p->__pyx_v_self, a); if (e) return e;
-  }
-  return 0;
-}
-
-static int __pyx_tp_clear_4borg_4item___pyx_scope_struct_8___repr__(PyObject *o) {
-  PyObject* tmp;
-  struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *p = (struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__ *)o;
-  tmp = ((PyObject*)p->__pyx_v_self);
-  p->__pyx_v_self = Py_None; Py_INCREF(Py_None);
-  Py_XDECREF(tmp);
-  return 0;
-}
-
-static PyTypeObject __pyx_type_4borg_4item___pyx_scope_struct_8___repr__ = {
-  PyVarObject_HEAD_INIT(0, 0)
-  "borg.item.__pyx_scope_struct_8___repr__", /*tp_name*/
-  sizeof(struct __pyx_obj_4borg_4item___pyx_scope_struct_8___repr__), /*tp_basicsize*/
-  0, /*tp_itemsize*/
-  __pyx_tp_dealloc_4borg_4item___pyx_scope_struct_8___repr__, /*tp_dealloc*/
-  #if PY_VERSION_HEX < 0x030800b4
-  0, /*tp_print*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4
-  0, /*tp_vectorcall_offset*/
-  #endif
-  0, /*tp_getattr*/
-  0, /*tp_setattr*/
-  #if PY_MAJOR_VERSION < 3
-  0, /*tp_compare*/
-  #endif
-  #if PY_MAJOR_VERSION >= 3
-  0, /*tp_as_async*/
-  #endif
-  0, /*tp_repr*/
-  0, /*tp_as_number*/
-  0, /*tp_as_sequence*/
-  0, /*tp_as_mapping*/
-  0, /*tp_hash*/
-  0, /*tp_call*/
-  0, /*tp_str*/
-  0, /*tp_getattro*/
-  0, /*tp_setattro*/
-  0, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
-  0, /*tp_doc*/
-  __pyx_tp_traverse_4borg_4item___pyx_scope_struct_8___repr__, /*tp_traverse*/
-  __pyx_tp_clear_4borg_4item___pyx_scope_struct_8___repr__, /*tp_clear*/
-  0, /*tp_richcompare*/
-  0, /*tp_weaklistoffset*/
-  0, /*tp_iter*/
-  0, /*tp_iternext*/
-  0, /*tp_methods*/
-  0, /*tp_members*/
-  0, /*tp_getset*/
-  0, /*tp_base*/
-  0, /*tp_dict*/
-  0, /*tp_descr_get*/
-  0, /*tp_descr_set*/
-  0, /*tp_dictoffset*/
-  0, /*tp_init*/
-  0, /*tp_alloc*/
-  __pyx_tp_new_4borg_4item___pyx_scope_struct_8___repr__, /*tp_new*/
-  0, /*tp_free*/
-  0, /*tp_is_gc*/
-  0, /*tp_bases*/
-  0, /*tp_mro*/
-  0, /*tp_cache*/
-  0, /*tp_subclasses*/
-  0, /*tp_weaklist*/
-  0, /*tp_del*/
-  0, /*tp_version_tag*/
-  #if PY_VERSION_HEX >= 0x030400a1
-  0, /*tp_finalize*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-  0, /*tp_vectorcall*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
-  0, /*tp_print*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
-  0, /*tp_pypy_flags*/
-  #endif
-};
-
-static struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *__pyx_freelist_4borg_4item___pyx_scope_struct_9_genexpr[8];
-static int __pyx_freecount_4borg_4item___pyx_scope_struct_9_genexpr = 0;
-
-static PyObject *__pyx_tp_new_4borg_4item___pyx_scope_struct_9_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
-  PyObject *o;
-  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_4borg_4item___pyx_scope_struct_9_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr)))) {
-    o = (PyObject*)__pyx_freelist_4borg_4item___pyx_scope_struct_9_genexpr[--__pyx_freecount_4borg_4item___pyx_scope_struct_9_genexpr];
-    memset(o, 0, sizeof(struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr));
-    (void) PyObject_INIT(o, t);
-    PyObject_GC_Track(o);
-  } else {
-    o = (*t->tp_alloc)(t, 0);
-    if (unlikely(!o)) return 0;
-  }
-  return o;
-}
-
-static void __pyx_tp_dealloc_4borg_4item___pyx_scope_struct_9_genexpr(PyObject *o) {
-  struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *p = (struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *)o;
-  PyObject_GC_UnTrack(o);
-  Py_CLEAR(p->__pyx_outer_scope);
-  Py_CLEAR(p->__pyx_v_d);
-  Py_CLEAR(p->__pyx_v_str);
-  Py_CLEAR(p->__pyx_t_0);
-  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_4borg_4item___pyx_scope_struct_9_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr)))) {
-    __pyx_freelist_4borg_4item___pyx_scope_struct_9_genexpr[__pyx_freecount_4borg_4item___pyx_scope_struct_9_genexpr++] = ((struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *)o);
-  } else {
-    (*Py_TYPE(o)->tp_free)(o);
-  }
-}
-
-static int __pyx_tp_traverse_4borg_4item___pyx_scope_struct_9_genexpr(PyObject *o, visitproc v, void *a) {
-  int e;
-  struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *p = (struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr *)o;
-  if (p->__pyx_outer_scope) {
-    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
-  }
-  if (p->__pyx_v_d) {
-    e = (*v)(p->__pyx_v_d, a); if (e) return e;
-  }
-  if (p->__pyx_v_str) {
-    e = (*v)(p->__pyx_v_str, a); if (e) return e;
-  }
-  if (p->__pyx_t_0) {
-    e = (*v)(p->__pyx_t_0, a); if (e) return e;
-  }
-  return 0;
-}
-
-static PyTypeObject __pyx_type_4borg_4item___pyx_scope_struct_9_genexpr = {
-  PyVarObject_HEAD_INIT(0, 0)
-  "borg.item.__pyx_scope_struct_9_genexpr", /*tp_name*/
-  sizeof(struct __pyx_obj_4borg_4item___pyx_scope_struct_9_genexpr), /*tp_basicsize*/
-  0, /*tp_itemsize*/
-  __pyx_tp_dealloc_4borg_4item___pyx_scope_struct_9_genexpr, /*tp_dealloc*/
-  #if PY_VERSION_HEX < 0x030800b4
-  0, /*tp_print*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4
-  0, /*tp_vectorcall_offset*/
-  #endif
-  0, /*tp_getattr*/
-  0, /*tp_setattr*/
-  #if PY_MAJOR_VERSION < 3
-  0, /*tp_compare*/
-  #endif
-  #if PY_MAJOR_VERSION >= 3
-  0, /*tp_as_async*/
-  #endif
-  0, /*tp_repr*/
-  0, /*tp_as_number*/
-  0, /*tp_as_sequence*/
-  0, /*tp_as_mapping*/
-  0, /*tp_hash*/
-  0, /*tp_call*/
-  0, /*tp_str*/
-  0, /*tp_getattro*/
-  0, /*tp_setattro*/
-  0, /*tp_as_buffer*/
-  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
-  0, /*tp_doc*/
-  __pyx_tp_traverse_4borg_4item___pyx_scope_struct_9_genexpr, /*tp_traverse*/
-  0, /*tp_clear*/
-  0, /*tp_richcompare*/
-  0, /*tp_weaklistoffset*/
-  0, /*tp_iter*/
-  0, /*tp_iternext*/
-  0, /*tp_methods*/
-  0, /*tp_members*/
-  0, /*tp_getset*/
-  0, /*tp_base*/
-  0, /*tp_dict*/
-  0, /*tp_descr_get*/
-  0, /*tp_descr_set*/
-  0, /*tp_dictoffset*/
-  0, /*tp_init*/
-  0, /*tp_alloc*/
-  __pyx_tp_new_4borg_4item___pyx_scope_struct_9_genexpr, /*tp_new*/
-  0, /*tp_free*/
-  0, /*tp_is_gc*/
-  0, /*tp_bases*/
-  0, /*tp_mro*/
-  0, /*tp_cache*/
-  0, /*tp_subclasses*/
-  0, /*tp_weaklist*/
-  0, /*tp_del*/
-  0, /*tp_version_tag*/
-  #if PY_VERSION_HEX >= 0x030400a1
-  0, /*tp_finalize*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
-  0, /*tp_vectorcall*/
-  #endif
-  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
-  0, /*tp_print*/
-  #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {"_init_names", (PyCFunction)__pyx_pw_4borg_4item_23_init_names, METH_NOARGS, __pyx_doc_4borg_4item_22_init_names},
   {0, 0, 0, 0}
@@ -21684,103 +22833,119 @@
 #else
     #define CYTHON_SMALL_CODE
 #endif
 #endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
   {&__pyx_kp_s_1_2_01, __pyx_k_1_2_01, sizeof(__pyx_k_1_2_01), 0, 0, 1, 0},
-  {&__pyx_kp_s_9_9, __pyx_k_9_9, sizeof(__pyx_k_9_9), 0, 0, 1, 0},
   {&__pyx_n_s_API_VERSION, __pyx_k_API_VERSION, sizeof(__pyx_k_API_VERSION), 0, 0, 1, 1},
   {&__pyx_n_s_ARCHIVE_KEYS, __pyx_k_ARCHIVE_KEYS, sizeof(__pyx_k_ARCHIVE_KEYS), 0, 0, 1, 1},
   {&__pyx_n_s_ArchiveItem, __pyx_k_ArchiveItem, sizeof(__pyx_k_ArchiveItem), 0, 0, 1, 1},
   {&__pyx_n_s_AttributeError, __pyx_k_AttributeError, sizeof(__pyx_k_AttributeError), 0, 0, 1, 1},
   {&__pyx_kp_s_Can_t_store_size_when_considerin, __pyx_k_Can_t_store_size_when_considerin, sizeof(__pyx_k_Can_t_store_size_when_considerin), 0, 0, 1, 0},
   {&__pyx_n_s_ChunkListEntry, __pyx_k_ChunkListEntry, sizeof(__pyx_k_ChunkListEntry), 0, 0, 1, 1},
   {&__pyx_kp_s_Comparison_of_two_items_from_di, __pyx_k_Comparison_of_two_items_from_di, sizeof(__pyx_k_Comparison_of_two_items_from_di), 0, 0, 1, 0},
+  {&__pyx_n_s_DiffChange, __pyx_k_DiffChange, sizeof(__pyx_k_DiffChange), 0, 0, 1, 1},
+  {&__pyx_n_s_DiffChange___init, __pyx_k_DiffChange___init, sizeof(__pyx_k_DiffChange___init), 0, 0, 1, 1},
+  {&__pyx_n_s_DiffChange_to_dict, __pyx_k_DiffChange_to_dict, sizeof(__pyx_k_DiffChange_to_dict), 0, 0, 1, 1},
   {&__pyx_n_s_EncryptedKey, __pyx_k_EncryptedKey, sizeof(__pyx_k_EncryptedKey), 0, 0, 1, 1},
   {&__pyx_n_s_ITEM_KEYS, __pyx_k_ITEM_KEYS, sizeof(__pyx_k_ITEM_KEYS), 0, 0, 1, 1},
   {&__pyx_n_s_Item, __pyx_k_Item, sizeof(__pyx_k_Item), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff, __pyx_k_ItemDiff, sizeof(__pyx_k_ItemDiff), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff___init, __pyx_k_ItemDiff___init, sizeof(__pyx_k_ItemDiff___init), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff___repr, __pyx_k_ItemDiff___repr, sizeof(__pyx_k_ItemDiff___repr), 0, 0, 1, 1},
-  {&__pyx_n_s_ItemDiff___repr___locals_genexpr, __pyx_k_ItemDiff___repr___locals_genexpr, sizeof(__pyx_k_ItemDiff___repr___locals_genexpr), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff__content_diff, __pyx_k_ItemDiff__content_diff, sizeof(__pyx_k_ItemDiff__content_diff), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff__content_equal, __pyx_k_ItemDiff__content_equal, sizeof(__pyx_k_ItemDiff__content_equal), 0, 0, 1, 1},
-  {&__pyx_n_s_ItemDiff__equal, __pyx_k_ItemDiff__equal, sizeof(__pyx_k_ItemDiff__equal), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff__link_diff, __pyx_k_ItemDiff__link_diff, sizeof(__pyx_k_ItemDiff__link_diff), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff__mode_diff, __pyx_k_ItemDiff__mode_diff, sizeof(__pyx_k_ItemDiff__mode_diff), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff__owner_diff, __pyx_k_ItemDiff__owner_diff, sizeof(__pyx_k_ItemDiff__owner_diff), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff__presence_diff, __pyx_k_ItemDiff__presence_diff, sizeof(__pyx_k_ItemDiff__presence_diff), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff__time_diffs, __pyx_k_ItemDiff__time_diffs, sizeof(__pyx_k_ItemDiff__time_diffs), 0, 0, 1, 1},
   {&__pyx_n_s_ItemDiff_changes, __pyx_k_ItemDiff_changes, sizeof(__pyx_k_ItemDiff_changes), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff_content, __pyx_k_ItemDiff_content, sizeof(__pyx_k_ItemDiff_content), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff_ctime, __pyx_k_ItemDiff_ctime, sizeof(__pyx_k_ItemDiff_ctime), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff_equal, __pyx_k_ItemDiff_equal, sizeof(__pyx_k_ItemDiff_equal), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff_group, __pyx_k_ItemDiff_group, sizeof(__pyx_k_ItemDiff_group), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff_mode, __pyx_k_ItemDiff_mode, sizeof(__pyx_k_ItemDiff_mode), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff_mtime, __pyx_k_ItemDiff_mtime, sizeof(__pyx_k_ItemDiff_mtime), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff_owner, __pyx_k_ItemDiff_owner, sizeof(__pyx_k_ItemDiff_owner), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff_type, __pyx_k_ItemDiff_type, sizeof(__pyx_k_ItemDiff_type), 0, 0, 1, 1},
+  {&__pyx_n_s_ItemDiff_user, __pyx_k_ItemDiff_user, sizeof(__pyx_k_ItemDiff_user), 0, 0, 1, 1},
   {&__pyx_n_s_Key, __pyx_k_Key, sizeof(__pyx_k_Key), 0, 0, 1, 1},
   {&__pyx_n_s_KeyError, __pyx_k_KeyError, sizeof(__pyx_k_KeyError), 0, 0, 1, 1},
   {&__pyx_n_s_ManifestItem, __pyx_k_ManifestItem, sizeof(__pyx_k_ManifestItem), 0, 0, 1, 1},
+  {&__pyx_n_s_OutputTimestamp, __pyx_k_OutputTimestamp, sizeof(__pyx_k_OutputTimestamp), 0, 0, 1, 1},
   {&__pyx_n_s_PropDict, __pyx_k_PropDict, sizeof(__pyx_k_PropDict), 0, 0, 1, 1},
   {&__pyx_n_s_PropDictProperty, __pyx_k_PropDictProperty, sizeof(__pyx_k_PropDictProperty), 0, 0, 1, 1},
   {&__pyx_n_s_S_ISBLK, __pyx_k_S_ISBLK, sizeof(__pyx_k_S_ISBLK), 0, 0, 1, 1},
   {&__pyx_n_s_S_ISCHR, __pyx_k_S_ISCHR, sizeof(__pyx_k_S_ISCHR), 0, 0, 1, 1},
   {&__pyx_n_s_S_ISDIR, __pyx_k_S_ISDIR, sizeof(__pyx_k_S_ISDIR), 0, 0, 1, 1},
   {&__pyx_n_s_S_ISFIFO, __pyx_k_S_ISFIFO, sizeof(__pyx_k_S_ISFIFO), 0, 0, 1, 1},
   {&__pyx_n_s_S_ISLNK, __pyx_k_S_ISLNK, sizeof(__pyx_k_S_ISLNK), 0, 0, 1, 1},
   {&__pyx_n_s_StableDict, __pyx_k_StableDict, sizeof(__pyx_k_StableDict), 0, 0, 1, 1},
+  {&__pyx_kp_s_Stores_a_change_in_a_diff_The_d, __pyx_k_Stores_a_change_in_a_diff_The_d, sizeof(__pyx_k_Stores_a_change_in_a_diff_The_d), 0, 0, 1, 0},
   {&__pyx_n_s_Timestamp, __pyx_k_Timestamp, sizeof(__pyx_k_Timestamp), 0, 0, 1, 1},
   {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
   {&__pyx_n_s_VALID_KEYS, __pyx_k_VALID_KEYS, sizeof(__pyx_k_VALID_KEYS), 0, 0, 1, 1},
   {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
   {&__pyx_kp_s__20, __pyx_k__20, sizeof(__pyx_k__20), 0, 0, 1, 0},
-  {&__pyx_kp_s__23, __pyx_k__23, sizeof(__pyx_k__23), 0, 0, 1, 0},
-  {&__pyx_kp_s__24, __pyx_k__24, sizeof(__pyx_k__24), 0, 0, 1, 0},
   {&__pyx_kp_b__9, __pyx_k__9, sizeof(__pyx_k__9), 0, 0, 0, 0},
   {&__pyx_n_s_a, __pyx_k_a, sizeof(__pyx_k_a), 0, 0, 1, 1},
   {&__pyx_n_s_acl_access, __pyx_k_acl_access, sizeof(__pyx_k_acl_access), 0, 0, 1, 1},
   {&__pyx_n_s_acl_default, __pyx_k_acl_default, sizeof(__pyx_k_acl_default), 0, 0, 1, 1},
   {&__pyx_n_s_acl_extended, __pyx_k_acl_extended, sizeof(__pyx_k_acl_extended), 0, 0, 1, 1},
   {&__pyx_n_s_acl_nfs4, __pyx_k_acl_nfs4, sizeof(__pyx_k_acl_nfs4), 0, 0, 1, 1},
-  {&__pyx_kp_s_added, __pyx_k_added, sizeof(__pyx_k_added), 0, 0, 1, 0},
-  {&__pyx_kp_s_added_13, __pyx_k_added_13, sizeof(__pyx_k_added_13), 0, 0, 1, 0},
+  {&__pyx_kp_u_added, __pyx_k_added, sizeof(__pyx_k_added), 0, 1, 0, 0},
   {&__pyx_n_s_added_2, __pyx_k_added_2, sizeof(__pyx_k_added_2), 0, 0, 1, 1},
   {&__pyx_n_s_added_ids, __pyx_k_added_ids, sizeof(__pyx_k_added_ids), 0, 0, 1, 1},
   {&__pyx_n_s_alen, __pyx_k_alen, sizeof(__pyx_k_alen), 0, 0, 1, 1},
   {&__pyx_n_s_algorithm, __pyx_k_algorithm, sizeof(__pyx_k_algorithm), 0, 0, 1, 1},
   {&__pyx_n_s_ap, __pyx_k_ap, sizeof(__pyx_k_ap), 0, 0, 1, 1},
   {&__pyx_n_s_archives, __pyx_k_archives, sizeof(__pyx_k_archives), 0, 0, 1, 1},
   {&__pyx_n_s_argon2_memory_cost, __pyx_k_argon2_memory_cost, sizeof(__pyx_k_argon2_memory_cost), 0, 0, 1, 1},
   {&__pyx_n_s_argon2_parallelism, __pyx_k_argon2_parallelism, sizeof(__pyx_k_argon2_parallelism), 0, 0, 1, 1},
   {&__pyx_n_s_argon2_time_cost, __pyx_k_argon2_time_cost, sizeof(__pyx_k_argon2_time_cost), 0, 0, 1, 1},
   {&__pyx_n_s_argon2_type, __pyx_k_argon2_type, sizeof(__pyx_k_argon2_type), 0, 0, 1, 1},
   {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
   {&__pyx_n_s_as_dict, __pyx_k_as_dict, sizeof(__pyx_k_as_dict), 0, 0, 1, 1},
+  {&__pyx_n_s_assert_sanitized_path, __pyx_k_assert_sanitized_path, sizeof(__pyx_k_assert_sanitized_path), 0, 0, 1, 1},
   {&__pyx_n_s_atime, __pyx_k_atime, sizeof(__pyx_k_atime), 0, 0, 1, 1},
   {&__pyx_n_s_attr, __pyx_k_attr, sizeof(__pyx_k_attr), 0, 0, 1, 1},
   {&__pyx_n_s_attr_list, __pyx_k_attr_list, sizeof(__pyx_k_attr_list), 0, 0, 1, 1},
   {&__pyx_kp_s_attribute_s_not_found, __pyx_k_attribute_s_not_found, sizeof(__pyx_k_attribute_s_not_found), 0, 0, 1, 0},
+  {&__pyx_n_s_attrs, __pyx_k_attrs, sizeof(__pyx_k_attrs), 0, 0, 1, 1},
   {&__pyx_n_s_b, __pyx_k_b, sizeof(__pyx_k_b), 0, 0, 1, 1},
   {&__pyx_n_s_birthtime, __pyx_k_birthtime, sizeof(__pyx_k_birthtime), 0, 0, 1, 1},
   {&__pyx_n_s_blen, __pyx_k_blen, sizeof(__pyx_k_blen), 0, 0, 1, 1},
   {&__pyx_n_s_blkdev, __pyx_k_blkdev, sizeof(__pyx_k_blkdev), 0, 0, 1, 1},
   {&__pyx_n_s_borg_item, __pyx_k_borg_item, sizeof(__pyx_k_borg_item), 0, 0, 1, 1},
   {&__pyx_n_s_bp, __pyx_k_bp, sizeof(__pyx_k_bp), 0, 0, 1, 1},
   {&__pyx_n_s_bsdflags, __pyx_k_bsdflags, sizeof(__pyx_k_bsdflags), 0, 0, 1, 1},
   {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
   {&__pyx_n_s_can_compare_chunk_ids, __pyx_k_can_compare_chunk_ids, sizeof(__pyx_k_can_compare_chunk_ids), 0, 0, 1, 1},
   {&__pyx_n_s_can_compare_chunk_ids_2, __pyx_k_can_compare_chunk_ids_2, sizeof(__pyx_k_can_compare_chunk_ids_2), 0, 0, 1, 1},
   {&__pyx_n_s_ce, __pyx_k_ce, sizeof(__pyx_k_ce), 0, 0, 1, 1},
   {&__pyx_n_s_ce_fixed, __pyx_k_ce_fixed, sizeof(__pyx_k_ce_fixed), 0, 0, 1, 1},
-  {&__pyx_n_s_ch, __pyx_k_ch, sizeof(__pyx_k_ch), 0, 0, 1, 1},
+  {&__pyx_kp_s_changed_group, __pyx_k_changed_group, sizeof(__pyx_k_changed_group), 0, 0, 1, 0},
   {&__pyx_kp_s_changed_link, __pyx_k_changed_link, sizeof(__pyx_k_changed_link), 0, 0, 1, 0},
+  {&__pyx_kp_s_changed_mode, __pyx_k_changed_mode, sizeof(__pyx_k_changed_mode), 0, 0, 1, 0},
+  {&__pyx_kp_s_changed_owner, __pyx_k_changed_owner, sizeof(__pyx_k_changed_owner), 0, 0, 1, 0},
+  {&__pyx_kp_s_changed_type, __pyx_k_changed_type, sizeof(__pyx_k_changed_type), 0, 0, 1, 0},
+  {&__pyx_kp_s_changed_user, __pyx_k_changed_user, sizeof(__pyx_k_changed_user), 0, 0, 1, 0},
   {&__pyx_n_s_changes, __pyx_k_changes, sizeof(__pyx_k_changes), 0, 0, 1, 1},
   {&__pyx_n_s_changes_2, __pyx_k_changes_2, sizeof(__pyx_k_changes_2), 0, 0, 1, 1},
   {&__pyx_n_s_check, __pyx_k_check, sizeof(__pyx_k_check), 0, 0, 1, 1},
   {&__pyx_n_s_check_key, __pyx_k_check_key, sizeof(__pyx_k_check_key), 0, 0, 1, 1},
-  {&__pyx_n_s_chg, __pyx_k_chg, sizeof(__pyx_k_chg), 0, 0, 1, 1},
   {&__pyx_n_s_chrdev, __pyx_k_chrdev, sizeof(__pyx_k_chrdev), 0, 0, 1, 1},
+  {&__pyx_n_s_chunk_1, __pyx_k_chunk_1, sizeof(__pyx_k_chunk_1), 0, 0, 1, 1},
+  {&__pyx_n_s_chunk_1_2, __pyx_k_chunk_1_2, sizeof(__pyx_k_chunk_1_2), 0, 0, 1, 1},
+  {&__pyx_n_s_chunk_2, __pyx_k_chunk_2, sizeof(__pyx_k_chunk_2), 0, 0, 1, 1},
+  {&__pyx_n_s_chunk_2_2, __pyx_k_chunk_2_2, sizeof(__pyx_k_chunk_2_2), 0, 0, 1, 1},
   {&__pyx_n_s_chunk_ids1, __pyx_k_chunk_ids1, sizeof(__pyx_k_chunk_ids1), 0, 0, 1, 1},
   {&__pyx_n_s_chunk_ids2, __pyx_k_chunk_ids2, sizeof(__pyx_k_chunk_ids2), 0, 0, 1, 1},
-  {&__pyx_n_s_chunk_iterator1, __pyx_k_chunk_iterator1, sizeof(__pyx_k_chunk_iterator1), 0, 0, 1, 1},
-  {&__pyx_n_s_chunk_iterator2, __pyx_k_chunk_iterator2, sizeof(__pyx_k_chunk_iterator2), 0, 0, 1, 1},
   {&__pyx_n_s_chunk_seed, __pyx_k_chunk_seed, sizeof(__pyx_k_chunk_seed), 0, 0, 1, 1},
   {&__pyx_n_s_chunker_params, __pyx_k_chunker_params, sizeof(__pyx_k_chunker_params), 0, 0, 1, 1},
   {&__pyx_n_s_chunks, __pyx_k_chunks, sizeof(__pyx_k_chunks), 0, 0, 1, 1},
   {&__pyx_n_s_chunks_a, __pyx_k_chunks_a, sizeof(__pyx_k_chunks_a), 0, 0, 1, 1},
   {&__pyx_n_s_chunks_b, __pyx_k_chunks_b, sizeof(__pyx_k_chunks_b), 0, 0, 1, 1},
   {&__pyx_n_s_chunks_contents_equal, __pyx_k_chunks_contents_equal, sizeof(__pyx_k_chunks_contents_equal), 0, 0, 1, 1},
   {&__pyx_n_s_chunks_healthy, __pyx_k_chunks_healthy, sizeof(__pyx_k_chunks_healthy), 0, 0, 1, 1},
@@ -21790,35 +22955,38 @@
   {&__pyx_n_s_cmdline, __pyx_k_cmdline, sizeof(__pyx_k_cmdline), 0, 0, 1, 1},
   {&__pyx_n_s_collections, __pyx_k_collections, sizeof(__pyx_k_collections), 0, 0, 1, 1},
   {&__pyx_n_s_command_line, __pyx_k_command_line, sizeof(__pyx_k_command_line), 0, 0, 1, 1},
   {&__pyx_n_s_comment, __pyx_k_comment, sizeof(__pyx_k_comment), 0, 0, 1, 1},
   {&__pyx_n_s_config, __pyx_k_config, sizeof(__pyx_k_config), 0, 0, 1, 1},
   {&__pyx_n_s_consider_ids, __pyx_k_consider_ids, sizeof(__pyx_k_consider_ids), 0, 0, 1, 1},
   {&__pyx_n_s_constants, __pyx_k_constants, sizeof(__pyx_k_constants), 0, 0, 1, 1},
+  {&__pyx_n_s_content, __pyx_k_content, sizeof(__pyx_k_content), 0, 0, 1, 1},
   {&__pyx_n_s_content_diff, __pyx_k_content_diff, sizeof(__pyx_k_content_diff), 0, 0, 1, 1},
   {&__pyx_n_s_content_equal, __pyx_k_content_equal, sizeof(__pyx_k_content_equal), 0, 0, 1, 1},
+  {&__pyx_n_s_content_only, __pyx_k_content_only, sizeof(__pyx_k_content_only), 0, 0, 1, 1},
   {&__pyx_n_s_create_deleted, __pyx_k_create_deleted, sizeof(__pyx_k_create_deleted), 0, 0, 1, 1},
   {&__pyx_n_s_crypt_key, __pyx_k_crypt_key, sizeof(__pyx_k_crypt_key), 0, 0, 1, 1},
   {&__pyx_n_s_ctime, __pyx_k_ctime, sizeof(__pyx_k_ctime), 0, 0, 1, 1},
   {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
   {&__pyx_n_s_data_dict, __pyx_k_data_dict, sizeof(__pyx_k_data_dict), 0, 0, 1, 1},
   {&__pyx_kp_s_data_dict_must_be_a_dict, __pyx_k_data_dict_must_be_a_dict, sizeof(__pyx_k_data_dict_must_be_a_dict), 0, 0, 1, 0},
   {&__pyx_n_s_decode, __pyx_k_decode, sizeof(__pyx_k_decode), 0, 0, 1, 1},
   {&__pyx_n_s_default, __pyx_k_default, sizeof(__pyx_k_default), 0, 0, 1, 1},
   {&__pyx_n_s_delete, __pyx_k_delete, sizeof(__pyx_k_delete), 0, 0, 1, 1},
   {&__pyx_n_s_deleted, __pyx_k_deleted, sizeof(__pyx_k_deleted), 0, 0, 1, 1},
   {&__pyx_kp_s_dict_of_str_dict, __pyx_k_dict_of_str_dict, sizeof(__pyx_k_dict_of_str_dict), 0, 0, 1, 0},
+  {&__pyx_n_s_diff_data, __pyx_k_diff_data, sizeof(__pyx_k_diff_data), 0, 0, 1, 1},
+  {&__pyx_n_s_diff_type, __pyx_k_diff_type, sizeof(__pyx_k_diff_type), 0, 0, 1, 1},
   {&__pyx_n_s_directory, __pyx_k_directory, sizeof(__pyx_k_directory), 0, 0, 1, 1},
   {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
   {&__pyx_n_s_e, __pyx_k_e, sizeof(__pyx_k_e), 0, 0, 1, 1},
   {&__pyx_n_s_enc_hmac_key, __pyx_k_enc_hmac_key, sizeof(__pyx_k_enc_hmac_key), 0, 0, 1, 1},
   {&__pyx_n_s_enc_key, __pyx_k_enc_key, sizeof(__pyx_k_enc_key), 0, 0, 1, 1},
   {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
   {&__pyx_n_s_equal, __pyx_k_equal, sizeof(__pyx_k_equal), 0, 0, 1, 1},
-  {&__pyx_n_s_equal_2, __pyx_k_equal_2, sizeof(__pyx_k_equal_2), 0, 0, 1, 1},
   {&__pyx_n_s_errors, __pyx_k_errors, sizeof(__pyx_k_errors), 0, 0, 1, 1},
   {&__pyx_n_s_feature_flags, __pyx_k_feature_flags, sizeof(__pyx_k_feature_flags), 0, 0, 1, 1},
   {&__pyx_n_s_fifo, __pyx_k_fifo, sizeof(__pyx_k_fifo), 0, 0, 1, 1},
   {&__pyx_n_s_filemode, __pyx_k_filemode, sizeof(__pyx_k_filemode), 0, 0, 1, 1},
   {&__pyx_n_s_fix_bytes_value, __pyx_k_fix_bytes_value, sizeof(__pyx_k_fix_bytes_value), 0, 0, 1, 1},
   {&__pyx_n_s_fix_key, __pyx_k_fix_key, sizeof(__pyx_k_fix_key), 0, 0, 1, 1},
   {&__pyx_n_s_fix_list_of_bytes, __pyx_k_fix_list_of_bytes, sizeof(__pyx_k_fix_list_of_bytes), 0, 0, 1, 1},
@@ -21826,15 +22994,14 @@
   {&__pyx_n_s_fix_list_of_str, __pyx_k_fix_list_of_str, sizeof(__pyx_k_fix_list_of_str), 0, 0, 1, 1},
   {&__pyx_n_s_fix_str_value, __pyx_k_fix_str_value, sizeof(__pyx_k_fix_str_value), 0, 0, 1, 1},
   {&__pyx_n_s_fix_timestamp, __pyx_k_fix_timestamp, sizeof(__pyx_k_fix_timestamp), 0, 0, 1, 1},
   {&__pyx_n_s_fix_tuple_of_str, __pyx_k_fix_tuple_of_str, sizeof(__pyx_k_fix_tuple_of_str), 0, 0, 1, 1},
   {&__pyx_n_s_fix_tuple_of_str_and_int, __pyx_k_fix_tuple_of_str_and_int, sizeof(__pyx_k_fix_tuple_of_str_and_int), 0, 0, 1, 1},
   {&__pyx_n_s_fix_tuple_of_str_and_int_locals, __pyx_k_fix_tuple_of_str_and_int_locals, sizeof(__pyx_k_fix_tuple_of_str_and_int_locals), 0, 0, 1, 1},
   {&__pyx_n_s_fix_tuple_of_str_locals_genexpr, __pyx_k_fix_tuple_of_str_locals_genexpr, sizeof(__pyx_k_fix_tuple_of_str_locals_genexpr), 0, 0, 1, 1},
-  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
   {&__pyx_n_s_format_file_size, __pyx_k_format_file_size, sizeof(__pyx_k_format_file_size), 0, 0, 1, 1},
   {&__pyx_n_s_from_bytes, __pyx_k_from_bytes, sizeof(__pyx_k_from_bytes), 0, 0, 1, 1},
   {&__pyx_n_s_from_chunks, __pyx_k_from_chunks, sizeof(__pyx_k_from_chunks), 0, 0, 1, 1},
   {&__pyx_n_s_from_optr, __pyx_k_from_optr, sizeof(__pyx_k_from_optr), 0, 0, 1, 1},
   {&__pyx_n_s_g1, __pyx_k_g1, sizeof(__pyx_k_g1), 0, 0, 1, 1},
   {&__pyx_n_s_g2, __pyx_k_g2, sizeof(__pyx_k_g2), 0, 0, 1, 1},
   {&__pyx_n_s_g_attr, __pyx_k_g_attr, sizeof(__pyx_k_g_attr), 0, 0, 1, 1},
@@ -21844,15 +23011,17 @@
   {&__pyx_n_s_get_size_locals_genexpr, __pyx_k_get_size_locals_genexpr, sizeof(__pyx_k_get_size_locals_genexpr), 0, 0, 1, 1},
   {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
   {&__pyx_n_s_gid, __pyx_k_gid, sizeof(__pyx_k_gid), 0, 0, 1, 1},
   {&__pyx_n_s_group, __pyx_k_group, sizeof(__pyx_k_group), 0, 0, 1, 1},
   {&__pyx_n_s_hardlink_master, __pyx_k_hardlink_master, sizeof(__pyx_k_hardlink_master), 0, 0, 1, 1},
   {&__pyx_n_s_hash, __pyx_k_hash, sizeof(__pyx_k_hash), 0, 0, 1, 1},
   {&__pyx_n_s_helpers, __pyx_k_helpers, sizeof(__pyx_k_helpers), 0, 0, 1, 1},
+  {&__pyx_n_s_helpers_fs, __pyx_k_helpers_fs, sizeof(__pyx_k_helpers_fs), 0, 0, 1, 1},
   {&__pyx_n_s_helpers_msgpack, __pyx_k_helpers_msgpack, sizeof(__pyx_k_helpers_msgpack), 0, 0, 1, 1},
+  {&__pyx_n_s_helpers_time, __pyx_k_helpers_time, sizeof(__pyx_k_helpers_time), 0, 0, 1, 1},
   {&__pyx_n_s_hlid, __pyx_k_hlid, sizeof(__pyx_k_hlid), 0, 0, 1, 1},
   {&__pyx_n_s_hostname, __pyx_k_hostname, sizeof(__pyx_k_hostname), 0, 0, 1, 1},
   {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
   {&__pyx_n_s_id_key, __pyx_k_id_key, sizeof(__pyx_k_id_key), 0, 0, 1, 1},
   {&__pyx_kp_s_id_size, __pyx_k_id_size, sizeof(__pyx_k_id_size), 0, 0, 1, 0},
   {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
   {&__pyx_n_s_init, __pyx_k_init, sizeof(__pyx_k_init), 0, 0, 1, 1},
@@ -21877,14 +23046,15 @@
   {&__pyx_n_s_items, __pyx_k_items, sizeof(__pyx_k_items), 0, 0, 1, 1},
   {&__pyx_n_s_iterations, __pyx_k_iterations, sizeof(__pyx_k_iterations), 0, 0, 1, 1},
   {&__pyx_n_s_join, __pyx_k_join, sizeof(__pyx_k_join), 0, 0, 1, 1},
   {&__pyx_kp_s_k_r, __pyx_k_k_r, sizeof(__pyx_k_k_r), 0, 0, 1, 0},
   {&__pyx_n_s_key, __pyx_k_key, sizeof(__pyx_k_key), 0, 0, 1, 1},
   {&__pyx_kp_s_key_must_be_str, __pyx_k_key_must_be_str, sizeof(__pyx_k_key_must_be_str), 0, 0, 1, 0},
   {&__pyx_kp_s_key_s_is_not_a_valid_key, __pyx_k_key_s_is_not_a_valid_key, sizeof(__pyx_k_key_s_is_not_a_valid_key), 0, 0, 1, 0},
+  {&__pyx_n_s_keys, __pyx_k_keys, sizeof(__pyx_k_keys), 0, 0, 1, 1},
   {&__pyx_n_s_link, __pyx_k_link, sizeof(__pyx_k_link), 0, 0, 1, 1},
   {&__pyx_n_s_link_diff, __pyx_k_link_diff, sizeof(__pyx_k_link_diff), 0, 0, 1, 1},
   {&__pyx_n_s_list, __pyx_k_list, sizeof(__pyx_k_list), 0, 0, 1, 1},
   {&__pyx_n_s_little, __pyx_k_little, sizeof(__pyx_k_little), 0, 0, 1, 1},
   {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
   {&__pyx_n_s_mandatory, __pyx_k_mandatory, sizeof(__pyx_k_mandatory), 0, 0, 1, 1},
   {&__pyx_n_s_memorize, __pyx_k_memorize, sizeof(__pyx_k_memorize), 0, 0, 1, 1},
@@ -21895,66 +23065,57 @@
   {&__pyx_n_s_mode_diff, __pyx_k_mode_diff, sizeof(__pyx_k_mode_diff), 0, 0, 1, 1},
   {&__pyx_n_s_modified, __pyx_k_modified, sizeof(__pyx_k_modified), 0, 0, 1, 1},
   {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
   {&__pyx_n_s_mtime, __pyx_k_mtime, sizeof(__pyx_k_mtime), 0, 0, 1, 1},
   {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
   {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
   {&__pyx_n_s_namedtuple, __pyx_k_namedtuple, sizeof(__pyx_k_namedtuple), 0, 0, 1, 1},
-  {&__pyx_n_s_new_group, __pyx_k_new_group, sizeof(__pyx_k_new_group), 0, 0, 1, 1},
-  {&__pyx_n_s_new_mode, __pyx_k_new_mode, sizeof(__pyx_k_new_mode), 0, 0, 1, 1},
-  {&__pyx_n_s_new_user, __pyx_k_new_user, sizeof(__pyx_k_new_user), 0, 0, 1, 1},
   {&__pyx_n_s_nfiles, __pyx_k_nfiles, sizeof(__pyx_k_nfiles), 0, 0, 1, 1},
   {&__pyx_n_s_nfiles_parts, __pyx_k_nfiles_parts, sizeof(__pyx_k_nfiles_parts), 0, 0, 1, 1},
   {&__pyx_n_s_nlink, __pyx_k_nlink, sizeof(__pyx_k_nlink), 0, 0, 1, 1},
   {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
   {&__pyx_kp_u_not_a_bytes_object_but, __pyx_k_not_a_bytes_object_but, sizeof(__pyx_k_not_a_bytes_object_but), 0, 1, 0, 0},
   {&__pyx_kp_u_not_a_str_object_but, __pyx_k_not_a_str_object_but, sizeof(__pyx_k_not_a_str_object_but), 0, 1, 0, 0},
   {&__pyx_n_s_numeric_ids, __pyx_k_numeric_ids, sizeof(__pyx_k_numeric_ids), 0, 0, 1, 1},
   {&__pyx_n_s_numeric_ids_2, __pyx_k_numeric_ids_2, sizeof(__pyx_k_numeric_ids_2), 0, 0, 1, 1},
-  {&__pyx_n_s_old_group, __pyx_k_old_group, sizeof(__pyx_k_old_group), 0, 0, 1, 1},
-  {&__pyx_n_s_old_mode, __pyx_k_old_mode, sizeof(__pyx_k_old_mode), 0, 0, 1, 1},
-  {&__pyx_n_s_old_user, __pyx_k_old_user, sizeof(__pyx_k_old_user), 0, 0, 1, 1},
   {&__pyx_n_s_owner, __pyx_k_owner, sizeof(__pyx_k_owner), 0, 0, 1, 1},
   {&__pyx_n_s_owner_diff, __pyx_k_owner_diff, sizeof(__pyx_k_owner_diff), 0, 0, 1, 1},
   {&__pyx_n_s_part, __pyx_k_part, sizeof(__pyx_k_part), 0, 0, 1, 1},
   {&__pyx_n_s_path, __pyx_k_path, sizeof(__pyx_k_path), 0, 0, 1, 1},
-  {&__pyx_n_s_pd, __pyx_k_pd, sizeof(__pyx_k_pd), 0, 0, 1, 1},
   {&__pyx_n_s_pop, __pyx_k_pop, sizeof(__pyx_k_pop), 0, 0, 1, 1},
-  {&__pyx_n_s_precision, __pyx_k_precision, sizeof(__pyx_k_precision), 0, 0, 1, 1},
   {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
   {&__pyx_n_s_presence_diff, __pyx_k_presence_diff, sizeof(__pyx_k_presence_diff), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
   {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
   {&__pyx_n_s_rdev, __pyx_k_rdev, sizeof(__pyx_k_rdev), 0, 0, 1, 1},
   {&__pyx_n_s_read, __pyx_k_read, sizeof(__pyx_k_read), 0, 0, 1, 1},
   {&__pyx_n_s_recreate_args, __pyx_k_recreate_args, sizeof(__pyx_k_recreate_args), 0, 0, 1, 1},
   {&__pyx_n_s_recreate_cmdline, __pyx_k_recreate_cmdline, sizeof(__pyx_k_recreate_cmdline), 0, 0, 1, 1},
   {&__pyx_n_s_recreate_command_line, __pyx_k_recreate_command_line, sizeof(__pyx_k_recreate_command_line), 0, 0, 1, 1},
   {&__pyx_n_s_recreate_partial_chunks, __pyx_k_recreate_partial_chunks, sizeof(__pyx_k_recreate_partial_chunks), 0, 0, 1, 1},
   {&__pyx_n_s_recreate_source_id, __pyx_k_recreate_source_id, sizeof(__pyx_k_recreate_source_id), 0, 0, 1, 1},
   {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
-  {&__pyx_kp_s_removed, __pyx_k_removed, sizeof(__pyx_k_removed), 0, 0, 1, 0},
-  {&__pyx_kp_s_removed_11, __pyx_k_removed_11, sizeof(__pyx_k_removed_11), 0, 0, 1, 0},
+  {&__pyx_kp_u_removed, __pyx_k_removed, sizeof(__pyx_k_removed), 0, 1, 0, 0},
   {&__pyx_n_s_removed_2, __pyx_k_removed_2, sizeof(__pyx_k_removed_2), 0, 0, 1, 1},
   {&__pyx_n_s_removed_ids, __pyx_k_removed_ids, sizeof(__pyx_k_removed_ids), 0, 0, 1, 1},
   {&__pyx_n_s_replace, __pyx_k_replace, sizeof(__pyx_k_replace), 0, 0, 1, 1},
   {&__pyx_n_s_repository_id, __pyx_k_repository_id, sizeof(__pyx_k_repository_id), 0, 0, 1, 1},
   {&__pyx_n_s_repr, __pyx_k_repr, sizeof(__pyx_k_repr), 0, 0, 1, 1},
   {&__pyx_kp_s_s_internal_dict_r, __pyx_k_s_internal_dict_r, sizeof(__pyx_k_s_internal_dict_r), 0, 0, 1, 0},
   {&__pyx_kp_s_s_s, __pyx_k_s_s, sizeof(__pyx_k_s_s), 0, 0, 1, 0},
   {&__pyx_kp_s_s_value_must_be_s, __pyx_k_s_value_must_be_s, sizeof(__pyx_k_s_value_must_be_s), 0, 0, 1, 0},
+  {&__pyx_n_s_safe_timestamp, __pyx_k_safe_timestamp, sizeof(__pyx_k_safe_timestamp), 0, 0, 1, 1},
   {&__pyx_n_s_salt, __pyx_k_salt, sizeof(__pyx_k_salt), 0, 0, 1, 1},
   {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
   {&__pyx_n_s_send, __pyx_k_send, sizeof(__pyx_k_send), 0, 0, 1, 1},
   {&__pyx_n_s_set_name, __pyx_k_set_name, sizeof(__pyx_k_set_name), 0, 0, 1, 1},
   {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
-  {&__pyx_n_s_sign, __pyx_k_sign, sizeof(__pyx_k_sign), 0, 0, 1, 1},
   {&__pyx_n_s_signed, __pyx_k_signed, sizeof(__pyx_k_signed), 0, 0, 1, 1},
   {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
   {&__pyx_n_s_size_parts, __pyx_k_size_parts, sizeof(__pyx_k_size_parts), 0, 0, 1, 1},
   {&__pyx_n_s_slicelen, __pyx_k_slicelen, sizeof(__pyx_k_slicelen), 0, 0, 1, 1},
   {&__pyx_n_s_source, __pyx_k_source, sizeof(__pyx_k_source), 0, 0, 1, 1},
   {&__pyx_kp_s_src_borg_item_pyx, __pyx_k_src_borg_item_pyx, sizeof(__pyx_k_src_borg_item_pyx), 0, 0, 1, 0},
   {&__pyx_n_s_stat, __pyx_k_stat, sizeof(__pyx_k_stat), 0, 0, 1, 1},
@@ -21966,17 +23127,22 @@
   {&__pyx_n_s_sz, __pyx_k_sz, sizeof(__pyx_k_sz), 0, 0, 1, 1},
   {&__pyx_n_s_t, __pyx_k_t, sizeof(__pyx_k_t), 0, 0, 1, 1},
   {&__pyx_n_s_tam_required, __pyx_k_tam_required, sizeof(__pyx_k_tam_required), 0, 0, 1, 1},
   {&__pyx_n_s_target, __pyx_k_target, sizeof(__pyx_k_target), 0, 0, 1, 1},
   {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
   {&__pyx_n_s_throw, __pyx_k_throw, sizeof(__pyx_k_throw), 0, 0, 1, 1},
   {&__pyx_n_s_time, __pyx_k_time, sizeof(__pyx_k_time), 0, 0, 1, 1},
+  {&__pyx_n_s_time_diffs, __pyx_k_time_diffs, sizeof(__pyx_k_time_diffs), 0, 0, 1, 1},
   {&__pyx_n_s_time_end, __pyx_k_time_end, sizeof(__pyx_k_time_end), 0, 0, 1, 1},
   {&__pyx_n_s_timestamp, __pyx_k_timestamp, sizeof(__pyx_k_timestamp), 0, 0, 1, 1},
   {&__pyx_n_s_timestamp_to_int, __pyx_k_timestamp_to_int, sizeof(__pyx_k_timestamp_to_int), 0, 0, 1, 1},
+  {&__pyx_n_s_to_dict, __pyx_k_to_dict, sizeof(__pyx_k_to_dict), 0, 0, 1, 1},
+  {&__pyx_n_s_to_sanitized_path, __pyx_k_to_sanitized_path, sizeof(__pyx_k_to_sanitized_path), 0, 0, 1, 1},
+  {&__pyx_n_s_ts1, __pyx_k_ts1, sizeof(__pyx_k_ts1), 0, 0, 1, 1},
+  {&__pyx_n_s_ts2, __pyx_k_ts2, sizeof(__pyx_k_ts2), 0, 0, 1, 1},
   {&__pyx_kp_s_tuple_of_str, __pyx_k_tuple_of_str, sizeof(__pyx_k_tuple_of_str), 0, 0, 1, 0},
   {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
   {&__pyx_n_s_u1, __pyx_k_u1, sizeof(__pyx_k_u1), 0, 0, 1, 1},
   {&__pyx_n_s_u2, __pyx_k_u2, sizeof(__pyx_k_u2), 0, 0, 1, 1},
   {&__pyx_n_s_u_attr, __pyx_k_u_attr, sizeof(__pyx_k_u_attr), 0, 0, 1, 1},
   {&__pyx_n_s_uid, __pyx_k_uid, sizeof(__pyx_k_uid), 0, 0, 1, 1},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
@@ -21993,70 +23159,70 @@
   {&__pyx_n_s_want_bytes, __pyx_k_want_bytes, sizeof(__pyx_k_want_bytes), 0, 0, 1, 1},
   {&__pyx_n_s_want_str, __pyx_k_want_str, sizeof(__pyx_k_want_str), 0, 0, 1, 1},
   {&__pyx_n_s_write, __pyx_k_write, sizeof(__pyx_k_write), 0, 0, 1, 1},
   {&__pyx_n_s_xattrs, __pyx_k_xattrs, sizeof(__pyx_k_xattrs), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(0, 148, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 185, __pyx_L1_error)
-  __pyx_builtin_KeyError = __Pyx_GetBuiltinName(__pyx_n_s_KeyError); if (!__pyx_builtin_KeyError) __PYX_ERR(0, 218, __pyx_L1_error)
-  __pyx_builtin_AttributeError = __Pyx_GetBuiltinName(__pyx_n_s_AttributeError); if (!__pyx_builtin_AttributeError) __PYX_ERR(0, 219, __pyx_L1_error)
-  __pyx_builtin_sum = __Pyx_GetBuiltinName(__pyx_n_s_sum); if (!__pyx_builtin_sum) __PYX_ERR(0, 328, __pyx_L1_error)
-  __pyx_builtin_vars = __Pyx_GetBuiltinName(__pyx_n_s_vars); if (!__pyx_builtin_vars) __PYX_ERR(0, 614, __pyx_L1_error)
+  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(0, 150, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 187, __pyx_L1_error)
+  __pyx_builtin_KeyError = __Pyx_GetBuiltinName(__pyx_n_s_KeyError); if (!__pyx_builtin_KeyError) __PYX_ERR(0, 220, __pyx_L1_error)
+  __pyx_builtin_AttributeError = __Pyx_GetBuiltinName(__pyx_n_s_AttributeError); if (!__pyx_builtin_AttributeError) __PYX_ERR(0, 221, __pyx_L1_error)
+  __pyx_builtin_sum = __Pyx_GetBuiltinName(__pyx_n_s_sum); if (!__pyx_builtin_sum) __PYX_ERR(0, 330, __pyx_L1_error)
+  __pyx_builtin_vars = __Pyx_GetBuiltinName(__pyx_n_s_vars); if (!__pyx_builtin_vars) __PYX_ERR(0, 616, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "borg/item.pyx":25
+  /* "borg/item.pyx":27
  *     if isinstance(key, bytes):
  *         value = data.pop(key)
  *         key = key.decode('utf-8', errors=errors)             # <<<<<<<<<<<<<<
  *         data[key] = value
  *     assert isinstance(key, str)
  */
-  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_utf_8); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 25, __pyx_L1_error)
+  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_utf_8); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 27, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple_);
   __Pyx_GIVEREF(__pyx_tuple_);
 
-  /* "borg/item.pyx":148
+  /* "borg/item.pyx":150
  *             self.update_internal(internal_dict)
  *         else:
  *             raise TypeError("internal_dict must be a dict")             # <<<<<<<<<<<<<<
  *         if data_dict is None:
  *             data = kw
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_internal_dict_must_be_a_dict); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 148, __pyx_L1_error)
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_internal_dict_must_be_a_dict); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 150, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__2);
   __Pyx_GIVEREF(__pyx_tuple__2);
 
-  /* "borg/item.pyx":154
+  /* "borg/item.pyx":156
  *             data = data_dict
  *         else:
  *             raise TypeError("data_dict must be a dict")             # <<<<<<<<<<<<<<
  *         if data:
  *             self.update(data)
  */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_data_dict_must_be_a_dict); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 154, __pyx_L1_error)
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_data_dict_must_be_a_dict); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 156, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__3);
   __Pyx_GIVEREF(__pyx_tuple__3);
 
-  /* "borg/item.pyx":183
+  /* "borg/item.pyx":185
  *         """make sure key is of type str and known"""
  *         if not isinstance(key, str):
  *             raise TypeError("key must be str")             # <<<<<<<<<<<<<<
  *         if key not in self.VALID_KEYS:
  *             raise ValueError("key '%s' is not a valid key" % key)
  */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_key_must_be_str); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 183, __pyx_L1_error)
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_key_must_be_str); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 185, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__4);
   __Pyx_GIVEREF(__pyx_tuple__4);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
@@ -22185,316 +23351,453 @@
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
   __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__19);
   __Pyx_GIVEREF(__pyx_tuple__19);
 
-  /* "borg/item.pyx":726
+  /* "borg/item.pyx":748
  * 
  *     def _owner_diff(self):
  *         u_attr, g_attr = ('uid', 'gid') if self._numeric_ids else ('user', 'group')             # <<<<<<<<<<<<<<
  *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
  *         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)
  */
-  __pyx_tuple__21 = PyTuple_Pack(2, __pyx_n_s_uid, __pyx_n_s_gid); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 726, __pyx_L1_error)
+  __pyx_tuple__21 = PyTuple_Pack(2, __pyx_n_s_uid, __pyx_n_s_gid); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 748, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__21);
   __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_tuple__22 = PyTuple_Pack(2, __pyx_n_s_user, __pyx_n_s_group); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 726, __pyx_L1_error)
+  __pyx_tuple__22 = PyTuple_Pack(2, __pyx_n_s_user, __pyx_n_s_group); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 748, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__22);
   __Pyx_GIVEREF(__pyx_tuple__22);
 
-  /* "borg/item.pyx":21
+  /* "borg/item.pyx":23
  * 
  * 
  * def fix_key(data, key, *, errors='strict'):             # <<<<<<<<<<<<<<
  *     """if k is a bytes-typed key, migrate key/value to a str-typed key in dict data"""
  *     if isinstance(key, bytes):
  */
-  __pyx_tuple__25 = PyTuple_Pack(4, __pyx_n_s_data, __pyx_n_s_key, __pyx_n_s_errors, __pyx_n_s_value); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 21, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__25);
-  __Pyx_GIVEREF(__pyx_tuple__25);
-  __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(2, 1, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_key, 21, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) __PYX_ERR(0, 21, __pyx_L1_error)
+  __pyx_tuple__23 = PyTuple_Pack(4, __pyx_n_s_data, __pyx_n_s_key, __pyx_n_s_errors, __pyx_n_s_value); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 23, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
+  __pyx_codeobj__24 = (PyObject*)__Pyx_PyCode_New(2, 1, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_key, 23, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__24)) __PYX_ERR(0, 23, __pyx_L1_error)
 
-  /* "borg/item.pyx":31
+  /* "borg/item.pyx":33
  * 
  * 
  * def fix_str_value(data, key, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """makes sure that data[key] is a str (decode if it is bytes)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  */
-  __pyx_tuple__27 = PyTuple_Pack(4, __pyx_n_s_data, __pyx_n_s_key, __pyx_n_s_errors, __pyx_n_s_value); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 31, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__27);
-  __Pyx_GIVEREF(__pyx_tuple__27);
-  __pyx_codeobj__28 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__27, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_str_value, 31, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__28)) __PYX_ERR(0, 31, __pyx_L1_error)
+  __pyx_tuple__25 = PyTuple_Pack(4, __pyx_n_s_data, __pyx_n_s_key, __pyx_n_s_errors, __pyx_n_s_value); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 33, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__25);
+  __Pyx_GIVEREF(__pyx_tuple__25);
+  __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_str_value, 33, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) __PYX_ERR(0, 33, __pyx_L1_error)
 
-  /* "borg/item.pyx":40
+  /* "borg/item.pyx":42
  * 
  * 
  * def fix_bytes_value(data, key):             # <<<<<<<<<<<<<<
  *     """makes sure that data[key] is bytes (encode if it is str)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  */
-  __pyx_tuple__29 = PyTuple_Pack(3, __pyx_n_s_data, __pyx_n_s_key, __pyx_n_s_value); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 40, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__29);
-  __Pyx_GIVEREF(__pyx_tuple__29);
-  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_bytes_value, 40, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __pyx_tuple__27 = PyTuple_Pack(3, __pyx_n_s_data, __pyx_n_s_key, __pyx_n_s_value); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 42, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__27);
+  __Pyx_GIVEREF(__pyx_tuple__27);
+  __pyx_codeobj__28 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__27, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_bytes_value, 42, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__28)) __PYX_ERR(0, 42, __pyx_L1_error)
 
-  /* "borg/item.pyx":49
+  /* "borg/item.pyx":51
  * 
  * 
  * def fix_list_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of str"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_tuple__31 = PyTuple_Pack(2, __pyx_n_s_v, __pyx_n_s_e); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__31);
-  __Pyx_GIVEREF(__pyx_tuple__31);
-  __pyx_codeobj__32 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__31, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_list_of_str, 49, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__32)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __pyx_tuple__29 = PyTuple_Pack(2, __pyx_n_s_v, __pyx_n_s_e); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 51, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__29);
+  __Pyx_GIVEREF(__pyx_tuple__29);
+  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_list_of_str, 51, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(0, 51, __pyx_L1_error)
 
-  /* "borg/item.pyx":55
+  /* "borg/item.pyx":57
  * 
  * 
  * def fix_list_of_bytes(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of bytes"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_tuple__33 = PyTuple_Pack(2, __pyx_n_s_v, __pyx_n_s_e); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 55, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__33);
-  __Pyx_GIVEREF(__pyx_tuple__33);
-  __pyx_codeobj__34 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__33, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_list_of_bytes, 55, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__34)) __PYX_ERR(0, 55, __pyx_L1_error)
+  __pyx_tuple__31 = PyTuple_Pack(2, __pyx_n_s_v, __pyx_n_s_e); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(0, 57, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__31);
+  __Pyx_GIVEREF(__pyx_tuple__31);
+  __pyx_codeobj__32 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__31, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_list_of_bytes, 57, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__32)) __PYX_ERR(0, 57, __pyx_L1_error)
 
-  /* "borg/item.pyx":61
+  /* "borg/item.pyx":63
  * 
  * 
  * def fix_list_of_chunkentries(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of correct chunkentries"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_tuple__35 = PyTuple_Pack(4, __pyx_n_s_v, __pyx_n_s_chunks, __pyx_n_s_ce, __pyx_n_s_ce_fixed); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 61, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__35);
-  __Pyx_GIVEREF(__pyx_tuple__35);
-  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_list_of_chunkentries, 61, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 61, __pyx_L1_error)
+  __pyx_tuple__33 = PyTuple_Pack(4, __pyx_n_s_v, __pyx_n_s_chunks, __pyx_n_s_ce, __pyx_n_s_ce_fixed); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 63, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__33);
+  __Pyx_GIVEREF(__pyx_tuple__33);
+  __pyx_codeobj__34 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__33, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_list_of_chunkentries, 63, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__34)) __PYX_ERR(0, 63, __pyx_L1_error)
 
-  /* "borg/item.pyx":75
+  /* "borg/item.pyx":77
  * 
  * 
  * def fix_tuple_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_tuple__37 = PyTuple_Pack(3, __pyx_n_s_v, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 75, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__37);
-  __Pyx_GIVEREF(__pyx_tuple__37);
-  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_tuple_of_str, 75, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __pyx_tuple__35 = PyTuple_Pack(3, __pyx_n_s_v, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 77, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__35);
+  __Pyx_GIVEREF(__pyx_tuple__35);
+  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_tuple_of_str, 77, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 77, __pyx_L1_error)
 
-  /* "borg/item.pyx":81
+  /* "borg/item.pyx":83
  * 
  * 
  * def fix_tuple_of_str_and_int(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_tuple__39 = PyTuple_Pack(5, __pyx_n_s_v, __pyx_n_s_t, __pyx_n_s_genexpr, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 81, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__39);
-  __Pyx_GIVEREF(__pyx_tuple__39);
-  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_tuple_of_str_and_int, 81, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(0, 81, __pyx_L1_error)
+  __pyx_tuple__37 = PyTuple_Pack(5, __pyx_n_s_v, __pyx_n_s_t, __pyx_n_s_genexpr, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__37);
+  __Pyx_GIVEREF(__pyx_tuple__37);
+  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_tuple_of_str_and_int, 83, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 83, __pyx_L1_error)
 
-  /* "borg/item.pyx":89
+  /* "borg/item.pyx":91
  * 
  * 
  * def fix_timestamp(v):             # <<<<<<<<<<<<<<
  *     """make sure v is a Timestamp"""
  *     if isinstance(v, Timestamp):
  */
-  __pyx_tuple__41 = PyTuple_Pack(1, __pyx_n_s_v); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 89, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__41);
-  __Pyx_GIVEREF(__pyx_tuple__41);
-  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_timestamp, 89, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_tuple__39 = PyTuple_Pack(1, __pyx_n_s_v); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__39);
+  __Pyx_GIVEREF(__pyx_tuple__39);
+  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_fix_timestamp, 91, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(0, 91, __pyx_L1_error)
 
-  /* "borg/item.pyx":100
+  /* "borg/item.pyx":102
  * 
  * 
  * def want_bytes(v, *, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """we know that we want bytes and the value should be bytes"""
  *     # legacy support: it being str can be caused by msgpack unpack decoding old data that was packed with use_bin_type=False
  */
-  __pyx_tuple__43 = PyTuple_Pack(2, __pyx_n_s_v, __pyx_n_s_errors); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(0, 100, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__43);
-  __Pyx_GIVEREF(__pyx_tuple__43);
-  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(1, 1, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__43, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_want_bytes, 100, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __pyx_tuple__41 = PyTuple_Pack(2, __pyx_n_s_v, __pyx_n_s_errors); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__41);
+  __Pyx_GIVEREF(__pyx_tuple__41);
+  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(1, 1, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_want_bytes, 102, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 102, __pyx_L1_error)
 
-  /* "borg/item.pyx":109
+  /* "borg/item.pyx":111
  * 
  * 
  * def want_str(v, *, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """we know that we want str and the value should be str"""
  *     if isinstance(v, bytes):
  */
-  __pyx_tuple__45 = PyTuple_Pack(2, __pyx_n_s_v, __pyx_n_s_errors); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 109, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__45);
-  __Pyx_GIVEREF(__pyx_tuple__45);
-  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(1, 1, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_want_str, 109, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) __PYX_ERR(0, 109, __pyx_L1_error)
+  __pyx_tuple__43 = PyTuple_Pack(2, __pyx_n_s_v, __pyx_n_s_errors); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(0, 111, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__43);
+  __Pyx_GIVEREF(__pyx_tuple__43);
+  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(1, 1, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__43, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_want_str, 111, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) __PYX_ERR(0, 111, __pyx_L1_error)
 
-  /* "borg/item.pyx":246
+  /* "borg/item.pyx":248
  * 
  * 
  * ChunkListEntry = namedtuple('ChunkListEntry', 'id size')             # <<<<<<<<<<<<<<
  * 
  * cdef class Item(PropDict):
  */
-  __pyx_tuple__47 = PyTuple_Pack(2, __pyx_n_s_ChunkListEntry, __pyx_kp_s_id_size); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(0, 246, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__47);
-  __Pyx_GIVEREF(__pyx_tuple__47);
+  __pyx_tuple__45 = PyTuple_Pack(2, __pyx_n_s_ChunkListEntry, __pyx_kp_s_id_size); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 248, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__45);
+  __Pyx_GIVEREF(__pyx_tuple__45);
+
+  /* "borg/item.pyx":630
+ *     The diff_data contains additional information about the change, e.g. the old and new mode.
+ *     """
+ *     def __init__(self, diff_type, diff_data=None):             # <<<<<<<<<<<<<<
+ *         self.diff_type = diff_type
+ *         self.diff_data = diff_data or {}
+ */
+  __pyx_tuple__46 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_diff_type, __pyx_n_s_diff_data); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 630, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__46);
+  __Pyx_GIVEREF(__pyx_tuple__46);
+  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__46, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_init, 630, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(0, 630, __pyx_L1_error)
+  __pyx_tuple__48 = PyTuple_Pack(1, ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 630, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__48);
+  __Pyx_GIVEREF(__pyx_tuple__48);
+
+  /* "borg/item.pyx":634
+ *         self.diff_data = diff_data or {}
+ * 
+ *     def to_dict(self):             # <<<<<<<<<<<<<<
+ *         return {"type": self.diff_type, **self.diff_data}
+ * 
+ */
+  __pyx_tuple__49 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(0, 634, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__49);
+  __Pyx_GIVEREF(__pyx_tuple__49);
+  __pyx_codeobj__50 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__49, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_to_dict, 634, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__50)) __PYX_ERR(0, 634, __pyx_L1_error)
 
-  /* "borg/item.pyx":629
+  /* "borg/item.pyx":645
  *     """
  * 
- *     def __init__(self, item1, item2, chunk_iterator1, chunk_iterator2, numeric_ids=False, can_compare_chunk_ids=False):             # <<<<<<<<<<<<<<
+ *     def __init__(self, path, item1, item2, chunk_1, chunk_2, numeric_ids=False, can_compare_chunk_ids=False):             # <<<<<<<<<<<<<<
+ *         self.path = path
  *         self._item1 = item1
- *         self._item2 = item2
  */
-  __pyx_tuple__48 = PyTuple_Pack(9, __pyx_n_s_self, __pyx_n_s_item1, __pyx_n_s_item2, __pyx_n_s_chunk_iterator1, __pyx_n_s_chunk_iterator2, __pyx_n_s_numeric_ids, __pyx_n_s_can_compare_chunk_ids, __pyx_n_s_changes_2, __pyx_n_s_ch); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 629, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__48);
-  __Pyx_GIVEREF(__pyx_tuple__48);
-  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(7, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__48, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_init, 629, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) __PYX_ERR(0, 629, __pyx_L1_error)
-  __pyx_tuple__50 = PyTuple_Pack(2, ((PyObject *)Py_False), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 629, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__50);
-  __Pyx_GIVEREF(__pyx_tuple__50);
+  __pyx_tuple__51 = PyTuple_Pack(8, __pyx_n_s_self, __pyx_n_s_path, __pyx_n_s_item1, __pyx_n_s_item2, __pyx_n_s_chunk_1, __pyx_n_s_chunk_2, __pyx_n_s_numeric_ids, __pyx_n_s_can_compare_chunk_ids); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 645, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__51);
+  __Pyx_GIVEREF(__pyx_tuple__51);
+  __pyx_codeobj__52 = (PyObject*)__Pyx_PyCode_New(8, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__51, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_init, 645, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__52)) __PYX_ERR(0, 645, __pyx_L1_error)
+  __pyx_tuple__53 = PyTuple_Pack(2, ((PyObject *)Py_False), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 645, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__53);
+  __Pyx_GIVEREF(__pyx_tuple__53);
 
-  /* "borg/item.pyx":662
- *         self._changes = [ch for ch in changes if ch]
+  /* "borg/item.pyx":680
+ * 
  * 
  *     def changes(self):             # <<<<<<<<<<<<<<
  *         return self._changes
  * 
  */
-  __pyx_tuple__51 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 662, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__51);
-  __Pyx_GIVEREF(__pyx_tuple__51);
-  __pyx_codeobj__52 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__51, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_changes_2, 662, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__52)) __PYX_ERR(0, 662, __pyx_L1_error)
+  __pyx_tuple__54 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__54)) __PYX_ERR(0, 680, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__54);
+  __Pyx_GIVEREF(__pyx_tuple__54);
+  __pyx_codeobj__55 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__54, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_changes_2, 680, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__55)) __PYX_ERR(0, 680, __pyx_L1_error)
 
-  /* "borg/item.pyx":665
+  /* "borg/item.pyx":683
  *         return self._changes
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
- *         if self.equal:
- *             return 'equal'
+ *         return (' '.join(self._changes.keys())) or 'equal'
+ * 
  */
-  __pyx_tuple__53 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 665, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__53);
-  __Pyx_GIVEREF(__pyx_tuple__53);
-  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_repr, 665, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) __PYX_ERR(0, 665, __pyx_L1_error)
+  __pyx_tuple__56 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__56)) __PYX_ERR(0, 683, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__56);
+  __Pyx_GIVEREF(__pyx_tuple__56);
+  __pyx_codeobj__57 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__56, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_repr, 683, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__57)) __PYX_ERR(0, 683, __pyx_L1_error)
 
-  /* "borg/item.pyx":670
- *         return ' '.join(str for d, str in self._changes)
+  /* "borg/item.pyx":686
+ *         return (' '.join(self._changes.keys())) or 'equal'
  * 
- *     def _equal(self, chunk_iterator1, chunk_iterator2):             # <<<<<<<<<<<<<<
+ *     def equal(self, content_only=False):             # <<<<<<<<<<<<<<
  *         # if both are deleted, there is nothing at path regardless of what was deleted
  *         if self._item1.get('deleted') and self._item2.get('deleted'):
  */
-  __pyx_tuple__55 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_chunk_iterator1, __pyx_n_s_chunk_iterator2, __pyx_n_s_attr_list, __pyx_n_s_attr); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 670, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__55);
-  __Pyx_GIVEREF(__pyx_tuple__55);
-  __pyx_codeobj__56 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__55, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_equal, 670, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__56)) __PYX_ERR(0, 670, __pyx_L1_error)
+  __pyx_tuple__58 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_content_only, __pyx_n_s_attr_list, __pyx_n_s_attr); if (unlikely(!__pyx_tuple__58)) __PYX_ERR(0, 686, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__58);
+  __Pyx_GIVEREF(__pyx_tuple__58);
+  __pyx_codeobj__59 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__58, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_equal, 686, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__59)) __PYX_ERR(0, 686, __pyx_L1_error)
+  __pyx_tuple__60 = PyTuple_Pack(1, ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__60)) __PYX_ERR(0, 686, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__60);
+  __Pyx_GIVEREF(__pyx_tuple__60);
 
-  /* "borg/item.pyx":691
+  /* "borg/item.pyx":710
  *         return True
  * 
  *     def _presence_diff(self, item_type):             # <<<<<<<<<<<<<<
  *         if not self._item1.get('deleted') and self._item2.get('deleted'):
- *             chg = 'removed ' + item_type
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")
  */
-  __pyx_tuple__57 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_item_type, __pyx_n_s_chg); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(0, 691, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__57);
-  __Pyx_GIVEREF(__pyx_tuple__57);
-  __pyx_codeobj__58 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__57, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_presence_diff, 691, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__58)) __PYX_ERR(0, 691, __pyx_L1_error)
+  __pyx_tuple__61 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_item_type); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(0, 710, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__61);
+  __Pyx_GIVEREF(__pyx_tuple__61);
+  __pyx_codeobj__62 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__61, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_presence_diff, 710, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__62)) __PYX_ERR(0, 710, __pyx_L1_error)
 
-  /* "borg/item.pyx":699
- *             return ({"type": chg}, chg)
+  /* "borg/item.pyx":718
+ *             return True
  * 
  *     def _link_diff(self):             # <<<<<<<<<<<<<<
- *         pd = self._presence_diff('link')
- *         if pd is not None:
+ *         if self._presence_diff('link'):
+ *             return True
  */
-  __pyx_tuple__59 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_pd); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 699, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__59);
-  __Pyx_GIVEREF(__pyx_tuple__59);
-  __pyx_codeobj__60 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__59, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_link_diff, 699, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__60)) __PYX_ERR(0, 699, __pyx_L1_error)
+  __pyx_tuple__63 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__63)) __PYX_ERR(0, 718, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__63);
+  __Pyx_GIVEREF(__pyx_tuple__63);
+  __pyx_codeobj__64 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__63, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_link_diff, 718, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__64)) __PYX_ERR(0, 718, __pyx_L1_error)
 
-  /* "borg/item.pyx":706
- *             return ({"type": 'changed link'}, 'changed link')
+  /* "borg/item.pyx":725
+ *             return True
  * 
  *     def _content_diff(self):             # <<<<<<<<<<<<<<
  *         if self._item1.get('deleted'):
  *             sz = self._item2.get_size()
  */
-  __pyx_tuple__61 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_sz, __pyx_n_s_chunk_ids1, __pyx_n_s_chunk_ids2, __pyx_n_s_added_ids, __pyx_n_s_removed_ids, __pyx_n_s_added_2, __pyx_n_s_removed_2, __pyx_n_s_c, __pyx_n_s_c); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(0, 706, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__61);
-  __Pyx_GIVEREF(__pyx_tuple__61);
-  __pyx_codeobj__62 = (PyObject*)__Pyx_PyCode_New(1, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__61, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_content_diff, 706, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__62)) __PYX_ERR(0, 706, __pyx_L1_error)
+  __pyx_tuple__65 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_sz, __pyx_n_s_chunk_ids1, __pyx_n_s_chunk_ids2, __pyx_n_s_added_ids, __pyx_n_s_removed_ids, __pyx_n_s_added_2, __pyx_n_s_removed_2, __pyx_n_s_c, __pyx_n_s_c); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 725, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__65);
+  __Pyx_GIVEREF(__pyx_tuple__65);
+  __pyx_codeobj__66 = (PyObject*)__Pyx_PyCode_New(1, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__65, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_content_diff, 725, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__66)) __PYX_ERR(0, 725, __pyx_L1_error)
 
-  /* "borg/item.pyx":725
- *             format_file_size(-removed, precision=1, sign=True)))
+  /* "borg/item.pyx":747
+ * 
  * 
  *     def _owner_diff(self):             # <<<<<<<<<<<<<<
  *         u_attr, g_attr = ('uid', 'gid') if self._numeric_ids else ('user', 'group')
  *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
  */
-  __pyx_tuple__63 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_u_attr, __pyx_n_s_g_attr, __pyx_n_s_u1, __pyx_n_s_g1, __pyx_n_s_u2, __pyx_n_s_g2); if (unlikely(!__pyx_tuple__63)) __PYX_ERR(0, 725, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__63);
-  __Pyx_GIVEREF(__pyx_tuple__63);
-  __pyx_codeobj__64 = (PyObject*)__Pyx_PyCode_New(1, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__63, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_owner_diff, 725, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__64)) __PYX_ERR(0, 725, __pyx_L1_error)
+  __pyx_tuple__67 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_u_attr, __pyx_n_s_g_attr, __pyx_n_s_u1, __pyx_n_s_g1, __pyx_n_s_u2, __pyx_n_s_g2); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 747, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__67);
+  __Pyx_GIVEREF(__pyx_tuple__67);
+  __pyx_codeobj__68 = (PyObject*)__Pyx_PyCode_New(1, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__67, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_owner_diff, 747, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__68)) __PYX_ERR(0, 747, __pyx_L1_error)
 
-  /* "borg/item.pyx":733
- *                     '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))
+  /* "borg/item.pyx":760
+ *         return True
  * 
  *     def _mode_diff(self):             # <<<<<<<<<<<<<<
  *         if 'mode' in self._item1 and 'mode' in self._item2 and self._item1.mode != self._item2.mode:
  *             mode1 = stat.filemode(self._item1.mode)
  */
-  __pyx_tuple__65 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_mode1, __pyx_n_s_mode2); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 733, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__65);
-  __Pyx_GIVEREF(__pyx_tuple__65);
-  __pyx_codeobj__66 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__65, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_mode_diff, 733, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__66)) __PYX_ERR(0, 733, __pyx_L1_error)
+  __pyx_tuple__69 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_mode1, __pyx_n_s_mode2); if (unlikely(!__pyx_tuple__69)) __PYX_ERR(0, 760, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__69);
+  __Pyx_GIVEREF(__pyx_tuple__69);
+  __pyx_codeobj__70 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__69, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_mode_diff, 760, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__70)) __PYX_ERR(0, 760, __pyx_L1_error)
 
-  /* "borg/item.pyx":739
- *             return ({"type": "mode", "old_mode": mode1, "new_mode": mode2}, '[{} -> {}]'.format(mode1, mode2))
+  /* "borg/item.pyx":768
+ *                 self._changes['type'] = DiffChange("changed type", {"item1": mode1[0], "item2": mode2[0]})
+ * 
+ *     def _time_diffs(self):             # <<<<<<<<<<<<<<
+ *         attrs = ["ctime", "mtime"]
+ *         for attr in attrs:
+ */
+  __pyx_tuple__71 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_attrs, __pyx_n_s_attr, __pyx_n_s_ts1, __pyx_n_s_ts2); if (unlikely(!__pyx_tuple__71)) __PYX_ERR(0, 768, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__71);
+  __Pyx_GIVEREF(__pyx_tuple__71);
+  __pyx_codeobj__72 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__71, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_time_diffs, 768, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__72)) __PYX_ERR(0, 768, __pyx_L1_error)
+
+  /* "borg/item.pyx":777
+ *         return True
+ * 
+ *     def content(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('content')
+ * 
+ */
+  __pyx_tuple__73 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__73)) __PYX_ERR(0, 777, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__73);
+  __Pyx_GIVEREF(__pyx_tuple__73);
+  __pyx_codeobj__74 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__73, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_content, 777, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__74)) __PYX_ERR(0, 777, __pyx_L1_error)
+
+  /* "borg/item.pyx":780
+ *         return self._changes.get('content')
+ * 
+ *     def ctime(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('ctime')
+ * 
+ */
+  __pyx_tuple__75 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__75)) __PYX_ERR(0, 780, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__75);
+  __Pyx_GIVEREF(__pyx_tuple__75);
+  __pyx_codeobj__76 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__75, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_ctime, 780, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__76)) __PYX_ERR(0, 780, __pyx_L1_error)
+
+  /* "borg/item.pyx":783
+ *         return self._changes.get('ctime')
+ * 
+ *     def mtime(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('mtime')
+ * 
+ */
+  __pyx_tuple__77 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__77)) __PYX_ERR(0, 783, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__77);
+  __Pyx_GIVEREF(__pyx_tuple__77);
+  __pyx_codeobj__78 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__77, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_mtime, 783, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__78)) __PYX_ERR(0, 783, __pyx_L1_error)
+
+  /* "borg/item.pyx":786
+ *         return self._changes.get('mtime')
+ * 
+ *     def mode(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('mode')
+ * 
+ */
+  __pyx_tuple__79 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__79)) __PYX_ERR(0, 786, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__79);
+  __Pyx_GIVEREF(__pyx_tuple__79);
+  __pyx_codeobj__80 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__79, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_mode, 786, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__80)) __PYX_ERR(0, 786, __pyx_L1_error)
+
+  /* "borg/item.pyx":789
+ *         return self._changes.get('mode')
+ * 
+ *     def type(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('type')
+ * 
+ */
+  __pyx_tuple__81 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__81)) __PYX_ERR(0, 789, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__81);
+  __Pyx_GIVEREF(__pyx_tuple__81);
+  __pyx_codeobj__82 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__81, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_type, 789, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__82)) __PYX_ERR(0, 789, __pyx_L1_error)
+
+  /* "borg/item.pyx":792
+ *         return self._changes.get('type')
+ * 
+ *     def owner(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('owner')
+ * 
+ */
+  __pyx_tuple__83 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__83)) __PYX_ERR(0, 792, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__83);
+  __Pyx_GIVEREF(__pyx_tuple__83);
+  __pyx_codeobj__84 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__83, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_owner, 792, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__84)) __PYX_ERR(0, 792, __pyx_L1_error)
+
+  /* "borg/item.pyx":795
+ *         return self._changes.get('owner')
+ * 
+ *     def user(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('user')
+ * 
+ */
+  __pyx_tuple__85 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__85)) __PYX_ERR(0, 795, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__85);
+  __Pyx_GIVEREF(__pyx_tuple__85);
+  __pyx_codeobj__86 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__85, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_user, 795, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__86)) __PYX_ERR(0, 795, __pyx_L1_error)
+
+  /* "borg/item.pyx":798
+ *         return self._changes.get('user')
  * 
- *     def _content_equal(self, chunk_iterator1, chunk_iterator2):             # <<<<<<<<<<<<<<
+ *     def group(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('group')
+ * 
+ */
+  __pyx_tuple__87 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__87)) __PYX_ERR(0, 798, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__87);
+  __Pyx_GIVEREF(__pyx_tuple__87);
+  __pyx_codeobj__88 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__87, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_group, 798, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__88)) __PYX_ERR(0, 798, __pyx_L1_error)
+
+  /* "borg/item.pyx":801
+ *         return self._changes.get('group')
+ * 
+ *     def _content_equal(self):             # <<<<<<<<<<<<<<
  *         if self._can_compare_chunk_ids:
  *             return self._item1.chunks == self._item2.chunks
  */
-  __pyx_tuple__67 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_chunk_iterator1, __pyx_n_s_chunk_iterator2); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 739, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__67);
-  __Pyx_GIVEREF(__pyx_tuple__67);
-  __pyx_codeobj__68 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__67, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_content_equal, 739, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__68)) __PYX_ERR(0, 739, __pyx_L1_error)
+  __pyx_tuple__89 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__89)) __PYX_ERR(0, 801, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__89);
+  __Pyx_GIVEREF(__pyx_tuple__89);
+  __pyx_codeobj__90 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__89, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_content_equal, 801, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__90)) __PYX_ERR(0, 801, __pyx_L1_error)
 
-  /* "borg/item.pyx":747
+  /* "borg/item.pyx":809
  * 
  * 
  * def chunks_contents_equal(chunks_a, chunks_b):             # <<<<<<<<<<<<<<
  *     """
  *     Compare chunk content and return True if they are identical.
  */
-  __pyx_tuple__69 = PyTuple_Pack(9, __pyx_n_s_chunks_a, __pyx_n_s_chunks_b, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_ap, __pyx_n_s_bp, __pyx_n_s_slicelen, __pyx_n_s_alen, __pyx_n_s_blen); if (unlikely(!__pyx_tuple__69)) __PYX_ERR(0, 747, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__69);
-  __Pyx_GIVEREF(__pyx_tuple__69);
-  __pyx_codeobj__70 = (PyObject*)__Pyx_PyCode_New(2, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__69, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_chunks_contents_equal, 747, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__70)) __PYX_ERR(0, 747, __pyx_L1_error)
+  __pyx_tuple__91 = PyTuple_Pack(9, __pyx_n_s_chunks_a, __pyx_n_s_chunks_b, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_ap, __pyx_n_s_bp, __pyx_n_s_slicelen, __pyx_n_s_alen, __pyx_n_s_blen); if (unlikely(!__pyx_tuple__91)) __PYX_ERR(0, 809, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__91);
+  __Pyx_GIVEREF(__pyx_tuple__91);
+  __pyx_codeobj__92 = (PyObject*)__Pyx_PyCode_New(2, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__91, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_item_pyx, __pyx_n_s_chunks_contents_equal, 809, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__92)) __PYX_ERR(0, 809, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
 static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
@@ -22531,182 +23834,166 @@
 static int __Pyx_modinit_type_init_code(void) {
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
-  if (PyType_Ready(&__pyx_type_4borg_4item_PropDict) < 0) __PYX_ERR(0, 117, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item_PropDict) < 0) __PYX_ERR(0, 119, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item_PropDict.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item_PropDict.tp_dictoffset && __pyx_type_4borg_4item_PropDict.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item_PropDict.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #if CYTHON_UPDATE_DESCRIPTOR_DOC
   {
-    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_4borg_4item_PropDict, "__contains__"); if (unlikely(!wrapper)) __PYX_ERR(0, 117, __pyx_L1_error)
+    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_4borg_4item_PropDict, "__contains__"); if (unlikely(!wrapper)) __PYX_ERR(0, 119, __pyx_L1_error)
     if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
       __pyx_wrapperbase_4borg_4item_8PropDict_14__contains__ = *((PyWrapperDescrObject *)wrapper)->d_base;
       __pyx_wrapperbase_4borg_4item_8PropDict_14__contains__.doc = __pyx_doc_4borg_4item_8PropDict_14__contains__;
       ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_4borg_4item_8PropDict_14__contains__;
     }
   }
   #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_PropDict, (PyObject *)&__pyx_type_4borg_4item_PropDict) < 0) __PYX_ERR(0, 117, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_PropDict) < 0) __PYX_ERR(0, 117, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_PropDict, (PyObject *)&__pyx_type_4borg_4item_PropDict) < 0) __PYX_ERR(0, 119, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_PropDict) < 0) __PYX_ERR(0, 119, __pyx_L1_error)
   __pyx_ptype_4borg_4item_PropDict = &__pyx_type_4borg_4item_PropDict;
   __pyx_vtabptr_4borg_4item_PropDictProperty = &__pyx_vtable_4borg_4item_PropDictProperty;
   __pyx_vtable_4borg_4item_PropDictProperty.__pyx___set_name__ = (PyObject *(*)(struct __pyx_obj_4borg_4item_PropDictProperty *, PyObject *, int __pyx_skip_dispatch))__pyx_f_4borg_4item_16PropDictProperty___set_name__;
-  if (PyType_Ready(&__pyx_type_4borg_4item_PropDictProperty) < 0) __PYX_ERR(0, 197, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item_PropDictProperty) < 0) __PYX_ERR(0, 199, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item_PropDictProperty.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item_PropDictProperty.tp_dictoffset && __pyx_type_4borg_4item_PropDictProperty.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item_PropDictProperty.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (__Pyx_SetVtable(__pyx_type_4borg_4item_PropDictProperty.tp_dict, __pyx_vtabptr_4borg_4item_PropDictProperty) < 0) __PYX_ERR(0, 197, __pyx_L1_error)
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_PropDictProperty, (PyObject *)&__pyx_type_4borg_4item_PropDictProperty) < 0) __PYX_ERR(0, 197, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_PropDictProperty) < 0) __PYX_ERR(0, 197, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_type_4borg_4item_PropDictProperty.tp_dict, __pyx_vtabptr_4borg_4item_PropDictProperty) < 0) __PYX_ERR(0, 199, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_PropDictProperty, (PyObject *)&__pyx_type_4borg_4item_PropDictProperty) < 0) __PYX_ERR(0, 199, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_PropDictProperty) < 0) __PYX_ERR(0, 199, __pyx_L1_error)
   __pyx_ptype_4borg_4item_PropDictProperty = &__pyx_type_4borg_4item_PropDictProperty;
   __pyx_type_4borg_4item_Item.tp_base = __pyx_ptype_4borg_4item_PropDict;
-  if (PyType_Ready(&__pyx_type_4borg_4item_Item) < 0) __PYX_ERR(0, 248, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item_Item) < 0) __PYX_ERR(0, 250, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item_Item.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item_Item.tp_dictoffset && __pyx_type_4borg_4item_Item.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item_Item.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Item, (PyObject *)&__pyx_type_4borg_4item_Item) < 0) __PYX_ERR(0, 248, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_Item) < 0) __PYX_ERR(0, 248, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Item, (PyObject *)&__pyx_type_4borg_4item_Item) < 0) __PYX_ERR(0, 250, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_Item) < 0) __PYX_ERR(0, 250, __pyx_L1_error)
   __pyx_ptype_4borg_4item_Item = &__pyx_type_4borg_4item_Item;
   __pyx_type_4borg_4item_EncryptedKey.tp_base = __pyx_ptype_4borg_4item_PropDict;
-  if (PyType_Ready(&__pyx_type_4borg_4item_EncryptedKey) < 0) __PYX_ERR(0, 410, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item_EncryptedKey) < 0) __PYX_ERR(0, 412, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item_EncryptedKey.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item_EncryptedKey.tp_dictoffset && __pyx_type_4borg_4item_EncryptedKey.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item_EncryptedKey.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_EncryptedKey, (PyObject *)&__pyx_type_4borg_4item_EncryptedKey) < 0) __PYX_ERR(0, 410, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_EncryptedKey) < 0) __PYX_ERR(0, 410, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_EncryptedKey, (PyObject *)&__pyx_type_4borg_4item_EncryptedKey) < 0) __PYX_ERR(0, 412, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_EncryptedKey) < 0) __PYX_ERR(0, 412, __pyx_L1_error)
   __pyx_ptype_4borg_4item_EncryptedKey = &__pyx_type_4borg_4item_EncryptedKey;
   __pyx_type_4borg_4item_Key.tp_base = __pyx_ptype_4borg_4item_PropDict;
-  if (PyType_Ready(&__pyx_type_4borg_4item_Key) < 0) __PYX_ERR(0, 449, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item_Key) < 0) __PYX_ERR(0, 451, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item_Key.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item_Key.tp_dictoffset && __pyx_type_4borg_4item_Key.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item_Key.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Key, (PyObject *)&__pyx_type_4borg_4item_Key) < 0) __PYX_ERR(0, 449, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_Key) < 0) __PYX_ERR(0, 449, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Key, (PyObject *)&__pyx_type_4borg_4item_Key) < 0) __PYX_ERR(0, 451, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_Key) < 0) __PYX_ERR(0, 451, __pyx_L1_error)
   __pyx_ptype_4borg_4item_Key = &__pyx_type_4borg_4item_Key;
   __pyx_type_4borg_4item_ArchiveItem.tp_base = __pyx_ptype_4borg_4item_PropDict;
-  if (PyType_Ready(&__pyx_type_4borg_4item_ArchiveItem) < 0) __PYX_ERR(0, 485, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item_ArchiveItem) < 0) __PYX_ERR(0, 487, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item_ArchiveItem.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item_ArchiveItem.tp_dictoffset && __pyx_type_4borg_4item_ArchiveItem.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item_ArchiveItem.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ArchiveItem, (PyObject *)&__pyx_type_4borg_4item_ArchiveItem) < 0) __PYX_ERR(0, 485, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_ArchiveItem) < 0) __PYX_ERR(0, 485, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ArchiveItem, (PyObject *)&__pyx_type_4borg_4item_ArchiveItem) < 0) __PYX_ERR(0, 487, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_ArchiveItem) < 0) __PYX_ERR(0, 487, __pyx_L1_error)
   __pyx_ptype_4borg_4item_ArchiveItem = &__pyx_type_4borg_4item_ArchiveItem;
   __pyx_type_4borg_4item_ManifestItem.tp_base = __pyx_ptype_4borg_4item_PropDict;
-  if (PyType_Ready(&__pyx_type_4borg_4item_ManifestItem) < 0) __PYX_ERR(0, 545, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item_ManifestItem) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item_ManifestItem.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item_ManifestItem.tp_dictoffset && __pyx_type_4borg_4item_ManifestItem.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item_ManifestItem.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ManifestItem, (PyObject *)&__pyx_type_4borg_4item_ManifestItem) < 0) __PYX_ERR(0, 545, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_ManifestItem) < 0) __PYX_ERR(0, 545, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ManifestItem, (PyObject *)&__pyx_type_4borg_4item_ManifestItem) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_4borg_4item_ManifestItem) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
   __pyx_ptype_4borg_4item_ManifestItem = &__pyx_type_4borg_4item_ManifestItem;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct__fix_tuple_of_str) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct__fix_tuple_of_str) < 0) __PYX_ERR(0, 77, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item___pyx_scope_struct__fix_tuple_of_str.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct__fix_tuple_of_str.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct__fix_tuple_of_str.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item___pyx_scope_struct__fix_tuple_of_str.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_4item___pyx_scope_struct__fix_tuple_of_str = &__pyx_type_4borg_4item___pyx_scope_struct__fix_tuple_of_str;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_1_genexpr) < 0) __PYX_ERR(0, 78, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_1_genexpr) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item___pyx_scope_struct_1_genexpr.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct_1_genexpr.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct_1_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item___pyx_scope_struct_1_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_4item___pyx_scope_struct_1_genexpr = &__pyx_type_4borg_4item___pyx_scope_struct_1_genexpr;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int) < 0) __PYX_ERR(0, 81, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int) < 0) __PYX_ERR(0, 83, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int = &__pyx_type_4borg_4item___pyx_scope_struct_2_fix_tuple_of_str_and_int;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_3_genexpr) < 0) __PYX_ERR(0, 84, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_3_genexpr) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item___pyx_scope_struct_3_genexpr.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct_3_genexpr.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct_3_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item___pyx_scope_struct_3_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_4item___pyx_scope_struct_3_genexpr = &__pyx_type_4borg_4item___pyx_scope_struct_3_genexpr;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_4_genexpr) < 0) __PYX_ERR(0, 85, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_4_genexpr) < 0) __PYX_ERR(0, 87, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item___pyx_scope_struct_4_genexpr.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct_4_genexpr.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct_4_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item___pyx_scope_struct_4_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_4item___pyx_scope_struct_4_genexpr = &__pyx_type_4borg_4item___pyx_scope_struct_4_genexpr;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_5_get_size) < 0) __PYX_ERR(0, 302, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_5_get_size) < 0) __PYX_ERR(0, 304, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item___pyx_scope_struct_5_get_size.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct_5_get_size.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct_5_get_size.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item___pyx_scope_struct_5_get_size.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_4item___pyx_scope_struct_5_get_size = &__pyx_type_4borg_4item___pyx_scope_struct_5_get_size;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_6_genexpr) < 0) __PYX_ERR(0, 328, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_6_genexpr) < 0) __PYX_ERR(0, 330, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item___pyx_scope_struct_6_genexpr.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct_6_genexpr.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct_6_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item___pyx_scope_struct_6_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_4item___pyx_scope_struct_6_genexpr = &__pyx_type_4borg_4item___pyx_scope_struct_6_genexpr;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_7_genexpr) < 0) __PYX_ERR(0, 330, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_7_genexpr) < 0) __PYX_ERR(0, 332, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_4item___pyx_scope_struct_7_genexpr.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct_7_genexpr.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct_7_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_4item___pyx_scope_struct_7_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_4item___pyx_scope_struct_7_genexpr = &__pyx_type_4borg_4item___pyx_scope_struct_7_genexpr;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_8___repr__) < 0) __PYX_ERR(0, 665, __pyx_L1_error)
-  #if PY_VERSION_HEX < 0x030800B1
-  __pyx_type_4borg_4item___pyx_scope_struct_8___repr__.tp_print = 0;
-  #endif
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct_8___repr__.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct_8___repr__.tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_type_4borg_4item___pyx_scope_struct_8___repr__.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
-  }
-  __pyx_ptype_4borg_4item___pyx_scope_struct_8___repr__ = &__pyx_type_4borg_4item___pyx_scope_struct_8___repr__;
-  if (PyType_Ready(&__pyx_type_4borg_4item___pyx_scope_struct_9_genexpr) < 0) __PYX_ERR(0, 668, __pyx_L1_error)
-  #if PY_VERSION_HEX < 0x030800B1
-  __pyx_type_4borg_4item___pyx_scope_struct_9_genexpr.tp_print = 0;
-  #endif
-  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_4item___pyx_scope_struct_9_genexpr.tp_dictoffset && __pyx_type_4borg_4item___pyx_scope_struct_9_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
-    __pyx_type_4borg_4item___pyx_scope_struct_9_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
-  }
-  __pyx_ptype_4borg_4item___pyx_scope_struct_9_genexpr = &__pyx_type_4borg_4item___pyx_scope_struct_9_genexpr;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
@@ -22716,22 +24003,21 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_0_29_35(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_35(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_0_29_35); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -23014,15 +24300,15 @@
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "borg/item.pyx":8
  * 
  * from .constants import ITEM_KEYS, ARCHIVE_KEYS
  * from .helpers import StableDict             # <<<<<<<<<<<<<<
  * from .helpers import format_file_size
- * from .helpers.msgpack import timestamp_to_int, int_to_timestamp, Timestamp
+ * from .helpers.fs import assert_sanitized_path, to_sanitized_path
  */
   __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_n_s_StableDict);
   __Pyx_GIVEREF(__pyx_n_s_StableDict);
   PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_StableDict);
   __pyx_t_2 = __Pyx_Import(__pyx_n_s_helpers, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 8, __pyx_L1_error)
@@ -23034,16 +24320,16 @@
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "borg/item.pyx":9
  * from .constants import ITEM_KEYS, ARCHIVE_KEYS
  * from .helpers import StableDict
  * from .helpers import format_file_size             # <<<<<<<<<<<<<<
+ * from .helpers.fs import assert_sanitized_path, to_sanitized_path
  * from .helpers.msgpack import timestamp_to_int, int_to_timestamp, Timestamp
- * 
  */
   __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_format_file_size);
   __Pyx_GIVEREF(__pyx_n_s_format_file_size);
   PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_format_file_size);
   __pyx_t_1 = __Pyx_Import(__pyx_n_s_helpers, __pyx_t_2, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9, __pyx_L1_error)
@@ -23054,1648 +24340,1872 @@
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_format_file_size, __pyx_t_2) < 0) __PYX_ERR(0, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "borg/item.pyx":10
  * from .helpers import StableDict
  * from .helpers import format_file_size
+ * from .helpers.fs import assert_sanitized_path, to_sanitized_path             # <<<<<<<<<<<<<<
+ * from .helpers.msgpack import timestamp_to_int, int_to_timestamp, Timestamp
+ * from .helpers.time import OutputTimestamp, safe_timestamp
+ */
+  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_n_s_assert_sanitized_path);
+  __Pyx_GIVEREF(__pyx_n_s_assert_sanitized_path);
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_assert_sanitized_path);
+  __Pyx_INCREF(__pyx_n_s_to_sanitized_path);
+  __Pyx_GIVEREF(__pyx_n_s_to_sanitized_path);
+  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_to_sanitized_path);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_helpers_fs, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 10, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_assert_sanitized_path); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_assert_sanitized_path, __pyx_t_1) < 0) __PYX_ERR(0, 10, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_to_sanitized_path); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_to_sanitized_path, __pyx_t_1) < 0) __PYX_ERR(0, 10, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "borg/item.pyx":11
+ * from .helpers import format_file_size
+ * from .helpers.fs import assert_sanitized_path, to_sanitized_path
  * from .helpers.msgpack import timestamp_to_int, int_to_timestamp, Timestamp             # <<<<<<<<<<<<<<
- * 
+ * from .helpers.time import OutputTimestamp, safe_timestamp
  * 
  */
-  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = PyList_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_n_s_timestamp_to_int);
   __Pyx_GIVEREF(__pyx_n_s_timestamp_to_int);
-  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_timestamp_to_int);
+  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_timestamp_to_int);
   __Pyx_INCREF(__pyx_n_s_int_to_timestamp);
   __Pyx_GIVEREF(__pyx_n_s_int_to_timestamp);
-  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_int_to_timestamp);
+  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_int_to_timestamp);
   __Pyx_INCREF(__pyx_n_s_Timestamp);
   __Pyx_GIVEREF(__pyx_n_s_Timestamp);
-  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_Timestamp);
-  __pyx_t_2 = __Pyx_Import(__pyx_n_s_helpers_msgpack, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 10, __pyx_L1_error)
+  PyList_SET_ITEM(__pyx_t_2, 2, __pyx_n_s_Timestamp);
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_helpers_msgpack, __pyx_t_2, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_timestamp_to_int, __pyx_t_2) < 0) __PYX_ERR(0, 11, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_int_to_timestamp, __pyx_t_2) < 0) __PYX_ERR(0, 11, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Timestamp); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Timestamp, __pyx_t_2) < 0) __PYX_ERR(0, 11, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
+
+  /* "borg/item.pyx":12
+ * from .helpers.fs import assert_sanitized_path, to_sanitized_path
+ * from .helpers.msgpack import timestamp_to_int, int_to_timestamp, Timestamp
+ * from .helpers.time import OutputTimestamp, safe_timestamp             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_timestamp_to_int, __pyx_t_1) < 0) __PYX_ERR(0, 10, __pyx_L1_error)
+  __Pyx_INCREF(__pyx_n_s_OutputTimestamp);
+  __Pyx_GIVEREF(__pyx_n_s_OutputTimestamp);
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_OutputTimestamp);
+  __Pyx_INCREF(__pyx_n_s_safe_timestamp);
+  __Pyx_GIVEREF(__pyx_n_s_safe_timestamp);
+  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_safe_timestamp);
+  __pyx_t_2 = __Pyx_Import(__pyx_n_s_helpers_time, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_OutputTimestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_int_to_timestamp, __pyx_t_1) < 0) __PYX_ERR(0, 10, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_OutputTimestamp, __pyx_t_1) < 0) __PYX_ERR(0, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Timestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_safe_timestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Timestamp, __pyx_t_1) < 0) __PYX_ERR(0, 10, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_safe_timestamp, __pyx_t_1) < 0) __PYX_ERR(0, 12, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":18
+  /* "borg/item.pyx":20
  * 
  * 
  * API_VERSION = '1.2_01'             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_API_VERSION, __pyx_kp_s_1_2_01) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_API_VERSION, __pyx_kp_s_1_2_01) < 0) __PYX_ERR(0, 20, __pyx_L1_error)
 
-  /* "borg/item.pyx":21
+  /* "borg/item.pyx":23
  * 
  * 
  * def fix_key(data, key, *, errors='strict'):             # <<<<<<<<<<<<<<
  *     """if k is a bytes-typed key, migrate key/value to a str-typed key in dict data"""
  *     if isinstance(key, bytes):
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_1fix_key, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 21, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_1fix_key, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 23, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_key, __pyx_t_2) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_key, __pyx_t_2) < 0) __PYX_ERR(0, 23, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":31
+  /* "borg/item.pyx":33
  * 
  * 
  * def fix_str_value(data, key, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """makes sure that data[key] is a str (decode if it is bytes)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_3fix_str_value, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 31, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_3fix_str_value, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 33, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_str_value, __pyx_t_2) < 0) __PYX_ERR(0, 31, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_str_value, __pyx_t_2) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":40
+  /* "borg/item.pyx":42
  * 
  * 
  * def fix_bytes_value(data, key):             # <<<<<<<<<<<<<<
  *     """makes sure that data[key] is bytes (encode if it is str)"""
  *     assert isinstance(key, str)  # fix_key must be called first
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_5fix_bytes_value, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 40, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_5fix_bytes_value, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 42, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_bytes_value, __pyx_t_2) < 0) __PYX_ERR(0, 40, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_bytes_value, __pyx_t_2) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":49
+  /* "borg/item.pyx":51
  * 
  * 
  * def fix_list_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of str"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_7fix_list_of_str, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_7fix_list_of_str, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 51, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_list_of_str, __pyx_t_2) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_list_of_str, __pyx_t_2) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":55
+  /* "borg/item.pyx":57
  * 
  * 
  * def fix_list_of_bytes(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of bytes"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_9fix_list_of_bytes, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 55, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_9fix_list_of_bytes, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 57, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_list_of_bytes, __pyx_t_2) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_list_of_bytes, __pyx_t_2) < 0) __PYX_ERR(0, 57, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":61
+  /* "borg/item.pyx":63
  * 
  * 
  * def fix_list_of_chunkentries(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a list of correct chunkentries"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_11fix_list_of_chunkentries, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 61, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_11fix_list_of_chunkentries, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 63, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_list_of_chunkentries, __pyx_t_2) < 0) __PYX_ERR(0, 61, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_list_of_chunkentries, __pyx_t_2) < 0) __PYX_ERR(0, 63, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":75
+  /* "borg/item.pyx":77
  * 
  * 
  * def fix_tuple_of_str(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_13fix_tuple_of_str, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_13fix_tuple_of_str, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 77, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_tuple_of_str, __pyx_t_2) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_tuple_of_str, __pyx_t_2) < 0) __PYX_ERR(0, 77, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":81
+  /* "borg/item.pyx":83
  * 
  * 
  * def fix_tuple_of_str_and_int(v):             # <<<<<<<<<<<<<<
  *     """make sure we have a tuple of str or int"""
  *     assert isinstance(v, (tuple, list))
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_15fix_tuple_of_str_and_int, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 81, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_15fix_tuple_of_str_and_int, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 83, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_tuple_of_str_and_int, __pyx_t_2) < 0) __PYX_ERR(0, 81, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_tuple_of_str_and_int, __pyx_t_2) < 0) __PYX_ERR(0, 83, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":89
+  /* "borg/item.pyx":91
  * 
  * 
  * def fix_timestamp(v):             # <<<<<<<<<<<<<<
  *     """make sure v is a Timestamp"""
  *     if isinstance(v, Timestamp):
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_17fix_timestamp, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_17fix_timestamp, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_timestamp, __pyx_t_2) < 0) __PYX_ERR(0, 89, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix_timestamp, __pyx_t_2) < 0) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":100
+  /* "borg/item.pyx":102
  * 
  * 
  * def want_bytes(v, *, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """we know that we want bytes and the value should be bytes"""
  *     # legacy support: it being str can be caused by msgpack unpack decoding old data that was packed with use_bin_type=False
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_19want_bytes, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_19want_bytes, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 102, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_want_bytes, __pyx_t_2) < 0) __PYX_ERR(0, 100, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_want_bytes, __pyx_t_2) < 0) __PYX_ERR(0, 102, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":109
+  /* "borg/item.pyx":111
  * 
  * 
  * def want_str(v, *, errors='surrogateescape'):             # <<<<<<<<<<<<<<
  *     """we know that we want str and the value should be str"""
  *     if isinstance(v, bytes):
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_21want_str, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 109, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_21want_str, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 111, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_want_str, __pyx_t_2) < 0) __PYX_ERR(0, 109, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_want_str, __pyx_t_2) < 0) __PYX_ERR(0, 111, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":137
+  /* "borg/item.pyx":139
  *     are ignored instead of causing an error.
  *     """
  *     VALID_KEYS = frozenset()  # override with <set of str> in child class             # <<<<<<<<<<<<<<
  * 
  *     cdef object _dict
  */
-  __pyx_t_2 = __Pyx_PyFrozenSet_New(((PyObject *)NULL)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyFrozenSet_New(((PyObject *)NULL)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 139, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_PropDict->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_2) < 0) __PYX_ERR(0, 137, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_PropDict->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_2) < 0) __PYX_ERR(0, 139, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_PropDict);
 
-  /* "borg/item.pyx":246
+  /* "borg/item.pyx":248
  * 
  * 
  * ChunkListEntry = namedtuple('ChunkListEntry', 'id size')             # <<<<<<<<<<<<<<
  * 
  * cdef class Item(PropDict):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_namedtuple); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 246, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_namedtuple); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 248, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__47, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 246, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__45, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 248, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ChunkListEntry, __pyx_t_1) < 0) __PYX_ERR(0, 246, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ChunkListEntry, __pyx_t_1) < 0) __PYX_ERR(0, 248, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":260
+  /* "borg/item.pyx":262
  *     """
  * 
  *     VALID_KEYS = ITEM_KEYS | {'deleted', 'nlink', }             # <<<<<<<<<<<<<<
  * 
  *     # properties statically defined, so that IDEs can know their names:
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ITEM_KEYS); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ITEM_KEYS); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 262, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PySet_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 260, __pyx_L1_error)
+  __pyx_t_2 = PySet_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 262, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PySet_Add(__pyx_t_2, __pyx_n_s_deleted) < 0) __PYX_ERR(0, 260, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_2, __pyx_n_s_nlink) < 0) __PYX_ERR(0, 260, __pyx_L1_error)
-  __pyx_t_3 = PyNumber_Or(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 260, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_deleted) < 0) __PYX_ERR(0, 262, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_nlink) < 0) __PYX_ERR(0, 262, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Or(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 262, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_3) < 0) __PYX_ERR(0, 260, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_3) < 0) __PYX_ERR(0, 262, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":264
+  /* "borg/item.pyx":266
  *     # properties statically defined, so that IDEs can know their names:
  * 
- *     path = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
+ *     path = PropDictProperty(str, 'surrogate-escaped str', encode=assert_sanitized_path, decode=to_sanitized_path)             # <<<<<<<<<<<<<<
  *     source = PropDictProperty(str, 'surrogate-escaped str')  # legacy borg 1.x. borg 2: see .target
  *     target = PropDictProperty(str, 'surrogate-escaped str')
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 264, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 266, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
   PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 264, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 266, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_assert_sanitized_path); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_encode, __pyx_t_1) < 0) __PYX_ERR(0, 266, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_to_sanitized_path); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_decode, __pyx_t_1) < 0) __PYX_ERR(0, 266, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_path, __pyx_t_2) < 0) __PYX_ERR(0, 264, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_path, __pyx_t_1) < 0) __PYX_ERR(0, 266, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":265
+  /* "borg/item.pyx":267
  * 
- *     path = PropDictProperty(str, 'surrogate-escaped str')
+ *     path = PropDictProperty(str, 'surrogate-escaped str', encode=assert_sanitized_path, decode=to_sanitized_path)
  *     source = PropDictProperty(str, 'surrogate-escaped str')  # legacy borg 1.x. borg 2: see .target             # <<<<<<<<<<<<<<
  *     target = PropDictProperty(str, 'surrogate-escaped str')
  *     user = PropDictProperty(str, 'surrogate-escaped str')
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 265, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 265, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 267, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_source, __pyx_t_2) < 0) __PYX_ERR(0, 267, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_source, __pyx_t_3) < 0) __PYX_ERR(0, 265, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":266
- *     path = PropDictProperty(str, 'surrogate-escaped str')
+  /* "borg/item.pyx":268
+ *     path = PropDictProperty(str, 'surrogate-escaped str', encode=assert_sanitized_path, decode=to_sanitized_path)
  *     source = PropDictProperty(str, 'surrogate-escaped str')  # legacy borg 1.x. borg 2: see .target
  *     target = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
  *     user = PropDictProperty(str, 'surrogate-escaped str')
  *     group = PropDictProperty(str, 'surrogate-escaped str')
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 266, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 268, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 266, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_target, __pyx_t_2) < 0) __PYX_ERR(0, 266, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 268, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_target, __pyx_t_1) < 0) __PYX_ERR(0, 268, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":267
+  /* "borg/item.pyx":269
  *     source = PropDictProperty(str, 'surrogate-escaped str')  # legacy borg 1.x. borg 2: see .target
  *     target = PropDictProperty(str, 'surrogate-escaped str')
  *     user = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
  *     group = PropDictProperty(str, 'surrogate-escaped str')
  * 
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 267, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 269, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 267, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 269, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_user, __pyx_t_2) < 0) __PYX_ERR(0, 269, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_user, __pyx_t_3) < 0) __PYX_ERR(0, 267, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":268
+  /* "borg/item.pyx":270
  *     target = PropDictProperty(str, 'surrogate-escaped str')
  *     user = PropDictProperty(str, 'surrogate-escaped str')
  *     group = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
  * 
  *     acl_access = PropDictProperty(bytes)
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 268, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 270, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 268, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_group, __pyx_t_2) < 0) __PYX_ERR(0, 268, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 270, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_group, __pyx_t_1) < 0) __PYX_ERR(0, 270, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":270
+  /* "borg/item.pyx":272
  *     group = PropDictProperty(str, 'surrogate-escaped str')
  * 
  *     acl_access = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     acl_default = PropDictProperty(bytes)
  *     acl_extended = PropDictProperty(bytes)
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 270, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_acl_access, __pyx_t_2) < 0) __PYX_ERR(0, 270, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 272, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_acl_access, __pyx_t_1) < 0) __PYX_ERR(0, 272, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":271
+  /* "borg/item.pyx":273
  * 
  *     acl_access = PropDictProperty(bytes)
  *     acl_default = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     acl_extended = PropDictProperty(bytes)
  *     acl_nfs4 = PropDictProperty(bytes)
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 271, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_acl_default, __pyx_t_2) < 0) __PYX_ERR(0, 271, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 273, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_acl_default, __pyx_t_1) < 0) __PYX_ERR(0, 273, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":272
+  /* "borg/item.pyx":274
  *     acl_access = PropDictProperty(bytes)
  *     acl_default = PropDictProperty(bytes)
  *     acl_extended = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     acl_nfs4 = PropDictProperty(bytes)
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 272, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_acl_extended, __pyx_t_2) < 0) __PYX_ERR(0, 272, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 274, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_acl_extended, __pyx_t_1) < 0) __PYX_ERR(0, 274, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":273
+  /* "borg/item.pyx":275
  *     acl_default = PropDictProperty(bytes)
  *     acl_extended = PropDictProperty(bytes)
  *     acl_nfs4 = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  * 
  *     mode = PropDictProperty(int)
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 273, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_acl_nfs4, __pyx_t_2) < 0) __PYX_ERR(0, 273, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 275, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_acl_nfs4, __pyx_t_1) < 0) __PYX_ERR(0, 275, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":275
+  /* "borg/item.pyx":277
  *     acl_nfs4 = PropDictProperty(bytes)
  * 
  *     mode = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     uid = PropDictProperty(int)
  *     gid = PropDictProperty(int)
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 275, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_mode, __pyx_t_2) < 0) __PYX_ERR(0, 275, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 277, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_mode, __pyx_t_1) < 0) __PYX_ERR(0, 277, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":276
+  /* "borg/item.pyx":278
  * 
  *     mode = PropDictProperty(int)
  *     uid = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     gid = PropDictProperty(int)
  *     rdev = PropDictProperty(int)
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 276, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_uid, __pyx_t_2) < 0) __PYX_ERR(0, 276, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 278, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_uid, __pyx_t_1) < 0) __PYX_ERR(0, 278, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":277
+  /* "borg/item.pyx":279
  *     mode = PropDictProperty(int)
  *     uid = PropDictProperty(int)
  *     gid = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     rdev = PropDictProperty(int)
  *     bsdflags = PropDictProperty(int)
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 277, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_gid, __pyx_t_2) < 0) __PYX_ERR(0, 277, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 279, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_gid, __pyx_t_1) < 0) __PYX_ERR(0, 279, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":278
+  /* "borg/item.pyx":280
  *     uid = PropDictProperty(int)
  *     gid = PropDictProperty(int)
  *     rdev = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     bsdflags = PropDictProperty(int)
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 278, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_rdev, __pyx_t_2) < 0) __PYX_ERR(0, 278, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 280, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_rdev, __pyx_t_1) < 0) __PYX_ERR(0, 280, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":279
+  /* "borg/item.pyx":281
  *     gid = PropDictProperty(int)
  *     rdev = PropDictProperty(int)
  *     bsdflags = PropDictProperty(int)             # <<<<<<<<<<<<<<
  * 
  *     atime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 279, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_bsdflags, __pyx_t_2) < 0) __PYX_ERR(0, 279, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 281, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_bsdflags, __pyx_t_1) < 0) __PYX_ERR(0, 281, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":281
+  /* "borg/item.pyx":283
  *     bsdflags = PropDictProperty(int)
  * 
  *     atime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)             # <<<<<<<<<<<<<<
  *     ctime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  *     mtime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 281, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 283, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)(&PyInt_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyInt_Type)));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyInt_Type)));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyInt_Type)));
   __Pyx_INCREF(__pyx_kp_s_int_ns);
   __Pyx_GIVEREF(__pyx_kp_s_int_ns);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_int_ns);
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 281, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_int_ns);
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 283, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 283, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_encode, __pyx_t_3) < 0) __PYX_ERR(0, 283, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 283, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_decode, __pyx_t_3) < 0) __PYX_ERR(0, 283, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 283, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 281, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_encode, __pyx_t_1) < 0) __PYX_ERR(0, 281, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 281, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_decode, __pyx_t_1) < 0) __PYX_ERR(0, 281, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 281, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_atime, __pyx_t_3) < 0) __PYX_ERR(0, 283, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_atime, __pyx_t_1) < 0) __PYX_ERR(0, 281, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":282
+  /* "borg/item.pyx":284
  * 
  *     atime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  *     ctime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)             # <<<<<<<<<<<<<<
  *     mtime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  *     birthtime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  */
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 284, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(((PyObject *)(&PyInt_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyInt_Type)));
-  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyInt_Type)));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyInt_Type)));
   __Pyx_INCREF(__pyx_kp_s_int_ns);
   __Pyx_GIVEREF(__pyx_kp_s_int_ns);
-  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_int_ns);
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 282, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 282, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_encode, __pyx_t_2) < 0) __PYX_ERR(0, 282, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 282, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_decode, __pyx_t_2) < 0) __PYX_ERR(0, 282, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 282, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_int_ns);
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 284, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 284, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_encode, __pyx_t_1) < 0) __PYX_ERR(0, 284, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 284, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_decode, __pyx_t_1) < 0) __PYX_ERR(0, 284, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 284, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_ctime, __pyx_t_2) < 0) __PYX_ERR(0, 282, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_ctime, __pyx_t_1) < 0) __PYX_ERR(0, 284, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":283
+  /* "borg/item.pyx":285
  *     atime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  *     ctime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  *     mtime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)             # <<<<<<<<<<<<<<
  *     birthtime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  * 
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 283, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 285, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)(&PyInt_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyInt_Type)));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyInt_Type)));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyInt_Type)));
   __Pyx_INCREF(__pyx_kp_s_int_ns);
   __Pyx_GIVEREF(__pyx_kp_s_int_ns);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_int_ns);
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 283, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_int_ns);
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 285, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 285, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_encode, __pyx_t_3) < 0) __PYX_ERR(0, 285, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 285, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_decode, __pyx_t_3) < 0) __PYX_ERR(0, 285, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 285, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 283, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_encode, __pyx_t_1) < 0) __PYX_ERR(0, 283, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 283, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_decode, __pyx_t_1) < 0) __PYX_ERR(0, 283, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 283, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_mtime, __pyx_t_3) < 0) __PYX_ERR(0, 285, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_mtime, __pyx_t_1) < 0) __PYX_ERR(0, 283, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":284
+  /* "borg/item.pyx":286
  *     ctime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  *     mtime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)
  *     birthtime = PropDictProperty(int, 'int (ns)', encode=int_to_timestamp, decode=timestamp_to_int)             # <<<<<<<<<<<<<<
  * 
  *     # size is only present for items with a chunk list and then it is sum(chunk_sizes)
  */
-  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 284, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(((PyObject *)(&PyInt_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyInt_Type)));
-  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyInt_Type)));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyInt_Type)));
   __Pyx_INCREF(__pyx_kp_s_int_ns);
   __Pyx_GIVEREF(__pyx_kp_s_int_ns);
-  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_int_ns);
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 284, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 284, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_encode, __pyx_t_2) < 0) __PYX_ERR(0, 284, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 284, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_decode, __pyx_t_2) < 0) __PYX_ERR(0, 284, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 284, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_int_ns);
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 286, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_int_to_timestamp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_encode, __pyx_t_1) < 0) __PYX_ERR(0, 286, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_timestamp_to_int); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_decode, __pyx_t_1) < 0) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_birthtime, __pyx_t_2) < 0) __PYX_ERR(0, 284, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_birthtime, __pyx_t_1) < 0) __PYX_ERR(0, 286, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":287
+  /* "borg/item.pyx":289
  * 
  *     # size is only present for items with a chunk list and then it is sum(chunk_sizes)
  *     size = PropDictProperty(int)             # <<<<<<<<<<<<<<
  * 
  *     hlid = PropDictProperty(bytes)  # hard link id: same value means same hard link.
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 287, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_size, __pyx_t_2) < 0) __PYX_ERR(0, 287, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 289, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_size, __pyx_t_1) < 0) __PYX_ERR(0, 289, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":289
+  /* "borg/item.pyx":291
  *     size = PropDictProperty(int)
  * 
  *     hlid = PropDictProperty(bytes)  # hard link id: same value means same hard link.             # <<<<<<<<<<<<<<
  *     hardlink_master = PropDictProperty(bool)  # legacy
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 289, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_hlid, __pyx_t_2) < 0) __PYX_ERR(0, 289, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 291, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_hlid, __pyx_t_1) < 0) __PYX_ERR(0, 291, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":290
+  /* "borg/item.pyx":292
  * 
  *     hlid = PropDictProperty(bytes)  # hard link id: same value means same hard link.
  *     hardlink_master = PropDictProperty(bool)  # legacy             # <<<<<<<<<<<<<<
  * 
  *     chunks = PropDictProperty(list, 'list')
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject*)&PyBool_Type)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 290, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_hardlink_master, __pyx_t_2) < 0) __PYX_ERR(0, 290, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject*)&PyBool_Type)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_hardlink_master, __pyx_t_1) < 0) __PYX_ERR(0, 292, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":292
+  /* "borg/item.pyx":294
  *     hardlink_master = PropDictProperty(bool)  # legacy
  * 
  *     chunks = PropDictProperty(list, 'list')             # <<<<<<<<<<<<<<
  *     chunks_healthy = PropDictProperty(list, 'list')
  * 
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 292, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 294, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)(&PyList_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyList_Type)));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyList_Type)));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyList_Type)));
   __Pyx_INCREF(__pyx_n_s_list);
   __Pyx_GIVEREF(__pyx_n_s_list);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_list);
-  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 292, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_list);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 294, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_chunks, __pyx_t_2) < 0) __PYX_ERR(0, 294, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_chunks, __pyx_t_3) < 0) __PYX_ERR(0, 292, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":293
+  /* "borg/item.pyx":295
  * 
  *     chunks = PropDictProperty(list, 'list')
  *     chunks_healthy = PropDictProperty(list, 'list')             # <<<<<<<<<<<<<<
  * 
  *     xattrs = PropDictProperty(StableDict)
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 293, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 295, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(((PyObject *)(&PyList_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyList_Type)));
-  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyList_Type)));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyList_Type)));
   __Pyx_INCREF(__pyx_n_s_list);
   __Pyx_GIVEREF(__pyx_n_s_list);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_n_s_list);
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 293, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_chunks_healthy, __pyx_t_2) < 0) __PYX_ERR(0, 293, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_list);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 295, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_chunks_healthy, __pyx_t_1) < 0) __PYX_ERR(0, 295, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":295
+  /* "borg/item.pyx":297
  *     chunks_healthy = PropDictProperty(list, 'list')
  * 
  *     xattrs = PropDictProperty(StableDict)             # <<<<<<<<<<<<<<
  * 
  *     deleted = PropDictProperty(bool)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 295, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_StableDict); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 297, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 297, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 295, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_xattrs, __pyx_t_2) < 0) __PYX_ERR(0, 297, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_xattrs, __pyx_t_3) < 0) __PYX_ERR(0, 295, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":297
+  /* "borg/item.pyx":299
  *     xattrs = PropDictProperty(StableDict)
  * 
  *     deleted = PropDictProperty(bool)             # <<<<<<<<<<<<<<
  *     nlink = PropDictProperty(int)
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject*)&PyBool_Type)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 297, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_deleted, __pyx_t_3) < 0) __PYX_ERR(0, 297, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject*)&PyBool_Type)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 299, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_deleted, __pyx_t_2) < 0) __PYX_ERR(0, 299, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":298
+  /* "borg/item.pyx":300
  * 
  *     deleted = PropDictProperty(bool)
  *     nlink = PropDictProperty(int)             # <<<<<<<<<<<<<<
  * 
  *     part = PropDictProperty(int)  # legacy only
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 298, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_nlink, __pyx_t_3) < 0) __PYX_ERR(0, 298, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 300, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_nlink, __pyx_t_2) < 0) __PYX_ERR(0, 300, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":300
+  /* "borg/item.pyx":302
  *     nlink = PropDictProperty(int)
  * 
  *     part = PropDictProperty(int)  # legacy only             # <<<<<<<<<<<<<<
  * 
  *     def get_size(self, *, memorize=False, from_chunks=False, consider_ids=None):
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 300, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_part, __pyx_t_3) < 0) __PYX_ERR(0, 300, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 302, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_part, __pyx_t_2) < 0) __PYX_ERR(0, 302, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":352
+  /* "borg/item.pyx":354
  * 
  *     @classmethod
  *     def from_optr(self, optr):             # <<<<<<<<<<<<<<
  *         return _optr_to_object(optr)
  * 
  */
-  __Pyx_GetNameInClass(__pyx_t_3, (PyObject *)__pyx_ptype_4borg_4item_Item, __pyx_n_s_from_optr); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 352, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_GetNameInClass(__pyx_t_2, (PyObject *)__pyx_ptype_4borg_4item_Item, __pyx_n_s_from_optr); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 354, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
 
-  /* "borg/item.pyx":351
+  /* "borg/item.pyx":353
  *         return _object_to_optr(self)
  * 
  *     @classmethod             # <<<<<<<<<<<<<<
  *     def from_optr(self, optr):
  *         return _optr_to_object(optr)
  */
-  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 351, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_from_optr, __pyx_t_2) < 0) __PYX_ERR(0, 352, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 353, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_from_optr, __pyx_t_1) < 0) __PYX_ERR(0, 354, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":356
+  /* "borg/item.pyx":358
  * 
  *     @classmethod
  *     def create_deleted(cls, path):             # <<<<<<<<<<<<<<
  *         return cls(deleted=True, chunks=[], mode=0, path=path)
  * 
  */
-  __Pyx_GetNameInClass(__pyx_t_2, (PyObject *)__pyx_ptype_4borg_4item_Item, __pyx_n_s_create_deleted); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 356, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_GetNameInClass(__pyx_t_1, (PyObject *)__pyx_ptype_4borg_4item_Item, __pyx_n_s_create_deleted); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 358, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
 
-  /* "borg/item.pyx":355
+  /* "borg/item.pyx":357
  *         return _optr_to_object(optr)
  * 
  *     @classmethod             # <<<<<<<<<<<<<<
  *     def create_deleted(cls, path):
  *         return cls(deleted=True, chunks=[], mode=0, path=path)
  */
-  __pyx_t_3 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 355, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 357, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_create_deleted, __pyx_t_2) < 0) __PYX_ERR(0, 358, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Item->tp_dict, __pyx_n_s_create_deleted, __pyx_t_3) < 0) __PYX_ERR(0, 356, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Item);
 
-  /* "borg/item.pyx":422
+  /* "borg/item.pyx":424
  *     """
  * 
  *     VALID_KEYS = {'version', 'algorithm', 'iterations', 'salt', 'hash', 'data',             # <<<<<<<<<<<<<<
  *                   'argon2_time_cost', 'argon2_memory_cost', 'argon2_parallelism', 'argon2_type'}
  * 
  */
-  __pyx_t_3 = PySet_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 422, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_version) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_algorithm) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_iterations) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_salt) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_hash) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_data) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_argon2_time_cost) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_argon2_memory_cost) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_argon2_parallelism) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_argon2_type) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_3) < 0) __PYX_ERR(0, 422, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = PySet_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 424, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_version) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_algorithm) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_iterations) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_salt) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_hash) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_data) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_argon2_time_cost) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_argon2_memory_cost) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_argon2_parallelism) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_argon2_type) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_2) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":425
+  /* "borg/item.pyx":427
  *                   'argon2_time_cost', 'argon2_memory_cost', 'argon2_parallelism', 'argon2_type'}
  * 
  *     version = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     algorithm = PropDictProperty(str)
  *     iterations = PropDictProperty(int)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 425, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_version, __pyx_t_3) < 0) __PYX_ERR(0, 425, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 427, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_version, __pyx_t_2) < 0) __PYX_ERR(0, 427, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":426
+  /* "borg/item.pyx":428
  * 
  *     version = PropDictProperty(int)
  *     algorithm = PropDictProperty(str)             # <<<<<<<<<<<<<<
  *     iterations = PropDictProperty(int)
  *     salt = PropDictProperty(bytes)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 426, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_algorithm, __pyx_t_3) < 0) __PYX_ERR(0, 426, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 428, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_algorithm, __pyx_t_2) < 0) __PYX_ERR(0, 428, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":427
+  /* "borg/item.pyx":429
  *     version = PropDictProperty(int)
  *     algorithm = PropDictProperty(str)
  *     iterations = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     salt = PropDictProperty(bytes)
  *     hash = PropDictProperty(bytes)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 427, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_iterations, __pyx_t_3) < 0) __PYX_ERR(0, 427, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 429, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_iterations, __pyx_t_2) < 0) __PYX_ERR(0, 429, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":428
+  /* "borg/item.pyx":430
  *     algorithm = PropDictProperty(str)
  *     iterations = PropDictProperty(int)
  *     salt = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     hash = PropDictProperty(bytes)
  *     data = PropDictProperty(bytes)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 428, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_salt, __pyx_t_3) < 0) __PYX_ERR(0, 428, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 430, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_salt, __pyx_t_2) < 0) __PYX_ERR(0, 430, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":429
+  /* "borg/item.pyx":431
  *     iterations = PropDictProperty(int)
  *     salt = PropDictProperty(bytes)
  *     hash = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     data = PropDictProperty(bytes)
  *     argon2_time_cost = PropDictProperty(int)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 429, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_hash, __pyx_t_3) < 0) __PYX_ERR(0, 429, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 431, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_hash, __pyx_t_2) < 0) __PYX_ERR(0, 431, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":430
+  /* "borg/item.pyx":432
  *     salt = PropDictProperty(bytes)
  *     hash = PropDictProperty(bytes)
  *     data = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     argon2_time_cost = PropDictProperty(int)
  *     argon2_memory_cost = PropDictProperty(int)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 430, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_data, __pyx_t_3) < 0) __PYX_ERR(0, 430, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 432, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_data, __pyx_t_2) < 0) __PYX_ERR(0, 432, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":431
+  /* "borg/item.pyx":433
  *     hash = PropDictProperty(bytes)
  *     data = PropDictProperty(bytes)
  *     argon2_time_cost = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     argon2_memory_cost = PropDictProperty(int)
  *     argon2_parallelism = PropDictProperty(int)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 431, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_argon2_time_cost, __pyx_t_3) < 0) __PYX_ERR(0, 431, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 433, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_argon2_time_cost, __pyx_t_2) < 0) __PYX_ERR(0, 433, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":432
+  /* "borg/item.pyx":434
  *     data = PropDictProperty(bytes)
  *     argon2_time_cost = PropDictProperty(int)
  *     argon2_memory_cost = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     argon2_parallelism = PropDictProperty(int)
  *     argon2_type = PropDictProperty(str)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 432, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_argon2_memory_cost, __pyx_t_3) < 0) __PYX_ERR(0, 432, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 434, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_argon2_memory_cost, __pyx_t_2) < 0) __PYX_ERR(0, 434, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":433
+  /* "borg/item.pyx":435
  *     argon2_time_cost = PropDictProperty(int)
  *     argon2_memory_cost = PropDictProperty(int)
  *     argon2_parallelism = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     argon2_type = PropDictProperty(str)
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 433, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_argon2_parallelism, __pyx_t_3) < 0) __PYX_ERR(0, 433, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 435, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_argon2_parallelism, __pyx_t_2) < 0) __PYX_ERR(0, 435, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":434
+  /* "borg/item.pyx":436
  *     argon2_memory_cost = PropDictProperty(int)
  *     argon2_parallelism = PropDictProperty(int)
  *     argon2_type = PropDictProperty(str)             # <<<<<<<<<<<<<<
  * 
  *     def update_internal(self, d):
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 434, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_argon2_type, __pyx_t_3) < 0) __PYX_ERR(0, 434, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 436, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_EncryptedKey->tp_dict, __pyx_n_s_argon2_type, __pyx_t_2) < 0) __PYX_ERR(0, 436, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_EncryptedKey);
 
-  /* "borg/item.pyx":461
+  /* "borg/item.pyx":463
  *     """
  * 
  *     VALID_KEYS = {'version', 'repository_id', 'crypt_key', 'id_key', 'chunk_seed', 'tam_required'}             # <<<<<<<<<<<<<<
  * 
  *     version = PropDictProperty(int)
  */
-  __pyx_t_3 = PySet_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 461, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_version) < 0) __PYX_ERR(0, 461, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_repository_id) < 0) __PYX_ERR(0, 461, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_crypt_key) < 0) __PYX_ERR(0, 461, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_id_key) < 0) __PYX_ERR(0, 461, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_chunk_seed) < 0) __PYX_ERR(0, 461, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_tam_required) < 0) __PYX_ERR(0, 461, __pyx_L1_error)
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_3) < 0) __PYX_ERR(0, 461, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = PySet_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 463, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_version) < 0) __PYX_ERR(0, 463, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_repository_id) < 0) __PYX_ERR(0, 463, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_crypt_key) < 0) __PYX_ERR(0, 463, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_id_key) < 0) __PYX_ERR(0, 463, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_chunk_seed) < 0) __PYX_ERR(0, 463, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_tam_required) < 0) __PYX_ERR(0, 463, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_2) < 0) __PYX_ERR(0, 463, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Key);
 
-  /* "borg/item.pyx":463
+  /* "borg/item.pyx":465
  *     VALID_KEYS = {'version', 'repository_id', 'crypt_key', 'id_key', 'chunk_seed', 'tam_required'}
  * 
  *     version = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     repository_id = PropDictProperty(bytes)
  *     crypt_key = PropDictProperty(bytes)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 463, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_version, __pyx_t_3) < 0) __PYX_ERR(0, 463, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 465, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_version, __pyx_t_2) < 0) __PYX_ERR(0, 465, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Key);
 
-  /* "borg/item.pyx":464
+  /* "borg/item.pyx":466
  * 
  *     version = PropDictProperty(int)
  *     repository_id = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     crypt_key = PropDictProperty(bytes)
  *     id_key = PropDictProperty(bytes)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 464, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_repository_id, __pyx_t_3) < 0) __PYX_ERR(0, 464, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 466, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_repository_id, __pyx_t_2) < 0) __PYX_ERR(0, 466, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Key);
 
-  /* "borg/item.pyx":465
+  /* "borg/item.pyx":467
  *     version = PropDictProperty(int)
  *     repository_id = PropDictProperty(bytes)
  *     crypt_key = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     id_key = PropDictProperty(bytes)
  *     chunk_seed = PropDictProperty(int)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 465, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_crypt_key, __pyx_t_3) < 0) __PYX_ERR(0, 465, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 467, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_crypt_key, __pyx_t_2) < 0) __PYX_ERR(0, 467, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Key);
 
-  /* "borg/item.pyx":466
+  /* "borg/item.pyx":468
  *     repository_id = PropDictProperty(bytes)
  *     crypt_key = PropDictProperty(bytes)
  *     id_key = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     chunk_seed = PropDictProperty(int)
  *     tam_required = PropDictProperty(bool)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 466, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_id_key, __pyx_t_3) < 0) __PYX_ERR(0, 466, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 468, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_id_key, __pyx_t_2) < 0) __PYX_ERR(0, 468, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Key);
 
-  /* "borg/item.pyx":467
+  /* "borg/item.pyx":469
  *     crypt_key = PropDictProperty(bytes)
  *     id_key = PropDictProperty(bytes)
  *     chunk_seed = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     tam_required = PropDictProperty(bool)
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 467, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_chunk_seed, __pyx_t_3) < 0) __PYX_ERR(0, 467, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 469, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_chunk_seed, __pyx_t_2) < 0) __PYX_ERR(0, 469, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Key);
 
-  /* "borg/item.pyx":468
+  /* "borg/item.pyx":470
  *     id_key = PropDictProperty(bytes)
  *     chunk_seed = PropDictProperty(int)
  *     tam_required = PropDictProperty(bool)             # <<<<<<<<<<<<<<
  * 
  *     def update_internal(self, d):
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject*)&PyBool_Type)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 468, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_tam_required, __pyx_t_3) < 0) __PYX_ERR(0, 468, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject*)&PyBool_Type)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 470, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_Key->tp_dict, __pyx_n_s_tam_required, __pyx_t_2) < 0) __PYX_ERR(0, 470, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_Key);
 
-  /* "borg/item.pyx":497
+  /* "borg/item.pyx":499
  *     """
  * 
  *     VALID_KEYS = ARCHIVE_KEYS             # <<<<<<<<<<<<<<
  * 
  *     version = PropDictProperty(int)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_ARCHIVE_KEYS); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 497, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_3) < 0) __PYX_ERR(0, 497, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ARCHIVE_KEYS); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 499, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_2) < 0) __PYX_ERR(0, 499, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":499
+  /* "borg/item.pyx":501
  *     VALID_KEYS = ARCHIVE_KEYS
  * 
  *     version = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     name = PropDictProperty(str, 'surrogate-escaped str')
  *     items = PropDictProperty(list)  # list of chunk ids of item metadata stream (only in memory)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 499, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_version, __pyx_t_3) < 0) __PYX_ERR(0, 499, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 501, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_version, __pyx_t_2) < 0) __PYX_ERR(0, 501, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":500
+  /* "borg/item.pyx":502
  * 
  *     version = PropDictProperty(int)
  *     name = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
  *     items = PropDictProperty(list)  # list of chunk ids of item metadata stream (only in memory)
  *     item_ptrs = PropDictProperty(list)  # list of blocks with list of chunk ids of ims, arch v2
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 500, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 500, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_name_2, __pyx_t_2) < 0) __PYX_ERR(0, 500, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 502, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_name_2, __pyx_t_1) < 0) __PYX_ERR(0, 502, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":501
+  /* "borg/item.pyx":503
  *     version = PropDictProperty(int)
  *     name = PropDictProperty(str, 'surrogate-escaped str')
  *     items = PropDictProperty(list)  # list of chunk ids of item metadata stream (only in memory)             # <<<<<<<<<<<<<<
  *     item_ptrs = PropDictProperty(list)  # list of blocks with list of chunk ids of ims, arch v2
  *     cmdline = PropDictProperty(list)  # legacy, list of s-e-str
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 501, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_items, __pyx_t_2) < 0) __PYX_ERR(0, 501, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 503, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_items, __pyx_t_1) < 0) __PYX_ERR(0, 503, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":502
+  /* "borg/item.pyx":504
  *     name = PropDictProperty(str, 'surrogate-escaped str')
  *     items = PropDictProperty(list)  # list of chunk ids of item metadata stream (only in memory)
  *     item_ptrs = PropDictProperty(list)  # list of blocks with list of chunk ids of ims, arch v2             # <<<<<<<<<<<<<<
  *     cmdline = PropDictProperty(list)  # legacy, list of s-e-str
  *     command_line = PropDictProperty(str, 'surrogate-escaped str')
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_item_ptrs, __pyx_t_2) < 0) __PYX_ERR(0, 502, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 504, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_item_ptrs, __pyx_t_1) < 0) __PYX_ERR(0, 504, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":503
+  /* "borg/item.pyx":505
  *     items = PropDictProperty(list)  # list of chunk ids of item metadata stream (only in memory)
  *     item_ptrs = PropDictProperty(list)  # list of blocks with list of chunk ids of ims, arch v2
  *     cmdline = PropDictProperty(list)  # legacy, list of s-e-str             # <<<<<<<<<<<<<<
  *     command_line = PropDictProperty(str, 'surrogate-escaped str')
  *     hostname = PropDictProperty(str, 'surrogate-escaped str')
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 503, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_cmdline, __pyx_t_2) < 0) __PYX_ERR(0, 503, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 505, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_cmdline, __pyx_t_1) < 0) __PYX_ERR(0, 505, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":504
+  /* "borg/item.pyx":506
  *     item_ptrs = PropDictProperty(list)  # list of blocks with list of chunk ids of ims, arch v2
  *     cmdline = PropDictProperty(list)  # legacy, list of s-e-str
  *     command_line = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
  *     hostname = PropDictProperty(str, 'surrogate-escaped str')
  *     username = PropDictProperty(str, 'surrogate-escaped str')
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 504, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 506, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 504, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 506, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_command_line, __pyx_t_2) < 0) __PYX_ERR(0, 506, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_command_line, __pyx_t_3) < 0) __PYX_ERR(0, 504, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":505
+  /* "borg/item.pyx":507
  *     cmdline = PropDictProperty(list)  # legacy, list of s-e-str
  *     command_line = PropDictProperty(str, 'surrogate-escaped str')
  *     hostname = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
  *     username = PropDictProperty(str, 'surrogate-escaped str')
  *     time = PropDictProperty(str)
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 505, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 507, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 505, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_hostname, __pyx_t_2) < 0) __PYX_ERR(0, 505, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 507, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_hostname, __pyx_t_1) < 0) __PYX_ERR(0, 507, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":506
+  /* "borg/item.pyx":508
  *     command_line = PropDictProperty(str, 'surrogate-escaped str')
  *     hostname = PropDictProperty(str, 'surrogate-escaped str')
  *     username = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
  *     time = PropDictProperty(str)
  *     time_end = PropDictProperty(str)
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 506, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 508, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 506, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 508, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_username, __pyx_t_2) < 0) __PYX_ERR(0, 508, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_username, __pyx_t_3) < 0) __PYX_ERR(0, 506, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":507
+  /* "borg/item.pyx":509
  *     hostname = PropDictProperty(str, 'surrogate-escaped str')
  *     username = PropDictProperty(str, 'surrogate-escaped str')
  *     time = PropDictProperty(str)             # <<<<<<<<<<<<<<
  *     time_end = PropDictProperty(str)
  *     comment = PropDictProperty(str, 'surrogate-escaped str')
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 507, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_time, __pyx_t_3) < 0) __PYX_ERR(0, 507, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 509, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_time, __pyx_t_2) < 0) __PYX_ERR(0, 509, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":508
+  /* "borg/item.pyx":510
  *     username = PropDictProperty(str, 'surrogate-escaped str')
  *     time = PropDictProperty(str)
  *     time_end = PropDictProperty(str)             # <<<<<<<<<<<<<<
  *     comment = PropDictProperty(str, 'surrogate-escaped str')
  *     chunker_params = PropDictProperty(tuple)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 508, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_time_end, __pyx_t_3) < 0) __PYX_ERR(0, 508, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 510, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_time_end, __pyx_t_2) < 0) __PYX_ERR(0, 510, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":509
+  /* "borg/item.pyx":511
  *     time = PropDictProperty(str)
  *     time_end = PropDictProperty(str)
  *     comment = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
  *     chunker_params = PropDictProperty(tuple)
  *     recreate_cmdline = PropDictProperty(list)  # legacy, list of s-e-str
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 509, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 511, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 509, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_comment, __pyx_t_2) < 0) __PYX_ERR(0, 509, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 511, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_comment, __pyx_t_1) < 0) __PYX_ERR(0, 511, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":510
+  /* "borg/item.pyx":512
  *     time_end = PropDictProperty(str)
  *     comment = PropDictProperty(str, 'surrogate-escaped str')
  *     chunker_params = PropDictProperty(tuple)             # <<<<<<<<<<<<<<
  *     recreate_cmdline = PropDictProperty(list)  # legacy, list of s-e-str
  *     recreate_command_line = PropDictProperty(str, 'surrogate-escaped str')
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyTuple_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 510, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_chunker_params, __pyx_t_2) < 0) __PYX_ERR(0, 510, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyTuple_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 512, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_chunker_params, __pyx_t_1) < 0) __PYX_ERR(0, 512, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":511
+  /* "borg/item.pyx":513
  *     comment = PropDictProperty(str, 'surrogate-escaped str')
  *     chunker_params = PropDictProperty(tuple)
  *     recreate_cmdline = PropDictProperty(list)  # legacy, list of s-e-str             # <<<<<<<<<<<<<<
  *     recreate_command_line = PropDictProperty(str, 'surrogate-escaped str')
  *     # recreate_source_id, recreate_args, recreate_partial_chunks were used in 1.1.0b1 .. b2
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 511, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_cmdline, __pyx_t_2) < 0) __PYX_ERR(0, 511, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 513, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_cmdline, __pyx_t_1) < 0) __PYX_ERR(0, 513, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":512
+  /* "borg/item.pyx":514
  *     chunker_params = PropDictProperty(tuple)
  *     recreate_cmdline = PropDictProperty(list)  # legacy, list of s-e-str
  *     recreate_command_line = PropDictProperty(str, 'surrogate-escaped str')             # <<<<<<<<<<<<<<
  *     # recreate_source_id, recreate_args, recreate_partial_chunks were used in 1.1.0b1 .. b2
  *     recreate_source_id = PropDictProperty(bytes)
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 512, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 514, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)(&PyString_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyString_Type)));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyString_Type)));
   __Pyx_INCREF(__pyx_kp_s_surrogate_escaped_str);
   __Pyx_GIVEREF(__pyx_kp_s_surrogate_escaped_str);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_surrogate_escaped_str);
-  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 512, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_surrogate_escaped_str);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 514, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_command_line, __pyx_t_2) < 0) __PYX_ERR(0, 514, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_command_line, __pyx_t_3) < 0) __PYX_ERR(0, 512, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":514
+  /* "borg/item.pyx":516
  *     recreate_command_line = PropDictProperty(str, 'surrogate-escaped str')
  *     # recreate_source_id, recreate_args, recreate_partial_chunks were used in 1.1.0b1 .. b2
  *     recreate_source_id = PropDictProperty(bytes)             # <<<<<<<<<<<<<<
  *     recreate_args = PropDictProperty(list)  # list of s-e-str
  *     recreate_partial_chunks = PropDictProperty(list)  # list of tuples
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 514, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_source_id, __pyx_t_3) < 0) __PYX_ERR(0, 514, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyBytes_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 516, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_source_id, __pyx_t_2) < 0) __PYX_ERR(0, 516, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":515
+  /* "borg/item.pyx":517
  *     # recreate_source_id, recreate_args, recreate_partial_chunks were used in 1.1.0b1 .. b2
  *     recreate_source_id = PropDictProperty(bytes)
  *     recreate_args = PropDictProperty(list)  # list of s-e-str             # <<<<<<<<<<<<<<
  *     recreate_partial_chunks = PropDictProperty(list)  # list of tuples
  *     size = PropDictProperty(int)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 515, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_args, __pyx_t_3) < 0) __PYX_ERR(0, 515, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 517, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_args, __pyx_t_2) < 0) __PYX_ERR(0, 517, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":516
+  /* "borg/item.pyx":518
  *     recreate_source_id = PropDictProperty(bytes)
  *     recreate_args = PropDictProperty(list)  # list of s-e-str
  *     recreate_partial_chunks = PropDictProperty(list)  # list of tuples             # <<<<<<<<<<<<<<
  *     size = PropDictProperty(int)
  *     nfiles = PropDictProperty(int)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 516, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_partial_chunks, __pyx_t_3) < 0) __PYX_ERR(0, 516, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 518, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_recreate_partial_chunks, __pyx_t_2) < 0) __PYX_ERR(0, 518, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":517
+  /* "borg/item.pyx":519
  *     recreate_args = PropDictProperty(list)  # list of s-e-str
  *     recreate_partial_chunks = PropDictProperty(list)  # list of tuples
  *     size = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     nfiles = PropDictProperty(int)
  *     size_parts = PropDictProperty(int)  # legacy only
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 517, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_size, __pyx_t_3) < 0) __PYX_ERR(0, 517, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 519, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_size, __pyx_t_2) < 0) __PYX_ERR(0, 519, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":518
+  /* "borg/item.pyx":520
  *     recreate_partial_chunks = PropDictProperty(list)  # list of tuples
  *     size = PropDictProperty(int)
  *     nfiles = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     size_parts = PropDictProperty(int)  # legacy only
  *     nfiles_parts = PropDictProperty(int)  # legacy only
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 518, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_nfiles, __pyx_t_3) < 0) __PYX_ERR(0, 518, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 520, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_nfiles, __pyx_t_2) < 0) __PYX_ERR(0, 520, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":519
+  /* "borg/item.pyx":521
  *     size = PropDictProperty(int)
  *     nfiles = PropDictProperty(int)
  *     size_parts = PropDictProperty(int)  # legacy only             # <<<<<<<<<<<<<<
  *     nfiles_parts = PropDictProperty(int)  # legacy only
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 519, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_size_parts, __pyx_t_3) < 0) __PYX_ERR(0, 519, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 521, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_size_parts, __pyx_t_2) < 0) __PYX_ERR(0, 521, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":520
+  /* "borg/item.pyx":522
  *     nfiles = PropDictProperty(int)
  *     size_parts = PropDictProperty(int)  # legacy only
  *     nfiles_parts = PropDictProperty(int)  # legacy only             # <<<<<<<<<<<<<<
  * 
  *     def update_internal(self, d):
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 520, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_nfiles_parts, __pyx_t_3) < 0) __PYX_ERR(0, 520, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 522, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ArchiveItem->tp_dict, __pyx_n_s_nfiles_parts, __pyx_t_2) < 0) __PYX_ERR(0, 522, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ArchiveItem);
 
-  /* "borg/item.pyx":557
+  /* "borg/item.pyx":559
  *     """
  * 
  *     VALID_KEYS = {'version', 'archives', 'timestamp', 'config', 'item_keys', }             # <<<<<<<<<<<<<<
  * 
  *     version = PropDictProperty(int)
  */
-  __pyx_t_3 = PySet_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 557, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_version) < 0) __PYX_ERR(0, 557, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_archives) < 0) __PYX_ERR(0, 557, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_timestamp) < 0) __PYX_ERR(0, 557, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_config) < 0) __PYX_ERR(0, 557, __pyx_L1_error)
-  if (PySet_Add(__pyx_t_3, __pyx_n_s_item_keys) < 0) __PYX_ERR(0, 557, __pyx_L1_error)
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_3) < 0) __PYX_ERR(0, 557, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = PySet_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 559, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_version) < 0) __PYX_ERR(0, 559, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_archives) < 0) __PYX_ERR(0, 559, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_timestamp) < 0) __PYX_ERR(0, 559, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_config) < 0) __PYX_ERR(0, 559, __pyx_L1_error)
+  if (PySet_Add(__pyx_t_2, __pyx_n_s_item_keys) < 0) __PYX_ERR(0, 559, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_VALID_KEYS, __pyx_t_2) < 0) __PYX_ERR(0, 559, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ManifestItem);
 
-  /* "borg/item.pyx":559
+  /* "borg/item.pyx":561
  *     VALID_KEYS = {'version', 'archives', 'timestamp', 'config', 'item_keys', }
  * 
  *     version = PropDictProperty(int)             # <<<<<<<<<<<<<<
  *     archives = PropDictProperty(dict, 'dict of str -> dict')  # name -> dict
  *     timestamp = PropDictProperty(str)
  */
-  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 559, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_version, __pyx_t_3) < 0) __PYX_ERR(0, 559, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyInt_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 561, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_version, __pyx_t_2) < 0) __PYX_ERR(0, 561, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ManifestItem);
 
-  /* "borg/item.pyx":560
+  /* "borg/item.pyx":562
  * 
  *     version = PropDictProperty(int)
  *     archives = PropDictProperty(dict, 'dict of str -> dict')  # name -> dict             # <<<<<<<<<<<<<<
  *     timestamp = PropDictProperty(str)
  *     config = PropDictProperty(dict)
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 560, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 562, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(((PyObject *)(&PyDict_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyDict_Type)));
-  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyDict_Type)));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyDict_Type)));
   __Pyx_INCREF(__pyx_kp_s_dict_of_str_dict);
   __Pyx_GIVEREF(__pyx_kp_s_dict_of_str_dict);
-  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_kp_s_dict_of_str_dict);
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 560, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_archives, __pyx_t_2) < 0) __PYX_ERR(0, 560, __pyx_L1_error)
+  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_dict_of_str_dict);
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 562, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_archives, __pyx_t_1) < 0) __PYX_ERR(0, 562, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ManifestItem);
 
-  /* "borg/item.pyx":561
+  /* "borg/item.pyx":563
  *     version = PropDictProperty(int)
  *     archives = PropDictProperty(dict, 'dict of str -> dict')  # name -> dict
  *     timestamp = PropDictProperty(str)             # <<<<<<<<<<<<<<
  *     config = PropDictProperty(dict)
  *     item_keys = PropDictProperty(tuple, 'tuple of str')
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 561, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_timestamp, __pyx_t_2) < 0) __PYX_ERR(0, 561, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyString_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 563, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_timestamp, __pyx_t_1) < 0) __PYX_ERR(0, 563, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ManifestItem);
 
-  /* "borg/item.pyx":562
+  /* "borg/item.pyx":564
  *     archives = PropDictProperty(dict, 'dict of str -> dict')  # name -> dict
  *     timestamp = PropDictProperty(str)
  *     config = PropDictProperty(dict)             # <<<<<<<<<<<<<<
  *     item_keys = PropDictProperty(tuple, 'tuple of str')
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyDict_Type))); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 562, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_config, __pyx_t_2) < 0) __PYX_ERR(0, 562, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), ((PyObject *)(&PyDict_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 564, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_config, __pyx_t_1) < 0) __PYX_ERR(0, 564, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ManifestItem);
 
-  /* "borg/item.pyx":563
+  /* "borg/item.pyx":565
  *     timestamp = PropDictProperty(str)
  *     config = PropDictProperty(dict)
  *     item_keys = PropDictProperty(tuple, 'tuple of str')             # <<<<<<<<<<<<<<
  * 
  *     def update_internal(self, d):
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 563, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(((PyObject *)(&PyTuple_Type)));
   __Pyx_GIVEREF(((PyObject *)(&PyTuple_Type)));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)(&PyTuple_Type)));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyTuple_Type)));
   __Pyx_INCREF(__pyx_kp_s_tuple_of_str);
   __Pyx_GIVEREF(__pyx_kp_s_tuple_of_str);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_kp_s_tuple_of_str);
-  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 563, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_tuple_of_str);
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_4borg_4item_PropDictProperty), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_item_keys, __pyx_t_2) < 0) __PYX_ERR(0, 565, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_4borg_4item_ManifestItem->tp_dict, __pyx_n_s_item_keys, __pyx_t_3) < 0) __PYX_ERR(0, 563, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   PyType_Modified(__pyx_ptype_4borg_4item_ManifestItem);
 
-  /* "borg/item.pyx":618
+  /* "borg/item.pyx":620
  *                 value.__set_name__(name)
  * 
  * _init_names()             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_3 = __pyx_f_4borg_4item__init_names(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 618, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __pyx_f_4borg_4item__init_names(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 620, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "borg/item.pyx":623
+ * 
+ * 
+ * class DiffChange:             # <<<<<<<<<<<<<<
+ *     """
+ *     Stores a change in a diff.
+ */
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_DiffChange, __pyx_n_s_DiffChange, (PyObject *) NULL, __pyx_n_s_borg_item, __pyx_kp_s_Stores_a_change_in_a_diff_The_d); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 623, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+
+  /* "borg/item.pyx":630
+ *     The diff_data contains additional information about the change, e.g. the old and new mode.
+ *     """
+ *     def __init__(self, diff_type, diff_data=None):             # <<<<<<<<<<<<<<
+ *         self.diff_type = diff_type
+ *         self.diff_data = diff_data or {}
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_10DiffChange_1__init__, 0, __pyx_n_s_DiffChange___init, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__47)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 630, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_1, __pyx_tuple__48);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_1) < 0) __PYX_ERR(0, 630, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":634
+ *         self.diff_data = diff_data or {}
+ * 
+ *     def to_dict(self):             # <<<<<<<<<<<<<<
+ *         return {"type": self.diff_type, **self.diff_data}
+ * 
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_10DiffChange_3to_dict, 0, __pyx_n_s_DiffChange_to_dict, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__50)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_to_dict, __pyx_t_1) < 0) __PYX_ERR(0, 634, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":623
+ * 
+ * 
+ * class DiffChange:             # <<<<<<<<<<<<<<
+ *     """
+ *     Stores a change in a diff.
+ */
+  __pyx_t_1 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_DiffChange, __pyx_empty_tuple, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 623, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DiffChange, __pyx_t_1) < 0) __PYX_ERR(0, 623, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/item.pyx":621
+  /* "borg/item.pyx":638
  * 
  * 
  * class ItemDiff:             # <<<<<<<<<<<<<<
  *     """
  *     Comparison of two items from different archives.
  */
-  __pyx_t_3 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_ItemDiff, __pyx_n_s_ItemDiff, (PyObject *) NULL, __pyx_n_s_borg_item, __pyx_kp_s_Comparison_of_two_items_from_di); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 621, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_ItemDiff, __pyx_n_s_ItemDiff, (PyObject *) NULL, __pyx_n_s_borg_item, __pyx_kp_s_Comparison_of_two_items_from_di); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 638, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
 
-  /* "borg/item.pyx":629
+  /* "borg/item.pyx":645
  *     """
  * 
- *     def __init__(self, item1, item2, chunk_iterator1, chunk_iterator2, numeric_ids=False, can_compare_chunk_ids=False):             # <<<<<<<<<<<<<<
+ *     def __init__(self, path, item1, item2, chunk_1, chunk_2, numeric_ids=False, can_compare_chunk_ids=False):             # <<<<<<<<<<<<<<
+ *         self.path = path
  *         self._item1 = item1
- *         self._item2 = item2
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_1__init__, 0, __pyx_n_s_ItemDiff___init, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__49)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 629, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_2, __pyx_tuple__50);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_init, __pyx_t_2) < 0) __PYX_ERR(0, 629, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_1__init__, 0, __pyx_n_s_ItemDiff___init, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__52)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 645, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_1, __pyx_tuple__53);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_1) < 0) __PYX_ERR(0, 645, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":662
- *         self._changes = [ch for ch in changes if ch]
+  /* "borg/item.pyx":680
+ * 
  * 
  *     def changes(self):             # <<<<<<<<<<<<<<
  *         return self._changes
  * 
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_3changes, 0, __pyx_n_s_ItemDiff_changes, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__52)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 662, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_changes_2, __pyx_t_2) < 0) __PYX_ERR(0, 662, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_3changes, 0, __pyx_n_s_ItemDiff_changes, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__55)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 680, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_changes_2, __pyx_t_1) < 0) __PYX_ERR(0, 680, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":665
+  /* "borg/item.pyx":683
  *         return self._changes
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
- *         if self.equal:
- *             return 'equal'
+ *         return (' '.join(self._changes.keys())) or 'equal'
+ * 
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_5__repr__, 0, __pyx_n_s_ItemDiff___repr, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__54)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 665, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_repr, __pyx_t_2) < 0) __PYX_ERR(0, 665, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_5__repr__, 0, __pyx_n_s_ItemDiff___repr, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__57)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 683, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_repr, __pyx_t_1) < 0) __PYX_ERR(0, 683, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":670
- *         return ' '.join(str for d, str in self._changes)
+  /* "borg/item.pyx":686
+ *         return (' '.join(self._changes.keys())) or 'equal'
  * 
- *     def _equal(self, chunk_iterator1, chunk_iterator2):             # <<<<<<<<<<<<<<
+ *     def equal(self, content_only=False):             # <<<<<<<<<<<<<<
  *         # if both are deleted, there is nothing at path regardless of what was deleted
  *         if self._item1.get('deleted') and self._item2.get('deleted'):
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_7_equal, 0, __pyx_n_s_ItemDiff__equal, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__56)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 670, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_equal, __pyx_t_2) < 0) __PYX_ERR(0, 670, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_7equal, 0, __pyx_n_s_ItemDiff_equal, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__59)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 686, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_1, __pyx_tuple__60);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_equal, __pyx_t_1) < 0) __PYX_ERR(0, 686, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":691
+  /* "borg/item.pyx":710
  *         return True
  * 
  *     def _presence_diff(self, item_type):             # <<<<<<<<<<<<<<
  *         if not self._item1.get('deleted') and self._item2.get('deleted'):
- *             chg = 'removed ' + item_type
+ *             self._changes[item_type] = DiffChange(f"removed {item_type}")
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_9_presence_diff, 0, __pyx_n_s_ItemDiff__presence_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__58)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 691, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_presence_diff, __pyx_t_2) < 0) __PYX_ERR(0, 691, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_9_presence_diff, 0, __pyx_n_s_ItemDiff__presence_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__62)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 710, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_presence_diff, __pyx_t_1) < 0) __PYX_ERR(0, 710, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":699
- *             return ({"type": chg}, chg)
+  /* "borg/item.pyx":718
+ *             return True
  * 
  *     def _link_diff(self):             # <<<<<<<<<<<<<<
- *         pd = self._presence_diff('link')
- *         if pd is not None:
+ *         if self._presence_diff('link'):
+ *             return True
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_11_link_diff, 0, __pyx_n_s_ItemDiff__link_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__60)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 699, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_link_diff, __pyx_t_2) < 0) __PYX_ERR(0, 699, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_11_link_diff, 0, __pyx_n_s_ItemDiff__link_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__64)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 718, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_link_diff, __pyx_t_1) < 0) __PYX_ERR(0, 718, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":706
- *             return ({"type": 'changed link'}, 'changed link')
+  /* "borg/item.pyx":725
+ *             return True
  * 
  *     def _content_diff(self):             # <<<<<<<<<<<<<<
  *         if self._item1.get('deleted'):
  *             sz = self._item2.get_size()
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_13_content_diff, 0, __pyx_n_s_ItemDiff__content_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__62)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 706, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_content_diff, __pyx_t_2) < 0) __PYX_ERR(0, 706, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_13_content_diff, 0, __pyx_n_s_ItemDiff__content_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__66)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 725, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_content_diff, __pyx_t_1) < 0) __PYX_ERR(0, 725, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":725
- *             format_file_size(-removed, precision=1, sign=True)))
+  /* "borg/item.pyx":747
+ * 
  * 
  *     def _owner_diff(self):             # <<<<<<<<<<<<<<
  *         u_attr, g_attr = ('uid', 'gid') if self._numeric_ids else ('user', 'group')
  *         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_15_owner_diff, 0, __pyx_n_s_ItemDiff__owner_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__64)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 725, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_owner_diff, __pyx_t_2) < 0) __PYX_ERR(0, 725, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_15_owner_diff, 0, __pyx_n_s_ItemDiff__owner_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__68)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 747, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_owner_diff, __pyx_t_1) < 0) __PYX_ERR(0, 747, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":733
- *                     '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))
+  /* "borg/item.pyx":760
+ *         return True
  * 
  *     def _mode_diff(self):             # <<<<<<<<<<<<<<
  *         if 'mode' in self._item1 and 'mode' in self._item2 and self._item1.mode != self._item2.mode:
  *             mode1 = stat.filemode(self._item1.mode)
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_17_mode_diff, 0, __pyx_n_s_ItemDiff__mode_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__66)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 733, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_mode_diff, __pyx_t_2) < 0) __PYX_ERR(0, 733, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_17_mode_diff, 0, __pyx_n_s_ItemDiff__mode_diff, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__70)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 760, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_mode_diff, __pyx_t_1) < 0) __PYX_ERR(0, 760, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":739
- *             return ({"type": "mode", "old_mode": mode1, "new_mode": mode2}, '[{} -> {}]'.format(mode1, mode2))
+  /* "borg/item.pyx":768
+ *                 self._changes['type'] = DiffChange("changed type", {"item1": mode1[0], "item2": mode2[0]})
+ * 
+ *     def _time_diffs(self):             # <<<<<<<<<<<<<<
+ *         attrs = ["ctime", "mtime"]
+ *         for attr in attrs:
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_19_time_diffs, 0, __pyx_n_s_ItemDiff__time_diffs, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__72)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 768, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_time_diffs, __pyx_t_1) < 0) __PYX_ERR(0, 768, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":777
+ *         return True
+ * 
+ *     def content(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('content')
+ * 
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_21content, 0, __pyx_n_s_ItemDiff_content, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__74)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 777, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_content, __pyx_t_1) < 0) __PYX_ERR(0, 777, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":780
+ *         return self._changes.get('content')
+ * 
+ *     def ctime(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('ctime')
+ * 
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_23ctime, 0, __pyx_n_s_ItemDiff_ctime, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__76)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 780, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_ctime, __pyx_t_1) < 0) __PYX_ERR(0, 780, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":783
+ *         return self._changes.get('ctime')
+ * 
+ *     def mtime(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('mtime')
+ * 
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_25mtime, 0, __pyx_n_s_ItemDiff_mtime, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__78)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 783, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_mtime, __pyx_t_1) < 0) __PYX_ERR(0, 783, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":786
+ *         return self._changes.get('mtime')
+ * 
+ *     def mode(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('mode')
+ * 
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_27mode, 0, __pyx_n_s_ItemDiff_mode, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__80)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 786, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_mode, __pyx_t_1) < 0) __PYX_ERR(0, 786, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":789
+ *         return self._changes.get('mode')
+ * 
+ *     def type(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('type')
+ * 
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_29type, 0, __pyx_n_s_ItemDiff_type, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__82)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 789, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_type, __pyx_t_1) < 0) __PYX_ERR(0, 789, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":792
+ *         return self._changes.get('type')
+ * 
+ *     def owner(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('owner')
+ * 
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_31owner, 0, __pyx_n_s_ItemDiff_owner, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__84)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 792, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_owner, __pyx_t_1) < 0) __PYX_ERR(0, 792, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":795
+ *         return self._changes.get('owner')
+ * 
+ *     def user(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('user')
+ * 
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_33user, 0, __pyx_n_s_ItemDiff_user, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__86)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 795, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_user, __pyx_t_1) < 0) __PYX_ERR(0, 795, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":798
+ *         return self._changes.get('user')
+ * 
+ *     def group(self):             # <<<<<<<<<<<<<<
+ *         return self._changes.get('group')
  * 
- *     def _content_equal(self, chunk_iterator1, chunk_iterator2):             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_35group, 0, __pyx_n_s_ItemDiff_group, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__88)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 798, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_group, __pyx_t_1) < 0) __PYX_ERR(0, 798, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "borg/item.pyx":801
+ *         return self._changes.get('group')
+ * 
+ *     def _content_equal(self):             # <<<<<<<<<<<<<<
  *         if self._can_compare_chunk_ids:
  *             return self._item1.chunks == self._item2.chunks
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_19_content_equal, 0, __pyx_n_s_ItemDiff__content_equal, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__68)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 739, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_content_equal, __pyx_t_2) < 0) __PYX_ERR(0, 739, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_4item_8ItemDiff_37_content_equal, 0, __pyx_n_s_ItemDiff__content_equal, NULL, __pyx_n_s_borg_item, __pyx_d, ((PyObject *)__pyx_codeobj__90)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 801, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_content_equal, __pyx_t_1) < 0) __PYX_ERR(0, 801, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "borg/item.pyx":621
+  /* "borg/item.pyx":638
  * 
  * 
  * class ItemDiff:             # <<<<<<<<<<<<<<
  *     """
  *     Comparison of two items from different archives.
  */
-  __pyx_t_2 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_ItemDiff, __pyx_empty_tuple, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 621, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ItemDiff, __pyx_t_2) < 0) __PYX_ERR(0, 621, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_ItemDiff, __pyx_empty_tuple, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ItemDiff, __pyx_t_1) < 0) __PYX_ERR(0, 638, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/item.pyx":747
+  /* "borg/item.pyx":809
  * 
  * 
  * def chunks_contents_equal(chunks_a, chunks_b):             # <<<<<<<<<<<<<<
  *     """
  *     Compare chunk content and return True if they are identical.
  */
-  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_25chunks_contents_equal, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 747, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_chunks_contents_equal, __pyx_t_3) < 0) __PYX_ERR(0, 747, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_4item_25chunks_contents_equal, NULL, __pyx_n_s_borg_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 809, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_chunks_contents_equal, __pyx_t_2) < 0) __PYX_ERR(0, 809, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "borg/item.pyx":1
  * import stat             # <<<<<<<<<<<<<<
  * from collections import namedtuple
  * 
  */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_3) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
@@ -25538,28 +27048,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -26356,14 +27866,19 @@
     if (likely(tp->tp_setattr))
         return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
 #endif
     return PyObject_SetAttr(obj, attr_name, value);
 }
 #endif
 
+/* RaiseMappingExpected */
+static void __Pyx_RaiseMappingExpectedError(PyObject* arg) {
+    PyErr_Format(PyExc_TypeError, "'%.200s' object is not a mapping", Py_TYPE(arg)->tp_name);
+}
+
 /* StringJoin */
 #if !CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyBytes_Join(PyObject* sep, PyObject* values) {
     return PyObject_CallMethodObjArgs(sep, __pyx_n_s_join, values, NULL);
 }
 #endif
 
@@ -26613,61 +28128,79 @@
     return 0;
 bad:
     Py_XDECREF(ob);
     return -1;
 }
 
 /* TypeImport */
-#ifndef __PYX_HAVE_RT_ImportType
-#define __PYX_HAVE_RT_ImportType
-static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, enum __Pyx_ImportType_CheckSize check_size)
+#ifndef __PYX_HAVE_RT_ImportType_0_29_35
+#define __PYX_HAVE_RT_ImportType_0_29_35
+static PyTypeObject *__Pyx_ImportType_0_29_35(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_35 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
+    Py_ssize_t itemsize;
 #ifdef Py_LIMITED_API
     PyObject *py_basicsize;
+    PyObject *py_itemsize;
 #endif
     result = PyObject_GetAttrString(module, class_name);
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
             "%.200s.%.200s is not a type object",
             module_name, class_name);
         goto bad;
     }
 #ifndef Py_LIMITED_API
     basicsize = ((PyTypeObject *)result)->tp_basicsize;
+    itemsize = ((PyTypeObject *)result)->tp_itemsize;
 #else
     py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
     if (!py_basicsize)
         goto bad;
     basicsize = PyLong_AsSsize_t(py_basicsize);
     Py_DECREF(py_basicsize);
     py_basicsize = 0;
     if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
         goto bad;
+    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
+    if (!py_itemsize)
+        goto bad;
+    itemsize = PyLong_AsSsize_t(py_itemsize);
+    Py_DECREF(py_itemsize);
+    py_itemsize = 0;
+    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
 #endif
-    if ((size_t)basicsize < size) {
+    if (itemsize) {
+        if (size % alignment) {
+            alignment = size % alignment;
+        }
+        if (itemsize < (Py_ssize_t)alignment)
+            itemsize = (Py_ssize_t)alignment;
+    }
+    if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
+    if (check_size == __Pyx_ImportType_CheckSize_Error_0_29_35 && (size_t)basicsize != size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_0_29_35 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
@@ -27431,15 +28964,18 @@
 #endif
 #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
     0,
 #endif
 };
 static int __pyx_CyFunction_init(void) {
     __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
     if (unlikely(__pyx_CyFunctionType == NULL)) {
         return -1;
@@ -27936,15 +29472,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -28132,15 +29668,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -29401,15 +30937,18 @@
 #endif
 #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
     0,
 #endif
 };
 static int __pyx_Generator_init(void) {
     __pyx_GeneratorType_type.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
     __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
     __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
```

### Comparing `borgbackup-2.0.0b5/src/borg/item.pyi` & `borgbackup-2.0.0b6/src/borg/item.pyi`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import FrozenSet, Set, NamedTuple, Tuple, Mapping, Dict, List, Iterator, Callable, Any
+from typing import FrozenSet, Set, NamedTuple, Tuple, Mapping, Dict, List, Iterator, Callable, Any, Optional
 
 from .helpers import StableDict
 
 API_VERSION: str
 
 def want_bytes(v: Any, *, errors: str = ...) -> bytes: ...
 def chunks_contents_equal(chunks1: Iterator, chunks2: Iterator) -> bool: ...
@@ -243,17 +243,44 @@
     @config.setter
     def config(self, val: Dict) -> None: ...
     @property
     def item_keys(self) -> Tuple: ...
     @item_keys.setter
     def item_keys(self, val: Tuple) -> None: ...
 
+class DiffChange:
+    diff_type: str
+    diff_data: Dict[str, Any]
+    def __init__(self, diff_type: str, diff_data: Optional[Dict[str, Any]] = ...) -> None: ...
+    def to_dict(self) -> Dict[str, Any]: ...
+
 class ItemDiff:
-    def __init__(self, *args, **kwargs) -> None: ...
-    def _chunk_content_equal(self, c1: Iterator, c2: Iterator) -> bool: ...
+    path: str
+    def __init__(
+        self,
+        path: str,
+        item1: Item,
+        item2: Item,
+        chunk_1: Iterator,
+        chunk_2: Iterator,
+        numeric_ids: bool = ...,
+        can_compare_chunk_ids: bool = ...,
+    ) -> None: ...
+    def changes(self) -> Dict[str, DiffChange]: ...
+    def equal(self, content_only: bool = ...) -> bool: ...
+    def content(self) -> Optional[DiffChange]: ...
+    def ctime(self) -> Optional[DiffChange]: ...
+    def mtime(self) -> Optional[DiffChange]: ...
+    def mode(self) -> Optional[DiffChange]: ...
+    def type(self) -> Optional[DiffChange]: ...
+    def owner(self) -> Optional[DiffChange]: ...
+    def user(self) -> Optional[DiffChange]: ...
+    def group(self) -> Optional[DiffChange]: ...
+
+def chunk_content_equal(chunks_a: Iterator, chunks_b: Iterator) -> bool: ...
 
 class Key(PropDict):
     @property
     def version(self) -> int: ...
     @version.setter
     def version(self, val: int) -> None: ...
     @property
```

### Comparing `borgbackup-2.0.0b5/src/borg/item.pyx` & `borgbackup-2.0.0b6/src/borg/item.pyx`

 * *Files 7% similar despite different names*

```diff
@@ -3,15 +3,17 @@
 
 from libc.string cimport memcmp
 from cpython.bytes cimport PyBytes_AsStringAndSize
 
 from .constants import ITEM_KEYS, ARCHIVE_KEYS
 from .helpers import StableDict
 from .helpers import format_file_size
+from .helpers.fs import assert_sanitized_path, to_sanitized_path
 from .helpers.msgpack import timestamp_to_int, int_to_timestamp, Timestamp
+from .helpers.time import OutputTimestamp, safe_timestamp
 
 
 cdef extern from "_item.c":
     object _object_to_optr(object obj)
     object _optr_to_object(object bytes)
 
 
@@ -257,15 +259,15 @@
     If an Item shall be serialized, give as_dict() method output to msgpack packer.
     """
 
     VALID_KEYS = ITEM_KEYS | {'deleted', 'nlink', }
 
     # properties statically defined, so that IDEs can know their names:
 
-    path = PropDictProperty(str, 'surrogate-escaped str')
+    path = PropDictProperty(str, 'surrogate-escaped str', encode=assert_sanitized_path, decode=to_sanitized_path)
     source = PropDictProperty(str, 'surrogate-escaped str')  # legacy borg 1.x. borg 2: see .target
     target = PropDictProperty(str, 'surrogate-escaped str')
     user = PropDictProperty(str, 'surrogate-escaped str')
     group = PropDictProperty(str, 'surrogate-escaped str')
 
     acl_access = PropDictProperty(bytes)
     acl_default = PropDictProperty(bytes)
@@ -614,138 +616,198 @@
         for name, value in vars(cls).items():
             if isinstance(value, PropDictProperty):
                 value.__set_name__(name)
 
 _init_names()
 
 
+class DiffChange:
+    """
+    Stores a change in a diff.
+
+    The diff_type denotes the type of change, e.g. "added", "removed", "modified".
+    The diff_data contains additional information about the change, e.g. the old and new mode.
+    """
+    def __init__(self, diff_type, diff_data=None):
+        self.diff_type = diff_type
+        self.diff_data = diff_data or {}
+
+    def to_dict(self):
+        return {"type": self.diff_type, **self.diff_data}
+
+
 class ItemDiff:
     """
     Comparison of two items from different archives.
 
     The items may have different paths and still be considered equal (e.g. for renames).
-    It does not include extended or time attributes in the comparison.
     """
 
-    def __init__(self, item1, item2, chunk_iterator1, chunk_iterator2, numeric_ids=False, can_compare_chunk_ids=False):
+    def __init__(self, path, item1, item2, chunk_1, chunk_2, numeric_ids=False, can_compare_chunk_ids=False):
+        self.path = path
         self._item1 = item1
         self._item2 = item2
         self._numeric_ids = numeric_ids
         self._can_compare_chunk_ids = can_compare_chunk_ids
-        self.equal = self._equal(chunk_iterator1, chunk_iterator2)
-        changes = []
+        self._chunk_1 = chunk_1
+        self._chunk_2 = chunk_2
+        
+        self._changes = {}
 
         if self._item1.is_link() or self._item2.is_link():
-            changes.append(self._link_diff())
+            self._link_diff()
 
         if 'chunks' in self._item1 and 'chunks' in self._item2:
-            changes.append(self._content_diff())
+            self._content_diff()
 
         if self._item1.is_dir() or self._item2.is_dir():
-            changes.append(self._presence_diff('directory'))
+            self._presence_diff('directory')
 
         if self._item1.is_blk() or self._item2.is_blk():
-            changes.append(self._presence_diff('blkdev'))
+            self._presence_diff('blkdev')
 
         if self._item1.is_chr() or self._item2.is_chr():
-            changes.append(self._presence_diff('chrdev'))
+            self._presence_diff('chrdev')
 
         if self._item1.is_fifo() or self._item2.is_fifo():
-            changes.append(self._presence_diff('fifo'))
+            self._presence_diff('fifo')
 
         if not (self._item1.get('deleted') or self._item2.get('deleted')):
-            changes.append(self._owner_diff())
-            changes.append(self._mode_diff())
+            self._owner_diff()
+            self._mode_diff()
+            self._time_diffs()
 
-        # filter out empty changes
-        self._changes = [ch for ch in changes if ch]
 
     def changes(self):
         return self._changes
 
     def __repr__(self):
-        if self.equal:
-            return 'equal'
-        return ' '.join(str for d, str in self._changes)
+        return (' '.join(self._changes.keys())) or 'equal'
 
-    def _equal(self, chunk_iterator1, chunk_iterator2):
+    def equal(self, content_only=False):
         # if both are deleted, there is nothing at path regardless of what was deleted
         if self._item1.get('deleted') and self._item2.get('deleted'):
             return True
 
-        attr_list = ['deleted', 'mode', 'target']
-        attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+        attr_list = ['deleted', 'target']
+        if not content_only:
+            attr_list += ['mode', 'ctime', 'mtime']
+            attr_list += ['uid', 'gid'] if self._numeric_ids else ['user', 'group']
+
         for attr in attr_list:
             if self._item1.get(attr) != self._item2.get(attr):
                 return False
 
         if 'mode' in self._item1:     # mode of item1 and item2 is equal
             if (self._item1.is_link() and 'target' in self._item1 and 'target' in self._item2
                 and self._item1.target != self._item2.target):
                 return False
 
         if 'chunks' in self._item1 and 'chunks' in self._item2:
-            return self._content_equal(chunk_iterator1, chunk_iterator2)
+            return self._content_equal()
 
         return True
 
     def _presence_diff(self, item_type):
         if not self._item1.get('deleted') and self._item2.get('deleted'):
-            chg = 'removed ' + item_type
-            return ({"type": chg}, chg)
+            self._changes[item_type] = DiffChange(f"removed {item_type}")
+            return True
         if self._item1.get('deleted') and not self._item2.get('deleted'):
-            chg = 'added ' + item_type
-            return ({"type": chg}, chg)
+            self._changes[item_type] = DiffChange(f"added {item_type}")
+            return True
 
     def _link_diff(self):
-        pd = self._presence_diff('link')
-        if pd is not None:
-            return pd
+        if self._presence_diff('link'):
+            return True
         if 'target' in self._item1 and 'target' in self._item2 and self._item1.target != self._item2.target:
-            return ({"type": 'changed link'}, 'changed link')
+            self._changes['link'] = DiffChange('changed link')
+            return True
 
     def _content_diff(self):
         if self._item1.get('deleted'):
             sz = self._item2.get_size()
-            return ({"type": "added", "size": sz}, 'added {:>13}'.format(format_file_size(sz)))
+            self._changes['content'] = DiffChange("added", {"added": sz, "removed": 0})
+            return True
         if self._item2.get('deleted'):
             sz = self._item1.get_size()
-            return ({"type": "removed", "size": sz}, 'removed {:>11}'.format(format_file_size(sz)))
+            self._changes['content'] = DiffChange("removed", {"added": 0, "removed": sz})
+            return True
         if not self._can_compare_chunk_ids:
-            return ({"type": "modified"}, "modified")
+            self._changes['content'] = DiffChange("modified")
+            return True
         chunk_ids1 = {c.id for c in self._item1.chunks}
         chunk_ids2 = {c.id for c in self._item2.chunks}
         added_ids = chunk_ids2 - chunk_ids1
         removed_ids = chunk_ids1 - chunk_ids2
         added = self._item2.get_size(consider_ids=added_ids)
         removed = self._item1.get_size(consider_ids=removed_ids)
-        return ({"type": "modified", "added": added, "removed": removed},
-            '{:>9} {:>9}'.format(format_file_size(added, precision=1, sign=True),
-            format_file_size(-removed, precision=1, sign=True)))
+        self._changes['content'] = DiffChange("modified", {"added": added, "removed": removed})
+        return True
+
 
     def _owner_diff(self):
         u_attr, g_attr = ('uid', 'gid') if self._numeric_ids else ('user', 'group')
         u1, g1 = self._item1.get(u_attr), self._item1.get(g_attr)
         u2, g2 = self._item2.get(u_attr), self._item2.get(g_attr)
-        if (u1, g1) != (u2, g2):
-            return ({"type": "owner", "old_user": u1, "old_group": g1, "new_user": u2, "new_group": g2},
-                    '[{}:{} -> {}:{}]'.format(u1, g1, u2, g2))
+        if (u1, g1) == (u2, g2):
+            return False
+        self._changes['owner'] = DiffChange("changed owner", {"item1": (u1, g1), "item2": (u2, g2)})
+        if u1 != u2:
+            self._changes['user'] = DiffChange("changed user", {"item1": u1, "item2": u2})
+        if g1 != g2:
+            self._changes['group'] = DiffChange("changed group", {"item1": g1, "item2": g2})
+        return True
 
     def _mode_diff(self):
         if 'mode' in self._item1 and 'mode' in self._item2 and self._item1.mode != self._item2.mode:
             mode1 = stat.filemode(self._item1.mode)
             mode2 = stat.filemode(self._item2.mode)
-            return ({"type": "mode", "old_mode": mode1, "new_mode": mode2}, '[{} -> {}]'.format(mode1, mode2))
+            self._changes['mode'] = DiffChange("changed mode", {"item1": mode1, "item2": mode2})
+            if mode1[0] != mode2[0]:
+                self._changes['type'] = DiffChange("changed type", {"item1": mode1[0], "item2": mode2[0]})
+
+    def _time_diffs(self):
+        attrs = ["ctime", "mtime"]
+        for attr in attrs:
+            if attr in self._item1 and attr in self._item2 and self._item1.get(attr) != self._item2.get(attr):
+                ts1 = OutputTimestamp(safe_timestamp(self._item1.get(attr)))
+                ts2 = OutputTimestamp(safe_timestamp(self._item2.get(attr)))
+                self._changes[attr] = DiffChange(attr, {"item1": ts1, "item2": ts2},)
+        return True
+
+    def content(self):
+        return self._changes.get('content')
+
+    def ctime(self):
+        return self._changes.get('ctime')
+
+    def mtime(self):
+        return self._changes.get('mtime')
+
+    def mode(self):
+        return self._changes.get('mode')
+
+    def type(self):
+        return self._changes.get('type')
+
+    def owner(self):
+        return self._changes.get('owner')
+
+    def user(self):
+        return self._changes.get('user')
+
+    def group(self):
+        return self._changes.get('group')
 
-    def _content_equal(self, chunk_iterator1, chunk_iterator2):
+    def _content_equal(self):
         if self._can_compare_chunk_ids:
             return self._item1.chunks == self._item2.chunks
         if self._item1.get_size() != self._item2.get_size():
             return False
-        return chunks_contents_equal(chunk_iterator1, chunk_iterator2)
+        return chunks_contents_equal(self._chunk_1, self._chunk_2)
 
 
 def chunks_contents_equal(chunks_a, chunks_b):
     """
     Compare chunk content and return True if they are identical.
 
     The chunks must be given as chunk iterators (like returned by :meth:`.DownloadPipeline.fetch_many`).
```

### Comparing `borgbackup-2.0.0b5/src/borg/locking.py` & `borgbackup-2.0.0b6/src/borg/locking.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/manifest.py` & `borgbackup-2.0.0b6/src/borg/manifest.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import enum
 import os
 import os.path
 import re
 from collections import abc, namedtuple
 from datetime import datetime, timedelta, timezone
 from operator import attrgetter
-from typing import Sequence, FrozenSet
+from collections.abc import Sequence
 
 from .logger import create_logger
 
 logger = create_logger()
 
 from .constants import *  # NOQA
 from .helpers.datastruct import StableDict
@@ -35,21 +35,27 @@
 
 
 def filter_archives_by_date(archives, older=None, newer=None, oldest=None, newest=None):
     def get_first_and_last_archive_ts(archives_list):
         timestamps = [x.ts for x in archives_list]
         return min(timestamps), max(timestamps)
 
+    if not archives:
+        return archives
+
     now = archive_ts_now()
     earliest_ts, latest_ts = get_first_and_last_archive_ts(archives)
 
     until_ts = calculate_relative_offset(older, now, earlier=True) if older is not None else latest_ts
     from_ts = calculate_relative_offset(newer, now, earlier=True) if newer is not None else earliest_ts
     archives = [x for x in archives if from_ts <= x.ts <= until_ts]
 
+    if not archives:
+        return archives
+
     earliest_ts, latest_ts = get_first_and_last_archive_ts(archives)
     if oldest:
         until_ts = calculate_relative_offset(oldest, earliest_ts, earlier=False)
         archives = [x for x in archives if x.ts <= until_ts]
     if newest:
         from_ts = calculate_relative_offset(newest, latest_ts, earlier=True)
         archives = [x for x in archives if x.ts >= from_ts]
@@ -132,15 +138,15 @@
             raise TypeError("sort_by must be a sequence of str")
 
         archives = self.values()
         regex = get_regex_from_pattern(match or "re:.*")
         regex = re.compile(regex + match_end)
         archives = [x for x in archives if regex.match(x.name) is not None]
 
-        if any([oldest, newest, older, newer]) and len(archives) > 0:
+        if any([oldest, newest, older, newer]):
             archives = filter_archives_by_date(archives, oldest=oldest, newest=newest, newer=newer, older=older)
         if not consider_checkpoints:
             archives = [x for x in archives if ".checkpoint" not in x.name]
         for sortkey in reversed(sort_by):
             archives.sort(key=attrgetter(sortkey))
         if first:
             archives = archives[:first]
@@ -207,15 +213,15 @@
         WRITE = "write"
         # The DELETE operation is for all operations (like archive deletion) that need a 100% correct reference
         # count and the need to be able to find all (directly and indirectly) referenced chunks of a given archive.
         DELETE = "delete"
 
     NO_OPERATION_CHECK: Sequence[Operation] = tuple()
 
-    SUPPORTED_REPO_FEATURES: FrozenSet[str] = frozenset([])
+    SUPPORTED_REPO_FEATURES: frozenset[str] = frozenset([])
 
     MANIFEST_ID = b"\0" * 32
 
     def __init__(self, key, repository, item_keys=None, ro_cls=RepoObj):
         self.archives = Archives()
         self.config = {}
         self.key = key
```

### Comparing `borgbackup-2.0.0b5/src/borg/paperkey.html` & `borgbackup-2.0.0b6/src/borg/paperkey.html`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/patterns.py` & `borgbackup-2.0.0b6/src/borg/patterns.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/platform/__init__.py` & `borgbackup-2.0.0b6/src/borg/platform/__init__.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/platform/base.py` & `borgbackup-2.0.0b6/src/borg/platform/base.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/platform/darwin.c` & `borgbackup-2.0.0b6/src/borg/platform/darwin.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-Wall",
@@ -23,16 +23,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -92,16 +92,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -217,15 +221,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -256,15 +260,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -5034,15 +5038,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_8platform_6darwin___pyx_scope_struct_1_getxattr *__pyx_freelist_4borg_8platform_6darwin___pyx_scope_struct_1_getxattr[8];
 static int __pyx_freecount_4borg_8platform_6darwin___pyx_scope_struct_1_getxattr = 0;
 
@@ -5152,15 +5156,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_8platform_6darwin___pyx_scope_struct_2_setxattr *__pyx_freelist_4borg_8platform_6darwin___pyx_scope_struct_2_setxattr[8];
 static int __pyx_freecount_4borg_8platform_6darwin___pyx_scope_struct_2_setxattr = 0;
 
@@ -5270,15 +5274,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
@@ -6860,15 +6864,18 @@
 #endif
 #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
     0,
 #endif
 };
 static int __pyx_CyFunction_init(void) {
     __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
     if (unlikely(__pyx_CyFunctionType == NULL)) {
         return -1;
@@ -8302,15 +8309,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -8498,15 +8505,15 @@
                         } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
                             return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -8770,15 +8777,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/platform/darwin.pyx` & `borgbackup-2.0.0b6/src/borg/platform/darwin.pyx`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/platform/freebsd.c` & `borgbackup-2.0.0b6/src/borg/platform/freebsd.c`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-Wall",
@@ -23,16 +23,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -92,16 +92,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -217,15 +221,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -256,15 +260,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -979,78 +983,78 @@
 /*--- Type declarations ---*/
 struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr;
 struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr;
 struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr;
 struct __pyx_opt_args_4borg_8platform_7freebsd__get_acl;
 struct __pyx_opt_args_4borg_8platform_7freebsd__set_acl;
 
-/* "borg/platform/freebsd.pyx":108
+/* "borg/platform/freebsd.pyx":126
  * 
  * 
  * cdef _get_acl(p, type, item, attribute, flags, fd=None):             # <<<<<<<<<<<<<<
  *     cdef acl_t acl = NULL
  *     cdef char *text = NULL
  */
 struct __pyx_opt_args_4borg_8platform_7freebsd__get_acl {
   int __pyx_n;
   PyObject *fd;
 };
 
-/* "borg/platform/freebsd.pyx":144
+/* "borg/platform/freebsd.pyx":162
  * 
  * 
  * cdef _set_acl(path, type, item, attribute, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     cdef acl_t acl = NULL
  *     text = item.get(attribute)
  */
 struct __pyx_opt_args_4borg_8platform_7freebsd__set_acl {
   int __pyx_n;
   PyObject *numeric_ids;
   PyObject *fd;
 };
 
-/* "borg/platform/freebsd.pyx":53
+/* "borg/platform/freebsd.pyx":75
  * 
  * 
  * def listxattr(path, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, buf, size):
+ *         if isinstance(path, int):
  */
 struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr {
   PyObject_HEAD
   PyObject *__pyx_v_follow_symlinks;
-  int __pyx_v_ns;
+  PyObject *__pyx_v_ns_id;
 };
 
 
-/* "borg/platform/freebsd.pyx":69
+/* "borg/platform/freebsd.pyx":91
  * 
  * 
  * def getxattr(path, name, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, buf, size):
+ *         if isinstance(path, int):
  */
 struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr {
   PyObject_HEAD
   PyObject *__pyx_v_follow_symlinks;
-  int __pyx_v_ns;
+  PyObject *__pyx_v_ns_id;
 };
 
 
-/* "borg/platform/freebsd.pyx":89
+/* "borg/platform/freebsd.pyx":107
  * 
  * 
  * def setxattr(path, name, value, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, value, size):
+ *         if isinstance(path, int):
  */
 struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr {
   PyObject_HEAD
   PyObject *__pyx_v_follow_symlinks;
-  int __pyx_v_ns;
+  PyObject *__pyx_v_ns_id;
 };
 
 
 /* --- Runtime support code (head) --- */
 /* Refnanny.proto */
 #ifndef CYTHON_REFNANNY
   #define CYTHON_REFNANNY 0
@@ -1110,39 +1114,61 @@
 #define __Pyx_DECREF_SET(r, v) do {\
         PyObject *tmp = (PyObject *) r;\
         r = v; __Pyx_DECREF(tmp);\
     } while (0)
 #define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
 #define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)
 
+/* PyObjectGetAttrStr.proto */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
+#else
+#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
+#endif
+
+/* GetBuiltinName.proto */
+static PyObject *__Pyx_GetBuiltinName(PyObject *name);
+
+/* RaiseArgTupleInvalid.proto */
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
+
 /* RaiseDoubleKeywords.proto */
 static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);
 
 /* ParseKeywords.proto */
 static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
     PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
     const char* function_name);
 
-/* RaiseArgTupleInvalid.proto */
-static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
-    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);
+/* PyObjectCall.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+#else
+#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#endif
+
+/* RaiseTooManyValuesToUnpack.proto */
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
+
+/* RaiseNeedMoreValuesToUnpack.proto */
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
+
+/* IterFinish.proto */
+static CYTHON_INLINE int __Pyx_IterFinish(void);
+
+/* UnpackItemEndCheck.proto */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
 
 /* None.proto */
 static CYTHON_INLINE void __Pyx_RaiseClosureNameError(const char *varname);
 
 /* FetchCommonType.proto */
 static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
 
-/* PyObjectGetAttrStr.proto */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
-#else
-#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
-#endif
-
 /* CythonFunctionShared.proto */
 #define __Pyx_CyFunction_USED 1
 #define __Pyx_CYFUNCTION_STATICMETHOD  0x01
 #define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
 #define __Pyx_CYFUNCTION_CCLASS        0x04
 #define __Pyx_CyFunction_GetClosure(f)\
     (((__pyx_CyFunctionObject *) (f))->func_closure)
@@ -1195,17 +1221,14 @@
 /* CythonFunction.proto */
 static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
                                       int flags, PyObject* qualname,
                                       PyObject *closure,
                                       PyObject *module, PyObject *globals,
                                       PyObject* code);
 
-/* GetBuiltinName.proto */
-static PyObject *__Pyx_GetBuiltinName(PyObject *name);
-
 /* PyDictVersioning.proto */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 #define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
 #define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
 #define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
     (version_var) = __PYX_GET_DICT_VERSION(dict);\
     (cache_var) = (value);
@@ -1245,14 +1268,43 @@
 static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
 #else
 #define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 #define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
 static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
+/* GetItemInt.proto */
+#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
+    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
+    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
+    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
+               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
+#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
+    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
+    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
+    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
+    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
+    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
+    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
+                                                     int is_list, int wraparound, int boundscheck);
+
+/* ObjectGetItem.proto */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
+#else
+#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
+#endif
+
 /* PyFunctionFastCall.proto */
 #if CYTHON_FAST_PYCALL
 #define __Pyx_PyFunction_FastCall(func, args, nargs)\
     __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
 #if 1 || PY_VERSION_HEX < 0x030600B1
 static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
 #else
@@ -1283,33 +1335,14 @@
 /* PyCFunctionFastCall.proto */
 #if CYTHON_FAST_PYCCALL
 static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
 #else
 #define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
 #endif
 
-/* PyObjectCall.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
-#else
-#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
-#endif
-
-/* RaiseTooManyValuesToUnpack.proto */
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
-
-/* RaiseNeedMoreValuesToUnpack.proto */
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
-
-/* IterFinish.proto */
-static CYTHON_INLINE int __Pyx_IterFinish(void);
-
-/* UnpackItemEndCheck.proto */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
-
 /* SliceObject.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetSlice(
         PyObject* obj, Py_ssize_t cstart, Py_ssize_t cstop,
         PyObject** py_start, PyObject** py_stop, PyObject** py_slice,
         int has_cstart, int has_cstop, int wraparound);
 
 /* PyObjectCall2Args.proto */
@@ -1336,25 +1369,49 @@
     }
     return PyList_Append(list, x);
 }
 #else
 #define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
 #endif
 
+/* GetTopmostException.proto */
+#if CYTHON_USE_EXC_INFO_STACK
+static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
+#endif
+
 /* PyThreadStateGet.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
 #define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
 #define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
 #else
 #define __Pyx_PyThreadState_declare
 #define __Pyx_PyThreadState_assign
 #define __Pyx_PyErr_Occurred()  PyErr_Occurred()
 #endif
 
+/* SaveResetException.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
+#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
+static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
+#else
+#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
+#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
+#endif
+
+/* PyErrExceptionMatches.proto */
+#if CYTHON_FAST_THREAD_STATE
+#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
+#else
+#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
+#endif
+
 /* PyErrFetchRestore.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
 #define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
 #define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
 #define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
 #define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
@@ -1388,30 +1445,14 @@
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
 static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #else
 static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
 #endif
 
-/* GetTopmostException.proto */
-#if CYTHON_USE_EXC_INFO_STACK
-static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
-#endif
-
-/* SaveResetException.proto */
-#if CYTHON_FAST_THREAD_STATE
-#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
-#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
-static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
-#else
-#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
-#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
-#endif
-
 /* ListAppend.proto */
 #if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
 static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
     PyListObject* L = (PyListObject*) list;
     Py_ssize_t len = Py_SIZE(list);
     if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
         Py_INCREF(x);
@@ -1421,36 +1462,14 @@
     }
     return PyList_Append(list, x);
 }
 #else
 #define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
 #endif
 
-/* GetItemInt.proto */
-#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
-    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
-               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
-#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
-    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck);
-#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
-    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck);
-static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
-                                                     int is_list, int wraparound, int boundscheck);
-
 /* StringJoin.proto */
 #if PY_MAJOR_VERSION < 3
 #define __Pyx_PyString_Join __Pyx_PyBytes_Join
 #define __Pyx_PyBaseString_Join(s, v) (PyUnicode_CheckExact(s) ? PyUnicode_Join(s, v) : __Pyx_PyBytes_Join(s, v))
 #else
 #define __Pyx_PyString_Join PyUnicode_Join
 #define __Pyx_PyBaseString_Join PyUnicode_Join
@@ -1508,24 +1527,24 @@
                                int py_line, const char *filename);
 
 /* GCCDiagnostics.proto */
 #if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
 #define __Pyx_HAS_GCC_DIAGNOSTIC
 #endif
 
+/* CIntToPy.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
+
 /* CIntFromPy.proto */
 static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *);
 
 /* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
-
-/* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
 
 /* FastTypeChecks.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
@@ -1555,83 +1574,95 @@
 static PyObject *__pyx_f_4borg_8platform_7freebsd__set_acl(PyObject *, PyObject *, PyObject *, PyObject *, struct __pyx_opt_args_4borg_8platform_7freebsd__set_acl *__pyx_optional_args); /*proto*/
 static PyObject *__pyx_f_4borg_8platform_7freebsd__nfs4_use_stored_uid_gid(PyObject *); /*proto*/
 #define __Pyx_MODULE_NAME "borg.platform.freebsd"
 extern int __pyx_module_is_main_borg__platform__freebsd;
 int __pyx_module_is_main_borg__platform__freebsd = 0;
 
 /* Implementation of 'borg.platform.freebsd' */
+static PyObject *__pyx_builtin_KeyError;
+static const char __pyx_k_[] = ".";
 static const char __pyx_k_n[] = "n";
-static const char __pyx_k__7[] = "\n";
-static const char __pyx_k__8[] = ":";
+static const char __pyx_k__9[] = "\n";
 static const char __pyx_k_fd[] = "fd";
 static const char __pyx_k_ns[] = "ns";
 static const char __pyx_k_os[] = "os";
 static const char __pyx_k_st[] = "st";
+static const char __pyx_k__10[] = ":";
 static const char __pyx_k_buf[] = "buf";
 static const char __pyx_k_get[] = "get";
 static const char __pyx_k_ret[] = "ret";
 static const char __pyx_k_func[] = "func";
 static const char __pyx_k_item[] = "item";
 static const char __pyx_k_join[] = "join";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_name[] = "name";
 static const char __pyx_k_path[] = "path";
 static const char __pyx_k_size[] = "size";
 static const char __pyx_k_test[] = "__test__";
-static const char __pyx_k_user[] = "user.";
+static const char __pyx_k_user[] = "user";
 static const char __pyx_k_flags[] = "flags";
 static const char __pyx_k_group[] = "group:";
+static const char __pyx_k_ns_id[] = "ns_id";
 static const char __pyx_k_posix[] = "posix";
 static const char __pyx_k_split[] = "split";
 static const char __pyx_k_value[] = "value";
 static const char __pyx_k_xattr[] = "xattr";
 static const char __pyx_k_1_2_05[] = "1.2_05";
 static const char __pyx_k_import[] = "__import__";
 static const char __pyx_k_name_2[] = "__name__";
-static const char __pyx_k_prefix[] = "prefix";
 static const char __pyx_k_user_2[] = "user:";
 static const char __pyx_k_acl_get[] = "acl_get";
 static const char __pyx_k_acl_set[] = "acl_set";
 static const char __pyx_k_helpers[] = "helpers";
+static const char __pyx_k_ns_name[] = "ns_name";
+static const char __pyx_k_KeyError[] = "KeyError";
 static const char __pyx_k_acl_nfs4[] = "acl_nfs4";
 static const char __pyx_k_fsencode[] = "fsencode";
 static const char __pyx_k_getxattr[] = "getxattr";
 static const char __pyx_k_setxattr[] = "setxattr";
+static const char __pyx_k_split_ns[] = "split_ns";
+static const char __pyx_k_NS_ID_MAP[] = "NS_ID_MAP";
 static const char __pyx_k_listxattr[] = "listxattr";
 static const char __pyx_k_acl_access[] = "acl_access";
+static const char __pyx_k_default_ns[] = "default_ns";
 static const char __pyx_k_startswith[] = "startswith";
 static const char __pyx_k_API_VERSION[] = "API_VERSION";
 static const char __pyx_k_acl_default[] = "acl_default";
 static const char __pyx_k_numeric_ids[] = "numeric_ids";
 static const char __pyx_k_safe_decode[] = "safe_decode";
 static const char __pyx_k_safe_encode[] = "safe_encode";
+static const char __pyx_k_ns_name_tuple[] = "ns_name_tuple";
 static const char __pyx_k_split_lstring[] = "split_lstring";
 static const char __pyx_k_getxattr_inner[] = "_getxattr_inner";
 static const char __pyx_k_setxattr_inner[] = "_setxattr_inner";
 static const char __pyx_k_follow_symlinks[] = "follow_symlinks";
 static const char __pyx_k_listxattr_inner[] = "_listxattr_inner";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_getxattr_locals_func[] = "getxattr.<locals>.func";
 static const char __pyx_k_setxattr_locals_func[] = "setxattr.<locals>.func";
 static const char __pyx_k_borg_platform_freebsd[] = "borg.platform.freebsd";
 static const char __pyx_k_listxattr_locals_func[] = "listxattr.<locals>.func";
 static const char __pyx_k_posix_acl_use_stored_uid_gid[] = "posix_acl_use_stored_uid_gid";
 static const char __pyx_k_src_borg_platform_freebsd_pyx[] = "src/borg/platform/freebsd.pyx";
+static PyObject *__pyx_kp_b_;
 static PyObject *__pyx_kp_s_1_2_05;
 static PyObject *__pyx_n_s_API_VERSION;
-static PyObject *__pyx_kp_s__7;
-static PyObject *__pyx_kp_s__8;
+static PyObject *__pyx_n_s_KeyError;
+static PyObject *__pyx_n_s_NS_ID_MAP;
+static PyObject *__pyx_kp_s__10;
+static PyObject *__pyx_kp_s__9;
 static PyObject *__pyx_n_s_acl_access;
 static PyObject *__pyx_n_s_acl_default;
 static PyObject *__pyx_n_s_acl_get;
 static PyObject *__pyx_n_s_acl_nfs4;
 static PyObject *__pyx_n_s_acl_set;
 static PyObject *__pyx_n_s_borg_platform_freebsd;
 static PyObject *__pyx_n_s_buf;
 static PyObject *__pyx_n_s_cline_in_traceback;
+static PyObject *__pyx_n_s_default_ns;
 static PyObject *__pyx_n_s_fd;
 static PyObject *__pyx_n_s_flags;
 static PyObject *__pyx_n_s_follow_symlinks;
 static PyObject *__pyx_n_s_fsencode;
 static PyObject *__pyx_n_s_func;
 static PyObject *__pyx_n_s_get;
 static PyObject *__pyx_n_s_getxattr;
@@ -1646,81 +1677,334 @@
 static PyObject *__pyx_n_s_listxattr_inner;
 static PyObject *__pyx_n_s_listxattr_locals_func;
 static PyObject *__pyx_n_s_main;
 static PyObject *__pyx_n_s_n;
 static PyObject *__pyx_n_s_name;
 static PyObject *__pyx_n_s_name_2;
 static PyObject *__pyx_n_s_ns;
+static PyObject *__pyx_n_s_ns_id;
+static PyObject *__pyx_n_s_ns_name;
+static PyObject *__pyx_n_s_ns_name_tuple;
 static PyObject *__pyx_n_s_numeric_ids;
 static PyObject *__pyx_n_s_os;
 static PyObject *__pyx_n_s_path;
 static PyObject *__pyx_n_s_posix;
 static PyObject *__pyx_n_s_posix_acl_use_stored_uid_gid;
-static PyObject *__pyx_n_s_prefix;
 static PyObject *__pyx_n_s_ret;
 static PyObject *__pyx_n_s_safe_decode;
 static PyObject *__pyx_n_s_safe_encode;
 static PyObject *__pyx_n_s_setxattr;
 static PyObject *__pyx_n_s_setxattr_inner;
 static PyObject *__pyx_n_s_setxattr_locals_func;
 static PyObject *__pyx_n_s_size;
 static PyObject *__pyx_n_s_split;
 static PyObject *__pyx_n_s_split_lstring;
+static PyObject *__pyx_n_s_split_ns;
 static PyObject *__pyx_kp_s_src_borg_platform_freebsd_pyx;
 static PyObject *__pyx_n_s_st;
 static PyObject *__pyx_n_s_startswith;
 static PyObject *__pyx_n_s_test;
-static PyObject *__pyx_kp_b_user;
+static PyObject *__pyx_n_b_user;
 static PyObject *__pyx_kp_s_user_2;
 static PyObject *__pyx_n_s_value;
 static PyObject *__pyx_n_s_xattr;
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_split_ns(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_ns_name, PyObject *__pyx_v_default_ns); /* proto */
 static PyObject *__pyx_pf_4borg_8platform_7freebsd_9listxattr_func(PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_buf, PyObject *__pyx_v_size); /* proto */
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_listxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_follow_symlinks); /* proto */
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_2listxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_follow_symlinks); /* proto */
 static PyObject *__pyx_pf_4borg_8platform_7freebsd_8getxattr_func(PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_buf, PyObject *__pyx_v_size); /* proto */
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_2getxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_follow_symlinks); /* proto */
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_4getxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_follow_symlinks); /* proto */
 static PyObject *__pyx_pf_4borg_8platform_7freebsd_8setxattr_func(PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_value, PyObject *__pyx_v_size); /* proto */
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_4setxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_value, PyObject *__pyx_v_follow_symlinks); /* proto */
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_6acl_get(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item, CYTHON_UNUSED PyObject *__pyx_v_st, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_fd); /* proto */
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_8acl_set(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_fd); /* proto */
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_6setxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_value, PyObject *__pyx_v_follow_symlinks); /* proto */
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_8acl_get(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item, CYTHON_UNUSED PyObject *__pyx_v_st, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_fd); /* proto */
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_10acl_set(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_fd); /* proto */
 static PyObject *__pyx_tp_new_4borg_8platform_7freebsd___pyx_scope_struct__listxattr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_int_1;
 static PyObject *__pyx_int_2;
 static PyObject *__pyx_int_neg_1;
-static PyObject *__pyx_tuple_;
-static PyObject *__pyx_slice__9;
+static PyObject *__pyx_tuple__2;
 static PyObject *__pyx_tuple__3;
 static PyObject *__pyx_tuple__5;
-static PyObject *__pyx_tuple__10;
+static PyObject *__pyx_tuple__7;
+static PyObject *__pyx_slice__11;
 static PyObject *__pyx_tuple__12;
 static PyObject *__pyx_tuple__14;
 static PyObject *__pyx_tuple__16;
 static PyObject *__pyx_tuple__18;
-static PyObject *__pyx_codeobj__2;
+static PyObject *__pyx_tuple__20;
+static PyObject *__pyx_tuple__22;
 static PyObject *__pyx_codeobj__4;
 static PyObject *__pyx_codeobj__6;
-static PyObject *__pyx_codeobj__11;
+static PyObject *__pyx_codeobj__8;
 static PyObject *__pyx_codeobj__13;
 static PyObject *__pyx_codeobj__15;
 static PyObject *__pyx_codeobj__17;
 static PyObject *__pyx_codeobj__19;
+static PyObject *__pyx_codeobj__21;
+static PyObject *__pyx_codeobj__23;
 /* Late includes */
 
-/* "borg/platform/freebsd.pyx":53
+/* "borg/platform/freebsd.pyx":58
  * 
  * 
- * def listxattr(path, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+ * def split_ns(ns_name, default_ns):             # <<<<<<<<<<<<<<
+ *     # split ns_name (which is in the form of b"namespace.name") into namespace and name.
+ *     # if there is no namespace given in ns_name, default to default_ns.
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_1split_ns(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_1split_ns = {"split_ns", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_1split_ns, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_1split_ns(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_ns_name = 0;
+  PyObject *__pyx_v_default_ns = 0;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("split_ns (wrapper)", 0);
+  {
+    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ns_name,&__pyx_n_s_default_ns,0};
+    PyObject* values[2] = {0,0};
+    if (unlikely(__pyx_kwds)) {
+      Py_ssize_t kw_args;
+      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
+      switch (pos_args) {
+        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = PyDict_Size(__pyx_kwds);
+      switch (pos_args) {
+        case  0:
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ns_name)) != 0)) kw_args--;
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_default_ns)) != 0)) kw_args--;
+        else {
+          __Pyx_RaiseArgtupleInvalid("split_ns", 1, 2, 2, 1); __PYX_ERR(0, 58, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "split_ns") < 0)) __PYX_ERR(0, 58, __pyx_L3_error)
+      }
+    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+    }
+    __pyx_v_ns_name = values[0];
+    __pyx_v_default_ns = values[1];
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("split_ns", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 58, __pyx_L3_error)
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("borg.platform.freebsd.split_ns", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_split_ns(__pyx_self, __pyx_v_ns_name, __pyx_v_default_ns);
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_split_ns(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_ns_name, PyObject *__pyx_v_default_ns) {
+  PyObject *__pyx_v_ns_name_tuple = NULL;
+  PyObject *__pyx_v_ns = NULL;
+  PyObject *__pyx_v_name = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  Py_ssize_t __pyx_t_3;
+  int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *(*__pyx_t_6)(PyObject *);
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("split_ns", 0);
+
+  /* "borg/platform/freebsd.pyx":65
+ *     # we also need to deal with "unexpected" namespaces here, they could come
+ *     # from borg archives made on other operating systems.
+ *     ns_name_tuple = ns_name.split(b".", 1)             # <<<<<<<<<<<<<<
+ *     if len(ns_name_tuple) == 2:
+ *         # we have a namespace prefix in the given name
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_ns_name, __pyx_n_s_split); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_ns_name_tuple = __pyx_t_2;
+  __pyx_t_2 = 0;
+
+  /* "borg/platform/freebsd.pyx":66
+ *     # from borg archives made on other operating systems.
+ *     ns_name_tuple = ns_name.split(b".", 1)
+ *     if len(ns_name_tuple) == 2:             # <<<<<<<<<<<<<<
+ *         # we have a namespace prefix in the given name
+ *         ns, name = ns_name_tuple
+ */
+  __pyx_t_3 = PyObject_Length(__pyx_v_ns_name_tuple); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 66, __pyx_L1_error)
+  __pyx_t_4 = ((__pyx_t_3 == 2) != 0);
+  if (__pyx_t_4) {
+
+    /* "borg/platform/freebsd.pyx":68
+ *     if len(ns_name_tuple) == 2:
+ *         # we have a namespace prefix in the given name
+ *         ns, name = ns_name_tuple             # <<<<<<<<<<<<<<
+ *     else:
+ *         # no namespace given in ns_name (== no dot found), maybe data coming from an old borg archive.
+ */
+    if ((likely(PyTuple_CheckExact(__pyx_v_ns_name_tuple))) || (PyList_CheckExact(__pyx_v_ns_name_tuple))) {
+      PyObject* sequence = __pyx_v_ns_name_tuple;
+      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
+      if (unlikely(size != 2)) {
+        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
+        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
+        __PYX_ERR(0, 68, __pyx_L1_error)
+      }
+      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+      if (likely(PyTuple_CheckExact(sequence))) {
+        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
+        __pyx_t_1 = PyTuple_GET_ITEM(sequence, 1); 
+      } else {
+        __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
+        __pyx_t_1 = PyList_GET_ITEM(sequence, 1); 
+      }
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_1);
+      #else
+      __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_1 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      #endif
+    } else {
+      Py_ssize_t index = -1;
+      __pyx_t_5 = PyObject_GetIter(__pyx_v_ns_name_tuple); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 68, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = Py_TYPE(__pyx_t_5)->tp_iternext;
+      index = 0; __pyx_t_2 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_2)) goto __pyx_L4_unpacking_failed;
+      __Pyx_GOTREF(__pyx_t_2);
+      index = 1; __pyx_t_1 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_1)) goto __pyx_L4_unpacking_failed;
+      __Pyx_GOTREF(__pyx_t_1);
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_5), 2) < 0) __PYX_ERR(0, 68, __pyx_L1_error)
+      __pyx_t_6 = NULL;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      goto __pyx_L5_unpacking_done;
+      __pyx_L4_unpacking_failed:;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_6 = NULL;
+      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
+      __PYX_ERR(0, 68, __pyx_L1_error)
+      __pyx_L5_unpacking_done:;
+    }
+    __pyx_v_ns = __pyx_t_2;
+    __pyx_t_2 = 0;
+    __pyx_v_name = __pyx_t_1;
+    __pyx_t_1 = 0;
+
+    /* "borg/platform/freebsd.pyx":66
+ *     # from borg archives made on other operating systems.
+ *     ns_name_tuple = ns_name.split(b".", 1)
+ *     if len(ns_name_tuple) == 2:             # <<<<<<<<<<<<<<
+ *         # we have a namespace prefix in the given name
+ *         ns, name = ns_name_tuple
+ */
+    goto __pyx_L3;
+  }
+
+  /* "borg/platform/freebsd.pyx":71
+ *     else:
+ *         # no namespace given in ns_name (== no dot found), maybe data coming from an old borg archive.
+ *         ns, name = default_ns, ns_name             # <<<<<<<<<<<<<<
+ *     return ns, name
  * 
  */
+  /*else*/ {
+    __pyx_t_1 = __pyx_v_default_ns;
+    __Pyx_INCREF(__pyx_t_1);
+    __pyx_t_2 = __pyx_v_ns_name;
+    __Pyx_INCREF(__pyx_t_2);
+    __pyx_v_ns = __pyx_t_1;
+    __pyx_t_1 = 0;
+    __pyx_v_name = __pyx_t_2;
+    __pyx_t_2 = 0;
+  }
+  __pyx_L3:;
+
+  /* "borg/platform/freebsd.pyx":72
+ *         # no namespace given in ns_name (== no dot found), maybe data coming from an old borg archive.
+ *         ns, name = default_ns, ns_name
+ *     return ns, name             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 72, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_INCREF(__pyx_v_ns);
+  __Pyx_GIVEREF(__pyx_v_ns);
+  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_ns);
+  __Pyx_INCREF(__pyx_v_name);
+  __Pyx_GIVEREF(__pyx_v_name);
+  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_name);
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
+  goto __pyx_L0;
+
+  /* "borg/platform/freebsd.pyx":58
+ * 
+ * 
+ * def split_ns(ns_name, default_ns):             # <<<<<<<<<<<<<<
+ *     # split ns_name (which is in the form of b"namespace.name") into namespace and name.
+ *     # if there is no namespace given in ns_name, default to default_ns.
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("borg.platform.freebsd.split_ns", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_ns_name_tuple);
+  __Pyx_XDECREF(__pyx_v_ns);
+  __Pyx_XDECREF(__pyx_v_name);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "borg/platform/freebsd.pyx":75
+ * 
+ * 
+ * def listxattr(path, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
+ *     def func(path, buf, size):
+ *         if isinstance(path, int):
+ */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_1listxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_1listxattr = {"listxattr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_1listxattr, METH_VARARGS|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_1listxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_3listxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_3listxattr = {"listxattr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_3listxattr, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_3listxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_path = 0;
   PyObject *__pyx_v_follow_symlinks = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -1746,45 +2030,45 @@
       }
       if (kw_args == 1) {
         const Py_ssize_t index = 1;
         PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
         if (value) { values[index] = value; kw_args--; }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "listxattr") < 0)) __PYX_ERR(0, 53, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "listxattr") < 0)) __PYX_ERR(0, 75, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_path = values[0];
     __pyx_v_follow_symlinks = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("listxattr", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 53, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("listxattr", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 75, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.platform.freebsd.listxattr", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_listxattr(__pyx_self, __pyx_v_path, __pyx_v_follow_symlinks);
+  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_2listxattr(__pyx_self, __pyx_v_path, __pyx_v_follow_symlinks);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":56
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+/* "borg/platform/freebsd.pyx":76
  * 
+ * def listxattr(path, *, follow_symlinks=False):
  *     def func(path, buf, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_list_fd(path, ns, <char *> buf, size)
+ *             return c_extattr_list_fd(path, ns_id, <char *> buf, size)
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_4borg_8platform_7freebsd_9listxattr_1func(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_9listxattr_1func = {"func", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_9listxattr_1func, METH_VARARGS|METH_KEYWORDS, 0};
 static PyObject *__pyx_pw_4borg_8platform_7freebsd_9listxattr_1func(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_path = 0;
@@ -1817,40 +2101,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("func", 1, 3, 3, 1); __PYX_ERR(0, 56, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("func", 1, 3, 3, 1); __PYX_ERR(0, 76, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_size)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("func", 1, 3, 3, 2); __PYX_ERR(0, 56, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("func", 1, 3, 3, 2); __PYX_ERR(0, 76, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "func") < 0)) __PYX_ERR(0, 56, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "func") < 0)) __PYX_ERR(0, 76, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_path = values[0];
     __pyx_v_buf = values[1];
     __pyx_v_size = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("func", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 56, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("func", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 76, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.platform.freebsd.listxattr.func", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8platform_7freebsd_9listxattr_func(__pyx_self, __pyx_v_path, __pyx_v_buf, __pyx_v_size);
 
@@ -1863,448 +2147,470 @@
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *__pyx_cur_scope;
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *__pyx_outer_scope;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
-  char *__pyx_t_4;
-  size_t __pyx_t_5;
-  PyObject *__pyx_t_6 = NULL;
-  char const *__pyx_t_7;
+  int __pyx_t_4;
+  char *__pyx_t_5;
+  size_t __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
   char const *__pyx_t_8;
+  char const *__pyx_t_9;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("func", 0);
   __pyx_outer_scope = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *) __Pyx_CyFunction_GetClosure(__pyx_self);
   __pyx_cur_scope = __pyx_outer_scope;
 
-  /* "borg/platform/freebsd.pyx":57
- * 
+  /* "borg/platform/freebsd.pyx":77
+ * def listxattr(path, *, follow_symlinks=False):
  *     def func(path, buf, size):
  *         if isinstance(path, int):             # <<<<<<<<<<<<<<
- *             return c_extattr_list_fd(path, ns, <char *> buf, size)
+ *             return c_extattr_list_fd(path, ns_id, <char *> buf, size)
  *         else:
  */
   __pyx_t_1 = PyInt_Check(__pyx_v_path); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/platform/freebsd.pyx":58
+    /* "borg/platform/freebsd.pyx":78
  *     def func(path, buf, size):
  *         if isinstance(path, int):
- *             return c_extattr_list_fd(path, ns, <char *> buf, size)             # <<<<<<<<<<<<<<
+ *             return c_extattr_list_fd(path, ns_id, <char *> buf, size)             # <<<<<<<<<<<<<<
  *         else:
  *             if follow_symlinks:
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_path); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 58, __pyx_L1_error)
-    __pyx_t_4 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 58, __pyx_L1_error)
-    __pyx_t_5 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_5 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 58, __pyx_L1_error)
-    __pyx_t_6 = PyInt_FromSsize_t(extattr_list_fd(__pyx_t_3, __pyx_cur_scope->__pyx_v_ns, ((char *)__pyx_t_4), __pyx_t_5)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 58, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __pyx_r = __pyx_t_6;
-    __pyx_t_6 = 0;
+    __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_path); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 78, __pyx_L1_error)
+    if (unlikely(!__pyx_cur_scope->__pyx_v_ns_id)) { __Pyx_RaiseClosureNameError("ns_id"); __PYX_ERR(0, 78, __pyx_L1_error) }
+    __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_cur_scope->__pyx_v_ns_id); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 78, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 78, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 78, __pyx_L1_error)
+    __pyx_t_7 = PyInt_FromSsize_t(extattr_list_fd(__pyx_t_3, __pyx_t_4, ((char *)__pyx_t_5), __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 78, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_7);
+    __pyx_r = __pyx_t_7;
+    __pyx_t_7 = 0;
     goto __pyx_L0;
 
-    /* "borg/platform/freebsd.pyx":57
- * 
+    /* "borg/platform/freebsd.pyx":77
+ * def listxattr(path, *, follow_symlinks=False):
  *     def func(path, buf, size):
  *         if isinstance(path, int):             # <<<<<<<<<<<<<<
- *             return c_extattr_list_fd(path, ns, <char *> buf, size)
+ *             return c_extattr_list_fd(path, ns_id, <char *> buf, size)
  *         else:
  */
   }
 
-  /* "borg/platform/freebsd.pyx":60
- *             return c_extattr_list_fd(path, ns, <char *> buf, size)
+  /* "borg/platform/freebsd.pyx":80
+ *             return c_extattr_list_fd(path, ns_id, <char *> buf, size)
  *         else:
  *             if follow_symlinks:             # <<<<<<<<<<<<<<
- *                 return c_extattr_list_file(path, ns, <char *> buf, size)
+ *                 return c_extattr_list_file(path, ns_id, <char *> buf, size)
  *             else:
  */
   /*else*/ {
-    if (unlikely(!__pyx_cur_scope->__pyx_v_follow_symlinks)) { __Pyx_RaiseClosureNameError("follow_symlinks"); __PYX_ERR(0, 60, __pyx_L1_error) }
-    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_cur_scope->__pyx_v_follow_symlinks); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 60, __pyx_L1_error)
+    if (unlikely(!__pyx_cur_scope->__pyx_v_follow_symlinks)) { __Pyx_RaiseClosureNameError("follow_symlinks"); __PYX_ERR(0, 80, __pyx_L1_error) }
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_cur_scope->__pyx_v_follow_symlinks); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 80, __pyx_L1_error)
     if (__pyx_t_2) {
 
-      /* "borg/platform/freebsd.pyx":61
+      /* "borg/platform/freebsd.pyx":81
  *         else:
  *             if follow_symlinks:
- *                 return c_extattr_list_file(path, ns, <char *> buf, size)             # <<<<<<<<<<<<<<
+ *                 return c_extattr_list_file(path, ns_id, <char *> buf, size)             # <<<<<<<<<<<<<<
  *             else:
- *                 return c_extattr_list_link(path, ns, <char *> buf, size)
+ *                 return c_extattr_list_link(path, ns_id, <char *> buf, size)
  */
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_7 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(0, 61, __pyx_L1_error)
-      __pyx_t_4 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 61, __pyx_L1_error)
-      __pyx_t_5 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_5 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 61, __pyx_L1_error)
-      __pyx_t_6 = PyInt_FromSsize_t(extattr_list_file(__pyx_t_7, __pyx_cur_scope->__pyx_v_ns, ((char *)__pyx_t_4), __pyx_t_5)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 61, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      __pyx_r = __pyx_t_6;
-      __pyx_t_6 = 0;
+      __pyx_t_8 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 81, __pyx_L1_error)
+      if (unlikely(!__pyx_cur_scope->__pyx_v_ns_id)) { __Pyx_RaiseClosureNameError("ns_id"); __PYX_ERR(0, 81, __pyx_L1_error) }
+      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_cur_scope->__pyx_v_ns_id); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 81, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 81, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 81, __pyx_L1_error)
+      __pyx_t_7 = PyInt_FromSsize_t(extattr_list_file(__pyx_t_8, __pyx_t_4, ((char *)__pyx_t_5), __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 81, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_r = __pyx_t_7;
+      __pyx_t_7 = 0;
       goto __pyx_L0;
 
-      /* "borg/platform/freebsd.pyx":60
- *             return c_extattr_list_fd(path, ns, <char *> buf, size)
+      /* "borg/platform/freebsd.pyx":80
+ *             return c_extattr_list_fd(path, ns_id, <char *> buf, size)
  *         else:
  *             if follow_symlinks:             # <<<<<<<<<<<<<<
- *                 return c_extattr_list_file(path, ns, <char *> buf, size)
+ *                 return c_extattr_list_file(path, ns_id, <char *> buf, size)
  *             else:
  */
     }
 
-    /* "borg/platform/freebsd.pyx":63
- *                 return c_extattr_list_file(path, ns, <char *> buf, size)
+    /* "borg/platform/freebsd.pyx":83
+ *                 return c_extattr_list_file(path, ns_id, <char *> buf, size)
  *             else:
- *                 return c_extattr_list_link(path, ns, <char *> buf, size)             # <<<<<<<<<<<<<<
+ *                 return c_extattr_list_link(path, ns_id, <char *> buf, size)             # <<<<<<<<<<<<<<
  * 
- *     n, buf = _listxattr_inner(func, path)
+ *     ns = b"user"
  */
     /*else*/ {
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_8 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 63, __pyx_L1_error)
-      __pyx_t_4 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 63, __pyx_L1_error)
-      __pyx_t_5 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_5 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 63, __pyx_L1_error)
-      __pyx_t_6 = PyInt_FromSsize_t(extattr_list_link(__pyx_t_8, __pyx_cur_scope->__pyx_v_ns, ((char *)__pyx_t_4), __pyx_t_5)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 63, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      __pyx_r = __pyx_t_6;
-      __pyx_t_6 = 0;
+      __pyx_t_9 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_9) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)
+      if (unlikely(!__pyx_cur_scope->__pyx_v_ns_id)) { __Pyx_RaiseClosureNameError("ns_id"); __PYX_ERR(0, 83, __pyx_L1_error) }
+      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_cur_scope->__pyx_v_ns_id); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)
+      __pyx_t_7 = PyInt_FromSsize_t(extattr_list_link(__pyx_t_9, __pyx_t_4, ((char *)__pyx_t_5), __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 83, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_r = __pyx_t_7;
+      __pyx_t_7 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "borg/platform/freebsd.pyx":56
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+  /* "borg/platform/freebsd.pyx":76
  * 
+ * def listxattr(path, *, follow_symlinks=False):
  *     def func(path, buf, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_list_fd(path, ns, <char *> buf, size)
+ *             return c_extattr_list_fd(path, ns_id, <char *> buf, size)
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_7);
   __Pyx_AddTraceback("borg.platform.freebsd.listxattr.func", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":53
+/* "borg/platform/freebsd.pyx":75
  * 
  * 
  * def listxattr(path, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, buf, size):
+ *         if isinstance(path, int):
  */
 
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_listxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_follow_symlinks) {
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_2listxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_follow_symlinks) {
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *__pyx_cur_scope;
-  PyObject *__pyx_v_prefix = NULL;
   PyObject *__pyx_v_func = 0;
+  PyObject *__pyx_v_ns = NULL;
   PyObject *__pyx_v_n = NULL;
   PyObject *__pyx_v_buf = NULL;
   PyObject *__pyx_7genexpr__pyx_v_name = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
+  PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   PyObject *(*__pyx_t_6)(PyObject *);
   PyObject *__pyx_t_7 = NULL;
   Py_ssize_t __pyx_t_8;
   PyObject *(*__pyx_t_9)(PyObject *);
   int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("listxattr", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *)__pyx_tp_new_4borg_8platform_7freebsd___pyx_scope_struct__listxattr(__pyx_ptype_4borg_8platform_7freebsd___pyx_scope_struct__listxattr, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 53, __pyx_L1_error)
+    __PYX_ERR(0, 75, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_v_follow_symlinks = __pyx_v_follow_symlinks;
   __Pyx_INCREF(__pyx_cur_scope->__pyx_v_follow_symlinks);
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_follow_symlinks);
 
-  /* "borg/platform/freebsd.pyx":54
+  /* "borg/platform/freebsd.pyx":76
  * 
  * def listxattr(path, *, follow_symlinks=False):
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'             # <<<<<<<<<<<<<<
+ *     def func(path, buf, size):             # <<<<<<<<<<<<<<
+ *         if isinstance(path, int):
+ *             return c_extattr_list_fd(path, ns_id, <char *> buf, size)
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8platform_7freebsd_9listxattr_1func, 0, __pyx_n_s_listxattr_locals_func, ((PyObject*)__pyx_cur_scope), __pyx_n_s_borg_platform_freebsd, __pyx_d, ((PyObject *)__pyx_codeobj__4)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_func = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "borg/platform/freebsd.pyx":85
+ *                 return c_extattr_list_link(path, ns_id, <char *> buf, size)
  * 
- *     def func(path, buf, size):
+ *     ns = b"user"             # <<<<<<<<<<<<<<
+ *     ns_id = NS_ID_MAP[ns]
+ *     n, buf = _listxattr_inner(func, path)
  */
-  __pyx_t_1 = EXTATTR_NAMESPACE_USER;
-  __pyx_t_2 = __pyx_kp_b_user;
-  __Pyx_INCREF(__pyx_t_2);
-  __pyx_cur_scope->__pyx_v_ns = __pyx_t_1;
-  __pyx_v_prefix = ((PyObject*)__pyx_t_2);
-  __pyx_t_2 = 0;
+  __Pyx_INCREF(__pyx_n_b_user);
+  __pyx_v_ns = __pyx_n_b_user;
 
-  /* "borg/platform/freebsd.pyx":56
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+  /* "borg/platform/freebsd.pyx":86
  * 
- *     def func(path, buf, size):             # <<<<<<<<<<<<<<
- *         if isinstance(path, int):
- *             return c_extattr_list_fd(path, ns, <char *> buf, size)
+ *     ns = b"user"
+ *     ns_id = NS_ID_MAP[ns]             # <<<<<<<<<<<<<<
+ *     n, buf = _listxattr_inner(func, path)
+ *     return [ns + b"." + name for name in split_lstring(buf[:n]) if name]
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8platform_7freebsd_9listxattr_1func, 0, __pyx_n_s_listxattr_locals_func, ((PyObject*)__pyx_cur_scope), __pyx_n_s_borg_platform_freebsd, __pyx_d, ((PyObject *)__pyx_codeobj__2)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 56, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_NS_ID_MAP); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 86, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_ns); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_v_func = __pyx_t_2;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_cur_scope->__pyx_v_ns_id = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "borg/platform/freebsd.pyx":65
- *                 return c_extattr_list_link(path, ns, <char *> buf, size)
- * 
+  /* "borg/platform/freebsd.pyx":87
+ *     ns = b"user"
+ *     ns_id = NS_ID_MAP[ns]
  *     n, buf = _listxattr_inner(func, path)             # <<<<<<<<<<<<<<
- *     return [prefix + name for name in split_lstring(buf[:n]) if name]
+ *     return [ns + b"." + name for name in split_lstring(buf[:n]) if name]
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_listxattr_inner); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 65, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = NULL;
-  __pyx_t_1 = 0;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_listxattr_inner); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 87, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = NULL;
+  __pyx_t_4 = 0;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_1 = 1;
+      __Pyx_DECREF_SET(__pyx_t_1, function);
+      __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
-  if (PyFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_func, __pyx_v_path};
-    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_1, 2+__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 65, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (PyFunction_Check(__pyx_t_1)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_func, __pyx_v_path};
+    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 87, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
-  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_func, __pyx_v_path};
-    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_1, 2+__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 65, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_func, __pyx_v_path};
+    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 87, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_2);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 65, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 87, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (__pyx_t_4) {
-      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
+    if (__pyx_t_3) {
+      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
     }
     __Pyx_INCREF(__pyx_v_func);
     __Pyx_GIVEREF(__pyx_v_func);
-    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_1, __pyx_v_func);
+    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_func);
     __Pyx_INCREF(__pyx_v_path);
     __Pyx_GIVEREF(__pyx_v_path);
-    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_1, __pyx_v_path);
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 65, __pyx_L1_error)
+    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_path);
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 87, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
     PyObject* sequence = __pyx_t_2;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 65, __pyx_L1_error)
+      __PYX_ERR(0, 87, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
-      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
+      __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
-      __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
+      __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
     }
-    __Pyx_INCREF(__pyx_t_3);
+    __Pyx_INCREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 65, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 65, __pyx_L1_error)
+    __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 87, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 87, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_4 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 65, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext;
-    index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_4); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
+    __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 87, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_4); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_6 = Py_TYPE(__pyx_t_3)->tp_iternext;
+    index = 0; __pyx_t_1 = __pyx_t_6(__pyx_t_3); if (unlikely(!__pyx_t_1)) goto __pyx_L3_unpacking_failed;
+    __Pyx_GOTREF(__pyx_t_1);
+    index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_3); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_5);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_4), 2) < 0) __PYX_ERR(0, 65, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_3), 2) < 0) __PYX_ERR(0, 87, __pyx_L1_error)
     __pyx_t_6 = NULL;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 65, __pyx_L1_error)
+    __PYX_ERR(0, 87, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
-  __pyx_v_n = __pyx_t_3;
-  __pyx_t_3 = 0;
+  __pyx_v_n = __pyx_t_1;
+  __pyx_t_1 = 0;
   __pyx_v_buf = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "borg/platform/freebsd.pyx":66
- * 
+  /* "borg/platform/freebsd.pyx":88
+ *     ns_id = NS_ID_MAP[ns]
  *     n, buf = _listxattr_inner(func, path)
- *     return [prefix + name for name in split_lstring(buf[:n]) if name]             # <<<<<<<<<<<<<<
+ *     return [ns + b"." + name for name in split_lstring(buf[:n]) if name]             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
   { /* enter inner scope */
-    __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 66, __pyx_L7_error)
+    __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 88, __pyx_L7_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_split_lstring); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 66, __pyx_L7_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_split_lstring); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 88, __pyx_L7_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = __Pyx_PyObject_GetSlice(__pyx_v_buf, 0, 0, NULL, &__pyx_v_n, NULL, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 88, __pyx_L7_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_GetSlice(__pyx_v_buf, 0, 0, NULL, &__pyx_v_n, NULL, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 66, __pyx_L7_error)
-    __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_7 = NULL;
-    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
+    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_1);
       if (likely(__pyx_t_7)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
         __Pyx_INCREF(__pyx_t_7);
         __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_3, function);
+        __Pyx_DECREF_SET(__pyx_t_1, function);
       }
     }
-    __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_7, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+    __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_7, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3);
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 66, __pyx_L7_error)
-    __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 88, __pyx_L7_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     if (likely(PyList_CheckExact(__pyx_t_5)) || PyTuple_CheckExact(__pyx_t_5)) {
-      __pyx_t_3 = __pyx_t_5; __Pyx_INCREF(__pyx_t_3); __pyx_t_8 = 0;
+      __pyx_t_1 = __pyx_t_5; __Pyx_INCREF(__pyx_t_1); __pyx_t_8 = 0;
       __pyx_t_9 = NULL;
     } else {
-      __pyx_t_8 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 66, __pyx_L7_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_9 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 66, __pyx_L7_error)
+      __pyx_t_8 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 88, __pyx_L7_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_9 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 88, __pyx_L7_error)
     }
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     for (;;) {
       if (likely(!__pyx_t_9)) {
-        if (likely(PyList_CheckExact(__pyx_t_3))) {
-          if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_3)) break;
+        if (likely(PyList_CheckExact(__pyx_t_1))) {
+          if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_1)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 66, __pyx_L7_error)
+          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 88, __pyx_L7_error)
           #else
-          __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 66, __pyx_L7_error)
+          __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 88, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_5);
           #endif
         } else {
-          if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
+          if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
           #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 66, __pyx_L7_error)
+          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 88, __pyx_L7_error)
           #else
-          __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 66, __pyx_L7_error)
+          __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 88, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_5);
           #endif
         }
       } else {
-        __pyx_t_5 = __pyx_t_9(__pyx_t_3);
+        __pyx_t_5 = __pyx_t_9(__pyx_t_1);
         if (unlikely(!__pyx_t_5)) {
           PyObject* exc_type = PyErr_Occurred();
           if (exc_type) {
             if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-            else __PYX_ERR(0, 66, __pyx_L7_error)
+            else __PYX_ERR(0, 88, __pyx_L7_error)
           }
           break;
         }
         __Pyx_GOTREF(__pyx_t_5);
       }
       __Pyx_XDECREF_SET(__pyx_7genexpr__pyx_v_name, __pyx_t_5);
       __pyx_t_5 = 0;
-      __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_7genexpr__pyx_v_name); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 66, __pyx_L7_error)
+      __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_7genexpr__pyx_v_name); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 88, __pyx_L7_error)
       if (__pyx_t_10) {
-        __pyx_t_5 = PyNumber_Add(__pyx_v_prefix, __pyx_7genexpr__pyx_v_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 66, __pyx_L7_error)
+        __pyx_t_5 = PyNumber_Add(__pyx_v_ns, __pyx_kp_b_); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 88, __pyx_L7_error)
         __Pyx_GOTREF(__pyx_t_5);
-        if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 66, __pyx_L7_error)
+        __pyx_t_3 = PyNumber_Add(__pyx_t_5, __pyx_7genexpr__pyx_v_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 88, __pyx_L7_error)
+        __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_3))) __PYX_ERR(0, 88, __pyx_L7_error)
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       }
     }
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_7genexpr__pyx_v_name); __pyx_7genexpr__pyx_v_name = 0;
     goto __pyx_L11_exit_scope;
     __pyx_L7_error:;
     __Pyx_XDECREF(__pyx_7genexpr__pyx_v_name); __pyx_7genexpr__pyx_v_name = 0;
     goto __pyx_L1_error;
     __pyx_L11_exit_scope:;
   } /* exit inner scope */
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "borg/platform/freebsd.pyx":53
+  /* "borg/platform/freebsd.pyx":75
  * 
  * 
  * def listxattr(path, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, buf, size):
+ *         if isinstance(path, int):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_AddTraceback("borg.platform.freebsd.listxattr", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_prefix);
   __Pyx_XDECREF(__pyx_v_func);
+  __Pyx_XDECREF(__pyx_v_ns);
   __Pyx_XDECREF(__pyx_v_n);
   __Pyx_XDECREF(__pyx_v_buf);
   __Pyx_XDECREF(__pyx_7genexpr__pyx_v_name);
   __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":69
+/* "borg/platform/freebsd.pyx":91
  * 
  * 
  * def getxattr(path, name, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, buf, size):
+ *         if isinstance(path, int):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_3getxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_3getxattr = {"getxattr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_3getxattr, METH_VARARGS|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_3getxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_5getxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_5getxattr = {"getxattr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_5getxattr, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_5getxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_path = 0;
   PyObject *__pyx_v_name = 0;
   PyObject *__pyx_v_follow_symlinks = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
@@ -2330,56 +2636,56 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("getxattr", 1, 2, 2, 1); __PYX_ERR(0, 69, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("getxattr", 1, 2, 2, 1); __PYX_ERR(0, 91, __pyx_L3_error)
         }
       }
       if (kw_args == 1) {
         const Py_ssize_t index = 2;
         PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
         if (value) { values[index] = value; kw_args--; }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getxattr") < 0)) __PYX_ERR(0, 69, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "getxattr") < 0)) __PYX_ERR(0, 91, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_path = values[0];
     __pyx_v_name = values[1];
     __pyx_v_follow_symlinks = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("getxattr", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 69, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("getxattr", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 91, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.platform.freebsd.getxattr", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_2getxattr(__pyx_self, __pyx_v_path, __pyx_v_name, __pyx_v_follow_symlinks);
+  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_4getxattr(__pyx_self, __pyx_v_path, __pyx_v_name, __pyx_v_follow_symlinks);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":72
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+/* "borg/platform/freebsd.pyx":92
  * 
+ * def getxattr(path, name, *, follow_symlinks=False):
  *     def func(path, name, buf, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_get_fd(path, ns, name, <char *> buf, size)
+ *             return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_4borg_8platform_7freebsd_8getxattr_1func(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_8getxattr_1func = {"func", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_8getxattr_1func, METH_VARARGS|METH_KEYWORDS, 0};
 static PyObject *__pyx_pw_4borg_8platform_7freebsd_8getxattr_1func(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_path = 0;
@@ -2415,31 +2721,31 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 1); __PYX_ERR(0, 72, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 1); __PYX_ERR(0, 92, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 2); __PYX_ERR(0, 72, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 2); __PYX_ERR(0, 92, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_size)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 3); __PYX_ERR(0, 72, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 3); __PYX_ERR(0, 92, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "func") < 0)) __PYX_ERR(0, 72, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "func") < 0)) __PYX_ERR(0, 92, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
@@ -2448,15 +2754,15 @@
     __pyx_v_path = values[0];
     __pyx_v_name = values[1];
     __pyx_v_buf = values[2];
     __pyx_v_size = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 72, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 92, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.platform.freebsd.getxattr.func", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8platform_7freebsd_8getxattr_func(__pyx_self, __pyx_v_path, __pyx_v_name, __pyx_v_buf, __pyx_v_size);
 
@@ -2469,428 +2775,490 @@
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *__pyx_cur_scope;
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *__pyx_outer_scope;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
-  char const *__pyx_t_4;
-  char *__pyx_t_5;
-  size_t __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
-  char const *__pyx_t_8;
+  int __pyx_t_4;
+  char const *__pyx_t_5;
+  char *__pyx_t_6;
+  size_t __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
   char const *__pyx_t_9;
   char const *__pyx_t_10;
   char const *__pyx_t_11;
+  char const *__pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("func", 0);
   __pyx_outer_scope = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *) __Pyx_CyFunction_GetClosure(__pyx_self);
   __pyx_cur_scope = __pyx_outer_scope;
 
-  /* "borg/platform/freebsd.pyx":73
- * 
+  /* "borg/platform/freebsd.pyx":93
+ * def getxattr(path, name, *, follow_symlinks=False):
  *     def func(path, name, buf, size):
  *         if isinstance(path, int):             # <<<<<<<<<<<<<<
- *             return c_extattr_get_fd(path, ns, name, <char *> buf, size)
+ *             return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)
  *         else:
  */
   __pyx_t_1 = PyInt_Check(__pyx_v_path); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/platform/freebsd.pyx":74
+    /* "borg/platform/freebsd.pyx":94
  *     def func(path, name, buf, size):
  *         if isinstance(path, int):
- *             return c_extattr_get_fd(path, ns, name, <char *> buf, size)             # <<<<<<<<<<<<<<
+ *             return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)             # <<<<<<<<<<<<<<
  *         else:
  *             if follow_symlinks:
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_path); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 74, __pyx_L1_error)
-    __pyx_t_4 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 74, __pyx_L1_error)
-    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 74, __pyx_L1_error)
-    __pyx_t_6 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 74, __pyx_L1_error)
-    __pyx_t_7 = PyInt_FromSsize_t(extattr_get_fd(__pyx_t_3, __pyx_cur_scope->__pyx_v_ns, __pyx_t_4, ((char *)__pyx_t_5), __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 74, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_r = __pyx_t_7;
-    __pyx_t_7 = 0;
+    __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_path); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 94, __pyx_L1_error)
+    if (unlikely(!__pyx_cur_scope->__pyx_v_ns_id)) { __Pyx_RaiseClosureNameError("ns_id"); __PYX_ERR(0, 94, __pyx_L1_error) }
+    __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_cur_scope->__pyx_v_ns_id); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 94, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 94, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 94, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_7 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 94, __pyx_L1_error)
+    __pyx_t_8 = PyInt_FromSsize_t(extattr_get_fd(__pyx_t_3, __pyx_t_4, __pyx_t_5, ((char *)__pyx_t_6), __pyx_t_7)); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 94, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_r = __pyx_t_8;
+    __pyx_t_8 = 0;
     goto __pyx_L0;
 
-    /* "borg/platform/freebsd.pyx":73
- * 
+    /* "borg/platform/freebsd.pyx":93
+ * def getxattr(path, name, *, follow_symlinks=False):
  *     def func(path, name, buf, size):
  *         if isinstance(path, int):             # <<<<<<<<<<<<<<
- *             return c_extattr_get_fd(path, ns, name, <char *> buf, size)
+ *             return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)
  *         else:
  */
   }
 
-  /* "borg/platform/freebsd.pyx":76
- *             return c_extattr_get_fd(path, ns, name, <char *> buf, size)
+  /* "borg/platform/freebsd.pyx":96
+ *             return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)
  *         else:
  *             if follow_symlinks:             # <<<<<<<<<<<<<<
- *                 return c_extattr_get_file(path, ns, name, <char *> buf, size)
+ *                 return c_extattr_get_file(path, ns_id, name, <char *> buf, size)
  *             else:
  */
   /*else*/ {
-    if (unlikely(!__pyx_cur_scope->__pyx_v_follow_symlinks)) { __Pyx_RaiseClosureNameError("follow_symlinks"); __PYX_ERR(0, 76, __pyx_L1_error) }
-    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_cur_scope->__pyx_v_follow_symlinks); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 76, __pyx_L1_error)
+    if (unlikely(!__pyx_cur_scope->__pyx_v_follow_symlinks)) { __Pyx_RaiseClosureNameError("follow_symlinks"); __PYX_ERR(0, 96, __pyx_L1_error) }
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_cur_scope->__pyx_v_follow_symlinks); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 96, __pyx_L1_error)
     if (__pyx_t_2) {
 
-      /* "borg/platform/freebsd.pyx":77
+      /* "borg/platform/freebsd.pyx":97
  *         else:
  *             if follow_symlinks:
- *                 return c_extattr_get_file(path, ns, name, <char *> buf, size)             # <<<<<<<<<<<<<<
+ *                 return c_extattr_get_file(path, ns_id, name, <char *> buf, size)             # <<<<<<<<<<<<<<
  *             else:
- *                 return c_extattr_get_link(path, ns, name, <char *> buf, size)
+ *                 return c_extattr_get_link(path, ns_id, name, <char *> buf, size)
  */
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_8 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 77, __pyx_L1_error)
-      __pyx_t_9 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_9) && PyErr_Occurred())) __PYX_ERR(0, 77, __pyx_L1_error)
-      __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 77, __pyx_L1_error)
-      __pyx_t_6 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 77, __pyx_L1_error)
-      __pyx_t_7 = PyInt_FromSsize_t(extattr_get_file(__pyx_t_8, __pyx_cur_scope->__pyx_v_ns, __pyx_t_9, ((char *)__pyx_t_5), __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 77, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __pyx_r = __pyx_t_7;
-      __pyx_t_7 = 0;
+      __pyx_t_9 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_9) && PyErr_Occurred())) __PYX_ERR(0, 97, __pyx_L1_error)
+      if (unlikely(!__pyx_cur_scope->__pyx_v_ns_id)) { __Pyx_RaiseClosureNameError("ns_id"); __PYX_ERR(0, 97, __pyx_L1_error) }
+      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_cur_scope->__pyx_v_ns_id); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 97, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 97, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 97, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_7 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 97, __pyx_L1_error)
+      __pyx_t_8 = PyInt_FromSsize_t(extattr_get_file(__pyx_t_9, __pyx_t_4, __pyx_t_10, ((char *)__pyx_t_6), __pyx_t_7)); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 97, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __pyx_r = __pyx_t_8;
+      __pyx_t_8 = 0;
       goto __pyx_L0;
 
-      /* "borg/platform/freebsd.pyx":76
- *             return c_extattr_get_fd(path, ns, name, <char *> buf, size)
+      /* "borg/platform/freebsd.pyx":96
+ *             return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)
  *         else:
  *             if follow_symlinks:             # <<<<<<<<<<<<<<
- *                 return c_extattr_get_file(path, ns, name, <char *> buf, size)
+ *                 return c_extattr_get_file(path, ns_id, name, <char *> buf, size)
  *             else:
  */
     }
 
-    /* "borg/platform/freebsd.pyx":79
- *                 return c_extattr_get_file(path, ns, name, <char *> buf, size)
+    /* "borg/platform/freebsd.pyx":99
+ *                 return c_extattr_get_file(path, ns_id, name, <char *> buf, size)
  *             else:
- *                 return c_extattr_get_link(path, ns, name, <char *> buf, size)             # <<<<<<<<<<<<<<
+ *                 return c_extattr_get_link(path, ns_id, name, <char *> buf, size)             # <<<<<<<<<<<<<<
  * 
- *     # strip namespace if there, but ignore if not there.
+ *     ns, name = split_ns(name, b"user")
  */
     /*else*/ {
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_10 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 79, __pyx_L1_error)
-      __pyx_t_11 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_11) && PyErr_Occurred())) __PYX_ERR(0, 79, __pyx_L1_error)
-      __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 79, __pyx_L1_error)
-      __pyx_t_6 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 79, __pyx_L1_error)
-      __pyx_t_7 = PyInt_FromSsize_t(extattr_get_link(__pyx_t_10, __pyx_cur_scope->__pyx_v_ns, __pyx_t_11, ((char *)__pyx_t_5), __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 79, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __pyx_r = __pyx_t_7;
-      __pyx_t_7 = 0;
+      __pyx_t_11 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_11) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
+      if (unlikely(!__pyx_cur_scope->__pyx_v_ns_id)) { __Pyx_RaiseClosureNameError("ns_id"); __PYX_ERR(0, 99, __pyx_L1_error) }
+      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_cur_scope->__pyx_v_ns_id); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
+      __pyx_t_12 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_12) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_AsWritableString(__pyx_v_buf); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_7 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
+      __pyx_t_8 = PyInt_FromSsize_t(extattr_get_link(__pyx_t_11, __pyx_t_4, __pyx_t_12, ((char *)__pyx_t_6), __pyx_t_7)); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 99, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __pyx_r = __pyx_t_8;
+      __pyx_t_8 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "borg/platform/freebsd.pyx":72
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+  /* "borg/platform/freebsd.pyx":92
  * 
+ * def getxattr(path, name, *, follow_symlinks=False):
  *     def func(path, name, buf, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_get_fd(path, ns, name, <char *> buf, size)
+ *             return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("borg.platform.freebsd.getxattr.func", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":69
+/* "borg/platform/freebsd.pyx":91
  * 
  * 
  * def getxattr(path, name, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, buf, size):
+ *         if isinstance(path, int):
  */
 
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_2getxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_follow_symlinks) {
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_4getxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_follow_symlinks) {
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *__pyx_cur_scope;
-  PyObject *__pyx_v_prefix = NULL;
   PyObject *__pyx_v_func = 0;
+  PyObject *__pyx_v_ns = NULL;
   PyObject *__pyx_v_n = NULL;
   PyObject *__pyx_v_buf = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
+  PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
-  PyObject *(*__pyx_t_8)(PyObject *);
+  int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *(*__pyx_t_6)(PyObject *);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("getxattr", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *)__pyx_tp_new_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr(__pyx_ptype_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 69, __pyx_L1_error)
+    __PYX_ERR(0, 91, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_v_follow_symlinks = __pyx_v_follow_symlinks;
   __Pyx_INCREF(__pyx_cur_scope->__pyx_v_follow_symlinks);
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_follow_symlinks);
   __Pyx_INCREF(__pyx_v_name);
 
-  /* "borg/platform/freebsd.pyx":70
+  /* "borg/platform/freebsd.pyx":92
  * 
  * def getxattr(path, name, *, follow_symlinks=False):
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'             # <<<<<<<<<<<<<<
- * 
- *     def func(path, name, buf, size):
- */
-  __pyx_t_1 = EXTATTR_NAMESPACE_USER;
-  __pyx_t_2 = __pyx_kp_b_user;
-  __Pyx_INCREF(__pyx_t_2);
-  __pyx_cur_scope->__pyx_v_ns = __pyx_t_1;
-  __pyx_v_prefix = ((PyObject*)__pyx_t_2);
-  __pyx_t_2 = 0;
-
-  /* "borg/platform/freebsd.pyx":72
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
  *     def func(path, name, buf, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_get_fd(path, ns, name, <char *> buf, size)
+ *             return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8platform_7freebsd_8getxattr_1func, 0, __pyx_n_s_getxattr_locals_func, ((PyObject*)__pyx_cur_scope), __pyx_n_s_borg_platform_freebsd, __pyx_d, ((PyObject *)__pyx_codeobj__4)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 72, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_v_func = __pyx_t_2;
-  __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8platform_7freebsd_8getxattr_1func, 0, __pyx_n_s_getxattr_locals_func, ((PyObject*)__pyx_cur_scope), __pyx_n_s_borg_platform_freebsd, __pyx_d, ((PyObject *)__pyx_codeobj__6)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 92, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_func = __pyx_t_1;
+  __pyx_t_1 = 0;
 
-  /* "borg/platform/freebsd.pyx":83
- *     # strip namespace if there, but ignore if not there.
- *     # older borg / attic versions did not prefix the namespace to the names.
- *     if name.startswith(prefix):             # <<<<<<<<<<<<<<
- *         name = name[len(prefix):]
+  /* "borg/platform/freebsd.pyx":101
+ *                 return c_extattr_get_link(path, ns_id, name, <char *> buf, size)
+ * 
+ *     ns, name = split_ns(name, b"user")             # <<<<<<<<<<<<<<
+ *     ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
  *     n, buf = _getxattr_inner(func, path, name)
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_name, __pyx_n_s_startswith); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 83, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_split_ns); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 101, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = NULL;
+  __pyx_t_4 = 0;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __pyx_t_4 = 1;
     }
   }
-  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_prefix) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_prefix);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 83, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 83, __pyx_L1_error)
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_name, __pyx_n_b_user};
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 101, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+  } else
+  #endif
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_name, __pyx_n_b_user};
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 101, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+  } else
+  #endif
+  {
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 101, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    if (__pyx_t_3) {
+      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
+    }
+    __Pyx_INCREF(__pyx_v_name);
+    __Pyx_GIVEREF(__pyx_v_name);
+    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_name);
+    __Pyx_INCREF(__pyx_n_b_user);
+    __Pyx_GIVEREF(__pyx_n_b_user);
+    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_n_b_user);
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 101, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__pyx_t_5) {
-
-    /* "borg/platform/freebsd.pyx":84
- *     # older borg / attic versions did not prefix the namespace to the names.
- *     if name.startswith(prefix):
- *         name = name[len(prefix):]             # <<<<<<<<<<<<<<
- *     n, buf = _getxattr_inner(func, path, name)
- *     return bytes(buf[:n])
- */
-    __pyx_t_6 = PyBytes_GET_SIZE(__pyx_v_prefix); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 84, __pyx_L1_error)
-    __pyx_t_2 = __Pyx_PyObject_GetSlice(__pyx_v_name, __pyx_t_6, 0, NULL, NULL, NULL, 1, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 84, __pyx_L1_error)
+  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
+    PyObject* sequence = __pyx_t_1;
+    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
+    if (unlikely(size != 2)) {
+      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
+      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
+      __PYX_ERR(0, 101, __pyx_L1_error)
+    }
+    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    if (likely(PyTuple_CheckExact(sequence))) {
+      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
+      __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
+    } else {
+      __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
+      __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
+    }
+    __Pyx_INCREF(__pyx_t_2);
+    __Pyx_INCREF(__pyx_t_5);
+    #else
+    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 101, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_2);
-    __pyx_t_2 = 0;
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 101, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    #endif
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  } else {
+    Py_ssize_t index = -1;
+    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 101, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_6 = Py_TYPE(__pyx_t_3)->tp_iternext;
+    index = 0; __pyx_t_2 = __pyx_t_6(__pyx_t_3); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
+    __Pyx_GOTREF(__pyx_t_2);
+    index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_3); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
+    __Pyx_GOTREF(__pyx_t_5);
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_3), 2) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
+    __pyx_t_6 = NULL;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    goto __pyx_L4_unpacking_done;
+    __pyx_L3_unpacking_failed:;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_6 = NULL;
+    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
+    __PYX_ERR(0, 101, __pyx_L1_error)
+    __pyx_L4_unpacking_done:;
+  }
+  __pyx_v_ns = __pyx_t_2;
+  __pyx_t_2 = 0;
+  __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_5);
+  __pyx_t_5 = 0;
 
-    /* "borg/platform/freebsd.pyx":83
- *     # strip namespace if there, but ignore if not there.
- *     # older borg / attic versions did not prefix the namespace to the names.
- *     if name.startswith(prefix):             # <<<<<<<<<<<<<<
- *         name = name[len(prefix):]
+  /* "borg/platform/freebsd.pyx":102
+ * 
+ *     ns, name = split_ns(name, b"user")
+ *     ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported             # <<<<<<<<<<<<<<
  *     n, buf = _getxattr_inner(func, path, name)
+ *     return bytes(buf[:n])
  */
-  }
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_NS_ID_MAP); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_ns); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_GIVEREF(__pyx_t_5);
+  __pyx_cur_scope->__pyx_v_ns_id = __pyx_t_5;
+  __pyx_t_5 = 0;
 
-  /* "borg/platform/freebsd.pyx":85
- *     if name.startswith(prefix):
- *         name = name[len(prefix):]
+  /* "borg/platform/freebsd.pyx":103
+ *     ns, name = split_ns(name, b"user")
+ *     ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
  *     n, buf = _getxattr_inner(func, path, name)             # <<<<<<<<<<<<<<
  *     return bytes(buf[:n])
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_getxattr_inner); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 85, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = NULL;
-  __pyx_t_1 = 0;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_getxattr_inner); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 103, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = NULL;
+  __pyx_t_4 = 0;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+      __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_1 = 1;
+      __Pyx_DECREF_SET(__pyx_t_1, function);
+      __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
-  if (PyFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_v_func, __pyx_v_path, __pyx_v_name};
-    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_1, 3+__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 85, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_GOTREF(__pyx_t_2);
+  if (PyFunction_Check(__pyx_t_1)) {
+    PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_func, __pyx_v_path, __pyx_v_name};
+    __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_GOTREF(__pyx_t_5);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
-  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_v_func, __pyx_v_path, __pyx_v_name};
-    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_1, 3+__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 85, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_GOTREF(__pyx_t_2);
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
+    PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_func, __pyx_v_path, __pyx_v_name};
+    __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_GOTREF(__pyx_t_5);
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(3+__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 85, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    if (__pyx_t_4) {
-      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
+    __pyx_t_3 = PyTuple_New(3+__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (__pyx_t_2) {
+      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2); __pyx_t_2 = NULL;
     }
     __Pyx_INCREF(__pyx_v_func);
     __Pyx_GIVEREF(__pyx_v_func);
-    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_1, __pyx_v_func);
+    PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_4, __pyx_v_func);
     __Pyx_INCREF(__pyx_v_path);
     __Pyx_GIVEREF(__pyx_v_path);
-    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_1, __pyx_v_path);
+    PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_4, __pyx_v_path);
     __Pyx_INCREF(__pyx_v_name);
     __Pyx_GIVEREF(__pyx_v_name);
-    PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_1, __pyx_v_name);
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 85, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    PyTuple_SET_ITEM(__pyx_t_3, 2+__pyx_t_4, __pyx_v_name);
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
-    PyObject* sequence = __pyx_t_2;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
+    PyObject* sequence = __pyx_t_5;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 85, __pyx_L1_error)
+      __PYX_ERR(0, 103, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
-      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
-      __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
+      __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
+      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
     } else {
-      __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
-      __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
+      __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
+      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
     }
+    __Pyx_INCREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_t_3);
-    __Pyx_INCREF(__pyx_t_7);
     #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 103, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 85, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
     #endif
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_4 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 85, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_8 = Py_TYPE(__pyx_t_4)->tp_iternext;
-    index = 0; __pyx_t_3 = __pyx_t_8(__pyx_t_4); if (unlikely(!__pyx_t_3)) goto __pyx_L4_unpacking_failed;
+    __pyx_t_2 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 103, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_6 = Py_TYPE(__pyx_t_2)->tp_iternext;
+    index = 0; __pyx_t_1 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_1)) goto __pyx_L5_unpacking_failed;
+    __Pyx_GOTREF(__pyx_t_1);
+    index = 1; __pyx_t_3 = __pyx_t_6(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_3);
-    index = 1; __pyx_t_7 = __pyx_t_8(__pyx_t_4); if (unlikely(!__pyx_t_7)) goto __pyx_L4_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_7);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_8(__pyx_t_4), 2) < 0) __PYX_ERR(0, 85, __pyx_L1_error)
-    __pyx_t_8 = NULL;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    goto __pyx_L5_unpacking_done;
-    __pyx_L4_unpacking_failed:;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_8 = NULL;
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_2), 2) < 0) __PYX_ERR(0, 103, __pyx_L1_error)
+    __pyx_t_6 = NULL;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    goto __pyx_L6_unpacking_done;
+    __pyx_L5_unpacking_failed:;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_6 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 85, __pyx_L1_error)
-    __pyx_L5_unpacking_done:;
+    __PYX_ERR(0, 103, __pyx_L1_error)
+    __pyx_L6_unpacking_done:;
   }
-  __pyx_v_n = __pyx_t_3;
+  __pyx_v_n = __pyx_t_1;
+  __pyx_t_1 = 0;
+  __pyx_v_buf = __pyx_t_3;
   __pyx_t_3 = 0;
-  __pyx_v_buf = __pyx_t_7;
-  __pyx_t_7 = 0;
 
-  /* "borg/platform/freebsd.pyx":86
- *         name = name[len(prefix):]
+  /* "borg/platform/freebsd.pyx":104
+ *     ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
  *     n, buf = _getxattr_inner(func, path, name)
  *     return bytes(buf[:n])             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetSlice(__pyx_v_buf, 0, 0, NULL, &__pyx_v_n, NULL, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 86, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_7 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_t_2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 86, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_r = __pyx_t_7;
-  __pyx_t_7 = 0;
+  __pyx_t_5 = __Pyx_PyObject_GetSlice(__pyx_v_buf, 0, 0, NULL, &__pyx_v_n, NULL, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "borg/platform/freebsd.pyx":69
+  /* "borg/platform/freebsd.pyx":91
  * 
  * 
  * def getxattr(path, name, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, buf, size):
+ *         if isinstance(path, int):
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("borg.platform.freebsd.getxattr", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_prefix);
   __Pyx_XDECREF(__pyx_v_func);
+  __Pyx_XDECREF(__pyx_v_ns);
   __Pyx_XDECREF(__pyx_v_n);
   __Pyx_XDECREF(__pyx_v_buf);
   __Pyx_XDECREF(__pyx_v_name);
   __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":89
+/* "borg/platform/freebsd.pyx":107
  * 
  * 
  * def setxattr(path, name, value, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, value, size):
+ *         if isinstance(path, int):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_5setxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_5setxattr = {"setxattr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_5setxattr, METH_VARARGS|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_5setxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_7setxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_7setxattr = {"setxattr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_7setxattr, METH_VARARGS|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_7setxattr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_path = 0;
   PyObject *__pyx_v_name = 0;
   PyObject *__pyx_v_value = 0;
   PyObject *__pyx_v_follow_symlinks = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -2919,30 +3287,30 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("setxattr", 1, 3, 3, 1); __PYX_ERR(0, 89, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("setxattr", 1, 3, 3, 1); __PYX_ERR(0, 107, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("setxattr", 1, 3, 3, 2); __PYX_ERR(0, 89, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("setxattr", 1, 3, 3, 2); __PYX_ERR(0, 107, __pyx_L3_error)
         }
       }
       if (kw_args == 1) {
         const Py_ssize_t index = 3;
         PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
         if (value) { values[index] = value; kw_args--; }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setxattr") < 0)) __PYX_ERR(0, 89, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setxattr") < 0)) __PYX_ERR(0, 107, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
@@ -2950,33 +3318,33 @@
     __pyx_v_path = values[0];
     __pyx_v_name = values[1];
     __pyx_v_value = values[2];
     __pyx_v_follow_symlinks = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("setxattr", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 89, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("setxattr", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 107, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.platform.freebsd.setxattr", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_4setxattr(__pyx_self, __pyx_v_path, __pyx_v_name, __pyx_v_value, __pyx_v_follow_symlinks);
+  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_6setxattr(__pyx_self, __pyx_v_path, __pyx_v_name, __pyx_v_value, __pyx_v_follow_symlinks);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":92
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+/* "borg/platform/freebsd.pyx":108
  * 
+ * def setxattr(path, name, value, *, follow_symlinks=False):
  *     def func(path, name, value, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_set_fd(path, ns, name, <char *> value, size)
+ *             return c_extattr_set_fd(path, ns_id, name, <char *> value, size)
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_4borg_8platform_7freebsd_8setxattr_1func(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_8setxattr_1func = {"func", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_8setxattr_1func, METH_VARARGS|METH_KEYWORDS, 0};
 static PyObject *__pyx_pw_4borg_8platform_7freebsd_8setxattr_1func(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_path = 0;
@@ -3012,31 +3380,31 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 1); __PYX_ERR(0, 92, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 1); __PYX_ERR(0, 108, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 2); __PYX_ERR(0, 92, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 2); __PYX_ERR(0, 108, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_size)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 3); __PYX_ERR(0, 92, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, 3); __PYX_ERR(0, 108, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "func") < 0)) __PYX_ERR(0, 92, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "func") < 0)) __PYX_ERR(0, 108, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
@@ -3045,15 +3413,15 @@
     __pyx_v_path = values[0];
     __pyx_v_name = values[1];
     __pyx_v_value = values[2];
     __pyx_v_size = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 92, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("func", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 108, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.platform.freebsd.setxattr.func", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_4borg_8platform_7freebsd_8setxattr_func(__pyx_self, __pyx_v_path, __pyx_v_name, __pyx_v_value, __pyx_v_size);
 
@@ -3066,351 +3434,488 @@
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *__pyx_cur_scope;
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *__pyx_outer_scope;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
-  char const *__pyx_t_4;
-  char *__pyx_t_5;
-  size_t __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
-  char const *__pyx_t_8;
+  int __pyx_t_4;
+  char const *__pyx_t_5;
+  char *__pyx_t_6;
+  size_t __pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
   char const *__pyx_t_9;
   char const *__pyx_t_10;
   char const *__pyx_t_11;
+  char const *__pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("func", 0);
   __pyx_outer_scope = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *) __Pyx_CyFunction_GetClosure(__pyx_self);
   __pyx_cur_scope = __pyx_outer_scope;
 
-  /* "borg/platform/freebsd.pyx":93
- * 
+  /* "borg/platform/freebsd.pyx":109
+ * def setxattr(path, name, value, *, follow_symlinks=False):
  *     def func(path, name, value, size):
  *         if isinstance(path, int):             # <<<<<<<<<<<<<<
- *             return c_extattr_set_fd(path, ns, name, <char *> value, size)
+ *             return c_extattr_set_fd(path, ns_id, name, <char *> value, size)
  *         else:
  */
   __pyx_t_1 = PyInt_Check(__pyx_v_path); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/platform/freebsd.pyx":94
+    /* "borg/platform/freebsd.pyx":110
  *     def func(path, name, value, size):
  *         if isinstance(path, int):
- *             return c_extattr_set_fd(path, ns, name, <char *> value, size)             # <<<<<<<<<<<<<<
+ *             return c_extattr_set_fd(path, ns_id, name, <char *> value, size)             # <<<<<<<<<<<<<<
  *         else:
  *             if follow_symlinks:
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_path); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 94, __pyx_L1_error)
-    __pyx_t_4 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 94, __pyx_L1_error)
-    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_value); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 94, __pyx_L1_error)
-    __pyx_t_6 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 94, __pyx_L1_error)
-    __pyx_t_7 = __Pyx_PyInt_From_int(extattr_set_fd(__pyx_t_3, __pyx_cur_scope->__pyx_v_ns, __pyx_t_4, ((char *)__pyx_t_5), __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 94, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
-    __pyx_r = __pyx_t_7;
-    __pyx_t_7 = 0;
+    __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_path); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 110, __pyx_L1_error)
+    if (unlikely(!__pyx_cur_scope->__pyx_v_ns_id)) { __Pyx_RaiseClosureNameError("ns_id"); __PYX_ERR(0, 110, __pyx_L1_error) }
+    __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_cur_scope->__pyx_v_ns_id); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 110, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 110, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_AsWritableString(__pyx_v_value); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 110, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_7 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 110, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyInt_From_int(extattr_set_fd(__pyx_t_3, __pyx_t_4, __pyx_t_5, ((char *)__pyx_t_6), __pyx_t_7)); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 110, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_8);
+    __pyx_r = __pyx_t_8;
+    __pyx_t_8 = 0;
     goto __pyx_L0;
 
-    /* "borg/platform/freebsd.pyx":93
- * 
+    /* "borg/platform/freebsd.pyx":109
+ * def setxattr(path, name, value, *, follow_symlinks=False):
  *     def func(path, name, value, size):
  *         if isinstance(path, int):             # <<<<<<<<<<<<<<
- *             return c_extattr_set_fd(path, ns, name, <char *> value, size)
+ *             return c_extattr_set_fd(path, ns_id, name, <char *> value, size)
  *         else:
  */
   }
 
-  /* "borg/platform/freebsd.pyx":96
- *             return c_extattr_set_fd(path, ns, name, <char *> value, size)
+  /* "borg/platform/freebsd.pyx":112
+ *             return c_extattr_set_fd(path, ns_id, name, <char *> value, size)
  *         else:
  *             if follow_symlinks:             # <<<<<<<<<<<<<<
- *                 return c_extattr_set_file(path, ns, name, <char *> value, size)
+ *                 return c_extattr_set_file(path, ns_id, name, <char *> value, size)
  *             else:
  */
   /*else*/ {
-    if (unlikely(!__pyx_cur_scope->__pyx_v_follow_symlinks)) { __Pyx_RaiseClosureNameError("follow_symlinks"); __PYX_ERR(0, 96, __pyx_L1_error) }
-    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_cur_scope->__pyx_v_follow_symlinks); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 96, __pyx_L1_error)
+    if (unlikely(!__pyx_cur_scope->__pyx_v_follow_symlinks)) { __Pyx_RaiseClosureNameError("follow_symlinks"); __PYX_ERR(0, 112, __pyx_L1_error) }
+    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_cur_scope->__pyx_v_follow_symlinks); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 112, __pyx_L1_error)
     if (__pyx_t_2) {
 
-      /* "borg/platform/freebsd.pyx":97
+      /* "borg/platform/freebsd.pyx":113
  *         else:
  *             if follow_symlinks:
- *                 return c_extattr_set_file(path, ns, name, <char *> value, size)             # <<<<<<<<<<<<<<
+ *                 return c_extattr_set_file(path, ns_id, name, <char *> value, size)             # <<<<<<<<<<<<<<
  *             else:
- *                 return c_extattr_set_link(path, ns, name, <char *> value, size)
+ *                 return c_extattr_set_link(path, ns_id, name, <char *> value, size)
  */
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_8 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 97, __pyx_L1_error)
-      __pyx_t_9 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_9) && PyErr_Occurred())) __PYX_ERR(0, 97, __pyx_L1_error)
-      __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_value); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 97, __pyx_L1_error)
-      __pyx_t_6 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 97, __pyx_L1_error)
-      __pyx_t_7 = __Pyx_PyInt_From_int(extattr_set_file(__pyx_t_8, __pyx_cur_scope->__pyx_v_ns, __pyx_t_9, ((char *)__pyx_t_5), __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 97, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __pyx_r = __pyx_t_7;
-      __pyx_t_7 = 0;
+      __pyx_t_9 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_9) && PyErr_Occurred())) __PYX_ERR(0, 113, __pyx_L1_error)
+      if (unlikely(!__pyx_cur_scope->__pyx_v_ns_id)) { __Pyx_RaiseClosureNameError("ns_id"); __PYX_ERR(0, 113, __pyx_L1_error) }
+      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_cur_scope->__pyx_v_ns_id); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 113, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 113, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_AsWritableString(__pyx_v_value); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 113, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_7 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 113, __pyx_L1_error)
+      __pyx_t_8 = __Pyx_PyInt_From_int(extattr_set_file(__pyx_t_9, __pyx_t_4, __pyx_t_10, ((char *)__pyx_t_6), __pyx_t_7)); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 113, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __pyx_r = __pyx_t_8;
+      __pyx_t_8 = 0;
       goto __pyx_L0;
 
-      /* "borg/platform/freebsd.pyx":96
- *             return c_extattr_set_fd(path, ns, name, <char *> value, size)
+      /* "borg/platform/freebsd.pyx":112
+ *             return c_extattr_set_fd(path, ns_id, name, <char *> value, size)
  *         else:
  *             if follow_symlinks:             # <<<<<<<<<<<<<<
- *                 return c_extattr_set_file(path, ns, name, <char *> value, size)
+ *                 return c_extattr_set_file(path, ns_id, name, <char *> value, size)
  *             else:
  */
     }
 
-    /* "borg/platform/freebsd.pyx":99
- *                 return c_extattr_set_file(path, ns, name, <char *> value, size)
+    /* "borg/platform/freebsd.pyx":115
+ *                 return c_extattr_set_file(path, ns_id, name, <char *> value, size)
  *             else:
- *                 return c_extattr_set_link(path, ns, name, <char *> value, size)             # <<<<<<<<<<<<<<
+ *                 return c_extattr_set_link(path, ns_id, name, <char *> value, size)             # <<<<<<<<<<<<<<
  * 
- *     # strip namespace if there, but ignore if not there.
+ *     ns, name = split_ns(name, b"user")
  */
     /*else*/ {
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_10 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
-      __pyx_t_11 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_11) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
-      __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_value); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
-      __pyx_t_6 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_6 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L1_error)
-      __pyx_t_7 = __Pyx_PyInt_From_int(extattr_set_link(__pyx_t_10, __pyx_cur_scope->__pyx_v_ns, __pyx_t_11, ((char *)__pyx_t_5), __pyx_t_6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 99, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_7);
-      __pyx_r = __pyx_t_7;
-      __pyx_t_7 = 0;
+      __pyx_t_11 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_11) && PyErr_Occurred())) __PYX_ERR(0, 115, __pyx_L1_error)
+      if (unlikely(!__pyx_cur_scope->__pyx_v_ns_id)) { __Pyx_RaiseClosureNameError("ns_id"); __PYX_ERR(0, 115, __pyx_L1_error) }
+      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_cur_scope->__pyx_v_ns_id); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 115, __pyx_L1_error)
+      __pyx_t_12 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_12) && PyErr_Occurred())) __PYX_ERR(0, 115, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_AsWritableString(__pyx_v_value); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 115, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PyInt_As_size_t(__pyx_v_size); if (unlikely((__pyx_t_7 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 115, __pyx_L1_error)
+      __pyx_t_8 = __Pyx_PyInt_From_int(extattr_set_link(__pyx_t_11, __pyx_t_4, __pyx_t_12, ((char *)__pyx_t_6), __pyx_t_7)); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 115, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __pyx_r = __pyx_t_8;
+      __pyx_t_8 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "borg/platform/freebsd.pyx":92
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+  /* "borg/platform/freebsd.pyx":108
  * 
+ * def setxattr(path, name, value, *, follow_symlinks=False):
  *     def func(path, name, value, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_set_fd(path, ns, name, <char *> value, size)
+ *             return c_extattr_set_fd(path, ns_id, name, <char *> value, size)
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("borg.platform.freebsd.setxattr.func", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":89
+/* "borg/platform/freebsd.pyx":107
  * 
  * 
  * def setxattr(path, name, value, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, value, size):
+ *         if isinstance(path, int):
  */
 
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_4setxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_value, PyObject *__pyx_v_follow_symlinks) {
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_6setxattr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_name, PyObject *__pyx_v_value, PyObject *__pyx_v_follow_symlinks) {
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *__pyx_cur_scope;
-  PyObject *__pyx_v_prefix = NULL;
   PyObject *__pyx_v_func = 0;
+  PyObject *__pyx_v_ns = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
+  PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
+  int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *(*__pyx_t_6)(PyObject *);
   PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setxattr", 0);
   __pyx_cur_scope = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *)__pyx_tp_new_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr(__pyx_ptype_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr, __pyx_empty_tuple, NULL);
   if (unlikely(!__pyx_cur_scope)) {
     __pyx_cur_scope = ((struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *)Py_None);
     __Pyx_INCREF(Py_None);
-    __PYX_ERR(0, 89, __pyx_L1_error)
+    __PYX_ERR(0, 107, __pyx_L1_error)
   } else {
     __Pyx_GOTREF(__pyx_cur_scope);
   }
   __pyx_cur_scope->__pyx_v_follow_symlinks = __pyx_v_follow_symlinks;
   __Pyx_INCREF(__pyx_cur_scope->__pyx_v_follow_symlinks);
   __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_follow_symlinks);
   __Pyx_INCREF(__pyx_v_name);
 
-  /* "borg/platform/freebsd.pyx":90
+  /* "borg/platform/freebsd.pyx":108
  * 
  * def setxattr(path, name, value, *, follow_symlinks=False):
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'             # <<<<<<<<<<<<<<
- * 
- *     def func(path, name, value, size):
- */
-  __pyx_t_1 = EXTATTR_NAMESPACE_USER;
-  __pyx_t_2 = __pyx_kp_b_user;
-  __Pyx_INCREF(__pyx_t_2);
-  __pyx_cur_scope->__pyx_v_ns = __pyx_t_1;
-  __pyx_v_prefix = ((PyObject*)__pyx_t_2);
-  __pyx_t_2 = 0;
-
-  /* "borg/platform/freebsd.pyx":92
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
  *     def func(path, name, value, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_set_fd(path, ns, name, <char *> value, size)
+ *             return c_extattr_set_fd(path, ns_id, name, <char *> value, size)
  */
-  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8platform_7freebsd_8setxattr_1func, 0, __pyx_n_s_setxattr_locals_func, ((PyObject*)__pyx_cur_scope), __pyx_n_s_borg_platform_freebsd, __pyx_d, ((PyObject *)__pyx_codeobj__6)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_v_func = __pyx_t_2;
-  __pyx_t_2 = 0;
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_4borg_8platform_7freebsd_8setxattr_1func, 0, __pyx_n_s_setxattr_locals_func, ((PyObject*)__pyx_cur_scope), __pyx_n_s_borg_platform_freebsd, __pyx_d, ((PyObject *)__pyx_codeobj__8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_func = __pyx_t_1;
+  __pyx_t_1 = 0;
 
-  /* "borg/platform/freebsd.pyx":103
- *     # strip namespace if there, but ignore if not there.
- *     # older borg / attic versions did not prefix the namespace to the names.
- *     if name.startswith(prefix):             # <<<<<<<<<<<<<<
- *         name = name[len(prefix):]
- *     _setxattr_inner(func, path, name, value)
+  /* "borg/platform/freebsd.pyx":117
+ *                 return c_extattr_set_link(path, ns_id, name, <char *> value, size)
+ * 
+ *     ns, name = split_ns(name, b"user")             # <<<<<<<<<<<<<<
+ *     try:
+ *         ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_name, __pyx_n_s_startswith); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 103, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = NULL;
-  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_split_ns); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 117, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = NULL;
+  __pyx_t_4 = 0;
+  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __pyx_t_4 = 1;
     }
   }
-  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_prefix) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_prefix);
-  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 103, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 103, __pyx_L1_error)
+  #if CYTHON_FAST_PYCALL
+  if (PyFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_name, __pyx_n_b_user};
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 117, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+  } else
+  #endif
+  #if CYTHON_FAST_PYCCALL
+  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
+    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_name, __pyx_n_b_user};
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 117, __pyx_L1_error)
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_GOTREF(__pyx_t_1);
+  } else
+  #endif
+  {
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 117, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    if (__pyx_t_3) {
+      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
+    }
+    __Pyx_INCREF(__pyx_v_name);
+    __Pyx_GIVEREF(__pyx_v_name);
+    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_name);
+    __Pyx_INCREF(__pyx_n_b_user);
+    __Pyx_GIVEREF(__pyx_n_b_user);
+    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_n_b_user);
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 117, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__pyx_t_5) {
+  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
+    PyObject* sequence = __pyx_t_1;
+    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
+    if (unlikely(size != 2)) {
+      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
+      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
+      __PYX_ERR(0, 117, __pyx_L1_error)
+    }
+    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    if (likely(PyTuple_CheckExact(sequence))) {
+      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
+      __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
+    } else {
+      __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
+      __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
+    }
+    __Pyx_INCREF(__pyx_t_2);
+    __Pyx_INCREF(__pyx_t_5);
+    #else
+    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 117, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 117, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    #endif
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  } else {
+    Py_ssize_t index = -1;
+    __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 117, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_6 = Py_TYPE(__pyx_t_3)->tp_iternext;
+    index = 0; __pyx_t_2 = __pyx_t_6(__pyx_t_3); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
+    __Pyx_GOTREF(__pyx_t_2);
+    index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_3); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
+    __Pyx_GOTREF(__pyx_t_5);
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_3), 2) < 0) __PYX_ERR(0, 117, __pyx_L1_error)
+    __pyx_t_6 = NULL;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    goto __pyx_L4_unpacking_done;
+    __pyx_L3_unpacking_failed:;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_6 = NULL;
+    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
+    __PYX_ERR(0, 117, __pyx_L1_error)
+    __pyx_L4_unpacking_done:;
+  }
+  __pyx_v_ns = __pyx_t_2;
+  __pyx_t_2 = 0;
+  __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_5);
+  __pyx_t_5 = 0;
 
-    /* "borg/platform/freebsd.pyx":104
- *     # older borg / attic versions did not prefix the namespace to the names.
- *     if name.startswith(prefix):
- *         name = name[len(prefix):]             # <<<<<<<<<<<<<<
- *     _setxattr_inner(func, path, name, value)
+  /* "borg/platform/freebsd.pyx":118
  * 
+ *     ns, name = split_ns(name, b"user")
+ *     try:             # <<<<<<<<<<<<<<
+ *         ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
+ *     except KeyError:
  */
-    __pyx_t_6 = PyBytes_GET_SIZE(__pyx_v_prefix); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 104, __pyx_L1_error)
-    __pyx_t_2 = __Pyx_PyObject_GetSlice(__pyx_v_name, __pyx_t_6, 0, NULL, NULL, NULL, 1, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 104, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_2);
-    __pyx_t_2 = 0;
+  {
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
+    __Pyx_XGOTREF(__pyx_t_7);
+    __Pyx_XGOTREF(__pyx_t_8);
+    __Pyx_XGOTREF(__pyx_t_9);
+    /*try:*/ {
 
-    /* "borg/platform/freebsd.pyx":103
- *     # strip namespace if there, but ignore if not there.
- *     # older borg / attic versions did not prefix the namespace to the names.
- *     if name.startswith(prefix):             # <<<<<<<<<<<<<<
- *         name = name[len(prefix):]
- *     _setxattr_inner(func, path, name, value)
+      /* "borg/platform/freebsd.pyx":119
+ *     ns, name = split_ns(name, b"user")
+ *     try:
+ *         ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported             # <<<<<<<<<<<<<<
+ *     except KeyError:
+ *         pass
  */
-  }
+      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_NS_ID_MAP); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 119, __pyx_L5_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_ns); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 119, __pyx_L5_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_GIVEREF(__pyx_t_5);
+      __pyx_cur_scope->__pyx_v_ns_id = __pyx_t_5;
+      __pyx_t_5 = 0;
+
+      /* "borg/platform/freebsd.pyx":118
+ * 
+ *     ns, name = split_ns(name, b"user")
+ *     try:             # <<<<<<<<<<<<<<
+ *         ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
+ *     except KeyError:
+ */
+    }
 
-  /* "borg/platform/freebsd.pyx":105
- *     if name.startswith(prefix):
- *         name = name[len(prefix):]
- *     _setxattr_inner(func, path, name, value)             # <<<<<<<<<<<<<<
+    /* "borg/platform/freebsd.pyx":123
+ *         pass
+ *     else:
+ *         _setxattr_inner(func, path, name, value)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_setxattr_inner); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 105, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = NULL;
-  __pyx_t_1 = 0;
-  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_1 = 1;
+    /*else:*/ {
+      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_setxattr_inner); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 123, __pyx_L7_except_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_2 = NULL;
+      __pyx_t_4 = 0;
+      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
+        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
+        if (likely(__pyx_t_2)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+          __Pyx_INCREF(__pyx_t_2);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_1, function);
+          __pyx_t_4 = 1;
+        }
+      }
+      #if CYTHON_FAST_PYCALL
+      if (PyFunction_Check(__pyx_t_1)) {
+        PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_v_func, __pyx_v_path, __pyx_v_name, __pyx_v_value};
+        __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_4, 4+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 123, __pyx_L7_except_error)
+        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __Pyx_GOTREF(__pyx_t_5);
+      } else
+      #endif
+      #if CYTHON_FAST_PYCCALL
+      if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
+        PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_v_func, __pyx_v_path, __pyx_v_name, __pyx_v_value};
+        __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_4, 4+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 123, __pyx_L7_except_error)
+        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __Pyx_GOTREF(__pyx_t_5);
+      } else
+      #endif
+      {
+        __pyx_t_3 = PyTuple_New(4+__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 123, __pyx_L7_except_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        if (__pyx_t_2) {
+          __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2); __pyx_t_2 = NULL;
+        }
+        __Pyx_INCREF(__pyx_v_func);
+        __Pyx_GIVEREF(__pyx_v_func);
+        PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_4, __pyx_v_func);
+        __Pyx_INCREF(__pyx_v_path);
+        __Pyx_GIVEREF(__pyx_v_path);
+        PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_4, __pyx_v_path);
+        __Pyx_INCREF(__pyx_v_name);
+        __Pyx_GIVEREF(__pyx_v_name);
+        PyTuple_SET_ITEM(__pyx_t_3, 2+__pyx_t_4, __pyx_v_name);
+        __Pyx_INCREF(__pyx_v_value);
+        __Pyx_GIVEREF(__pyx_v_value);
+        PyTuple_SET_ITEM(__pyx_t_3, 3+__pyx_t_4, __pyx_v_value);
+        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 123, __pyx_L7_except_error)
+        __Pyx_GOTREF(__pyx_t_5);
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      }
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     }
-  }
-  #if CYTHON_FAST_PYCALL
-  if (PyFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[5] = {__pyx_t_4, __pyx_v_func, __pyx_v_path, __pyx_v_name, __pyx_v_value};
-    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_1, 4+__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 105, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_GOTREF(__pyx_t_2);
-  } else
-  #endif
-  #if CYTHON_FAST_PYCCALL
-  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
-    PyObject *__pyx_temp[5] = {__pyx_t_4, __pyx_v_func, __pyx_v_path, __pyx_v_name, __pyx_v_value};
-    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_1, 4+__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 105, __pyx_L1_error)
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_GOTREF(__pyx_t_2);
-  } else
-  #endif
-  {
-    __pyx_t_7 = PyTuple_New(4+__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 105, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_7);
+    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
+    goto __pyx_L10_try_end;
+    __pyx_L5_error:;
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+
+    /* "borg/platform/freebsd.pyx":120
+ *     try:
+ *         ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
+ *     except KeyError:             # <<<<<<<<<<<<<<
+ *         pass
+ *     else:
+ */
+    __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_KeyError);
     if (__pyx_t_4) {
-      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
+      __Pyx_ErrRestore(0,0,0);
+      goto __pyx_L6_exception_handled;
     }
-    __Pyx_INCREF(__pyx_v_func);
-    __Pyx_GIVEREF(__pyx_v_func);
-    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_1, __pyx_v_func);
-    __Pyx_INCREF(__pyx_v_path);
-    __Pyx_GIVEREF(__pyx_v_path);
-    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_1, __pyx_v_path);
-    __Pyx_INCREF(__pyx_v_name);
-    __Pyx_GIVEREF(__pyx_v_name);
-    PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_1, __pyx_v_name);
-    __Pyx_INCREF(__pyx_v_value);
-    __Pyx_GIVEREF(__pyx_v_value);
-    PyTuple_SET_ITEM(__pyx_t_7, 3+__pyx_t_1, __pyx_v_value);
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 105, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+    goto __pyx_L7_except_error;
+    __pyx_L7_except_error:;
+
+    /* "borg/platform/freebsd.pyx":118
+ * 
+ *     ns, name = split_ns(name, b"user")
+ *     try:             # <<<<<<<<<<<<<<
+ *         ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
+ *     except KeyError:
+ */
+    __Pyx_XGIVEREF(__pyx_t_7);
+    __Pyx_XGIVEREF(__pyx_t_8);
+    __Pyx_XGIVEREF(__pyx_t_9);
+    __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
+    goto __pyx_L1_error;
+    __pyx_L6_exception_handled:;
+    __Pyx_XGIVEREF(__pyx_t_7);
+    __Pyx_XGIVEREF(__pyx_t_8);
+    __Pyx_XGIVEREF(__pyx_t_9);
+    __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
+    __pyx_L10_try_end:;
   }
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/platform/freebsd.pyx":89
+  /* "borg/platform/freebsd.pyx":107
  * 
  * 
  * def setxattr(path, name, value, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, value, size):
+ *         if isinstance(path, int):
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("borg.platform.freebsd.setxattr", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_prefix);
   __Pyx_XDECREF(__pyx_v_func);
+  __Pyx_XDECREF(__pyx_v_ns);
   __Pyx_XDECREF(__pyx_v_name);
   __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":108
+/* "borg/platform/freebsd.pyx":126
  * 
  * 
  * cdef _get_acl(p, type, item, attribute, flags, fd=None):             # <<<<<<<<<<<<<<
  *     cdef acl_t acl = NULL
  *     cdef char *text = NULL
  */
 
@@ -3439,160 +3944,160 @@
   __Pyx_RefNannySetupContext("_get_acl", 0);
   if (__pyx_optional_args) {
     if (__pyx_optional_args->__pyx_n > 0) {
       __pyx_v_fd = __pyx_optional_args->fd;
     }
   }
 
-  /* "borg/platform/freebsd.pyx":109
+  /* "borg/platform/freebsd.pyx":127
  * 
  * cdef _get_acl(p, type, item, attribute, flags, fd=None):
  *     cdef acl_t acl = NULL             # <<<<<<<<<<<<<<
  *     cdef char *text = NULL
  *     try:
  */
   __pyx_v_acl = NULL;
 
-  /* "borg/platform/freebsd.pyx":110
+  /* "borg/platform/freebsd.pyx":128
  * cdef _get_acl(p, type, item, attribute, flags, fd=None):
  *     cdef acl_t acl = NULL
  *     cdef char *text = NULL             # <<<<<<<<<<<<<<
  *     try:
  *         if fd is not None:
  */
   __pyx_v_text = NULL;
 
-  /* "borg/platform/freebsd.pyx":111
+  /* "borg/platform/freebsd.pyx":129
  *     cdef acl_t acl = NULL
  *     cdef char *text = NULL
  *     try:             # <<<<<<<<<<<<<<
  *         if fd is not None:
  *             acl = acl_get_fd_np(fd, type)
  */
   /*try:*/ {
 
-    /* "borg/platform/freebsd.pyx":112
+    /* "borg/platform/freebsd.pyx":130
  *     cdef char *text = NULL
  *     try:
  *         if fd is not None:             # <<<<<<<<<<<<<<
  *             acl = acl_get_fd_np(fd, type)
  *         else:
  */
     __pyx_t_1 = (__pyx_v_fd != Py_None);
     __pyx_t_2 = (__pyx_t_1 != 0);
     if (__pyx_t_2) {
 
-      /* "borg/platform/freebsd.pyx":113
+      /* "borg/platform/freebsd.pyx":131
  *     try:
  *         if fd is not None:
  *             acl = acl_get_fd_np(fd, type)             # <<<<<<<<<<<<<<
  *         else:
  *             acl = acl_get_link_np(p, type)
  */
-      __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_fd); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 113, __pyx_L4_error)
-      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_v_type); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 113, __pyx_L4_error)
+      __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_fd); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 131, __pyx_L4_error)
+      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_v_type); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 131, __pyx_L4_error)
       __pyx_v_acl = acl_get_fd_np(__pyx_t_3, __pyx_t_4);
 
-      /* "borg/platform/freebsd.pyx":112
+      /* "borg/platform/freebsd.pyx":130
  *     cdef char *text = NULL
  *     try:
  *         if fd is not None:             # <<<<<<<<<<<<<<
  *             acl = acl_get_fd_np(fd, type)
  *         else:
  */
       goto __pyx_L6;
     }
 
-    /* "borg/platform/freebsd.pyx":115
+    /* "borg/platform/freebsd.pyx":133
  *             acl = acl_get_fd_np(fd, type)
  *         else:
  *             acl = acl_get_link_np(p, type)             # <<<<<<<<<<<<<<
  *         if acl is not NULL:
  *             text = acl_to_text_np(acl, NULL, flags)
  */
     /*else*/ {
-      __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_p); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 115, __pyx_L4_error)
-      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_v_type); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 115, __pyx_L4_error)
+      __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_p); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 133, __pyx_L4_error)
+      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_v_type); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 133, __pyx_L4_error)
       __pyx_v_acl = acl_get_link_np(__pyx_t_5, __pyx_t_4);
     }
     __pyx_L6:;
 
-    /* "borg/platform/freebsd.pyx":116
+    /* "borg/platform/freebsd.pyx":134
  *         else:
  *             acl = acl_get_link_np(p, type)
  *         if acl is not NULL:             # <<<<<<<<<<<<<<
  *             text = acl_to_text_np(acl, NULL, flags)
  *             if text is not NULL:
  */
     __pyx_t_2 = ((__pyx_v_acl != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "borg/platform/freebsd.pyx":117
+      /* "borg/platform/freebsd.pyx":135
  *             acl = acl_get_link_np(p, type)
  *         if acl is not NULL:
  *             text = acl_to_text_np(acl, NULL, flags)             # <<<<<<<<<<<<<<
  *             if text is not NULL:
  *                 item[attribute] = text
  */
-      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_v_flags); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 117, __pyx_L4_error)
+      __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_v_flags); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 135, __pyx_L4_error)
       __pyx_v_text = acl_to_text_np(__pyx_v_acl, NULL, __pyx_t_4);
 
-      /* "borg/platform/freebsd.pyx":118
+      /* "borg/platform/freebsd.pyx":136
  *         if acl is not NULL:
  *             text = acl_to_text_np(acl, NULL, flags)
  *             if text is not NULL:             # <<<<<<<<<<<<<<
  *                 item[attribute] = text
  *     finally:
  */
       __pyx_t_2 = ((__pyx_v_text != NULL) != 0);
       if (__pyx_t_2) {
 
-        /* "borg/platform/freebsd.pyx":119
+        /* "borg/platform/freebsd.pyx":137
  *             text = acl_to_text_np(acl, NULL, flags)
  *             if text is not NULL:
  *                 item[attribute] = text             # <<<<<<<<<<<<<<
  *     finally:
  *         acl_free(text)
  */
-        __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_text); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 119, __pyx_L4_error)
+        __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_text); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 137, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_6);
-        if (unlikely(PyObject_SetItem(__pyx_v_item, __pyx_v_attribute, __pyx_t_6) < 0)) __PYX_ERR(0, 119, __pyx_L4_error)
+        if (unlikely(PyObject_SetItem(__pyx_v_item, __pyx_v_attribute, __pyx_t_6) < 0)) __PYX_ERR(0, 137, __pyx_L4_error)
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-        /* "borg/platform/freebsd.pyx":118
+        /* "borg/platform/freebsd.pyx":136
  *         if acl is not NULL:
  *             text = acl_to_text_np(acl, NULL, flags)
  *             if text is not NULL:             # <<<<<<<<<<<<<<
  *                 item[attribute] = text
  *     finally:
  */
       }
 
-      /* "borg/platform/freebsd.pyx":116
+      /* "borg/platform/freebsd.pyx":134
  *         else:
  *             acl = acl_get_link_np(p, type)
  *         if acl is not NULL:             # <<<<<<<<<<<<<<
  *             text = acl_to_text_np(acl, NULL, flags)
  *             if text is not NULL:
  */
     }
   }
 
-  /* "borg/platform/freebsd.pyx":121
+  /* "borg/platform/freebsd.pyx":139
  *                 item[attribute] = text
  *     finally:
  *         acl_free(text)             # <<<<<<<<<<<<<<
  *         acl_free(acl)
  * 
  */
   /*finally:*/ {
     /*normal exit:*/{
       (void)(acl_free(__pyx_v_text));
 
-      /* "borg/platform/freebsd.pyx":122
+      /* "borg/platform/freebsd.pyx":140
  *     finally:
  *         acl_free(text)
  *         acl_free(acl)             # <<<<<<<<<<<<<<
  * 
  * 
  */
       (void)(acl_free(__pyx_v_acl));
@@ -3611,24 +4116,24 @@
       __Pyx_XGOTREF(__pyx_t_10);
       __Pyx_XGOTREF(__pyx_t_11);
       __Pyx_XGOTREF(__pyx_t_12);
       __Pyx_XGOTREF(__pyx_t_13);
       __pyx_t_4 = __pyx_lineno; __pyx_t_3 = __pyx_clineno; __pyx_t_7 = __pyx_filename;
       {
 
-        /* "borg/platform/freebsd.pyx":121
+        /* "borg/platform/freebsd.pyx":139
  *                 item[attribute] = text
  *     finally:
  *         acl_free(text)             # <<<<<<<<<<<<<<
  *         acl_free(acl)
  * 
  */
         (void)(acl_free(__pyx_v_text));
 
-        /* "borg/platform/freebsd.pyx":122
+        /* "borg/platform/freebsd.pyx":140
  *     finally:
  *         acl_free(text)
  *         acl_free(acl)             # <<<<<<<<<<<<<<
  * 
  * 
  */
         (void)(acl_free(__pyx_v_acl));
@@ -3646,15 +4151,15 @@
       __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0;
       __pyx_lineno = __pyx_t_4; __pyx_clineno = __pyx_t_3; __pyx_filename = __pyx_t_7;
       goto __pyx_L1_error;
     }
     __pyx_L5:;
   }
 
-  /* "borg/platform/freebsd.pyx":108
+  /* "borg/platform/freebsd.pyx":126
  * 
  * 
  * cdef _get_acl(p, type, item, attribute, flags, fd=None):             # <<<<<<<<<<<<<<
  *     cdef acl_t acl = NULL
  *     cdef char *text = NULL
  */
 
@@ -3667,27 +4172,27 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":125
+/* "borg/platform/freebsd.pyx":143
  * 
  * 
  * def acl_get(path, item, st, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     """Saves ACL Entries
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_7acl_get(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_4borg_8platform_7freebsd_6acl_get[] = "Saves ACL Entries\n\n    If `numeric_ids` is True the user/group field is not preserved only uid/gid\n    ";
-static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_7acl_get = {"acl_get", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_7acl_get, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4borg_8platform_7freebsd_6acl_get};
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_7acl_get(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_9acl_get(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_4borg_8platform_7freebsd_8acl_get[] = "Saves ACL Entries\n\n    If `numeric_ids` is True the user/group field is not preserved only uid/gid\n    ";
+static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_9acl_get = {"acl_get", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_9acl_get, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4borg_8platform_7freebsd_8acl_get};
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_9acl_get(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_path = 0;
   PyObject *__pyx_v_item = 0;
   CYTHON_UNUSED PyObject *__pyx_v_st = 0;
   PyObject *__pyx_v_numeric_ids = 0;
   PyObject *__pyx_v_fd = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
@@ -3722,21 +4227,21 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_item)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("acl_get", 0, 3, 5, 1); __PYX_ERR(0, 125, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("acl_get", 0, 3, 5, 1); __PYX_ERR(0, 143, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_st)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("acl_get", 0, 3, 5, 2); __PYX_ERR(0, 125, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("acl_get", 0, 3, 5, 2); __PYX_ERR(0, 143, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_numeric_ids);
           if (value) { values[3] = value; kw_args--; }
         }
@@ -3744,15 +4249,15 @@
         case  4:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fd);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "acl_get") < 0)) __PYX_ERR(0, 125, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "acl_get") < 0)) __PYX_ERR(0, 143, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -3767,28 +4272,28 @@
     __pyx_v_item = values[1];
     __pyx_v_st = values[2];
     __pyx_v_numeric_ids = values[3];
     __pyx_v_fd = values[4];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("acl_get", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 125, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("acl_get", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 143, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.platform.freebsd.acl_get", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_6acl_get(__pyx_self, __pyx_v_path, __pyx_v_item, __pyx_v_st, __pyx_v_numeric_ids, __pyx_v_fd);
+  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_8acl_get(__pyx_self, __pyx_v_path, __pyx_v_item, __pyx_v_st, __pyx_v_numeric_ids, __pyx_v_fd);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_6acl_get(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item, CYTHON_UNUSED PyObject *__pyx_v_st, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_fd) {
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_8acl_get(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item, CYTHON_UNUSED PyObject *__pyx_v_st, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_fd) {
   int __pyx_v_flags;
   long __pyx_v_ret;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
@@ -3799,84 +4304,84 @@
   struct __pyx_opt_args_4borg_8platform_7freebsd__get_acl __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("acl_get", 0);
   __Pyx_INCREF(__pyx_v_path);
 
-  /* "borg/platform/freebsd.pyx":130
+  /* "borg/platform/freebsd.pyx":148
  *     If `numeric_ids` is True the user/group field is not preserved only uid/gid
  *     """
  *     cdef int flags = ACL_TEXT_APPEND_ID             # <<<<<<<<<<<<<<
  *     if isinstance(path, str):
  *         path = os.fsencode(path)
  */
   __pyx_v_flags = ACL_TEXT_APPEND_ID;
 
-  /* "borg/platform/freebsd.pyx":131
+  /* "borg/platform/freebsd.pyx":149
  *     """
  *     cdef int flags = ACL_TEXT_APPEND_ID
  *     if isinstance(path, str):             # <<<<<<<<<<<<<<
  *         path = os.fsencode(path)
  *     ret = lpathconf(path, _PC_ACL_NFS4)
  */
   __pyx_t_1 = PyString_Check(__pyx_v_path); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/platform/freebsd.pyx":132
+    /* "borg/platform/freebsd.pyx":150
  *     cdef int flags = ACL_TEXT_APPEND_ID
  *     if isinstance(path, str):
  *         path = os.fsencode(path)             # <<<<<<<<<<<<<<
  *     ret = lpathconf(path, _PC_ACL_NFS4)
  *     if ret < 0 and errno == EINVAL:
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 132, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 150, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_fsencode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 132, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_fsencode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 150, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_path) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_path);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 132, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 150, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_path, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "borg/platform/freebsd.pyx":131
+    /* "borg/platform/freebsd.pyx":149
  *     """
  *     cdef int flags = ACL_TEXT_APPEND_ID
  *     if isinstance(path, str):             # <<<<<<<<<<<<<<
  *         path = os.fsencode(path)
  *     ret = lpathconf(path, _PC_ACL_NFS4)
  */
   }
 
-  /* "borg/platform/freebsd.pyx":133
+  /* "borg/platform/freebsd.pyx":151
  *     if isinstance(path, str):
  *         path = os.fsencode(path)
  *     ret = lpathconf(path, _PC_ACL_NFS4)             # <<<<<<<<<<<<<<
  *     if ret < 0 and errno == EINVAL:
  *         return
  */
-  __pyx_t_6 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 133, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 151, __pyx_L1_error)
   __pyx_v_ret = lpathconf(__pyx_t_6, _PC_ACL_NFS4);
 
-  /* "borg/platform/freebsd.pyx":134
+  /* "borg/platform/freebsd.pyx":152
  *         path = os.fsencode(path)
  *     ret = lpathconf(path, _PC_ACL_NFS4)
  *     if ret < 0 and errno == EINVAL:             # <<<<<<<<<<<<<<
  *         return
  *     flags |= ACL_TEXT_NUMERIC_IDS if numeric_ids else 0
  */
   __pyx_t_1 = ((__pyx_v_ret < 0) != 0);
@@ -3886,130 +4391,130 @@
     goto __pyx_L5_bool_binop_done;
   }
   __pyx_t_1 = ((errno == EINVAL) != 0);
   __pyx_t_2 = __pyx_t_1;
   __pyx_L5_bool_binop_done:;
   if (__pyx_t_2) {
 
-    /* "borg/platform/freebsd.pyx":135
+    /* "borg/platform/freebsd.pyx":153
  *     ret = lpathconf(path, _PC_ACL_NFS4)
  *     if ret < 0 and errno == EINVAL:
  *         return             # <<<<<<<<<<<<<<
  *     flags |= ACL_TEXT_NUMERIC_IDS if numeric_ids else 0
  *     if ret > 0:
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "borg/platform/freebsd.pyx":134
+    /* "borg/platform/freebsd.pyx":152
  *         path = os.fsencode(path)
  *     ret = lpathconf(path, _PC_ACL_NFS4)
  *     if ret < 0 and errno == EINVAL:             # <<<<<<<<<<<<<<
  *         return
  *     flags |= ACL_TEXT_NUMERIC_IDS if numeric_ids else 0
  */
   }
 
-  /* "borg/platform/freebsd.pyx":136
+  /* "borg/platform/freebsd.pyx":154
  *     if ret < 0 and errno == EINVAL:
  *         return
  *     flags |= ACL_TEXT_NUMERIC_IDS if numeric_ids else 0             # <<<<<<<<<<<<<<
  *     if ret > 0:
  *         _get_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', flags, fd=fd)
  */
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_numeric_ids); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 136, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_numeric_ids); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 154, __pyx_L1_error)
   if (__pyx_t_2) {
     __pyx_t_7 = ACL_TEXT_NUMERIC_IDS;
   } else {
     __pyx_t_7 = 0;
   }
   __pyx_v_flags = (__pyx_v_flags | __pyx_t_7);
 
-  /* "borg/platform/freebsd.pyx":137
+  /* "borg/platform/freebsd.pyx":155
  *         return
  *     flags |= ACL_TEXT_NUMERIC_IDS if numeric_ids else 0
  *     if ret > 0:             # <<<<<<<<<<<<<<
  *         _get_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', flags, fd=fd)
  *     else:
  */
   __pyx_t_2 = ((__pyx_v_ret > 0) != 0);
   if (__pyx_t_2) {
 
-    /* "borg/platform/freebsd.pyx":138
+    /* "borg/platform/freebsd.pyx":156
  *     flags |= ACL_TEXT_NUMERIC_IDS if numeric_ids else 0
  *     if ret > 0:
  *         _get_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', flags, fd=fd)             # <<<<<<<<<<<<<<
  *     else:
  *         _get_acl(path, ACL_TYPE_ACCESS, item, 'acl_access', flags, fd=fd)
  */
-    __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_NFS4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 138, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_NFS4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 156, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 138, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 156, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_8.__pyx_n = 1;
     __pyx_t_8.fd = __pyx_v_fd;
-    __pyx_t_4 = __pyx_f_4borg_8platform_7freebsd__get_acl(__pyx_v_path, __pyx_t_3, __pyx_v_item, __pyx_n_s_acl_nfs4, __pyx_t_5, &__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 138, __pyx_L1_error)
+    __pyx_t_4 = __pyx_f_4borg_8platform_7freebsd__get_acl(__pyx_v_path, __pyx_t_3, __pyx_v_item, __pyx_n_s_acl_nfs4, __pyx_t_5, &__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 156, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "borg/platform/freebsd.pyx":137
+    /* "borg/platform/freebsd.pyx":155
  *         return
  *     flags |= ACL_TEXT_NUMERIC_IDS if numeric_ids else 0
  *     if ret > 0:             # <<<<<<<<<<<<<<
  *         _get_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', flags, fd=fd)
  *     else:
  */
     goto __pyx_L7;
   }
 
-  /* "borg/platform/freebsd.pyx":140
+  /* "borg/platform/freebsd.pyx":158
  *         _get_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', flags, fd=fd)
  *     else:
  *         _get_acl(path, ACL_TYPE_ACCESS, item, 'acl_access', flags, fd=fd)             # <<<<<<<<<<<<<<
  *         _get_acl(path, ACL_TYPE_DEFAULT, item, 'acl_default', flags, fd=fd)
  * 
  */
   /*else*/ {
-    __pyx_t_4 = __Pyx_PyInt_From_int(ACL_TYPE_ACCESS); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 140, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_int(ACL_TYPE_ACCESS); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 158, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 140, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 158, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_8.__pyx_n = 1;
     __pyx_t_8.fd = __pyx_v_fd;
-    __pyx_t_3 = __pyx_f_4borg_8platform_7freebsd__get_acl(__pyx_v_path, __pyx_t_4, __pyx_v_item, __pyx_n_s_acl_access, __pyx_t_5, &__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 140, __pyx_L1_error)
+    __pyx_t_3 = __pyx_f_4borg_8platform_7freebsd__get_acl(__pyx_v_path, __pyx_t_4, __pyx_v_item, __pyx_n_s_acl_access, __pyx_t_5, &__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 158, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "borg/platform/freebsd.pyx":141
+    /* "borg/platform/freebsd.pyx":159
  *     else:
  *         _get_acl(path, ACL_TYPE_ACCESS, item, 'acl_access', flags, fd=fd)
  *         _get_acl(path, ACL_TYPE_DEFAULT, item, 'acl_default', flags, fd=fd)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_DEFAULT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 141, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_DEFAULT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 159, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 141, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 159, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __pyx_t_8.__pyx_n = 1;
     __pyx_t_8.fd = __pyx_v_fd;
-    __pyx_t_4 = __pyx_f_4borg_8platform_7freebsd__get_acl(__pyx_v_path, __pyx_t_3, __pyx_v_item, __pyx_n_s_acl_default, __pyx_t_5, &__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 141, __pyx_L1_error)
+    __pyx_t_4 = __pyx_f_4borg_8platform_7freebsd__get_acl(__pyx_v_path, __pyx_t_3, __pyx_v_item, __pyx_n_s_acl_default, __pyx_t_5, &__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 159, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
   __pyx_L7:;
 
-  /* "borg/platform/freebsd.pyx":125
+  /* "borg/platform/freebsd.pyx":143
  * 
  * 
  * def acl_get(path, item, st, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     """Saves ACL Entries
  * 
  */
 
@@ -4025,15 +4530,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_path);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":144
+/* "borg/platform/freebsd.pyx":162
  * 
  * 
  * cdef _set_acl(path, type, item, attribute, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     cdef acl_t acl = NULL
  *     text = item.get(attribute)
  */
 
@@ -4070,273 +4575,273 @@
       __pyx_v_numeric_ids = __pyx_optional_args->numeric_ids;
       if (__pyx_optional_args->__pyx_n > 1) {
         __pyx_v_fd = __pyx_optional_args->fd;
       }
     }
   }
 
-  /* "borg/platform/freebsd.pyx":145
+  /* "borg/platform/freebsd.pyx":163
  * 
  * cdef _set_acl(path, type, item, attribute, numeric_ids=False, fd=None):
  *     cdef acl_t acl = NULL             # <<<<<<<<<<<<<<
  *     text = item.get(attribute)
  *     if text is not None:
  */
   __pyx_v_acl = NULL;
 
-  /* "borg/platform/freebsd.pyx":146
+  /* "borg/platform/freebsd.pyx":164
  * cdef _set_acl(path, type, item, attribute, numeric_ids=False, fd=None):
  *     cdef acl_t acl = NULL
  *     text = item.get(attribute)             # <<<<<<<<<<<<<<
  *     if text is not None:
  *         if numeric_ids and type == ACL_TYPE_NFS4:
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_item, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_item, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 164, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_attribute) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_attribute);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 164, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_text = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "borg/platform/freebsd.pyx":147
+  /* "borg/platform/freebsd.pyx":165
  *     cdef acl_t acl = NULL
  *     text = item.get(attribute)
  *     if text is not None:             # <<<<<<<<<<<<<<
  *         if numeric_ids and type == ACL_TYPE_NFS4:
  *             text = _nfs4_use_stored_uid_gid(text)
  */
   __pyx_t_4 = (__pyx_v_text != Py_None);
   __pyx_t_5 = (__pyx_t_4 != 0);
   if (__pyx_t_5) {
 
-    /* "borg/platform/freebsd.pyx":148
+    /* "borg/platform/freebsd.pyx":166
  *     text = item.get(attribute)
  *     if text is not None:
  *         if numeric_ids and type == ACL_TYPE_NFS4:             # <<<<<<<<<<<<<<
  *             text = _nfs4_use_stored_uid_gid(text)
  *         elif numeric_ids and type in (ACL_TYPE_ACCESS, ACL_TYPE_DEFAULT):
  */
-    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_numeric_ids); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 148, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_numeric_ids); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 166, __pyx_L1_error)
     if (__pyx_t_4) {
     } else {
       __pyx_t_5 = __pyx_t_4;
       goto __pyx_L5_bool_binop_done;
     }
-    __pyx_t_1 = __Pyx_PyInt_From_int(ACL_TYPE_NFS4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 148, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyInt_From_int(ACL_TYPE_NFS4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 166, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = PyObject_RichCompare(__pyx_v_type, __pyx_t_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 148, __pyx_L1_error)
+    __pyx_t_2 = PyObject_RichCompare(__pyx_v_type, __pyx_t_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 166, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 148, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 166, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_5 = __pyx_t_4;
     __pyx_L5_bool_binop_done:;
     if (__pyx_t_5) {
 
-      /* "borg/platform/freebsd.pyx":149
+      /* "borg/platform/freebsd.pyx":167
  *     if text is not None:
  *         if numeric_ids and type == ACL_TYPE_NFS4:
  *             text = _nfs4_use_stored_uid_gid(text)             # <<<<<<<<<<<<<<
  *         elif numeric_ids and type in (ACL_TYPE_ACCESS, ACL_TYPE_DEFAULT):
  *             text = posix_acl_use_stored_uid_gid(text)
  */
-      __pyx_t_2 = __pyx_f_4borg_8platform_7freebsd__nfs4_use_stored_uid_gid(__pyx_v_text); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 149, __pyx_L1_error)
+      __pyx_t_2 = __pyx_f_4borg_8platform_7freebsd__nfs4_use_stored_uid_gid(__pyx_v_text); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 167, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF_SET(__pyx_v_text, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/platform/freebsd.pyx":148
+      /* "borg/platform/freebsd.pyx":166
  *     text = item.get(attribute)
  *     if text is not None:
  *         if numeric_ids and type == ACL_TYPE_NFS4:             # <<<<<<<<<<<<<<
  *             text = _nfs4_use_stored_uid_gid(text)
  *         elif numeric_ids and type in (ACL_TYPE_ACCESS, ACL_TYPE_DEFAULT):
  */
       goto __pyx_L4;
     }
 
-    /* "borg/platform/freebsd.pyx":150
+    /* "borg/platform/freebsd.pyx":168
  *         if numeric_ids and type == ACL_TYPE_NFS4:
  *             text = _nfs4_use_stored_uid_gid(text)
  *         elif numeric_ids and type in (ACL_TYPE_ACCESS, ACL_TYPE_DEFAULT):             # <<<<<<<<<<<<<<
  *             text = posix_acl_use_stored_uid_gid(text)
  *         try:
  */
-    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_numeric_ids); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_numeric_ids); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 168, __pyx_L1_error)
     if (__pyx_t_4) {
     } else {
       __pyx_t_5 = __pyx_t_4;
       goto __pyx_L7_bool_binop_done;
     }
     __Pyx_INCREF(__pyx_v_type);
     __pyx_t_2 = __pyx_v_type;
-    __pyx_t_1 = __Pyx_PyInt_From_int(ACL_TYPE_ACCESS); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyInt_From_int(ACL_TYPE_ACCESS); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_t_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_t_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 168, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 168, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     if (!__pyx_t_6) {
     } else {
       __pyx_t_4 = __pyx_t_6;
       goto __pyx_L9_bool_binop_done;
     }
-    __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_DEFAULT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_DEFAULT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 168, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 = PyObject_RichCompare(__pyx_t_2, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_1 = PyObject_RichCompare(__pyx_t_2, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 168, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __pyx_t_4 = __pyx_t_6;
     __pyx_L9_bool_binop_done:;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_6 = (__pyx_t_4 != 0);
     __pyx_t_5 = __pyx_t_6;
     __pyx_L7_bool_binop_done:;
     if (__pyx_t_5) {
 
-      /* "borg/platform/freebsd.pyx":151
+      /* "borg/platform/freebsd.pyx":169
  *             text = _nfs4_use_stored_uid_gid(text)
  *         elif numeric_ids and type in (ACL_TYPE_ACCESS, ACL_TYPE_DEFAULT):
  *             text = posix_acl_use_stored_uid_gid(text)             # <<<<<<<<<<<<<<
  *         try:
  *             acl = acl_from_text(<bytes> text)
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_posix_acl_use_stored_uid_gid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 151, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_posix_acl_use_stored_uid_gid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 169, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __pyx_t_3 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
         __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
         if (likely(__pyx_t_3)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
           __Pyx_INCREF(__pyx_t_3);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_1, function);
         }
       }
       __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_text) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_text);
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 151, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 169, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_DECREF_SET(__pyx_v_text, __pyx_t_2);
       __pyx_t_2 = 0;
 
-      /* "borg/platform/freebsd.pyx":150
+      /* "borg/platform/freebsd.pyx":168
  *         if numeric_ids and type == ACL_TYPE_NFS4:
  *             text = _nfs4_use_stored_uid_gid(text)
  *         elif numeric_ids and type in (ACL_TYPE_ACCESS, ACL_TYPE_DEFAULT):             # <<<<<<<<<<<<<<
  *             text = posix_acl_use_stored_uid_gid(text)
  *         try:
  */
     }
     __pyx_L4:;
 
-    /* "borg/platform/freebsd.pyx":152
+    /* "borg/platform/freebsd.pyx":170
  *         elif numeric_ids and type in (ACL_TYPE_ACCESS, ACL_TYPE_DEFAULT):
  *             text = posix_acl_use_stored_uid_gid(text)
  *         try:             # <<<<<<<<<<<<<<
  *             acl = acl_from_text(<bytes> text)
  *             if acl is not NULL:
  */
     /*try:*/ {
 
-      /* "borg/platform/freebsd.pyx":153
+      /* "borg/platform/freebsd.pyx":171
  *             text = posix_acl_use_stored_uid_gid(text)
  *         try:
  *             acl = acl_from_text(<bytes> text)             # <<<<<<<<<<<<<<
  *             if acl is not NULL:
  *                 if fd is not None:
  */
       if (unlikely(__pyx_v_text == Py_None)) {
         PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-        __PYX_ERR(0, 153, __pyx_L12_error)
+        __PYX_ERR(0, 171, __pyx_L12_error)
       }
-      __pyx_t_7 = __Pyx_PyBytes_AsString(__pyx_v_text); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(0, 153, __pyx_L12_error)
+      __pyx_t_7 = __Pyx_PyBytes_AsString(__pyx_v_text); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(0, 171, __pyx_L12_error)
       __pyx_v_acl = acl_from_text(__pyx_t_7);
 
-      /* "borg/platform/freebsd.pyx":154
+      /* "borg/platform/freebsd.pyx":172
  *         try:
  *             acl = acl_from_text(<bytes> text)
  *             if acl is not NULL:             # <<<<<<<<<<<<<<
  *                 if fd is not None:
  *                     acl_set_fd_np(fd, acl, type)
  */
       __pyx_t_5 = ((__pyx_v_acl != NULL) != 0);
       if (__pyx_t_5) {
 
-        /* "borg/platform/freebsd.pyx":155
+        /* "borg/platform/freebsd.pyx":173
  *             acl = acl_from_text(<bytes> text)
  *             if acl is not NULL:
  *                 if fd is not None:             # <<<<<<<<<<<<<<
  *                     acl_set_fd_np(fd, acl, type)
  *                 else:
  */
         __pyx_t_5 = (__pyx_v_fd != Py_None);
         __pyx_t_6 = (__pyx_t_5 != 0);
         if (__pyx_t_6) {
 
-          /* "borg/platform/freebsd.pyx":156
+          /* "borg/platform/freebsd.pyx":174
  *             if acl is not NULL:
  *                 if fd is not None:
  *                     acl_set_fd_np(fd, acl, type)             # <<<<<<<<<<<<<<
  *                 else:
  *                     acl_set_link_np(path, type, acl)
  */
-          __pyx_t_8 = __Pyx_PyInt_As_int(__pyx_v_fd); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 156, __pyx_L12_error)
-          __pyx_t_9 = __Pyx_PyInt_As_int(__pyx_v_type); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 156, __pyx_L12_error)
+          __pyx_t_8 = __Pyx_PyInt_As_int(__pyx_v_fd); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 174, __pyx_L12_error)
+          __pyx_t_9 = __Pyx_PyInt_As_int(__pyx_v_type); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 174, __pyx_L12_error)
           (void)(acl_set_fd_np(__pyx_t_8, __pyx_v_acl, __pyx_t_9));
 
-          /* "borg/platform/freebsd.pyx":155
+          /* "borg/platform/freebsd.pyx":173
  *             acl = acl_from_text(<bytes> text)
  *             if acl is not NULL:
  *                 if fd is not None:             # <<<<<<<<<<<<<<
  *                     acl_set_fd_np(fd, acl, type)
  *                 else:
  */
           goto __pyx_L15;
         }
 
-        /* "borg/platform/freebsd.pyx":158
+        /* "borg/platform/freebsd.pyx":176
  *                     acl_set_fd_np(fd, acl, type)
  *                 else:
  *                     acl_set_link_np(path, type, acl)             # <<<<<<<<<<<<<<
  *         finally:
  *             acl_free(acl)
  */
         /*else*/ {
-          __pyx_t_10 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 158, __pyx_L12_error)
-          __pyx_t_9 = __Pyx_PyInt_As_int(__pyx_v_type); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 158, __pyx_L12_error)
+          __pyx_t_10 = __Pyx_PyObject_AsString(__pyx_v_path); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) __PYX_ERR(0, 176, __pyx_L12_error)
+          __pyx_t_9 = __Pyx_PyInt_As_int(__pyx_v_type); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 176, __pyx_L12_error)
           (void)(acl_set_link_np(__pyx_t_10, __pyx_t_9, __pyx_v_acl));
         }
         __pyx_L15:;
 
-        /* "borg/platform/freebsd.pyx":154
+        /* "borg/platform/freebsd.pyx":172
  *         try:
  *             acl = acl_from_text(<bytes> text)
  *             if acl is not NULL:             # <<<<<<<<<<<<<<
  *                 if fd is not None:
  *                     acl_set_fd_np(fd, acl, type)
  */
       }
     }
 
-    /* "borg/platform/freebsd.pyx":160
+    /* "borg/platform/freebsd.pyx":178
  *                     acl_set_link_np(path, type, acl)
  *         finally:
  *             acl_free(acl)             # <<<<<<<<<<<<<<
  * 
  * 
  */
     /*finally:*/ {
@@ -4377,24 +4882,24 @@
         __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0; __pyx_t_17 = 0;
         __pyx_lineno = __pyx_t_9; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_11;
         goto __pyx_L1_error;
       }
       __pyx_L13:;
     }
 
-    /* "borg/platform/freebsd.pyx":147
+    /* "borg/platform/freebsd.pyx":165
  *     cdef acl_t acl = NULL
  *     text = item.get(attribute)
  *     if text is not None:             # <<<<<<<<<<<<<<
  *         if numeric_ids and type == ACL_TYPE_NFS4:
  *             text = _nfs4_use_stored_uid_gid(text)
  */
   }
 
-  /* "borg/platform/freebsd.pyx":144
+  /* "borg/platform/freebsd.pyx":162
  * 
  * 
  * cdef _set_acl(path, type, item, attribute, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     cdef acl_t acl = NULL
  *     text = item.get(attribute)
  */
 
@@ -4410,15 +4915,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_text);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":163
+/* "borg/platform/freebsd.pyx":181
  * 
  * 
  * cdef _nfs4_use_stored_uid_gid(acl):             # <<<<<<<<<<<<<<
  *     """Replace the user/group field with the stored uid/gid
  *     """
  */
 
@@ -4439,330 +4944,330 @@
   PyObject *__pyx_t_9 = NULL;
   int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_nfs4_use_stored_uid_gid", 0);
 
-  /* "borg/platform/freebsd.pyx":166
+  /* "borg/platform/freebsd.pyx":184
  *     """Replace the user/group field with the stored uid/gid
  *     """
  *     assert isinstance(acl, bytes)             # <<<<<<<<<<<<<<
  *     entries = []
  *     for entry in safe_decode(acl).split('\n'):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_1 = PyBytes_Check(__pyx_v_acl); 
     if (unlikely(!(__pyx_t_1 != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(0, 166, __pyx_L1_error)
+      __PYX_ERR(0, 184, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "borg/platform/freebsd.pyx":167
+  /* "borg/platform/freebsd.pyx":185
  *     """
  *     assert isinstance(acl, bytes)
  *     entries = []             # <<<<<<<<<<<<<<
  *     for entry in safe_decode(acl).split('\n'):
  *         if entry:
  */
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 167, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 185, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_v_entries = ((PyObject*)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "borg/platform/freebsd.pyx":168
+  /* "borg/platform/freebsd.pyx":186
  *     assert isinstance(acl, bytes)
  *     entries = []
  *     for entry in safe_decode(acl).split('\n'):             # <<<<<<<<<<<<<<
  *         if entry:
  *             if entry.startswith('user:') or entry.startswith('group:'):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_safe_decode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 168, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_safe_decode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_acl) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_acl);
   __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 168, __pyx_L1_error)
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_split); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 168, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_split); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
-  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_kp_s__7) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_kp_s__7);
+  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_kp_s__9) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_kp_s__9);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 168, __pyx_L1_error)
+  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
     __pyx_t_4 = __pyx_t_2; __Pyx_INCREF(__pyx_t_4); __pyx_t_6 = 0;
     __pyx_t_7 = NULL;
   } else {
-    __pyx_t_6 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 168, __pyx_L1_error)
+    __pyx_t_6 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 186, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_7 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 168, __pyx_L1_error)
+    __pyx_t_7 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 186, __pyx_L1_error)
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   for (;;) {
     if (likely(!__pyx_t_7)) {
       if (likely(PyList_CheckExact(__pyx_t_4))) {
         if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 168, __pyx_L1_error)
+        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 186, __pyx_L1_error)
         #else
-        __pyx_t_2 = PySequence_ITEM(__pyx_t_4, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 168, __pyx_L1_error)
+        __pyx_t_2 = PySequence_ITEM(__pyx_t_4, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         #endif
       } else {
         if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 168, __pyx_L1_error)
+        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 186, __pyx_L1_error)
         #else
-        __pyx_t_2 = PySequence_ITEM(__pyx_t_4, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 168, __pyx_L1_error)
+        __pyx_t_2 = PySequence_ITEM(__pyx_t_4, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         #endif
       }
     } else {
       __pyx_t_2 = __pyx_t_7(__pyx_t_4);
       if (unlikely(!__pyx_t_2)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 168, __pyx_L1_error)
+          else __PYX_ERR(0, 186, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_2);
     }
     __Pyx_XDECREF_SET(__pyx_v_entry, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "borg/platform/freebsd.pyx":169
+    /* "borg/platform/freebsd.pyx":187
  *     entries = []
  *     for entry in safe_decode(acl).split('\n'):
  *         if entry:             # <<<<<<<<<<<<<<
  *             if entry.startswith('user:') or entry.startswith('group:'):
  *                 fields = entry.split(':')
  */
-    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_entry); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 169, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_entry); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 187, __pyx_L1_error)
     if (__pyx_t_1) {
 
-      /* "borg/platform/freebsd.pyx":170
+      /* "borg/platform/freebsd.pyx":188
  *     for entry in safe_decode(acl).split('\n'):
  *         if entry:
  *             if entry.startswith('user:') or entry.startswith('group:'):             # <<<<<<<<<<<<<<
  *                 fields = entry.split(':')
  *                 entries.append(':'.join(fields[0], fields[5], *fields[2:-1]))
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_entry, __pyx_n_s_startswith); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 170, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_entry, __pyx_n_s_startswith); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 188, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_kp_s_user_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_user_2);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 170, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 188, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 170, __pyx_L1_error)
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 188, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       if (!__pyx_t_8) {
       } else {
         __pyx_t_1 = __pyx_t_8;
         goto __pyx_L7_bool_binop_done;
       }
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_entry, __pyx_n_s_startswith); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 170, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_entry, __pyx_n_s_startswith); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 188, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_t_5 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_5)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
           __Pyx_INCREF(__pyx_t_5);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_3, function);
         }
       }
       __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_kp_s_group) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_group);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 170, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 188, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 170, __pyx_L1_error)
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 188, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __pyx_t_1 = __pyx_t_8;
       __pyx_L7_bool_binop_done:;
       if (__pyx_t_1) {
 
-        /* "borg/platform/freebsd.pyx":171
+        /* "borg/platform/freebsd.pyx":189
  *         if entry:
  *             if entry.startswith('user:') or entry.startswith('group:'):
  *                 fields = entry.split(':')             # <<<<<<<<<<<<<<
  *                 entries.append(':'.join(fields[0], fields[5], *fields[2:-1]))
  *             else:
  */
-        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_entry, __pyx_n_s_split); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 171, __pyx_L1_error)
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_entry, __pyx_n_s_split); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 189, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __pyx_t_5 = NULL;
         if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
           __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
           if (likely(__pyx_t_5)) {
             PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
             __Pyx_INCREF(__pyx_t_5);
             __Pyx_INCREF(function);
             __Pyx_DECREF_SET(__pyx_t_3, function);
           }
         }
-        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_kp_s__8) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s__8);
+        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_kp_s__10) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s__10);
         __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 171, __pyx_L1_error)
+        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         __Pyx_XDECREF_SET(__pyx_v_fields, __pyx_t_2);
         __pyx_t_2 = 0;
 
-        /* "borg/platform/freebsd.pyx":172
+        /* "borg/platform/freebsd.pyx":190
  *             if entry.startswith('user:') or entry.startswith('group:'):
  *                 fields = entry.split(':')
  *                 entries.append(':'.join(fields[0], fields[5], *fields[2:-1]))             # <<<<<<<<<<<<<<
  *             else:
  *                 entries.append(entry)
  */
-        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s__8, __pyx_n_s_join); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 172, __pyx_L1_error)
+        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s__10, __pyx_n_s_join); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 190, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_2);
-        __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_fields, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 172, __pyx_L1_error)
+        __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_fields, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 190, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_5 = __Pyx_GetItemInt(__pyx_v_fields, 5, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 172, __pyx_L1_error)
+        __pyx_t_5 = __Pyx_GetItemInt(__pyx_v_fields, 5, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 190, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
-        __pyx_t_9 = PyTuple_New(2); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 172, __pyx_L1_error)
+        __pyx_t_9 = PyTuple_New(2); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 190, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         __Pyx_GIVEREF(__pyx_t_3);
         PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_3);
         __Pyx_GIVEREF(__pyx_t_5);
         PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_t_5);
         __pyx_t_3 = 0;
         __pyx_t_5 = 0;
-        __pyx_t_5 = __Pyx_PyObject_GetSlice(__pyx_v_fields, 2, -1L, NULL, NULL, &__pyx_slice__9, 1, 1, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 172, __pyx_L1_error)
+        __pyx_t_5 = __Pyx_PyObject_GetSlice(__pyx_v_fields, 2, -1L, NULL, NULL, &__pyx_slice__11, 1, 1, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 190, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
-        __pyx_t_3 = __Pyx_PySequence_Tuple(__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 172, __pyx_L1_error)
+        __pyx_t_3 = __Pyx_PySequence_Tuple(__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 190, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __pyx_t_5 = PyNumber_Add(__pyx_t_9, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 172, __pyx_L1_error)
+        __pyx_t_5 = PyNumber_Add(__pyx_t_9, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 190, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 172, __pyx_L1_error)
+        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 190, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __pyx_t_10 = __Pyx_PyList_Append(__pyx_v_entries, __pyx_t_3); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 172, __pyx_L1_error)
+        __pyx_t_10 = __Pyx_PyList_Append(__pyx_v_entries, __pyx_t_3); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 190, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-        /* "borg/platform/freebsd.pyx":170
+        /* "borg/platform/freebsd.pyx":188
  *     for entry in safe_decode(acl).split('\n'):
  *         if entry:
  *             if entry.startswith('user:') or entry.startswith('group:'):             # <<<<<<<<<<<<<<
  *                 fields = entry.split(':')
  *                 entries.append(':'.join(fields[0], fields[5], *fields[2:-1]))
  */
         goto __pyx_L6;
       }
 
-      /* "borg/platform/freebsd.pyx":174
+      /* "borg/platform/freebsd.pyx":192
  *                 entries.append(':'.join(fields[0], fields[5], *fields[2:-1]))
  *             else:
  *                 entries.append(entry)             # <<<<<<<<<<<<<<
  *     return safe_encode('\n'.join(entries))
  * 
  */
       /*else*/ {
-        __pyx_t_10 = __Pyx_PyList_Append(__pyx_v_entries, __pyx_v_entry); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 174, __pyx_L1_error)
+        __pyx_t_10 = __Pyx_PyList_Append(__pyx_v_entries, __pyx_v_entry); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 192, __pyx_L1_error)
       }
       __pyx_L6:;
 
-      /* "borg/platform/freebsd.pyx":169
+      /* "borg/platform/freebsd.pyx":187
  *     entries = []
  *     for entry in safe_decode(acl).split('\n'):
  *         if entry:             # <<<<<<<<<<<<<<
  *             if entry.startswith('user:') or entry.startswith('group:'):
  *                 fields = entry.split(':')
  */
     }
 
-    /* "borg/platform/freebsd.pyx":168
+    /* "borg/platform/freebsd.pyx":186
  *     assert isinstance(acl, bytes)
  *     entries = []
  *     for entry in safe_decode(acl).split('\n'):             # <<<<<<<<<<<<<<
  *         if entry:
  *             if entry.startswith('user:') or entry.startswith('group:'):
  */
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "borg/platform/freebsd.pyx":175
+  /* "borg/platform/freebsd.pyx":193
  *             else:
  *                 entries.append(entry)
  *     return safe_encode('\n'.join(entries))             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_safe_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 175, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_safe_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 193, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyString_Join(__pyx_kp_s__7, __pyx_v_entries); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 175, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyString_Join(__pyx_kp_s__9, __pyx_v_entries); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 193, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_4 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 175, __pyx_L1_error)
+  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 193, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_4;
   __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "borg/platform/freebsd.pyx":163
+  /* "borg/platform/freebsd.pyx":181
  * 
  * 
  * cdef _nfs4_use_stored_uid_gid(acl):             # <<<<<<<<<<<<<<
  *     """Replace the user/group field with the stored uid/gid
  *     """
  */
 
@@ -4780,27 +5285,27 @@
   __Pyx_XDECREF(__pyx_v_entry);
   __Pyx_XDECREF(__pyx_v_fields);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "borg/platform/freebsd.pyx":178
+/* "borg/platform/freebsd.pyx":196
  * 
  * 
  * def acl_set(path, item, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     """Restore ACL Entries
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_9acl_set(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_4borg_8platform_7freebsd_8acl_set[] = "Restore ACL Entries\n\n    If `numeric_ids` is True the stored uid/gid is used instead\n    of the user/group names\n    ";
-static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_9acl_set = {"acl_set", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_9acl_set, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4borg_8platform_7freebsd_8acl_set};
-static PyObject *__pyx_pw_4borg_8platform_7freebsd_9acl_set(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_11acl_set(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_4borg_8platform_7freebsd_10acl_set[] = "Restore ACL Entries\n\n    If `numeric_ids` is True the stored uid/gid is used instead\n    of the user/group names\n    ";
+static PyMethodDef __pyx_mdef_4borg_8platform_7freebsd_11acl_set = {"acl_set", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4borg_8platform_7freebsd_11acl_set, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4borg_8platform_7freebsd_10acl_set};
+static PyObject *__pyx_pw_4borg_8platform_7freebsd_11acl_set(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_path = 0;
   PyObject *__pyx_v_item = 0;
   PyObject *__pyx_v_numeric_ids = 0;
   PyObject *__pyx_v_fd = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -4832,15 +5337,15 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_item)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("acl_set", 0, 2, 4, 1); __PYX_ERR(0, 178, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("acl_set", 0, 2, 4, 1); __PYX_ERR(0, 196, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_numeric_ids);
           if (value) { values[2] = value; kw_args--; }
         }
@@ -4848,15 +5353,15 @@
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fd);
           if (value) { values[3] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "acl_set") < 0)) __PYX_ERR(0, 178, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "acl_set") < 0)) __PYX_ERR(0, 196, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -4869,141 +5374,141 @@
     __pyx_v_path = values[0];
     __pyx_v_item = values[1];
     __pyx_v_numeric_ids = values[2];
     __pyx_v_fd = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("acl_set", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 178, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("acl_set", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 196, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("borg.platform.freebsd.acl_set", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_8acl_set(__pyx_self, __pyx_v_path, __pyx_v_item, __pyx_v_numeric_ids, __pyx_v_fd);
+  __pyx_r = __pyx_pf_4borg_8platform_7freebsd_10acl_set(__pyx_self, __pyx_v_path, __pyx_v_item, __pyx_v_numeric_ids, __pyx_v_fd);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_4borg_8platform_7freebsd_8acl_set(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_fd) {
+static PyObject *__pyx_pf_4borg_8platform_7freebsd_10acl_set(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_path, PyObject *__pyx_v_item, PyObject *__pyx_v_numeric_ids, PyObject *__pyx_v_fd) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   struct __pyx_opt_args_4borg_8platform_7freebsd__set_acl __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("acl_set", 0);
   __Pyx_INCREF(__pyx_v_path);
 
-  /* "borg/platform/freebsd.pyx":184
+  /* "borg/platform/freebsd.pyx":202
  *     of the user/group names
  *     """
  *     if isinstance(path, str):             # <<<<<<<<<<<<<<
  *         path = os.fsencode(path)
  *     _set_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', numeric_ids, fd=fd)
  */
   __pyx_t_1 = PyString_Check(__pyx_v_path); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "borg/platform/freebsd.pyx":185
+    /* "borg/platform/freebsd.pyx":203
  *     """
  *     if isinstance(path, str):
  *         path = os.fsencode(path)             # <<<<<<<<<<<<<<
  *     _set_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', numeric_ids, fd=fd)
  *     _set_acl(path, ACL_TYPE_ACCESS, item, 'acl_access', numeric_ids, fd=fd)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 185, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_os); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 203, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_fsencode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 185, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_fsencode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 203, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_5, function);
       }
     }
     __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_path) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_path);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 185, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 203, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_path, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "borg/platform/freebsd.pyx":184
+    /* "borg/platform/freebsd.pyx":202
  *     of the user/group names
  *     """
  *     if isinstance(path, str):             # <<<<<<<<<<<<<<
  *         path = os.fsencode(path)
  *     _set_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', numeric_ids, fd=fd)
  */
   }
 
-  /* "borg/platform/freebsd.pyx":186
+  /* "borg/platform/freebsd.pyx":204
  *     if isinstance(path, str):
  *         path = os.fsencode(path)
  *     _set_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', numeric_ids, fd=fd)             # <<<<<<<<<<<<<<
  *     _set_acl(path, ACL_TYPE_ACCESS, item, 'acl_access', numeric_ids, fd=fd)
  *     _set_acl(path, ACL_TYPE_DEFAULT, item, 'acl_default', numeric_ids, fd=fd)
  */
-  __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_NFS4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 186, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_NFS4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 204, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_6.__pyx_n = 2;
   __pyx_t_6.numeric_ids = __pyx_v_numeric_ids;
   __pyx_t_6.fd = __pyx_v_fd;
-  __pyx_t_5 = __pyx_f_4borg_8platform_7freebsd__set_acl(__pyx_v_path, __pyx_t_3, __pyx_v_item, __pyx_n_s_acl_nfs4, &__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 186, __pyx_L1_error)
+  __pyx_t_5 = __pyx_f_4borg_8platform_7freebsd__set_acl(__pyx_v_path, __pyx_t_3, __pyx_v_item, __pyx_n_s_acl_nfs4, &__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 204, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-  /* "borg/platform/freebsd.pyx":187
+  /* "borg/platform/freebsd.pyx":205
  *         path = os.fsencode(path)
  *     _set_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', numeric_ids, fd=fd)
  *     _set_acl(path, ACL_TYPE_ACCESS, item, 'acl_access', numeric_ids, fd=fd)             # <<<<<<<<<<<<<<
  *     _set_acl(path, ACL_TYPE_DEFAULT, item, 'acl_default', numeric_ids, fd=fd)
  */
-  __pyx_t_5 = __Pyx_PyInt_From_int(ACL_TYPE_ACCESS); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 187, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_From_int(ACL_TYPE_ACCESS); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 205, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_6.__pyx_n = 2;
   __pyx_t_6.numeric_ids = __pyx_v_numeric_ids;
   __pyx_t_6.fd = __pyx_v_fd;
-  __pyx_t_3 = __pyx_f_4borg_8platform_7freebsd__set_acl(__pyx_v_path, __pyx_t_5, __pyx_v_item, __pyx_n_s_acl_access, &__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 187, __pyx_L1_error)
+  __pyx_t_3 = __pyx_f_4borg_8platform_7freebsd__set_acl(__pyx_v_path, __pyx_t_5, __pyx_v_item, __pyx_n_s_acl_access, &__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 205, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "borg/platform/freebsd.pyx":188
+  /* "borg/platform/freebsd.pyx":206
  *     _set_acl(path, ACL_TYPE_NFS4, item, 'acl_nfs4', numeric_ids, fd=fd)
  *     _set_acl(path, ACL_TYPE_ACCESS, item, 'acl_access', numeric_ids, fd=fd)
  *     _set_acl(path, ACL_TYPE_DEFAULT, item, 'acl_default', numeric_ids, fd=fd)             # <<<<<<<<<<<<<<
  */
-  __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_DEFAULT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 188, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(ACL_TYPE_DEFAULT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 206, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_6.__pyx_n = 2;
   __pyx_t_6.numeric_ids = __pyx_v_numeric_ids;
   __pyx_t_6.fd = __pyx_v_fd;
-  __pyx_t_5 = __pyx_f_4borg_8platform_7freebsd__set_acl(__pyx_v_path, __pyx_t_3, __pyx_v_item, __pyx_n_s_acl_default, &__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 188, __pyx_L1_error)
+  __pyx_t_5 = __pyx_f_4borg_8platform_7freebsd__set_acl(__pyx_v_path, __pyx_t_3, __pyx_v_item, __pyx_n_s_acl_default, &__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 206, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-  /* "borg/platform/freebsd.pyx":178
+  /* "borg/platform/freebsd.pyx":196
  * 
  * 
  * def acl_set(path, item, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     """Restore ACL Entries
  * 
  */
 
@@ -5040,36 +5545,43 @@
   return o;
 }
 
 static void __pyx_tp_dealloc_4borg_8platform_7freebsd___pyx_scope_struct__listxattr(PyObject *o) {
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *p = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *)o;
   PyObject_GC_UnTrack(o);
   Py_CLEAR(p->__pyx_v_follow_symlinks);
+  Py_CLEAR(p->__pyx_v_ns_id);
   if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_4borg_8platform_7freebsd___pyx_scope_struct__listxattr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr)))) {
     __pyx_freelist_4borg_8platform_7freebsd___pyx_scope_struct__listxattr[__pyx_freecount_4borg_8platform_7freebsd___pyx_scope_struct__listxattr++] = ((struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *)o);
   } else {
     (*Py_TYPE(o)->tp_free)(o);
   }
 }
 
 static int __pyx_tp_traverse_4borg_8platform_7freebsd___pyx_scope_struct__listxattr(PyObject *o, visitproc v, void *a) {
   int e;
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *p = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *)o;
   if (p->__pyx_v_follow_symlinks) {
     e = (*v)(p->__pyx_v_follow_symlinks, a); if (e) return e;
   }
+  if (p->__pyx_v_ns_id) {
+    e = (*v)(p->__pyx_v_ns_id, a); if (e) return e;
+  }
   return 0;
 }
 
 static int __pyx_tp_clear_4borg_8platform_7freebsd___pyx_scope_struct__listxattr(PyObject *o) {
   PyObject* tmp;
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *p = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr *)o;
   tmp = ((PyObject*)p->__pyx_v_follow_symlinks);
   p->__pyx_v_follow_symlinks = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->__pyx_v_ns_id);
+  p->__pyx_v_ns_id = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
   return 0;
 }
 
 static PyTypeObject __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct__listxattr = {
   PyVarObject_HEAD_INIT(0, 0)
   "borg.platform.freebsd.__pyx_scope_struct__listxattr", /*tp_name*/
   sizeof(struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct__listxattr), /*tp_basicsize*/
@@ -5132,15 +5644,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *__pyx_freelist_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr[8];
 static int __pyx_freecount_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr = 0;
 
@@ -5158,36 +5670,43 @@
   return o;
 }
 
 static void __pyx_tp_dealloc_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr(PyObject *o) {
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *p = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *)o;
   PyObject_GC_UnTrack(o);
   Py_CLEAR(p->__pyx_v_follow_symlinks);
+  Py_CLEAR(p->__pyx_v_ns_id);
   if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr)))) {
     __pyx_freelist_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr[__pyx_freecount_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr++] = ((struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *)o);
   } else {
     (*Py_TYPE(o)->tp_free)(o);
   }
 }
 
 static int __pyx_tp_traverse_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr(PyObject *o, visitproc v, void *a) {
   int e;
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *p = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *)o;
   if (p->__pyx_v_follow_symlinks) {
     e = (*v)(p->__pyx_v_follow_symlinks, a); if (e) return e;
   }
+  if (p->__pyx_v_ns_id) {
+    e = (*v)(p->__pyx_v_ns_id, a); if (e) return e;
+  }
   return 0;
 }
 
 static int __pyx_tp_clear_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr(PyObject *o) {
   PyObject* tmp;
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *p = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr *)o;
   tmp = ((PyObject*)p->__pyx_v_follow_symlinks);
   p->__pyx_v_follow_symlinks = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->__pyx_v_ns_id);
+  p->__pyx_v_ns_id = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
   return 0;
 }
 
 static PyTypeObject __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr = {
   PyVarObject_HEAD_INIT(0, 0)
   "borg.platform.freebsd.__pyx_scope_struct_1_getxattr", /*tp_name*/
   sizeof(struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr), /*tp_basicsize*/
@@ -5250,15 +5769,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *__pyx_freelist_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr[8];
 static int __pyx_freecount_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr = 0;
 
@@ -5276,36 +5795,43 @@
   return o;
 }
 
 static void __pyx_tp_dealloc_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr(PyObject *o) {
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *p = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *)o;
   PyObject_GC_UnTrack(o);
   Py_CLEAR(p->__pyx_v_follow_symlinks);
+  Py_CLEAR(p->__pyx_v_ns_id);
   if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr)))) {
     __pyx_freelist_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr[__pyx_freecount_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr++] = ((struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *)o);
   } else {
     (*Py_TYPE(o)->tp_free)(o);
   }
 }
 
 static int __pyx_tp_traverse_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr(PyObject *o, visitproc v, void *a) {
   int e;
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *p = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *)o;
   if (p->__pyx_v_follow_symlinks) {
     e = (*v)(p->__pyx_v_follow_symlinks, a); if (e) return e;
   }
+  if (p->__pyx_v_ns_id) {
+    e = (*v)(p->__pyx_v_ns_id, a); if (e) return e;
+  }
   return 0;
 }
 
 static int __pyx_tp_clear_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr(PyObject *o) {
   PyObject* tmp;
   struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *p = (struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr *)o;
   tmp = ((PyObject*)p->__pyx_v_follow_symlinks);
   p->__pyx_v_follow_symlinks = Py_None; Py_INCREF(Py_None);
   Py_XDECREF(tmp);
+  tmp = ((PyObject*)p->__pyx_v_ns_id);
+  p->__pyx_v_ns_id = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
   return 0;
 }
 
 static PyTypeObject __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr = {
   PyVarObject_HEAD_INIT(0, 0)
   "borg.platform.freebsd.__pyx_scope_struct_2_setxattr", /*tp_name*/
   sizeof(struct __pyx_obj_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr), /*tp_basicsize*/
@@ -5368,15 +5894,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
@@ -5419,26 +5945,30 @@
     #define CYTHON_SMALL_CODE __attribute__((cold))
 #else
     #define CYTHON_SMALL_CODE
 #endif
 #endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp_b_, __pyx_k_, sizeof(__pyx_k_), 0, 0, 0, 0},
   {&__pyx_kp_s_1_2_05, __pyx_k_1_2_05, sizeof(__pyx_k_1_2_05), 0, 0, 1, 0},
   {&__pyx_n_s_API_VERSION, __pyx_k_API_VERSION, sizeof(__pyx_k_API_VERSION), 0, 0, 1, 1},
-  {&__pyx_kp_s__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 0, 1, 0},
-  {&__pyx_kp_s__8, __pyx_k__8, sizeof(__pyx_k__8), 0, 0, 1, 0},
+  {&__pyx_n_s_KeyError, __pyx_k_KeyError, sizeof(__pyx_k_KeyError), 0, 0, 1, 1},
+  {&__pyx_n_s_NS_ID_MAP, __pyx_k_NS_ID_MAP, sizeof(__pyx_k_NS_ID_MAP), 0, 0, 1, 1},
+  {&__pyx_kp_s__10, __pyx_k__10, sizeof(__pyx_k__10), 0, 0, 1, 0},
+  {&__pyx_kp_s__9, __pyx_k__9, sizeof(__pyx_k__9), 0, 0, 1, 0},
   {&__pyx_n_s_acl_access, __pyx_k_acl_access, sizeof(__pyx_k_acl_access), 0, 0, 1, 1},
   {&__pyx_n_s_acl_default, __pyx_k_acl_default, sizeof(__pyx_k_acl_default), 0, 0, 1, 1},
   {&__pyx_n_s_acl_get, __pyx_k_acl_get, sizeof(__pyx_k_acl_get), 0, 0, 1, 1},
   {&__pyx_n_s_acl_nfs4, __pyx_k_acl_nfs4, sizeof(__pyx_k_acl_nfs4), 0, 0, 1, 1},
   {&__pyx_n_s_acl_set, __pyx_k_acl_set, sizeof(__pyx_k_acl_set), 0, 0, 1, 1},
   {&__pyx_n_s_borg_platform_freebsd, __pyx_k_borg_platform_freebsd, sizeof(__pyx_k_borg_platform_freebsd), 0, 0, 1, 1},
   {&__pyx_n_s_buf, __pyx_k_buf, sizeof(__pyx_k_buf), 0, 0, 1, 1},
   {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
+  {&__pyx_n_s_default_ns, __pyx_k_default_ns, sizeof(__pyx_k_default_ns), 0, 0, 1, 1},
   {&__pyx_n_s_fd, __pyx_k_fd, sizeof(__pyx_k_fd), 0, 0, 1, 1},
   {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
   {&__pyx_n_s_follow_symlinks, __pyx_k_follow_symlinks, sizeof(__pyx_k_follow_symlinks), 0, 0, 1, 1},
   {&__pyx_n_s_fsencode, __pyx_k_fsencode, sizeof(__pyx_k_fsencode), 0, 0, 1, 1},
   {&__pyx_n_s_func, __pyx_k_func, sizeof(__pyx_k_func), 0, 0, 1, 1},
   {&__pyx_n_s_get, __pyx_k_get, sizeof(__pyx_k_get), 0, 0, 1, 1},
   {&__pyx_n_s_getxattr, __pyx_k_getxattr, sizeof(__pyx_k_getxattr), 0, 0, 1, 1},
@@ -5453,162 +5983,192 @@
   {&__pyx_n_s_listxattr_inner, __pyx_k_listxattr_inner, sizeof(__pyx_k_listxattr_inner), 0, 0, 1, 1},
   {&__pyx_n_s_listxattr_locals_func, __pyx_k_listxattr_locals_func, sizeof(__pyx_k_listxattr_locals_func), 0, 0, 1, 1},
   {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
   {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
   {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
   {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
   {&__pyx_n_s_ns, __pyx_k_ns, sizeof(__pyx_k_ns), 0, 0, 1, 1},
+  {&__pyx_n_s_ns_id, __pyx_k_ns_id, sizeof(__pyx_k_ns_id), 0, 0, 1, 1},
+  {&__pyx_n_s_ns_name, __pyx_k_ns_name, sizeof(__pyx_k_ns_name), 0, 0, 1, 1},
+  {&__pyx_n_s_ns_name_tuple, __pyx_k_ns_name_tuple, sizeof(__pyx_k_ns_name_tuple), 0, 0, 1, 1},
   {&__pyx_n_s_numeric_ids, __pyx_k_numeric_ids, sizeof(__pyx_k_numeric_ids), 0, 0, 1, 1},
   {&__pyx_n_s_os, __pyx_k_os, sizeof(__pyx_k_os), 0, 0, 1, 1},
   {&__pyx_n_s_path, __pyx_k_path, sizeof(__pyx_k_path), 0, 0, 1, 1},
   {&__pyx_n_s_posix, __pyx_k_posix, sizeof(__pyx_k_posix), 0, 0, 1, 1},
   {&__pyx_n_s_posix_acl_use_stored_uid_gid, __pyx_k_posix_acl_use_stored_uid_gid, sizeof(__pyx_k_posix_acl_use_stored_uid_gid), 0, 0, 1, 1},
-  {&__pyx_n_s_prefix, __pyx_k_prefix, sizeof(__pyx_k_prefix), 0, 0, 1, 1},
   {&__pyx_n_s_ret, __pyx_k_ret, sizeof(__pyx_k_ret), 0, 0, 1, 1},
   {&__pyx_n_s_safe_decode, __pyx_k_safe_decode, sizeof(__pyx_k_safe_decode), 0, 0, 1, 1},
   {&__pyx_n_s_safe_encode, __pyx_k_safe_encode, sizeof(__pyx_k_safe_encode), 0, 0, 1, 1},
   {&__pyx_n_s_setxattr, __pyx_k_setxattr, sizeof(__pyx_k_setxattr), 0, 0, 1, 1},
   {&__pyx_n_s_setxattr_inner, __pyx_k_setxattr_inner, sizeof(__pyx_k_setxattr_inner), 0, 0, 1, 1},
   {&__pyx_n_s_setxattr_locals_func, __pyx_k_setxattr_locals_func, sizeof(__pyx_k_setxattr_locals_func), 0, 0, 1, 1},
   {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
   {&__pyx_n_s_split, __pyx_k_split, sizeof(__pyx_k_split), 0, 0, 1, 1},
   {&__pyx_n_s_split_lstring, __pyx_k_split_lstring, sizeof(__pyx_k_split_lstring), 0, 0, 1, 1},
+  {&__pyx_n_s_split_ns, __pyx_k_split_ns, sizeof(__pyx_k_split_ns), 0, 0, 1, 1},
   {&__pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_k_src_borg_platform_freebsd_pyx, sizeof(__pyx_k_src_borg_platform_freebsd_pyx), 0, 0, 1, 0},
   {&__pyx_n_s_st, __pyx_k_st, sizeof(__pyx_k_st), 0, 0, 1, 1},
   {&__pyx_n_s_startswith, __pyx_k_startswith, sizeof(__pyx_k_startswith), 0, 0, 1, 1},
   {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
-  {&__pyx_kp_b_user, __pyx_k_user, sizeof(__pyx_k_user), 0, 0, 0, 0},
+  {&__pyx_n_b_user, __pyx_k_user, sizeof(__pyx_k_user), 0, 0, 0, 1},
   {&__pyx_kp_s_user_2, __pyx_k_user_2, sizeof(__pyx_k_user_2), 0, 0, 1, 0},
   {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
   {&__pyx_n_s_xattr, __pyx_k_xattr, sizeof(__pyx_k_xattr), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
+  __pyx_builtin_KeyError = __Pyx_GetBuiltinName(__pyx_n_s_KeyError); if (!__pyx_builtin_KeyError) __PYX_ERR(0, 120, __pyx_L1_error)
   return 0;
+  __pyx_L1_error:;
+  return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "borg/platform/freebsd.pyx":56
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
- *     def func(path, buf, size):             # <<<<<<<<<<<<<<
- *         if isinstance(path, int):
- *             return c_extattr_list_fd(path, ns, <char *> buf, size)
- */
-  __pyx_tuple_ = PyTuple_Pack(3, __pyx_n_s_path, __pyx_n_s_buf, __pyx_n_s_size); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 56, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple_);
-  __Pyx_GIVEREF(__pyx_tuple_);
-  __pyx_codeobj__2 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple_, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_func, 56, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__2)) __PYX_ERR(0, 56, __pyx_L1_error)
+  /* "borg/platform/freebsd.pyx":65
+ *     # we also need to deal with "unexpected" namespaces here, they could come
+ *     # from borg archives made on other operating systems.
+ *     ns_name_tuple = ns_name.split(b".", 1)             # <<<<<<<<<<<<<<
+ *     if len(ns_name_tuple) == 2:
+ *         # we have a namespace prefix in the given name
+ */
+  __pyx_tuple__2 = PyTuple_Pack(2, __pyx_kp_b_, __pyx_int_1); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
 
-  /* "borg/platform/freebsd.pyx":72
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+  /* "borg/platform/freebsd.pyx":76
  * 
- *     def func(path, name, buf, size):             # <<<<<<<<<<<<<<
+ * def listxattr(path, *, follow_symlinks=False):
+ *     def func(path, buf, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_get_fd(path, ns, name, <char *> buf, size)
+ *             return c_extattr_list_fd(path, ns_id, <char *> buf, size)
  */
-  __pyx_tuple__3 = PyTuple_Pack(4, __pyx_n_s_path, __pyx_n_s_name, __pyx_n_s_buf, __pyx_n_s_size); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 72, __pyx_L1_error)
+  __pyx_tuple__3 = PyTuple_Pack(3, __pyx_n_s_path, __pyx_n_s_buf, __pyx_n_s_size); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 76, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__3);
   __Pyx_GIVEREF(__pyx_tuple__3);
-  __pyx_codeobj__4 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__3, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_func, 72, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__4)) __PYX_ERR(0, 72, __pyx_L1_error)
+  __pyx_codeobj__4 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__3, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_func, 76, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__4)) __PYX_ERR(0, 76, __pyx_L1_error)
 
   /* "borg/platform/freebsd.pyx":92
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
  * 
- *     def func(path, name, value, size):             # <<<<<<<<<<<<<<
+ * def getxattr(path, name, *, follow_symlinks=False):
+ *     def func(path, name, buf, size):             # <<<<<<<<<<<<<<
  *         if isinstance(path, int):
- *             return c_extattr_set_fd(path, ns, name, <char *> value, size)
+ *             return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)
  */
-  __pyx_tuple__5 = PyTuple_Pack(4, __pyx_n_s_path, __pyx_n_s_name, __pyx_n_s_value, __pyx_n_s_size); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 92, __pyx_L1_error)
+  __pyx_tuple__5 = PyTuple_Pack(4, __pyx_n_s_path, __pyx_n_s_name, __pyx_n_s_buf, __pyx_n_s_size); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 92, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__5);
   __Pyx_GIVEREF(__pyx_tuple__5);
   __pyx_codeobj__6 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__5, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_func, 92, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__6)) __PYX_ERR(0, 92, __pyx_L1_error)
 
-  /* "borg/platform/freebsd.pyx":172
+  /* "borg/platform/freebsd.pyx":108
+ * 
+ * def setxattr(path, name, value, *, follow_symlinks=False):
+ *     def func(path, name, value, size):             # <<<<<<<<<<<<<<
+ *         if isinstance(path, int):
+ *             return c_extattr_set_fd(path, ns_id, name, <char *> value, size)
+ */
+  __pyx_tuple__7 = PyTuple_Pack(4, __pyx_n_s_path, __pyx_n_s_name, __pyx_n_s_value, __pyx_n_s_size); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 108, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
+  __pyx_codeobj__8 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__7, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_func, 108, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__8)) __PYX_ERR(0, 108, __pyx_L1_error)
+
+  /* "borg/platform/freebsd.pyx":190
  *             if entry.startswith('user:') or entry.startswith('group:'):
  *                 fields = entry.split(':')
  *                 entries.append(':'.join(fields[0], fields[5], *fields[2:-1]))             # <<<<<<<<<<<<<<
  *             else:
  *                 entries.append(entry)
  */
-  __pyx_slice__9 = PySlice_New(__pyx_int_2, __pyx_int_neg_1, Py_None); if (unlikely(!__pyx_slice__9)) __PYX_ERR(0, 172, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__9);
-  __Pyx_GIVEREF(__pyx_slice__9);
+  __pyx_slice__11 = PySlice_New(__pyx_int_2, __pyx_int_neg_1, Py_None); if (unlikely(!__pyx_slice__11)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__11);
+  __Pyx_GIVEREF(__pyx_slice__11);
 
-  /* "borg/platform/freebsd.pyx":53
+  /* "borg/platform/freebsd.pyx":58
  * 
  * 
- * def listxattr(path, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+ * def split_ns(ns_name, default_ns):             # <<<<<<<<<<<<<<
+ *     # split ns_name (which is in the form of b"namespace.name") into namespace and name.
+ *     # if there is no namespace given in ns_name, default to default_ns.
+ */
+  __pyx_tuple__12 = PyTuple_Pack(5, __pyx_n_s_ns_name, __pyx_n_s_default_ns, __pyx_n_s_ns_name_tuple, __pyx_n_s_ns, __pyx_n_s_name); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 58, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__12);
+  __Pyx_GIVEREF(__pyx_tuple__12);
+  __pyx_codeobj__13 = (PyObject*)__Pyx_PyCode_New(2, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__12, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_split_ns, 58, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__13)) __PYX_ERR(0, 58, __pyx_L1_error)
+
+  /* "borg/platform/freebsd.pyx":75
  * 
+ * 
+ * def listxattr(path, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
+ *     def func(path, buf, size):
+ *         if isinstance(path, int):
  */
-  __pyx_tuple__10 = PyTuple_Pack(9, __pyx_n_s_path, __pyx_n_s_follow_symlinks, __pyx_n_s_ns, __pyx_n_s_prefix, __pyx_n_s_func, __pyx_n_s_func, __pyx_n_s_n, __pyx_n_s_buf, __pyx_n_s_name); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__10);
-  __Pyx_GIVEREF(__pyx_tuple__10);
-  __pyx_codeobj__11 = (PyObject*)__Pyx_PyCode_New(1, 1, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__10, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_listxattr, 53, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__11)) __PYX_ERR(0, 53, __pyx_L1_error)
+  __pyx_tuple__14 = PyTuple_Pack(9, __pyx_n_s_path, __pyx_n_s_follow_symlinks, __pyx_n_s_func, __pyx_n_s_func, __pyx_n_s_ns, __pyx_n_s_ns_id, __pyx_n_s_n, __pyx_n_s_buf, __pyx_n_s_name); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_codeobj__15 = (PyObject*)__Pyx_PyCode_New(1, 1, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_listxattr, 75, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__15)) __PYX_ERR(0, 75, __pyx_L1_error)
 
-  /* "borg/platform/freebsd.pyx":69
+  /* "borg/platform/freebsd.pyx":91
  * 
  * 
  * def getxattr(path, name, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, buf, size):
+ *         if isinstance(path, int):
  */
-  __pyx_tuple__12 = PyTuple_Pack(9, __pyx_n_s_path, __pyx_n_s_name, __pyx_n_s_follow_symlinks, __pyx_n_s_ns, __pyx_n_s_prefix, __pyx_n_s_func, __pyx_n_s_func, __pyx_n_s_n, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 69, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__12);
-  __Pyx_GIVEREF(__pyx_tuple__12);
-  __pyx_codeobj__13 = (PyObject*)__Pyx_PyCode_New(2, 1, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__12, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_getxattr, 69, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__13)) __PYX_ERR(0, 69, __pyx_L1_error)
+  __pyx_tuple__16 = PyTuple_Pack(9, __pyx_n_s_path, __pyx_n_s_name, __pyx_n_s_follow_symlinks, __pyx_n_s_func, __pyx_n_s_func, __pyx_n_s_ns, __pyx_n_s_ns_id, __pyx_n_s_n, __pyx_n_s_buf); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
+  __Pyx_GIVEREF(__pyx_tuple__16);
+  __pyx_codeobj__17 = (PyObject*)__Pyx_PyCode_New(2, 1, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_getxattr, 91, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__17)) __PYX_ERR(0, 91, __pyx_L1_error)
 
-  /* "borg/platform/freebsd.pyx":89
+  /* "borg/platform/freebsd.pyx":107
  * 
  * 
  * def setxattr(path, name, value, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, value, size):
+ *         if isinstance(path, int):
  */
-  __pyx_tuple__14 = PyTuple_Pack(8, __pyx_n_s_path, __pyx_n_s_name, __pyx_n_s_value, __pyx_n_s_follow_symlinks, __pyx_n_s_ns, __pyx_n_s_prefix, __pyx_n_s_func, __pyx_n_s_func); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 89, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__14);
-  __Pyx_GIVEREF(__pyx_tuple__14);
-  __pyx_codeobj__15 = (PyObject*)__Pyx_PyCode_New(3, 1, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__14, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_setxattr, 89, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__15)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_tuple__18 = PyTuple_Pack(8, __pyx_n_s_path, __pyx_n_s_name, __pyx_n_s_value, __pyx_n_s_follow_symlinks, __pyx_n_s_func, __pyx_n_s_func, __pyx_n_s_ns, __pyx_n_s_ns_id); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 107, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_codeobj__19 = (PyObject*)__Pyx_PyCode_New(3, 1, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_setxattr, 107, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__19)) __PYX_ERR(0, 107, __pyx_L1_error)
 
-  /* "borg/platform/freebsd.pyx":125
+  /* "borg/platform/freebsd.pyx":143
  * 
  * 
  * def acl_get(path, item, st, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     """Saves ACL Entries
  * 
  */
-  __pyx_tuple__16 = PyTuple_Pack(7, __pyx_n_s_path, __pyx_n_s_item, __pyx_n_s_st, __pyx_n_s_numeric_ids, __pyx_n_s_fd, __pyx_n_s_flags, __pyx_n_s_ret); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 125, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__16);
-  __Pyx_GIVEREF(__pyx_tuple__16);
-  __pyx_codeobj__17 = (PyObject*)__Pyx_PyCode_New(5, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_acl_get, 125, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__17)) __PYX_ERR(0, 125, __pyx_L1_error)
+  __pyx_tuple__20 = PyTuple_Pack(7, __pyx_n_s_path, __pyx_n_s_item, __pyx_n_s_st, __pyx_n_s_numeric_ids, __pyx_n_s_fd, __pyx_n_s_flags, __pyx_n_s_ret); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 143, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
+  __pyx_codeobj__21 = (PyObject*)__Pyx_PyCode_New(5, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__20, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_acl_get, 143, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__21)) __PYX_ERR(0, 143, __pyx_L1_error)
 
-  /* "borg/platform/freebsd.pyx":178
+  /* "borg/platform/freebsd.pyx":196
  * 
  * 
  * def acl_set(path, item, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     """Restore ACL Entries
  * 
  */
-  __pyx_tuple__18 = PyTuple_Pack(4, __pyx_n_s_path, __pyx_n_s_item, __pyx_n_s_numeric_ids, __pyx_n_s_fd); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 178, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
-  __pyx_codeobj__19 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_acl_set, 178, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__19)) __PYX_ERR(0, 178, __pyx_L1_error)
+  __pyx_tuple__22 = PyTuple_Pack(4, __pyx_n_s_path, __pyx_n_s_item, __pyx_n_s_numeric_ids, __pyx_n_s_fd); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 196, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
+  __pyx_codeobj__23 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__22, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_borg_platform_freebsd_pyx, __pyx_n_s_acl_set, 196, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__23)) __PYX_ERR(0, 196, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
@@ -5647,31 +6207,31 @@
 static int __Pyx_modinit_type_init_code(void) {
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
-  if (PyType_Ready(&__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct__listxattr) < 0) __PYX_ERR(0, 53, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct__listxattr) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct__listxattr.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct__listxattr.tp_dictoffset && __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct__listxattr.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct__listxattr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_8platform_7freebsd___pyx_scope_struct__listxattr = &__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct__listxattr;
-  if (PyType_Ready(&__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr) < 0) __PYX_ERR(0, 69, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr) < 0) __PYX_ERR(0, 91, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr.tp_dictoffset && __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr = &__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_1_getxattr;
-  if (PyType_Ready(&__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr) < 0) __PYX_ERR(0, 89, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr) < 0) __PYX_ERR(0, 107, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr.tp_dictoffset && __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
   }
   __pyx_ptype_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr = &__pyx_type_4borg_8platform_7freebsd___pyx_scope_struct_2_setxattr;
@@ -6013,72 +6573,100 @@
  * 
  * API_VERSION = '1.2_05'             # <<<<<<<<<<<<<<
  * 
  * cdef extern from "errno.h":
  */
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_API_VERSION, __pyx_kp_s_1_2_05) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
 
-  /* "borg/platform/freebsd.pyx":53
+  /* "borg/platform/freebsd.pyx":55
+ * # On FreeBSD, borg currently only deals with the USER namespace as it is unclear
+ * # whether (and if so, how exactly) it should deal with the SYSTEM namespace.
+ * NS_ID_MAP = {b"user": EXTATTR_NAMESPACE_USER, }             # <<<<<<<<<<<<<<
  * 
  * 
- * def listxattr(path, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+ */
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 55, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = __Pyx_PyInt_From_int(EXTATTR_NAMESPACE_USER); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 55, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_b_user, __pyx_t_1) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NS_ID_MAP, __pyx_t_2) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "borg/platform/freebsd.pyx":58
  * 
+ * 
+ * def split_ns(ns_name, default_ns):             # <<<<<<<<<<<<<<
+ *     # split ns_name (which is in the form of b"namespace.name") into namespace and name.
+ *     # if there is no namespace given in ns_name, default to default_ns.
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_1listxattr, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 53, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_1split_ns, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 58, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_listxattr, __pyx_t_2) < 0) __PYX_ERR(0, 53, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_split_ns, __pyx_t_2) < 0) __PYX_ERR(0, 58, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/platform/freebsd.pyx":69
+  /* "borg/platform/freebsd.pyx":75
  * 
  * 
- * def getxattr(path, name, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+ * def listxattr(path, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
+ *     def func(path, buf, size):
+ *         if isinstance(path, int):
+ */
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_3listxattr, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_listxattr, __pyx_t_2) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "borg/platform/freebsd.pyx":91
  * 
+ * 
+ * def getxattr(path, name, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
+ *     def func(path, name, buf, size):
+ *         if isinstance(path, int):
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_3getxattr, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 69, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_5getxattr, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_getxattr, __pyx_t_2) < 0) __PYX_ERR(0, 69, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_getxattr, __pyx_t_2) < 0) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/platform/freebsd.pyx":89
+  /* "borg/platform/freebsd.pyx":107
  * 
  * 
  * def setxattr(path, name, value, *, follow_symlinks=False):             # <<<<<<<<<<<<<<
- *     ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
- * 
+ *     def func(path, name, value, size):
+ *         if isinstance(path, int):
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_5setxattr, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_7setxattr, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 107, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setxattr, __pyx_t_2) < 0) __PYX_ERR(0, 89, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setxattr, __pyx_t_2) < 0) __PYX_ERR(0, 107, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/platform/freebsd.pyx":125
+  /* "borg/platform/freebsd.pyx":143
  * 
  * 
  * def acl_get(path, item, st, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     """Saves ACL Entries
  * 
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_7acl_get, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 125, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_9acl_get, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 143, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_acl_get, __pyx_t_2) < 0) __PYX_ERR(0, 125, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_acl_get, __pyx_t_2) < 0) __PYX_ERR(0, 143, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "borg/platform/freebsd.pyx":178
+  /* "borg/platform/freebsd.pyx":196
  * 
  * 
  * def acl_set(path, item, numeric_ids=False, fd=None):             # <<<<<<<<<<<<<<
  *     """Restore ACL Entries
  * 
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_9acl_set, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 178, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_4borg_8platform_7freebsd_11acl_set, NULL, __pyx_n_s_borg_platform_freebsd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 196, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_acl_set, __pyx_t_2) < 0) __PYX_ERR(0, 178, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_acl_set, __pyx_t_2) < 0) __PYX_ERR(0, 196, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "borg/platform/freebsd.pyx":1
  * import os             # <<<<<<<<<<<<<<
  * 
  * from .posix import posix_acl_use_stored_uid_gid
  */
@@ -6126,14 +6714,68 @@
 end:
     Py_XDECREF(p);
     Py_XDECREF(m);
     return (__Pyx_RefNannyAPIStruct *)r;
 }
 #endif
 
+/* PyObjectGetAttrStr */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#endif
+
+/* GetBuiltinName */
+static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
+    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
+    if (unlikely(!result)) {
+        PyErr_Format(PyExc_NameError,
+#if PY_MAJOR_VERSION >= 3
+            "name '%U' is not defined", name);
+#else
+            "name '%.200s' is not defined", PyString_AS_STRING(name));
+#endif
+    }
+    return result;
+}
+
+/* RaiseArgTupleInvalid */
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *more_or_less;
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
+    } else {
+        num_expected = num_max;
+        more_or_less = "at most";
+    }
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    PyErr_Format(PyExc_TypeError,
+                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                 func_name, more_or_less, num_expected,
+                 (num_expected == 1) ? "" : "s", num_found);
+}
+
 /* RaiseDoubleKeywords */
 static void __Pyx_RaiseDoubleKeywordsError(
     const char* func_name,
     PyObject* kw_name)
 {
     PyErr_Format(PyExc_TypeError,
         #if PY_MAJOR_VERSION >= 3
@@ -6242,38 +6884,90 @@
         "%s() got an unexpected keyword argument '%U'",
         function_name, key);
     #endif
 bad:
     return -1;
 }
 
-/* RaiseArgTupleInvalid */
-static void __Pyx_RaiseArgtupleInvalid(
-    const char* func_name,
-    int exact,
-    Py_ssize_t num_min,
-    Py_ssize_t num_max,
-    Py_ssize_t num_found)
-{
-    Py_ssize_t num_expected;
-    const char *more_or_less;
-    if (num_found < num_min) {
-        num_expected = num_min;
-        more_or_less = "at least";
-    } else {
-        num_expected = num_max;
-        more_or_less = "at most";
+/* PyObjectCall */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    PyObject *result;
+    ternaryfunc call = Py_TYPE(func)->tp_call;
+    if (unlikely(!call))
+        return PyObject_Call(func, arg, kw);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = (*call)(func, arg, kw);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
     }
-    if (exact) {
-        more_or_less = "exactly";
+    return result;
+}
+#endif
+
+/* RaiseTooManyValuesToUnpack */
+static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
+    PyErr_Format(PyExc_ValueError,
+                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
+}
+
+/* RaiseNeedMoreValuesToUnpack */
+static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
+    PyErr_Format(PyExc_ValueError,
+                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
+                 index, (index == 1) ? "" : "s");
+}
+
+/* IterFinish */
+static CYTHON_INLINE int __Pyx_IterFinish(void) {
+#if CYTHON_FAST_THREAD_STATE
+    PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject* exc_type = tstate->curexc_type;
+    if (unlikely(exc_type)) {
+        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
+            PyObject *exc_value, *exc_tb;
+            exc_value = tstate->curexc_value;
+            exc_tb = tstate->curexc_traceback;
+            tstate->curexc_type = 0;
+            tstate->curexc_value = 0;
+            tstate->curexc_traceback = 0;
+            Py_DECREF(exc_type);
+            Py_XDECREF(exc_value);
+            Py_XDECREF(exc_tb);
+            return 0;
+        } else {
+            return -1;
+        }
     }
-    PyErr_Format(PyExc_TypeError,
-                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
-                 func_name, more_or_less, num_expected,
-                 (num_expected == 1) ? "" : "s", num_found);
+    return 0;
+#else
+    if (unlikely(PyErr_Occurred())) {
+        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
+            PyErr_Clear();
+            return 0;
+        } else {
+            return -1;
+        }
+    }
+    return 0;
+#endif
+}
+
+/* UnpackItemEndCheck */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
+    if (unlikely(retval)) {
+        Py_DECREF(retval);
+        __Pyx_RaiseTooManyValuesError(expected);
+        return -1;
+    }
+    return __Pyx_IterFinish();
 }
 
 /* None */
 static CYTHON_INLINE void __Pyx_RaiseClosureNameError(const char *varname) {
     PyErr_Format(PyExc_NameError, "free variable '%s' referenced before assignment in enclosing scope", varname);
 }
 
@@ -6312,28 +7006,14 @@
     return cached_type;
 bad:
     Py_XDECREF(cached_type);
     cached_type = NULL;
     goto done;
 }
 
-/* PyObjectGetAttrStr */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro))
-        return tp->tp_getattro(obj, attr_name);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_getattr))
-        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
-#endif
-    return PyObject_GetAttr(obj, attr_name);
-}
-#endif
-
 /* CythonFunctionShared */
 #include <structmember.h>
 static PyObject *
 __Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
 {
     if (unlikely(op->func_doc == NULL)) {
         if (op->func.m_ml->ml_doc) {
@@ -6905,15 +7585,18 @@
 #endif
 #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
     0,
 #endif
 };
 static int __pyx_CyFunction_init(void) {
     __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
     if (unlikely(__pyx_CyFunctionType == NULL)) {
         return -1;
@@ -6955,28 +7638,14 @@
     );
     if (likely(op)) {
         PyObject_GC_Track(op);
     }
     return op;
 }
 
-/* GetBuiltinName */
-static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
-    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
-    if (unlikely(!result)) {
-        PyErr_Format(PyExc_NameError,
-#if PY_MAJOR_VERSION >= 3
-            "name '%U' is not defined", name);
-#else
-            "name '%.200s' is not defined", PyString_AS_STRING(name));
-#endif
-    }
-    return result;
-}
-
 /* PyDictVersioning */
 #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
 static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
     PyObject *dict = Py_TYPE(obj)->tp_dict;
     return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
 }
 static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
@@ -7030,14 +7699,130 @@
         return __Pyx_NewRef(result);
     }
     PyErr_Clear();
 #endif
     return __Pyx_GetBuiltinName(name);
 }
 
+/* GetItemInt */
+static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyList_GET_SIZE(o);
+    }
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
+        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyTuple_GET_SIZE(o);
+    }
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
+        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
+                                                     CYTHON_NCP_UNUSED int wraparound,
+                                                     CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
+    if (is_list || PyList_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
+        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
+            PyObject *r = PyList_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    else if (PyTuple_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
+        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    } else {
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
+                if (likely(l >= 0)) {
+                    i += l;
+                } else {
+                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
+                        return NULL;
+                    PyErr_Clear();
+                }
+            }
+            return m->sq_item(o, i);
+        }
+    }
+#else
+    if (is_list || PySequence_Check(o)) {
+        return PySequence_GetItem(o, i);
+    }
+#endif
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
+
+/* ObjectGetItem */
+#if CYTHON_USE_TYPE_SLOTS
+static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
+    PyObject *runerr = NULL;
+    Py_ssize_t key_value;
+    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
+    if (unlikely(!(m && m->sq_item))) {
+        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
+        return NULL;
+    }
+    key_value = __Pyx_PyIndex_AsSsize_t(index);
+    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
+        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
+    }
+    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
+        PyErr_Clear();
+        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
+    }
+    return NULL;
+}
+static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
+    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
+    if (likely(m && m->mp_subscript)) {
+        return m->mp_subscript(obj, key);
+    }
+    return __Pyx_PyObject_GetIndex(obj, key);
+}
+#endif
+
 /* PyFunctionFastCall */
 #if CYTHON_FAST_PYCALL
 static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                                PyObject *globals) {
     PyFrameObject *f;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
     PyObject **fastlocals;
@@ -7172,92 +7957,14 @@
         return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
     } else {
         return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
     }
 }
 #endif
 
-/* PyObjectCall */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
-    PyObject *result;
-    ternaryfunc call = Py_TYPE(func)->tp_call;
-    if (unlikely(!call))
-        return PyObject_Call(func, arg, kw);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = (*call)(func, arg, kw);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
-    }
-    return result;
-}
-#endif
-
-/* RaiseTooManyValuesToUnpack */
-static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
-    PyErr_Format(PyExc_ValueError,
-                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
-}
-
-/* RaiseNeedMoreValuesToUnpack */
-static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
-    PyErr_Format(PyExc_ValueError,
-                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
-                 index, (index == 1) ? "" : "s");
-}
-
-/* IterFinish */
-static CYTHON_INLINE int __Pyx_IterFinish(void) {
-#if CYTHON_FAST_THREAD_STATE
-    PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject* exc_type = tstate->curexc_type;
-    if (unlikely(exc_type)) {
-        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
-            PyObject *exc_value, *exc_tb;
-            exc_value = tstate->curexc_value;
-            exc_tb = tstate->curexc_traceback;
-            tstate->curexc_type = 0;
-            tstate->curexc_value = 0;
-            tstate->curexc_traceback = 0;
-            Py_DECREF(exc_type);
-            Py_XDECREF(exc_value);
-            Py_XDECREF(exc_tb);
-            return 0;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-#else
-    if (unlikely(PyErr_Occurred())) {
-        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
-            PyErr_Clear();
-            return 0;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-#endif
-}
-
-/* UnpackItemEndCheck */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
-    if (unlikely(retval)) {
-        Py_DECREF(retval);
-        __Pyx_RaiseTooManyValuesError(expected);
-        return -1;
-    }
-    return __Pyx_IterFinish();
-}
-
 /* SliceObject */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetSlice(PyObject* obj,
         Py_ssize_t cstart, Py_ssize_t cstop,
         PyObject** _py_start, PyObject** _py_stop, PyObject** _py_slice,
         int has_cstart, int has_cstop, CYTHON_UNUSED int wraparound) {
 #if CYTHON_USE_TYPE_SLOTS
     PyMappingMethods* mp;
@@ -7436,14 +8143,95 @@
     if (unlikely(!args)) return NULL;
     result = __Pyx_PyObject_Call(func, args, NULL);
     Py_DECREF(args);
     return result;
 }
 #endif
 
+/* GetTopmostException */
+#if CYTHON_USE_EXC_INFO_STACK
+static _PyErr_StackItem *
+__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
+{
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
+           exc_info->previous_item != NULL)
+    {
+        exc_info = exc_info->previous_item;
+    }
+    return exc_info;
+}
+#endif
+
+/* SaveResetException */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
+    *type = exc_info->exc_type;
+    *value = exc_info->exc_value;
+    *tb = exc_info->exc_traceback;
+    #else
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    #endif
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+}
+static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    tmp_type = exc_info->exc_type;
+    tmp_value = exc_info->exc_value;
+    tmp_tb = exc_info->exc_traceback;
+    exc_info->exc_type = type;
+    exc_info->exc_value = value;
+    exc_info->exc_traceback = tb;
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    #endif
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+#endif
+
+/* PyErrExceptionMatches */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
+    }
+#endif
+    for (i=0; i<n; i++) {
+        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
+    }
+    return 0;
+}
+static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
+    PyObject *exc_type = tstate->curexc_type;
+    if (exc_type == err) return 1;
+    if (unlikely(!exc_type)) return 0;
+    if (unlikely(PyTuple_Check(err)))
+        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
+    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
+}
+#endif
+
 /* PyErrFetchRestore */
 #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     tmp_type = tstate->curexc_type;
     tmp_value = tstate->curexc_value;
     tmp_tb = tstate->curexc_traceback;
@@ -7569,157 +8357,14 @@
     PyErr_SetExcInfo(*type, *value, *tb);
     *type = tmp_type;
     *value = tmp_value;
     *tb = tmp_tb;
 }
 #endif
 
-/* GetTopmostException */
-#if CYTHON_USE_EXC_INFO_STACK
-static _PyErr_StackItem *
-__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
-{
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
-           exc_info->previous_item != NULL)
-    {
-        exc_info = exc_info->previous_item;
-    }
-    return exc_info;
-}
-#endif
-
-/* SaveResetException */
-#if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-    #if CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
-    *type = exc_info->exc_type;
-    *value = exc_info->exc_value;
-    *tb = exc_info->exc_traceback;
-    #else
-    *type = tstate->exc_type;
-    *value = tstate->exc_value;
-    *tb = tstate->exc_traceback;
-    #endif
-    Py_XINCREF(*type);
-    Py_XINCREF(*value);
-    Py_XINCREF(*tb);
-}
-static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    #if CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    tmp_type = exc_info->exc_type;
-    tmp_value = exc_info->exc_value;
-    tmp_tb = exc_info->exc_traceback;
-    exc_info->exc_type = type;
-    exc_info->exc_value = value;
-    exc_info->exc_traceback = tb;
-    #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = type;
-    tstate->exc_value = value;
-    tstate->exc_traceback = tb;
-    #endif
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-}
-#endif
-
-/* GetItemInt */
-static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
-    PyObject *r;
-    if (!j) return NULL;
-    r = PyObject_GetItem(o, j);
-    Py_DECREF(j);
-    return r;
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyList_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
-        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyTuple_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
-        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
-                                                     CYTHON_NCP_UNUSED int wraparound,
-                                                     CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
-    if (is_list || PyList_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
-        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
-            PyObject *r = PyList_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    }
-    else if (PyTuple_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
-        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
-            PyObject *r = PyTuple_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    } else {
-        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
-        if (likely(m && m->sq_item)) {
-            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
-                Py_ssize_t l = m->sq_length(o);
-                if (likely(l >= 0)) {
-                    i += l;
-                } else {
-                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
-                        return NULL;
-                    PyErr_Clear();
-                }
-            }
-            return m->sq_item(o, i);
-        }
-    }
-#else
-    if (is_list || PySequence_Check(o)) {
-        return PySequence_GetItem(o, i);
-    }
-#endif
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-}
-
 /* StringJoin */
 #if !CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyBytes_Join(PyObject* sep, PyObject* values) {
     return PyObject_CallMethodObjArgs(sep, __pyx_n_s_join, values, NULL);
 }
 #endif
 
@@ -8089,14 +8734,52 @@
                 else\
                     goto raise_overflow;\
             }\
         }\
         return (target_type) value;\
     }
 
+/* CIntToPy */
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const int neg_one = (int) -1, const_zero = (int) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+    if (is_unsigned) {
+        if (sizeof(int) < sizeof(long)) {
+            return PyInt_FromLong((long) value);
+        } else if (sizeof(int) <= sizeof(unsigned long)) {
+            return PyLong_FromUnsignedLong((unsigned long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
+            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
+#endif
+        }
+    } else {
+        if (sizeof(int) <= sizeof(long)) {
+            return PyInt_FromLong((long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
+            return PyLong_FromLongLong((PY_LONG_LONG) value);
+#endif
+        }
+    }
+    {
+        int one = 1; int little = (int)*(unsigned char *)&one;
+        unsigned char *bytes = (unsigned char *)&value;
+        return _PyLong_FromByteArray(bytes, sizeof(int),
+                                     little, !is_unsigned);
+    }
+}
+
 /* CIntFromPy */
 static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const int neg_one = (int) -1, const_zero = (int) 0;
@@ -8149,15 +8832,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -8345,15 +9028,15 @@
                         } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
                             return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -8482,52 +9165,14 @@
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to size_t");
     return (size_t) -1;
 }
 
 /* CIntToPy */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const int neg_one = (int) -1, const_zero = (int) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(int) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(int) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(int) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-        return _PyLong_FromByteArray(bytes, sizeof(int),
-                                     little, !is_unsigned);
-    }
-}
-
-/* CIntToPy */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const long neg_one = (long) -1, const_zero = (long) 0;
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
@@ -8617,15 +9262,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/platform/freebsd.pyx` & `borgbackup-2.0.0b6/src/borg/platform/freebsd.pyx`

 * *Files 11% similar despite different names*

```diff
@@ -46,67 +46,85 @@
     int ACL_TEXT_APPEND_ID
 
 cdef extern from "unistd.h":
     long lpathconf(const char *path, int name)
     int _PC_ACL_NFS4
 
 
-def listxattr(path, *, follow_symlinks=False):
-    ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
+# On FreeBSD, borg currently only deals with the USER namespace as it is unclear
+# whether (and if so, how exactly) it should deal with the SYSTEM namespace.
+NS_ID_MAP = {b"user": EXTATTR_NAMESPACE_USER, }
+
+
+def split_ns(ns_name, default_ns):
+    # split ns_name (which is in the form of b"namespace.name") into namespace and name.
+    # if there is no namespace given in ns_name, default to default_ns.
+    # note:
+    # borg < 1.1.10 on FreeBSD did not prefix the namespace to the names, see #3952.
+    # we also need to deal with "unexpected" namespaces here, they could come
+    # from borg archives made on other operating systems.
+    ns_name_tuple = ns_name.split(b".", 1)
+    if len(ns_name_tuple) == 2:
+        # we have a namespace prefix in the given name
+        ns, name = ns_name_tuple
+    else:
+        # no namespace given in ns_name (== no dot found), maybe data coming from an old borg archive.
+        ns, name = default_ns, ns_name
+    return ns, name
+
 
+def listxattr(path, *, follow_symlinks=False):
     def func(path, buf, size):
         if isinstance(path, int):
-            return c_extattr_list_fd(path, ns, <char *> buf, size)
+            return c_extattr_list_fd(path, ns_id, <char *> buf, size)
         else:
             if follow_symlinks:
-                return c_extattr_list_file(path, ns, <char *> buf, size)
+                return c_extattr_list_file(path, ns_id, <char *> buf, size)
             else:
-                return c_extattr_list_link(path, ns, <char *> buf, size)
+                return c_extattr_list_link(path, ns_id, <char *> buf, size)
 
+    ns = b"user"
+    ns_id = NS_ID_MAP[ns]
     n, buf = _listxattr_inner(func, path)
-    return [prefix + name for name in split_lstring(buf[:n]) if name]
+    return [ns + b"." + name for name in split_lstring(buf[:n]) if name]
 
 
 def getxattr(path, name, *, follow_symlinks=False):
-    ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
-
     def func(path, name, buf, size):
         if isinstance(path, int):
-            return c_extattr_get_fd(path, ns, name, <char *> buf, size)
+            return c_extattr_get_fd(path, ns_id, name, <char *> buf, size)
         else:
             if follow_symlinks:
-                return c_extattr_get_file(path, ns, name, <char *> buf, size)
+                return c_extattr_get_file(path, ns_id, name, <char *> buf, size)
             else:
-                return c_extattr_get_link(path, ns, name, <char *> buf, size)
+                return c_extattr_get_link(path, ns_id, name, <char *> buf, size)
 
-    # strip namespace if there, but ignore if not there.
-    # older borg / attic versions did not prefix the namespace to the names.
-    if name.startswith(prefix):
-        name = name[len(prefix):]
+    ns, name = split_ns(name, b"user")
+    ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
     n, buf = _getxattr_inner(func, path, name)
     return bytes(buf[:n])
 
 
 def setxattr(path, name, value, *, follow_symlinks=False):
-    ns, prefix = EXTATTR_NAMESPACE_USER, b'user.'
-
     def func(path, name, value, size):
         if isinstance(path, int):
-            return c_extattr_set_fd(path, ns, name, <char *> value, size)
+            return c_extattr_set_fd(path, ns_id, name, <char *> value, size)
         else:
             if follow_symlinks:
-                return c_extattr_set_file(path, ns, name, <char *> value, size)
+                return c_extattr_set_file(path, ns_id, name, <char *> value, size)
             else:
-                return c_extattr_set_link(path, ns, name, <char *> value, size)
+                return c_extattr_set_link(path, ns_id, name, <char *> value, size)
 
-    # strip namespace if there, but ignore if not there.
-    # older borg / attic versions did not prefix the namespace to the names.
-    if name.startswith(prefix):
-        name = name[len(prefix):]
-    _setxattr_inner(func, path, name, value)
+    ns, name = split_ns(name, b"user")
+    try:
+        ns_id = NS_ID_MAP[ns]  # this will raise a KeyError it the namespace is unsupported
+    except KeyError:
+        pass
+    else:
+        _setxattr_inner(func, path, name, value)
 
 
 cdef _get_acl(p, type, item, attribute, flags, fd=None):
     cdef acl_t acl = NULL
     cdef char *text = NULL
     try:
         if fd is not None:
```

### Comparing `borgbackup-2.0.0b5/src/borg/platform/linux.c` & `borgbackup-2.0.0b6/src/borg/platform/linux.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-Wall",
@@ -26,16 +26,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -95,16 +95,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -220,15 +224,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -259,15 +263,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -9541,15 +9545,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_8platform_5linux___pyx_scope_struct_1_getxattr *__pyx_freelist_4borg_8platform_5linux___pyx_scope_struct_1_getxattr[8];
 static int __pyx_freecount_4borg_8platform_5linux___pyx_scope_struct_1_getxattr = 0;
 
@@ -9659,15 +9663,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static struct __pyx_obj_4borg_8platform_5linux___pyx_scope_struct_2_setxattr *__pyx_freelist_4borg_8platform_5linux___pyx_scope_struct_2_setxattr[8];
 static int __pyx_freecount_4borg_8platform_5linux___pyx_scope_struct_2_setxattr = 0;
 
@@ -9777,15 +9781,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
@@ -12062,15 +12066,18 @@
 #endif
 #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
     0,
 #endif
 #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
     0,
 #endif
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
     0,
 #endif
 };
 static int __pyx_CyFunction_init(void) {
     __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
     if (unlikely(__pyx_CyFunctionType == NULL)) {
         return -1;
@@ -13088,28 +13095,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -14335,15 +14342,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -14531,15 +14538,15 @@
                         } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
                             return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -14803,15 +14810,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/platform/linux.pyx` & `borgbackup-2.0.0b6/src/borg/platform/linux.pyx`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/platform/posix.c` & `borgbackup-2.0.0b6/src/borg/platform/posix.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-Wall",
@@ -23,16 +23,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -92,16 +92,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -217,15 +221,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -256,15 +260,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -6157,15 +6161,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -6353,15 +6357,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/platform/posix.pyx` & `borgbackup-2.0.0b6/src/borg/platform/posix.pyx`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/platform/syncfilerange.c` & `borgbackup-2.0.0b6/src/borg/platform/syncfilerange.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-Wall",
@@ -23,16 +23,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -92,16 +92,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -217,15 +221,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -256,15 +260,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -1981,15 +1985,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -2177,15 +2181,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/platform/syncfilerange.pyx` & `borgbackup-2.0.0b6/src/borg/platform/syncfilerange.pyx`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/platform/windows.c` & `borgbackup-2.0.0b6/src/borg/platform/windows.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [],
         "extra_compile_args": [
             "-Wall",
@@ -23,16 +23,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_35"
+#define CYTHON_HEX_VERSION 0x001D23F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -92,16 +92,20 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
@@ -217,15 +221,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -256,15 +260,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -3855,28 +3859,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -4305,15 +4309,15 @@
                         } else if (8 * sizeof(DWORD) >= 4 * PyLong_SHIFT) {
                             return (DWORD) (((((((((DWORD)digits[3]) << PyLong_SHIFT) | (DWORD)digits[2]) << PyLong_SHIFT) | (DWORD)digits[1]) << PyLong_SHIFT) | (DWORD)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -4501,15 +4505,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -4697,15 +4701,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `borgbackup-2.0.0b5/src/borg/platform/windows.pyx` & `borgbackup-2.0.0b6/src/borg/platform/windows.pyx`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/platform/xattr.py` & `borgbackup-2.0.0b6/src/borg/platform/xattr.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/remote.py` & `borgbackup-2.0.0b6/src/borg/remote.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,48 +1,50 @@
+import atexit
 import errno
 import functools
 import inspect
-import json
 import logging
 import os
+import queue
 import select
 import shlex
 import shutil
+import socket
 import struct
 import sys
 import tempfile
 import textwrap
 import time
 import traceback
 from subprocess import Popen, PIPE
 
+import borg.logger
 from . import __version__
 from .compress import Compressor
 from .constants import *  # NOQA
 from .helpers import Error, IntegrityError
 from .helpers import bin_to_hex
-from .helpers import get_base_dir
 from .helpers import get_limited_unpacker
 from .helpers import replace_placeholders
 from .helpers import sysinfo
 from .helpers import format_file_size
 from .helpers import safe_unlink
 from .helpers import prepare_subprocess_env, ignore_sigint
-from .logger import create_logger, setup_logging
+from .helpers import get_socket_filename
+from .logger import create_logger, borg_serve_log_queue
 from .helpers import msgpack
 from .repository import Repository
 from .version import parse_version, format_version
 from .checksums import xxh64
 from .helpers.datastruct import EfficientCollectionQueue
 
 logger = create_logger(__name__)
 
-RPC_PROTOCOL_VERSION = 2
 BORG_VERSION = parse_version(__version__)
-MSGID, MSG, ARGS, RESULT = "i", "m", "a", "r"
+MSGID, MSG, ARGS, RESULT, LOG = "i", "m", "a", "r", "l"
 
 MAX_INFLIGHT = 100
 
 RATELIMIT_PERIOD = 0.1
 
 
 def os_write(fd, data):
@@ -97,249 +99,228 @@
         super().__init__(data)
 
 
 # Protocol compatibility:
 # In general the server is responsible for rejecting too old clients and the client it responsible for rejecting
 # too old servers. This ensures that the knowledge what is compatible is always held by the newer component.
 #
-# The server can do checks for the client version in RepositoryServer.negotiate. If the client_data is 2 then
-# client is in the version range [0.29.0, 1.0.x] inclusive. For newer clients client_data is a dict which contains
-# client_version.
-#
-# For the client the return of the negotiate method is either 2 if the server is in the version range [0.29.0, 1.0.x]
-# inclusive, or it is a dict which includes the server version.
+# For the client the return of the negotiate method is a dict which includes the server version.
 #
 # All method calls on the remote repository object must be allowlisted in RepositoryServer.rpc_methods and have api
 # stubs in RemoteRepository. The @api decorator on these stubs is used to set server version requirements.
 #
 # Method parameters are identified only by name and never by position. Unknown parameters are ignored by the server side.
 # If a new parameter is important and may not be ignored, on the client a parameter specific version requirement needs
 # to be added.
 # When parameters are removed, they need to be preserved as defaulted parameters on the client stubs so that older
 # servers still get compatible input.
 
 
-compatMap = {
-    "check": ("repair",),
-    "commit": (),
-    "rollback": (),
-    "destroy": (),
-    "__len__": (),
-    "list": ("limit", "marker"),
-    "put": ("id", "data"),
-    "get": ("id",),
-    "delete": ("id",),
-    "save_key": ("keydata",),
-    "load_key": (),
-    "break_lock": (),
-    "negotiate": ("client_data",),
-    "open": ("path", "create", "lock_wait", "lock", "exclusive", "append_only"),
-    "info": (),
-    "get_free_nonce": (),
-    "commit_nonce_reservation": ("next_unreserved", "start_nonce"),
-}
-
-
 class RepositoryServer:  # pragma: no cover
     rpc_methods = (
         "__len__",
         "check",
         "commit",
         "delete",
         "destroy",
         "flags",
         "flags_many",
         "get",
         "list",
         "scan",
         "negotiate",
         "open",
+        "close",
         "info",
         "put",
         "rollback",
         "save_key",
         "load_key",
         "break_lock",
-        "get_free_nonce",
-        "commit_nonce_reservation",
         "inject_exception",
     )
 
-    def __init__(self, restrict_to_paths, restrict_to_repositories, append_only, storage_quota):
+    def __init__(self, restrict_to_paths, restrict_to_repositories, append_only, storage_quota, use_socket):
         self.repository = None
         self.restrict_to_paths = restrict_to_paths
         self.restrict_to_repositories = restrict_to_repositories
         # This flag is parsed from the serve command line via Archiver.do_serve,
         # i.e. it reflects local system policy and generally ranks higher than
         # whatever the client wants, except when initializing a new repository
         # (see RepositoryServer.open below).
         self.append_only = append_only
         self.storage_quota = storage_quota
-        self.client_version = parse_version(
-            "1.0.8"
-        )  # fallback version if client is too old to send version information
-
-    def positional_to_named(self, method, argv):
-        """Translate from positional protocol to named protocol."""
-        try:
-            return {name: argv[pos] for pos, name in enumerate(compatMap[method])}
-        except IndexError:
-            if method == "open" and len(argv) == 4:
-                # borg clients < 1.0.7 use open() with 4 args
-                mapping = compatMap[method][:4]
-            else:
-                raise
-            return {name: argv[pos] for pos, name in enumerate(mapping)}
+        self.client_version = None  # we update this after client sends version information
+        if use_socket is False:
+            self.socket_path = None
+        elif use_socket is True:  # --socket
+            self.socket_path = get_socket_filename()
+        else:  # --socket=/some/path
+            self.socket_path = use_socket
 
     def filter_args(self, f, kwargs):
         """Remove unknown named parameters from call, because client did (implicitly) say it's ok."""
         known = set(inspect.signature(f).parameters)
         return {name: kwargs[name] for name in kwargs if name in known}
 
-    def serve(self):
-        stdin_fd = sys.stdin.fileno()
-        stdout_fd = sys.stdout.fileno()
-        stderr_fd = sys.stdout.fileno()
-        os.set_blocking(stdin_fd, False)
-        os.set_blocking(stdout_fd, True)
-        os.set_blocking(stderr_fd, True)
-        unpacker = get_limited_unpacker("server")
+    def send_queued_log(self):
         while True:
-            r, w, es = select.select([stdin_fd], [], [], 10)
-            if r:
-                data = os.read(stdin_fd, BUFSIZE)
-                if not data:
-                    if self.repository is not None:
-                        self.repository.close()
-                    else:
-                        os_write(
-                            stderr_fd,
-                            "Borg {}: Got connection close before repository was opened.\n".format(
-                                __version__
-                            ).encode(),
-                        )
+            try:
+                # lr_dict contents see BorgQueueHandler
+                lr_dict = borg_serve_log_queue.get_nowait()
+            except queue.Empty:
+                break
+            else:
+                msg = msgpack.packb({LOG: lr_dict})
+                os_write(self.stdout_fd, msg)
+
+    def serve(self):
+        def inner_serve():
+            os.set_blocking(self.stdin_fd, False)
+            assert not os.get_blocking(self.stdin_fd)
+            os.set_blocking(self.stdout_fd, True)
+            assert os.get_blocking(self.stdout_fd)
+
+            unpacker = get_limited_unpacker("server")
+            shutdown_serve = False
+            while True:
+                # before processing any new RPCs, send out all pending log output
+                self.send_queued_log()
+
+                if shutdown_serve:
+                    # shutdown wanted! get out of here after sending all log output.
+                    assert self.repository is None
                     return
-                unpacker.feed(data)
-                for unpacked in unpacker:
-                    if isinstance(unpacked, dict):
-                        dictFormat = True
-                        msgid = unpacked[MSGID]
-                        method = unpacked[MSG]
-                        args = unpacked[ARGS]
-                    elif isinstance(unpacked, tuple) and len(unpacked) == 4:
-                        dictFormat = False
-                        # The first field 'type' was always 1 and has always been ignored
-                        _, msgid, method, args = unpacked
-                        args = self.positional_to_named(method, args)
-                    else:
-                        if self.repository is not None:
-                            self.repository.close()
-                        raise UnexpectedRPCDataFormatFromClient(__version__)
-                    try:
-                        if method not in self.rpc_methods:
-                            raise InvalidRPCMethod(method)
+
+                # process new RPCs
+                r, w, es = select.select([self.stdin_fd], [], [], 10)
+                if r:
+                    data = os.read(self.stdin_fd, BUFSIZE)
+                    if not data:
+                        shutdown_serve = True
+                        continue
+                    unpacker.feed(data)
+                    for unpacked in unpacker:
+                        if isinstance(unpacked, dict):
+                            msgid = unpacked[MSGID]
+                            method = unpacked[MSG]
+                            args = unpacked[ARGS]
+                        else:
+                            if self.repository is not None:
+                                self.repository.close()
+                            raise UnexpectedRPCDataFormatFromClient(__version__)
                         try:
-                            f = getattr(self, method)
-                        except AttributeError:
-                            f = getattr(self.repository, method)
-                        args = self.filter_args(f, args)
-                        res = f(**args)
-                    except BaseException as e:
-                        if dictFormat:
+                            if method not in self.rpc_methods:
+                                raise InvalidRPCMethod(method)
+                            try:
+                                f = getattr(self, method)
+                            except AttributeError:
+                                f = getattr(self.repository, method)
+                            args = self.filter_args(f, args)
+                            res = f(**args)
+                        except BaseException as e:
                             ex_short = traceback.format_exception_only(e.__class__, e)
                             ex_full = traceback.format_exception(*sys.exc_info())
                             ex_trace = True
                             if isinstance(e, Error):
                                 ex_short = [e.get_message()]
                                 ex_trace = e.traceback
                             if isinstance(e, (Repository.DoesNotExist, Repository.AlreadyExists, PathNotAllowed)):
                                 # These exceptions are reconstructed on the client end in RemoteRepository.call_many(),
                                 # and will be handled just like locally raised exceptions. Suppress the remote traceback
                                 # for these, except ErrorWithTraceback, which should always display a traceback.
                                 pass
                             else:
                                 logging.debug("\n".join(ex_full))
 
+                            sys_info = sysinfo()
                             try:
                                 msg = msgpack.packb(
                                     {
                                         MSGID: msgid,
                                         "exception_class": e.__class__.__name__,
                                         "exception_args": e.args,
                                         "exception_full": ex_full,
                                         "exception_short": ex_short,
                                         "exception_trace": ex_trace,
-                                        "sysinfo": sysinfo(),
+                                        "sysinfo": sys_info,
                                     }
                                 )
                             except TypeError:
                                 msg = msgpack.packb(
                                     {
                                         MSGID: msgid,
                                         "exception_class": e.__class__.__name__,
                                         "exception_args": [
                                             x if isinstance(x, (str, bytes, int)) else None for x in e.args
                                         ],
                                         "exception_full": ex_full,
                                         "exception_short": ex_short,
                                         "exception_trace": ex_trace,
-                                        "sysinfo": sysinfo(),
+                                        "sysinfo": sys_info,
                                     }
                                 )
-
-                            os_write(stdout_fd, msg)
+                            os_write(self.stdout_fd, msg)
                         else:
-                            if isinstance(e, (Repository.DoesNotExist, Repository.AlreadyExists, PathNotAllowed)):
-                                # These exceptions are reconstructed on the client end in RemoteRepository.call_many(),
-                                # and will be handled just like locally raised exceptions. Suppress the remote traceback
-                                # for these, except ErrorWithTraceback, which should always display a traceback.
-                                pass
-                            else:
-                                if isinstance(e, Error):
-                                    tb_log_level = logging.ERROR if e.traceback else logging.DEBUG
-                                    msg = e.get_message()
-                                else:
-                                    tb_log_level = logging.ERROR
-                                    msg = "%s Exception in RPC call" % e.__class__.__name__
-                                tb = f"{traceback.format_exc()}\n{sysinfo()}"
-                                logging.error(msg)
-                                logging.log(tb_log_level, tb)
-                            exc = "Remote Exception (see remote log for the traceback)"
-                            os_write(stdout_fd, msgpack.packb((1, msgid, e.__class__.__name__, exc)))
-                    else:
-                        if dictFormat:
-                            os_write(stdout_fd, msgpack.packb({MSGID: msgid, RESULT: res}))
-                        else:
-                            os_write(stdout_fd, msgpack.packb((1, msgid, None, res)))
-            if es:
-                self.repository.close()
-                return
+                            os_write(self.stdout_fd, msgpack.packb({MSGID: msgid, RESULT: res}))
+                if es:
+                    shutdown_serve = True
+                    continue
+
+        if self.socket_path:  # server for socket:// connections
+            try:
+                # remove any left-over socket file
+                os.unlink(self.socket_path)
+            except OSError:
+                if os.path.exists(self.socket_path):
+                    raise
+            sock_dir = os.path.dirname(self.socket_path)
+            os.makedirs(sock_dir, exist_ok=True)
+            if self.socket_path.endswith(".sock"):
+                pid_file = self.socket_path.replace(".sock", ".pid")
+            else:
+                pid_file = self.socket_path + ".pid"
+            pid = os.getpid()
+            with open(pid_file, "w") as f:
+                f.write(str(pid))
+            atexit.register(functools.partial(os.remove, pid_file))
+            atexit.register(functools.partial(os.remove, self.socket_path))
+            sock = socket.socket(family=socket.AF_UNIX, type=socket.SOCK_STREAM)
+            sock.bind(self.socket_path)  # this creates the socket file in the fs
+            sock.listen(0)  # no backlog
+            os.chmod(self.socket_path, mode=0o0770)  # group members may use the socket, too.
+            print(f"borg serve: PID {pid}, listening on socket {self.socket_path} ...", file=sys.stderr)
+
+            while True:
+                connection, client_address = sock.accept()
+                print(f"Accepted a connection on socket {self.socket_path} ...", file=sys.stderr)
+                self.stdin_fd = connection.makefile("rb").fileno()
+                self.stdout_fd = connection.makefile("wb").fileno()
+                inner_serve()
+                print(f"Finished with connection on socket {self.socket_path} .", file=sys.stderr)
+        else:  # server for one ssh:// connection
+            self.stdin_fd = sys.stdin.fileno()
+            self.stdout_fd = sys.stdout.fileno()
+            inner_serve()
 
     def negotiate(self, client_data):
-        # old format used in 1.0.x
-        if client_data == RPC_PROTOCOL_VERSION:
-            return RPC_PROTOCOL_VERSION
-        # clients since 1.1.0b3 use a dict as client_data
-        # clients since 1.1.0b6 support json log format from server
         if isinstance(client_data, dict):
             self.client_version = client_data["client_version"]
-            level = logging.getLevelName(logging.getLogger("").level)
-            setup_logging(is_serve=True, json=True, level=level)
-            logger.debug("Initialized logging system for JSON-based protocol")
         else:
             self.client_version = BORG_VERSION  # seems to be newer than current version (no known old format)
 
         # not a known old format, send newest negotiate this version knows
         return {"server_version": BORG_VERSION}
 
     def _resolve_path(self, path):
         if isinstance(path, bytes):
             path = os.fsdecode(path)
         if path.startswith("/~/"):  # /~/x = path x relative to own home dir
-            path = os.path.join(get_base_dir(), path[3:])
+            home_dir = os.environ.get("HOME") or os.path.expanduser("~%s" % os.environ.get("USER", ""))
+            path = os.path.join(home_dir, path[3:])
         elif path.startswith("/./"):  # /./x = path x relative to cwd
             path = path[3:]
         return os.path.realpath(path)
 
     def open(
         self, path, create=False, lock_wait=None, lock=True, exclusive=None, append_only=False, make_parent_dirs=False
     ):
@@ -377,14 +358,21 @@
             storage_quota=self.storage_quota,
             exclusive=exclusive,
             make_parent_dirs=make_parent_dirs,
         )
         self.repository.__enter__()  # clean exit handled by serve() method
         return self.repository.id
 
+    def close(self):
+        if self.repository is not None:
+            self.repository.__exit__(None, None, None)
+            self.repository = None
+        borg.logger.flush_logging()
+        self.send_queued_log()
+
     def inject_exception(self, kind):
         s1 = "test string"
         s2 = "test string2"
         if kind == "DoesNotExist":
             raise Repository.DoesNotExist(s1)
         elif kind == "AlreadyExists":
             raise Repository.AlreadyExists(s1)
@@ -495,60 +483,47 @@
 
 
 class RemoteRepository:
     extra_test_args = []  # type: ignore
 
     class RPCError(Exception):
         def __init__(self, unpacked):
-            # for borg < 1.1: unpacked only has 'exception_class' as key
-            # for borg 1.1+: unpacked has keys: 'exception_args', 'exception_full', 'exception_short', 'sysinfo'
+            # unpacked has keys: 'exception_args', 'exception_full', 'exception_short', 'sysinfo'
             self.unpacked = unpacked
 
         def get_message(self):
-            if "exception_short" in self.unpacked:
-                return "\n".join(self.unpacked["exception_short"])
-            else:
-                return self.exception_class
+            return "\n".join(self.unpacked["exception_short"])
 
         @property
         def traceback(self):
             return self.unpacked.get("exception_trace", True)
 
         @property
         def exception_class(self):
             return self.unpacked["exception_class"]
 
         @property
         def exception_full(self):
-            if "exception_full" in self.unpacked:
-                return "\n".join(self.unpacked["exception_full"])
-            else:
-                return self.get_message() + "\nRemote Exception (see remote log for the traceback)"
+            return "\n".join(self.unpacked["exception_full"])
 
         @property
         def sysinfo(self):
-            if "sysinfo" in self.unpacked:
-                return self.unpacked["sysinfo"]
-            else:
-                return ""
+            return self.unpacked["sysinfo"]
 
     class RPCServerOutdated(Error):
         """Borg server is too old for {}. Required version {}"""
 
         @property
         def method(self):
             return self.args[0]
 
         @property
         def required_version(self):
             return self.args[1]
 
-    # If compatibility with 1.0.x is not longer needed, replace all checks of this with True and simplify the code
-    dictFormat = False  # outside of __init__ for testing of legacy free protocol
-
     def __init__(
         self,
         location,
         create=False,
         exclusive=False,
         lock_wait=None,
         lock=True,
@@ -558,106 +533,105 @@
     ):
         self.location = self._location = location
         self.preload_ids = []
         self.msgid = 0
         self.rx_bytes = 0
         self.tx_bytes = 0
         self.to_send = EfficientCollectionQueue(1024 * 1024, bytes)
+        self.stdin_fd = self.stdout_fd = self.stderr_fd = None
         self.stderr_received = b""  # incomplete stderr line bytes received (no \n yet)
         self.chunkid_to_msgids = {}
         self.ignore_responses = set()
         self.responses = {}
         self.async_responses = {}
         self.shutdown_time = None
         self.ratelimit = SleepingBandwidthLimiter(args.upload_ratelimit * 1024 if args and args.upload_ratelimit else 0)
         self.upload_buffer_size_limit = args.upload_buffer * 1024 * 1024 if args and args.upload_buffer else 0
         self.unpacker = get_limited_unpacker("client")
-        self.server_version = parse_version(
-            "1.0.8"
-        )  # fallback version if server is too old to send version information
-        self.p = None
+        self.server_version = None  # we update this after server sends its version
+        self.p = self.sock = None
         self._args = args
-        testing = location.host == "__testsuite__"
-        # when testing, we invoke and talk to a borg process directly (no ssh).
-        # when not testing, we invoke the system-installed ssh binary to talk to a remote borg.
-        env = prepare_subprocess_env(system=not testing)
-        borg_cmd = self.borg_cmd(args, testing)
-        if not testing:
-            borg_cmd = self.ssh_cmd(location) + borg_cmd
-        logger.debug("SSH command line: %s", borg_cmd)
-        # we do not want the ssh getting killed by Ctrl-C/SIGINT because it is needed for clean shutdown of borg.
-        # borg's SIGINT handler tries to write a checkpoint and requires the remote repo connection.
-        self.p = Popen(borg_cmd, bufsize=0, stdin=PIPE, stdout=PIPE, stderr=PIPE, env=env, preexec_fn=ignore_sigint)
-        self.stdin_fd = self.p.stdin.fileno()
-        self.stdout_fd = self.p.stdout.fileno()
-        self.stderr_fd = self.p.stderr.fileno()
+        if self.location.proto == "ssh":
+            testing = location.host == "__testsuite__"
+            # when testing, we invoke and talk to a borg process directly (no ssh).
+            # when not testing, we invoke the system-installed ssh binary to talk to a remote borg.
+            env = prepare_subprocess_env(system=not testing)
+            borg_cmd = self.borg_cmd(args, testing)
+            if not testing:
+                borg_cmd = self.ssh_cmd(location) + borg_cmd
+            logger.debug("SSH command line: %s", borg_cmd)
+            # we do not want the ssh getting killed by Ctrl-C/SIGINT because it is needed for clean shutdown of borg.
+            # borg's SIGINT handler tries to write a checkpoint and requires the remote repo connection.
+            self.p = Popen(borg_cmd, bufsize=0, stdin=PIPE, stdout=PIPE, stderr=PIPE, env=env, preexec_fn=ignore_sigint)
+            self.stdin_fd = self.p.stdin.fileno()
+            self.stdout_fd = self.p.stdout.fileno()
+            self.stderr_fd = self.p.stderr.fileno()
+            self.r_fds = [self.stdout_fd, self.stderr_fd]
+            self.x_fds = [self.stdin_fd, self.stdout_fd, self.stderr_fd]
+        elif self.location.proto == "socket":
+            if args.use_socket is False or args.use_socket is True:  # nothing or --socket
+                socket_path = get_socket_filename()
+            else:  # --socket=/some/path
+                socket_path = args.use_socket
+            self.sock = socket.socket(family=socket.AF_UNIX, type=socket.SOCK_STREAM)
+            try:
+                self.sock.connect(socket_path)  # note: socket_path length is rather limited.
+            except FileNotFoundError:
+                self.sock = None
+                raise Error(f"The socket file {socket_path} does not exist.")
+            except ConnectionRefusedError:
+                self.sock = None
+                raise Error(f"There is no borg serve running for the socket file {socket_path}.")
+            self.stdin_fd = self.sock.makefile("wb").fileno()
+            self.stdout_fd = self.sock.makefile("rb").fileno()
+            self.stderr_fd = None
+            self.r_fds = [self.stdout_fd]
+            self.x_fds = [self.stdin_fd, self.stdout_fd]
+        else:
+            raise Error(f"Unsupported protocol {location.proto}")
+
         os.set_blocking(self.stdin_fd, False)
+        assert not os.get_blocking(self.stdin_fd)
         os.set_blocking(self.stdout_fd, False)
-        os.set_blocking(self.stderr_fd, False)
-        self.r_fds = [self.stdout_fd, self.stderr_fd]
-        self.x_fds = [self.stdin_fd, self.stdout_fd, self.stderr_fd]
+        assert not os.get_blocking(self.stdout_fd)
+        if self.stderr_fd is not None:
+            os.set_blocking(self.stderr_fd, False)
+            assert not os.get_blocking(self.stderr_fd)
 
         try:
             try:
                 version = self.call("negotiate", {"client_data": {"client_version": BORG_VERSION}})
             except ConnectionClosed:
                 raise ConnectionClosedWithHint("Is borg working on the server?") from None
-            if version == RPC_PROTOCOL_VERSION:
-                self.dictFormat = False
-            elif isinstance(version, dict) and "server_version" in version:
-                self.dictFormat = True
+            if isinstance(version, dict):
                 self.server_version = version["server_version"]
             else:
                 raise Exception("Server insisted on using unsupported protocol version %s" % version)
 
-            def do_open():
-                self.id = self.open(
-                    path=self.location.path,
-                    create=create,
-                    lock_wait=lock_wait,
-                    lock=lock,
-                    exclusive=exclusive,
-                    append_only=append_only,
-                    make_parent_dirs=make_parent_dirs,
-                )
-                info = self.info()
-                self.version = info["version"]
-                self.append_only = info["append_only"]
+            self.id = self.open(
+                path=self.location.path,
+                create=create,
+                lock_wait=lock_wait,
+                lock=lock,
+                exclusive=exclusive,
+                append_only=append_only,
+                make_parent_dirs=make_parent_dirs,
+            )
+            info = self.info()
+            self.version = info["version"]
+            self.append_only = info["append_only"]
 
-            if self.dictFormat:
-                do_open()
-            else:
-                # Ugly detection of versions prior to 1.0.7: If open throws it has to be 1.0.6 or lower
-                try:
-                    do_open()
-                except self.RPCError as err:
-                    if err.exception_class != "TypeError":
-                        raise
-                    msg = """\
-Please note:
-If you see a TypeError complaining about the number of positional arguments
-given to open(), you can ignore it if it comes from a borg version < 1.0.7.
-This TypeError is a cosmetic side effect of the compatibility code borg
-clients >= 1.0.7 have to support older borg servers.
-This problem will go away as soon as the server has been upgraded to 1.0.7+.
-"""
-                    # emit this msg in the same way as the 'Remote: ...' lines that show the remote TypeError
-                    sys.stderr.write(msg)
-                    self.server_version = parse_version("1.0.6")
-                    compatMap["open"] = ("path", "create", "lock_wait", "lock")
-                    # try again with corrected version and compatMap
-                    do_open()
         except Exception:
             self.close()
             raise
 
     def __del__(self):
         if len(self.responses):
             logging.debug("still %d cached responses left in RemoteRepository" % (len(self.responses),))
-        if self.p:
+        if self.p or self.sock:
             self.close()
             assert False, "cleanup happened in Repository.__del__"
 
     def __repr__(self):
         return f"<{self.__class__.__name__} {self.location.canonical_path()}>"
 
     def __enter__(self):
@@ -738,17 +712,14 @@
             args += ["-p", str(location.port)]
         if location.user:
             args.append(f"{location.user}@{location.host}")
         else:
             args.append("%s" % location.host)
         return args
 
-    def named_to_positional(self, method, kwargs):
-        return [kwargs[name] for name in compatMap[method]]
-
     def call(self, cmd, args, **kw):
         for resp in self.call_many(cmd, [args], **kw):
             return resp
 
     def call_many(self, cmd, calls, wait=True, is_preloaded=False, async_wait=True):
         if not calls and cmd != "async_responses":
             return
@@ -769,46 +740,36 @@
         def pop_preload_msgid(chunkid):
             msgid = self.chunkid_to_msgids[chunkid].pop(0)
             if not self.chunkid_to_msgids[chunkid]:
                 del self.chunkid_to_msgids[chunkid]
             return msgid
 
         def handle_error(unpacked):
+            if "exception_class" not in unpacked:
+                return
+
             error = unpacked["exception_class"]
-            old_server = "exception_args" not in unpacked
-            args = unpacked.get("exception_args")
+            args = unpacked["exception_args"]
 
             if error == "DoesNotExist":
                 raise Repository.DoesNotExist(self.location.processed)
             elif error == "AlreadyExists":
                 raise Repository.AlreadyExists(self.location.processed)
             elif error == "CheckNeeded":
                 raise Repository.CheckNeeded(self.location.processed)
             elif error == "IntegrityError":
-                if old_server:
-                    raise IntegrityError("(not available)")
-                else:
-                    raise IntegrityError(args[0])
+                raise IntegrityError(args[0])
             elif error == "PathNotAllowed":
-                if old_server:
-                    raise PathNotAllowed("(unknown)")
-                else:
-                    raise PathNotAllowed(args[0])
+                raise PathNotAllowed(args[0])
             elif error == "ParentPathDoesNotExist":
                 raise Repository.ParentPathDoesNotExist(args[0])
             elif error == "ObjectNotFound":
-                if old_server:
-                    raise Repository.ObjectNotFound("(not available)", self.location.processed)
-                else:
-                    raise Repository.ObjectNotFound(args[0], self.location.processed)
+                raise Repository.ObjectNotFound(args[0], self.location.processed)
             elif error == "InvalidRPCMethod":
-                if old_server:
-                    raise InvalidRPCMethod("(not available)")
-                else:
-                    raise InvalidRPCMethod(args[0])
+                raise InvalidRPCMethod(args[0])
             else:
                 raise self.RPCError(unpacked)
 
         calls = list(calls)
         waiting_for = []
         maximum_to_send = 0 if wait else self.upload_buffer_size_limit
         send_buffer()  # Try to send data, as some cases (async_response) will never try to send data otherwise.
@@ -822,38 +783,34 @@
                     len(self.async_responses),
                 )
                 return
             while waiting_for:
                 try:
                     unpacked = self.responses.pop(waiting_for[0])
                     waiting_for.pop(0)
-                    if "exception_class" in unpacked:
-                        handle_error(unpacked)
-                    else:
-                        yield unpacked[RESULT]
-                        if not waiting_for and not calls:
-                            return
+                    handle_error(unpacked)
+                    yield unpacked[RESULT]
+                    if not waiting_for and not calls:
+                        return
                 except KeyError:
                     break
             if cmd == "async_responses":
                 while True:
                     try:
                         msgid, unpacked = self.async_responses.popitem()
                     except KeyError:
                         # there is nothing left what we already have received
                         if async_wait and self.ignore_responses:
                             # but do not return if we shall wait and there is something left to wait for:
                             break
                         else:
                             return
                     else:
-                        if "exception_class" in unpacked:
-                            handle_error(unpacked)
-                        else:
-                            yield unpacked[RESULT]
+                        handle_error(unpacked)
+                        yield unpacked[RESULT]
             if self.to_send or ((calls or self.preload_ids) and len(waiting_for) < MAX_INFLIGHT):
                 w_fds = [self.stdin_fd]
             else:
                 w_fds = []
             r, w, x = select.select(self.r_fds, w_fds, self.x_fds, 1)
             if x:
                 raise Exception("FD exception occurred")
@@ -861,26 +818,26 @@
                 if fd is self.stdout_fd:
                     data = os.read(fd, BUFSIZE)
                     if not data:
                         raise ConnectionClosed()
                     self.rx_bytes += len(data)
                     self.unpacker.feed(data)
                     for unpacked in self.unpacker:
-                        if isinstance(unpacked, dict):
-                            msgid = unpacked[MSGID]
-                        elif isinstance(unpacked, tuple) and len(unpacked) == 4:
-                            # The first field 'type' was always 1 and has always been ignored
-                            _, msgid, error, res = unpacked
-                            if error:
-                                # ignore res, because it is only a fixed string anyway.
-                                unpacked = {MSGID: msgid, "exception_class": error}
-                            else:
-                                unpacked = {MSGID: msgid, RESULT: res}
-                        else:
+                        if not isinstance(unpacked, dict):
                             raise UnexpectedRPCDataFormatFromServer(data)
+
+                        lr_dict = unpacked.get(LOG)
+                        if lr_dict is not None:
+                            # Re-emit remote log messages locally.
+                            _logger = logging.getLogger(lr_dict["name"])
+                            if _logger.isEnabledFor(lr_dict["level"]):
+                                _logger.handle(logging.LogRecord(**lr_dict))
+                            continue
+
+                        msgid = unpacked[MSGID]
                         if msgid in self.ignore_responses:
                             self.ignore_responses.remove(msgid)
                             # async methods never return values, but may raise exceptions.
                             if "exception_class" in unpacked:
                                 self.async_responses[msgid] = unpacked
                             else:
                                 # we currently do not have async result values except "None",
@@ -898,16 +855,22 @@
                     if self.stderr_received:
                         data = self.stderr_received + data
                         self.stderr_received = b""
                     lines = data.splitlines(keepends=True)
                     if lines and not lines[-1].endswith((b"\r", b"\n")):
                         self.stderr_received = lines.pop()
                     # now we have complete lines in <lines> and any partial line in self.stderr_received.
+                    _logger = logging.getLogger()
                     for line in lines:
-                        handle_remote_line(line.decode())  # decode late, avoid partial utf-8 sequences
+                        # borg serve (remote/server side) should not emit stuff on stderr,
+                        # but e.g. the ssh process (local/client side) might output errors there.
+                        assert line.endswith((b"\r", b"\n"))
+                        # something came in on stderr, log it to not lose it.
+                        # decode late, avoid partial utf-8 sequences.
+                        _logger.warning("stderr: " + line.decode().strip())
             if w:
                 while (
                     (len(self.to_send) <= maximum_to_send)
                     and (calls or self.preload_ids)
                     and len(waiting_for) < MAX_INFLIGHT
                 ):
                     if calls:
@@ -918,31 +881,21 @@
                         else:
                             args = calls.pop(0)
                             if cmd == "get" and args["id"] in self.chunkid_to_msgids:
                                 waiting_for.append(pop_preload_msgid(args["id"]))
                             else:
                                 self.msgid += 1
                                 waiting_for.append(self.msgid)
-                                if self.dictFormat:
-                                    self.to_send.push_back(msgpack.packb({MSGID: self.msgid, MSG: cmd, ARGS: args}))
-                                else:
-                                    self.to_send.push_back(
-                                        msgpack.packb((1, self.msgid, cmd, self.named_to_positional(cmd, args)))
-                                    )
+                                self.to_send.push_back(msgpack.packb({MSGID: self.msgid, MSG: cmd, ARGS: args}))
                     if not self.to_send and self.preload_ids:
                         chunk_id = self.preload_ids.pop(0)
                         args = {"id": chunk_id}
                         self.msgid += 1
                         self.chunkid_to_msgids.setdefault(chunk_id, []).append(self.msgid)
-                        if self.dictFormat:
-                            self.to_send.push_back(msgpack.packb({MSGID: self.msgid, MSG: "get", ARGS: args}))
-                        else:
-                            self.to_send.push_back(
-                                msgpack.packb((1, self.msgid, "get", self.named_to_positional("get", args)))
-                            )
+                        self.to_send.push_back(msgpack.packb({MSGID: self.msgid, MSG: "get", ARGS: args}))
 
                 send_buffer()
         self.ignore_responses |= set(waiting_for)  # we lose order here
 
     @api(
         since=parse_version("1.0.0"),
         append_only={"since": parse_version("1.0.7"), "previously": False},
@@ -1021,114 +974,42 @@
         """actual remoting is done via self.call in the @api decorator"""
 
     @api(since=parse_version("1.0.0"))
     def load_key(self):
         """actual remoting is done via self.call in the @api decorator"""
 
     @api(since=parse_version("1.0.0"))
-    def get_free_nonce(self):
-        """actual remoting is done via self.call in the @api decorator"""
-
-    @api(since=parse_version("1.0.0"))
-    def commit_nonce_reservation(self, next_unreserved, start_nonce):
-        """actual remoting is done via self.call in the @api decorator"""
-
-    @api(since=parse_version("1.0.0"))
     def break_lock(self):
         """actual remoting is done via self.call in the @api decorator"""
 
     def close(self):
+        if self.p or self.sock:
+            self.call("close", {}, wait=True)
         if self.p:
             self.p.stdin.close()
             self.p.stdout.close()
             self.p.wait()
             self.p = None
+        if self.sock:
+            try:
+                self.sock.shutdown(socket.SHUT_RDWR)
+            except OSError as e:
+                if e.errno != errno.ENOTCONN:
+                    raise
+            self.sock.close()
+            self.sock = None
 
     def async_response(self, wait=True):
         for resp in self.call_many("async_responses", calls=[], wait=True, async_wait=wait):
             return resp
 
     def preload(self, ids):
         self.preload_ids += ids
 
 
-def handle_remote_line(line):
-    """
-    Handle a remote log line.
-
-    This function is remarkably complex because it handles multiple wire formats.
-    """
-    assert line.endswith(("\r", "\n"))
-    if line.startswith("{"):
-        # This format is used by Borg since 1.1.0b6 for new-protocol clients.
-        # It is the same format that is exposed by --log-json.
-        msg = json.loads(line)
-
-        if msg["type"] not in ("progress_message", "progress_percent", "log_message"):
-            logger.warning("Dropped remote log message with unknown type %r: %s", msg["type"], line)
-            return
-
-        if msg["type"] == "log_message":
-            # Re-emit log messages on the same level as the remote to get correct log suppression and verbosity.
-            level = getattr(logging, msg["levelname"], logging.CRITICAL)
-            assert isinstance(level, int)
-            target_logger = logging.getLogger(msg["name"])
-            msg["message"] = "Remote: " + msg["message"]
-            # In JSON mode, we manually check whether the log message should be propagated.
-            if logging.getLogger("borg").json and level >= target_logger.getEffectiveLevel():
-                sys.stderr.write(json.dumps(msg) + "\n")
-            else:
-                target_logger.log(level, "%s", msg["message"])
-        elif msg["type"].startswith("progress_"):
-            # Progress messages are a bit more complex.
-            # First of all, we check whether progress output is enabled. This is signalled
-            # through the effective level of the borg.output.progress logger
-            # (also see ProgressIndicatorBase in borg.helpers).
-            progress_logger = logging.getLogger("borg.output.progress")
-            if progress_logger.getEffectiveLevel() == logging.INFO:
-                # When progress output is enabled, we check whether the client is in
-                # --log-json mode, as signalled by the "json" attribute on the "borg" logger.
-                if logging.getLogger("borg").json:
-                    # In --log-json mode we re-emit the progress JSON line as sent by the server,
-                    # with the message, if any, prefixed with "Remote: ".
-                    if "message" in msg:
-                        msg["message"] = "Remote: " + msg["message"]
-                    sys.stderr.write(json.dumps(msg) + "\n")
-                elif "message" in msg:
-                    # In text log mode we write only the message to stderr and terminate with \r
-                    # (carriage return, i.e. move the write cursor back to the beginning of the line)
-                    # so that the next message, progress or not, overwrites it. This mirrors the behaviour
-                    # of local progress displays.
-                    sys.stderr.write("Remote: " + msg["message"] + "\r")
-    elif line.startswith("$LOG "):
-        # This format is used by borg serve 0.xx, 1.0.x and 1.1.0b1..b5.
-        # It prefixed log lines with $LOG as a marker, followed by the log level
-        # and optionally a logger name, then "Remote:" as a separator followed by the original
-        # message.
-        _, level, msg = line.split(" ", 2)
-        level = getattr(logging, level, logging.CRITICAL)  # str -> int
-        if msg.startswith("Remote:"):
-            # server format: '$LOG <level> Remote: <msg>'
-            logging.log(level, msg.rstrip())
-        else:
-            # server format '$LOG <level> <logname> Remote: <msg>'
-            logname, msg = msg.split(" ", 1)
-            logging.getLogger(logname).log(level, msg.rstrip())
-    else:
-        # Plain 1.0.x and older format - re-emit to stderr (mirroring what the 1.0.x
-        # client did) or as a generic log message.
-        # We don't know what priority the line had.
-        if logging.getLogger("borg").json:
-            logging.getLogger("").warning("Remote: " + line.strip())
-        else:
-            # In non-JSON mode we circumvent logging to preserve carriage returns (\r)
-            # which are generated by remote progress displays.
-            sys.stderr.write("Remote: " + line)
-
-
 class RepositoryNoCache:
     """A not caching Repository wrapper, passes through to repository.
 
     Just to have same API (including the context manager) as RepositoryCache.
 
     *transform* is a callable taking two arguments, key and raw repository data.
     The return value is returned from get()/get_many(). By default, the raw
```

### Comparing `borgbackup-2.0.0b5/src/borg/repoobj.py` & `borgbackup-2.0.0b6/src/borg/repoobj.py`

 * *Files 13% similar despite different names*

```diff
@@ -66,43 +66,58 @@
         len_meta_encrypted = self.meta_len_hdr.unpack(hdr)[0]
         assert offs + len_meta_encrypted <= len(obj)
         meta_encrypted = obj[offs : offs + len_meta_encrypted]
         meta_packed = self.key.decrypt(id, meta_encrypted)
         meta = msgpack.unpackb(meta_packed)
         return meta
 
-    def parse(self, id: bytes, cdata: bytes, decompress: bool = True) -> tuple[dict, bytes]:
+    def parse(
+        self, id: bytes, cdata: bytes, decompress: bool = True, want_compressed: bool = False
+    ) -> tuple[dict, bytes]:
+        """
+        Parse a repo object into metadata and data (decrypt it, maybe decompress, maybe verify if the chunk plaintext
+        corresponds to the chunk id via assert_id()).
+
+        Tweaking options (default is usually fine):
+        - decompress=True, want_compressed=False: slow, verifying. returns decompressed data (default).
+        - decompress=True, want_compressed=True: slow, verifying. returns compressed data (caller wants to reuse it).
+        - decompress=False, want_compressed=True: quick, not verifying. returns compressed data (caller wants to reuse).
+        - decompress=False, want_compressed=False: invalid
+        """
+        assert not (not decompress and not want_compressed), "invalid parameter combination!"
         assert isinstance(id, bytes)
         assert isinstance(cdata, bytes)
         obj = memoryview(cdata)
         offs = self.meta_len_hdr.size
         hdr = obj[:offs]
         len_meta_encrypted = self.meta_len_hdr.unpack(hdr)[0]
         assert offs + len_meta_encrypted <= len(obj)
         meta_encrypted = obj[offs : offs + len_meta_encrypted]
         offs += len_meta_encrypted
         meta_packed = self.key.decrypt(id, meta_encrypted)
-        meta = msgpack.unpackb(meta_packed)
+        meta_compressed = msgpack.unpackb(meta_packed)  # means: before adding more metadata in decompress block
         data_encrypted = obj[offs:]
-        data_compressed = self.key.decrypt(id, data_encrypted)
+        data_compressed = self.key.decrypt(id, data_encrypted)  # does not include the type/level bytes
         if decompress:
-            ctype = meta["ctype"]
-            clevel = meta["clevel"]
-            csize = meta["csize"]  # always the overall size
+            ctype = meta_compressed["ctype"]
+            clevel = meta_compressed["clevel"]
+            csize = meta_compressed["csize"]  # always the overall size
             assert csize == len(data_compressed)
-            psize = meta.get("psize", csize)  # obfuscation: psize (payload size) is potentially less than csize.
+            psize = meta_compressed.get(
+                "psize", csize
+            )  # obfuscation: psize (payload size) is potentially less than csize.
             assert psize <= csize
             compr_hdr = bytes((ctype, clevel))
             compressor_cls, compression_level = Compressor.detect(compr_hdr)
             compressor = compressor_cls(level=compression_level)
-            meta, data = compressor.decompress(meta, data_compressed[:psize])
+            meta, data = compressor.decompress(dict(meta_compressed), data_compressed[:psize])
             self.key.assert_id(id, data)
         else:
-            data = data_compressed  # does not include the type/level bytes
-        return meta, data
+            meta, data = None, None
+        return meta_compressed if want_compressed else meta, data_compressed if want_compressed else data
 
 
 class RepoObj1:  # legacy
     @classmethod
     def extract_crypted_data(cls, data: bytes) -> bytes:
         # used for crypto type detection
         return data
@@ -136,23 +151,26 @@
             data_compressed = data  # is already compressed, must include type/level bytes
         data_encrypted = self.key.encrypt(id, data_compressed)
         return data_encrypted
 
     def parse_meta(self, id: bytes, cdata: bytes) -> dict:
         raise NotImplementedError("parse_meta is not available for RepoObj1")
 
-    def parse(self, id: bytes, cdata: bytes, decompress: bool = True) -> tuple[dict, bytes]:
+    def parse(
+        self, id: bytes, cdata: bytes, decompress: bool = True, want_compressed: bool = False
+    ) -> tuple[dict, bytes]:
+        assert not (not decompress and not want_compressed), "invalid parameter combination!"
         assert isinstance(id, bytes)
         assert isinstance(cdata, bytes)
         data_compressed = self.key.decrypt(id, cdata)
         compressor_cls, compression_level = Compressor.detect(data_compressed[:2])
         compressor = compressor_cls(level=compression_level, legacy_mode=True)
+        meta_compressed = {}
+        meta_compressed["ctype"] = compressor.ID
+        meta_compressed["clevel"] = compressor.level
+        meta_compressed["csize"] = len(data_compressed)
         if decompress:
             meta, data = compressor.decompress(None, data_compressed)
             self.key.assert_id(id, data)
         else:
-            meta = {}
-            meta["ctype"] = compressor.ID
-            meta["clevel"] = compressor.level
-            meta["csize"] = len(data_compressed)
-            data = data_compressed
-        return meta, data
+            meta, data = None, None
+        return meta_compressed if want_compressed else meta, data_compressed if want_compressed else data
```

### Comparing `borgbackup-2.0.0b5/src/borg/repository.py` & `borgbackup-2.0.0b6/src/borg/repository.py`

 * *Files 2% similar despite different names*

```diff
@@ -365,44 +365,14 @@
         self.save_config(self.path, self.config)
 
     def load_key(self):
         keydata = self.config.get("repository", "key", fallback="").strip()
         # note: if we return an empty string, it means there is no repo key
         return keydata.encode("utf-8")  # remote repo: msgpack issue #99, returning bytes
 
-    def get_free_nonce(self):
-        if self.do_lock and not self.lock.got_exclusive_lock():
-            raise AssertionError("bug in code, exclusive lock should exist here")
-
-        nonce_path = os.path.join(self.path, "nonce")
-        try:
-            with open(nonce_path) as fd:
-                return int.from_bytes(unhexlify(fd.read()), byteorder="big")
-        except FileNotFoundError:
-            return None
-
-    def commit_nonce_reservation(self, next_unreserved, start_nonce):
-        if self.do_lock and not self.lock.got_exclusive_lock():
-            raise AssertionError("bug in code, exclusive lock should exist here")
-
-        if self.get_free_nonce() != start_nonce:
-            raise Exception("nonce space reservation with mismatched previous state")
-        nonce_path = os.path.join(self.path, "nonce")
-        try:
-            with SaveFile(nonce_path, binary=False) as fd:
-                fd.write(bin_to_hex(next_unreserved.to_bytes(8, byteorder="big")))
-        except PermissionError as e:
-            # error is only a problem if we even had a lock
-            if self.do_lock:
-                raise
-            logger.warning(
-                "%s: Failed writing to '%s'. This is expected when working on "
-                "read-only repositories." % (e.strerror, e.filename)
-            )
-
     def destroy(self):
         """Destroy the repository at `self.path`"""
         if self.append_only:
             raise ValueError(self.path + " is in append-only mode")
         self.close()
         os.remove(os.path.join(self.path, "config"))  # kill config first
         shutil.rmtree(self.path)
@@ -933,14 +903,15 @@
                             # shadowed segments list is empty -> remove it
                             del self.shadow_index[key]
             assert segments[segment] == 0, "Corrupted segment reference count - corrupted index or hints"
             unused.append(segment)
             pi.show()
         pi.finish()
         complete_xfer(intermediate=False)
+        self.io.clear_empty_dirs()
         quota_use_after = self.storage_quota_use
         logger.info("Compaction freed about %s repository space.", format_file_size(quota_use_before - quota_use_after))
         logger.debug("Compaction completed.")
 
     def replay_segments(self, index_transaction_id, segments_transaction_id):
         # fake an old client, so that in case we do not have an exclusive lock yet, prepare_txn will upgrade the lock:
         remember_exclusive = self.exclusive
@@ -1402,47 +1373,59 @@
         self.fds = None  # Just to make sure we're disabled
 
     def _close_fd(self, ts_fd):
         ts, fd = ts_fd
         safe_fadvise(fd.fileno(), 0, 0, "DONTNEED")
         fd.close()
 
+    def get_segment_dirs(self, data_dir, start_index=MIN_SEGMENT_DIR_INDEX, end_index=MAX_SEGMENT_DIR_INDEX):
+        """Returns generator yielding required segment dirs in data_dir as `os.DirEntry` objects.
+        Start and end are inclusive.
+        """
+        segment_dirs = (
+            f
+            for f in os.scandir(data_dir)
+            if f.is_dir() and f.name.isdigit() and start_index <= int(f.name) <= end_index
+        )
+        return segment_dirs
+
+    def get_segment_files(self, segment_dir, start_index=MIN_SEGMENT_INDEX, end_index=MAX_SEGMENT_INDEX):
+        """Returns generator yielding required segment files in segment_dir as `os.DirEntry` objects.
+        Start and end are inclusive.
+        """
+        segment_files = (
+            f
+            for f in os.scandir(segment_dir)
+            if f.is_file() and f.name.isdigit() and start_index <= int(f.name) <= end_index
+        )
+        return segment_files
+
     def segment_iterator(self, start_segment=None, end_segment=None, reverse=False):
         if start_segment is None:
-            start_segment = 0 if not reverse else 2**32 - 1
+            start_segment = MIN_SEGMENT_INDEX if not reverse else MAX_SEGMENT_INDEX
         if end_segment is None:
-            end_segment = 2**32 - 1 if not reverse else 0
+            end_segment = MAX_SEGMENT_INDEX if not reverse else MIN_SEGMENT_INDEX
         data_path = os.path.join(self.path, "data")
         start_segment_dir = start_segment // self.segments_per_dir
         end_segment_dir = end_segment // self.segments_per_dir
-        dirs = os.listdir(data_path)
         if not reverse:
-            dirs = [dir for dir in dirs if dir.isdigit() and start_segment_dir <= int(dir) <= end_segment_dir]
+            dirs = self.get_segment_dirs(data_path, start_index=start_segment_dir, end_index=end_segment_dir)
         else:
-            dirs = [dir for dir in dirs if dir.isdigit() and start_segment_dir >= int(dir) >= end_segment_dir]
-        dirs = sorted(dirs, key=int, reverse=reverse)
+            dirs = self.get_segment_dirs(data_path, start_index=end_segment_dir, end_index=start_segment_dir)
+        dirs = sorted(dirs, key=lambda dir: int(dir.name), reverse=reverse)
         for dir in dirs:
-            filenames = os.listdir(os.path.join(data_path, dir))
             if not reverse:
-                filenames = [
-                    filename
-                    for filename in filenames
-                    if filename.isdigit() and start_segment <= int(filename) <= end_segment
-                ]
+                files = self.get_segment_files(dir, start_index=start_segment, end_index=end_segment)
             else:
-                filenames = [
-                    filename
-                    for filename in filenames
-                    if filename.isdigit() and start_segment >= int(filename) >= end_segment
-                ]
-            filenames = sorted(filenames, key=int, reverse=reverse)
-            for filename in filenames:
+                files = self.get_segment_files(dir, start_index=end_segment, end_index=start_segment)
+            files = sorted(files, key=lambda file: int(file.name), reverse=reverse)
+            for file in files:
                 # Note: Do not filter out logically deleted segments  (see "File system interaction" above),
                 # since this is used by cleanup and txn state detection as well.
-                yield int(filename), os.path.join(data_path, dir, filename)
+                yield int(file.name), file.path
 
     def get_latest_segment(self):
         for segment, filename in self.segment_iterator(reverse=True):
             return segment
         return None
 
     def get_segments_transaction_id(self):
@@ -1549,15 +1532,15 @@
         try:
             ts, fd = self.fds[segment]
         except KeyError:
             fd = open_fd()
         else:
             # we only have fresh enough stuff here.
             # update the timestamp of the lru cache entry.
-            self.fds.upd(segment, (now, fd))
+            self.fds.replace(segment, (now, fd))
         return fd
 
     def close_segment(self):
         # set self._write_fd to None early to guard against reentry from error handling code paths:
         fd, self._write_fd = self._write_fd, None
         if fd is not None:
             self.segment += 1
@@ -1568,14 +1551,29 @@
         if segment in self.fds:
             del self.fds[segment]
         try:
             safe_unlink(self.segment_filename(segment))
         except FileNotFoundError:
             pass
 
+    def clear_empty_dirs(self):
+        """Delete empty segment dirs, i.e those with no segment files."""
+        data_dir = os.path.join(self.path, "data")
+        segment_dirs = self.get_segment_dirs(data_dir)
+        for segment_dir in segment_dirs:
+            try:
+                # os.rmdir will only delete the directory if it is empty
+                # so we don't need to explicitly check for emptiness first.
+                os.rmdir(segment_dir)
+            except OSError:
+                # OSError is raised by os.rmdir if directory is not empty. This is expected.
+                # Its subclass FileNotFoundError may be raised if the directory already does not exist. Ignorable.
+                pass
+        sync_dir(data_dir)
+
     def segment_exists(self, segment):
         filename = self.segment_filename(segment)
         # When deleting segments, they are first truncated. If truncate(2) and unlink(2) are split
         # across FS transactions, then logically deleted segments will show up as truncated.
         return os.path.exists(filename) and os.path.getsize(filename)
 
     def segment_size(self, segment):
@@ -1689,15 +1687,15 @@
             self._write_fd.sync()
         fd = self.get_fd(segment)
         fd.seek(offset)
         header = fd.read(self.header_fmt.size)
         size, tag, key, data = self._read(fd, header, segment, offset, (TAG_PUT2, TAG_PUT), read_data=read_data)
         if id != key:
             raise IntegrityError(
-                "Invalid segment entry header, is not for wanted id [segment {}, offset {}]".format(segment, offset)
+                f"Invalid segment entry header, is not for wanted id [segment {segment}, offset {offset}]"
             )
         data_size_from_header = size - header_size(tag)
         if expected_size is not None and expected_size != data_size_from_header:
             raise IntegrityError(
                 f"size from repository index: {expected_size} != " f"size from entry header: {data_size_from_header}"
             )
         return data
```

### Comparing `borgbackup-2.0.0b5/src/borg/selftest.py` & `borgbackup-2.0.0b6/src/borg/selftest.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/__init__.py` & `borgbackup-2.0.0b6/src/borg/testsuite/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -4,27 +4,30 @@
 import os
 
 try:
     import posix
 except ImportError:
     posix = None
 
+import re
 import stat
 import sys
 import sysconfig
 import tempfile
 import time
 import unittest
 
 from ..xattr import get_all
 from ..platform import get_flags
+from ..platformflags import is_win32
 from ..helpers import umount
 from ..helpers import EXIT_SUCCESS, EXIT_WARNING, EXIT_ERROR
 from .. import platform
 
+
 # Note: this is used by borg.selftest, do not use or import py.test functionality here.
 
 from ..fuse_impl import llfuse, has_pyfuse3, has_llfuse
 
 # Does this version of llfuse support ns precision?
 have_fuse_mtime_ns = hasattr(llfuse.EntryAttributes, "st_mtime_ns") if llfuse else False
 
@@ -55,20 +58,46 @@
 def same_ts_ns(ts_ns1, ts_ns2):
     """compare 2 timestamps (both in nanoseconds) whether they are (roughly) equal"""
     diff_ts = int(abs(ts_ns1 - ts_ns2))
     diff_max = 10 ** (-st_mtime_ns_round)
     return diff_ts <= diff_max
 
 
+rejected_dotdot_paths = (
+    "..",
+    "../",
+    "../etc/shadow",
+    "/..",
+    "/../",
+    "/../etc",
+    "/../etc/",
+    "etc/..",
+    "/etc/..",
+    "/etc/../etc/shadow",
+    "//etc/..",
+    "etc//..",
+    "etc/..//",
+    "foo/../bar",
+)
+
+
 @contextmanager
 def unopened_tempfile():
     with tempfile.TemporaryDirectory() as tempdir:
         yield os.path.join(tempdir, "file")
 
 
+def is_root():
+    """return True if running with high privileges, like as root"""
+    if is_win32:
+        return False  # TODO
+    else:
+        return os.getuid() == 0
+
+
 @functools.lru_cache
 def are_symlinks_supported():
     with unopened_tempfile() as filepath:
         try:
             os.symlink("somewhere", filepath)
             if os.stat(filepath, follow_symlinks=False) and os.readlink(filepath) == "somewhere":
                 return True
@@ -183,14 +212,17 @@
         yield
         assert os.path.exists(path), f"{path} should exist"
 
     def assert_dirs_equal(self, dir1, dir2, **kwargs):
         diff = filecmp.dircmp(dir1, dir2)
         self._assert_dirs_equal_cmp(diff, **kwargs)
 
+    def assert_line_exists(self, lines, expected_regexpr):
+        assert any(re.search(expected_regexpr, line) for line in lines), f"no match for {expected_regexpr} in {lines}"
+
     def _assert_dirs_equal_cmp(self, diff, ignore_flags=False, ignore_xattrs=False, ignore_ns=False):
         self.assert_equal(diff.left_only, [])
         self.assert_equal(diff.right_only, [])
         self.assert_equal(diff.diff_files, [])
         self.assert_equal(diff.funny_files, [])
         for filename in diff.common:
             path1 = os.path.join(diff.left, filename)
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archive.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archive.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 from datetime import datetime, timezone
 from io import StringIO
 from unittest.mock import Mock
 
 import pytest
 
 from . import BaseTestCase
+from . import rejected_dotdot_paths
 from ..crypto.key import PlaintextKey
 from ..archive import Archive, CacheChunkBuffer, RobustUnpacker, valid_msgpacked_dict, ITEM_KEYS, Statistics
 from ..archive import BackupOSError, backup_io, backup_io_iter, get_item_uid_gid
 from ..helpers import msgpack
 from ..item import Item, ArchiveItem
 from ..manifest import Manifest
 from ..platform import uid2user, gid2group, is_win32
@@ -255,14 +256,15 @@
         msgpack.packb(o)
         for o in [
             {"path": b"/a/b/c"},  # small (different msgpack mapping type!)
             OrderedDict((k, b"") for k in IK),  # as big (key count) as it gets
             OrderedDict((k, b"x" * 1000) for k in IK),  # as big (key count and volume) as it gets
         ]
     ],
+    ids=["minimal", "empty-values", "long-values"],
 )
 def test_valid_msgpacked_items(packed, item_keys_serialized):
     assert valid_msgpacked_dict(packed, item_keys_serialized)
 
 
 def test_key_length_msgpacked_items():
     key = "x" * 32  # 31 bytes is the limit for fixstr msgpack type
@@ -389,7 +391,13 @@
     assert uid == 15
     assert gid == 0
 
     uid, gid = get_item_uid_gid(item, numeric=True, gid_default=16)
     # as there is nothing, it'll fall back to uid_default/gid_default.
     assert uid == 0
     assert gid == 16
+
+
+def test_reject_non_sanitized_item():
+    for path in rejected_dotdot_paths:
+        with pytest.raises(ValueError, match="unexpected '..' element in path"):
+            Item(path=path, user="root", group="root")
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/__init__.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -17,27 +17,29 @@
 from ...archive import Archive
 from ...archiver import Archiver, PURE_PYTHON_MSGPACK_WARNING
 from ...cache import Cache
 from ...constants import *  # NOQA
 from ...helpers import Location
 from ...helpers import EXIT_SUCCESS
 from ...helpers import bin_to_hex
+from ...logger import flush_logging
 from ...manifest import Manifest
-from ...logger import setup_logging
 from ...remote import RemoteRepository
 from ...repository import Repository
 from .. import has_lchflags
 from .. import BaseTestCase, changedir, environment_variable
 from .. import are_symlinks_supported, are_hardlinks_supported, are_fifos_supported
 from ..platform import is_win32
 
 RK_ENCRYPTION = "--encryption=repokey-aes-ocb"
 KF_ENCRYPTION = "--encryption=keyfile-chacha20-poly1305"
 
-src_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
+# this points to src/borg/archiver directory (which is small and has only a few files)
+src_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", "archiver"))
+src_file = "archiver/__init__.py"  # relative path of one file in src_dir
 
 requires_hardlinks = pytest.mark.skipif(not are_hardlinks_supported(), reason="hardlinks not supported")
 
 
 def exec_cmd(*args, archiver=None, fork=False, exe=None, input=b"", binary_output=False, **kw):
     if fork:
         try:
@@ -76,15 +78,18 @@
                 args = archiver.parse_args(list(args))
                 # argparse parsing may raise SystemExit when the command line is bad or
                 # actions that abort early (eg. --help) where given. Catch this and return
                 # the error code as-if we invoked a Borg binary.
             except SystemExit as e:
                 output_text.flush()
                 return e.code, output.getvalue() if binary_output else output.getvalue().decode()
-            ret = archiver.run(args)
+            try:
+                ret = archiver.run(args)  # calls setup_logging internally
+            finally:
+                flush_logging()  # usually done via atexit, but we do not exit here
             output_text.flush()
             return ret, output.getvalue() if binary_output else output.getvalue().decode()
         finally:
             sys.stdin, sys.stdout, sys.stderr = stdin, stdout, stderr
 
 
 # check if the binary "borg.exe" is available (for local testing a symlink to virtualenv/bin/borg should do)
@@ -149,15 +154,14 @@
         self._old_wd = os.getcwd()
         os.chdir(self.tmpdir)
 
     def tearDown(self):
         os.chdir(self._old_wd)
         # note: ignore_errors=True as workaround for issue #862
         shutil.rmtree(self.tmpdir, ignore_errors=True)
-        setup_logging()
 
     def cmd(self, *args, **kw):
         exit_code = kw.pop("exit_code", 0)
         fork = kw.pop("fork", None)
         binary_output = kw.get("binary_output", False)
         if fork is None:
             fork = self.FORK_DEFAULT
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/argparsing.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/argparsing.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,14 +7,31 @@
 
 class ArchiverTestCase(ArchiverTestCaseBase):
     def test_bad_filters(self):
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
         self.cmd(f"--repo={self.repository_location}", "create", "test", "input")
         self.cmd(f"--repo={self.repository_location}", "delete", "--first", "1", "--last", "1", fork=True, exit_code=2)
 
+    def test_highlander(self):
+        self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
+        self.cmd(f"--repo={self.repository_location}", "create", "--comment", "comment 1", "test-1", __file__)
+        error_msg = "There can be only one"
+        # Default umask value is 0077
+        # Test that it works with a one time specified default or custom value
+        output_default = self.cmd(f"--repo={self.repository_location}", "--umask", "0077", "rlist")
+        assert error_msg not in output_default
+        output_custom = self.cmd(f"--repo={self.repository_location}", "--umask", "0007", "rlist")
+        assert error_msg not in output_custom
+        # Test that all combinations of custom and default values fail
+        for first, second in [("0007", "0007"), ("0007", "0077"), ("0077", "0007"), ("0077", "0077")]:
+            output_custom = self.cmd(
+                f"--repo={self.repository_location}", "--umask", first, "--umask", second, "rlist", exit_code=2
+            )
+            assert error_msg in output_custom
+
 
 def test_get_args():
     archiver = Archiver()
     # everything normal:
     # first param is argv as produced by ssh forced command,
     # second param is like from SSH_ORIGINAL_COMMAND env variable
     args = archiver.get_args(
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/bypass_lock_option.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/bypass_lock_option.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/check_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/check_cmd.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-import logging
 import shutil
 import unittest
 from unittest.mock import patch
 
 from ...archive import ChunkBuffer
 from ...constants import *  # NOQA
 from ...helpers import bin_to_hex
 from ...helpers import msgpack
 from ...manifest import Manifest
 from ...repository import Repository
 from . import ArchiverTestCaseBase, RemoteArchiverTestCaseBase, ArchiverTestCaseBinaryBase, RK_ENCRYPTION, BORG_EXES
+from . import src_file
 
 
 class ArchiverCheckTestCase(ArchiverTestCaseBase):
     def setUp(self):
         super().setUp()
         with patch.object(ChunkBuffer, "BUFFER_SIZE", 10):
             self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
@@ -21,16 +21,14 @@
             self.create_src_archive("archive2")
 
     def test_check_usage(self):
         output = self.cmd(f"--repo={self.repository_location}", "check", "-v", "--progress", exit_code=0)
         self.assert_in("Starting repository check", output)
         self.assert_in("Starting archive consistency check", output)
         self.assert_in("Checking segments", output)
-        # reset logging to new process default to avoid need for fork=True on next check
-        logging.getLogger("borg.output.progress").setLevel(logging.NOTSET)
         output = self.cmd(f"--repo={self.repository_location}", "check", "-v", "--repository-only", exit_code=0)
         self.assert_in("Starting repository check", output)
         self.assert_not_in("Starting archive consistency check", output)
         self.assert_not_in("Checking segments", output)
         output = self.cmd(f"--repo={self.repository_location}", "check", "-v", "--archives-only", exit_code=0)
         self.assert_not_in("Starting repository check", output)
         self.assert_in("Starting archive consistency check", output)
@@ -87,19 +85,26 @@
         output = self.cmd(
             f"--repo={self.repository_location}", "check", "-v", "--archives-only", "--older=1d", exit_code=0
         )
         self.assert_in("archive1", output)
         self.assert_in("archive2", output)
         self.assert_not_in("archive3", output)
 
+        # check for output when timespan older than earliest archive is given. Issue #1711
+        output = self.cmd(
+            f"--repo={self.repository_location}", "check", "-v", "--archives-only", "--older=9999m", exit_code=0
+        )
+        for archive in ("archive1", "archive2", "archive3"):
+            self.assert_not_in(archive, output)
+
     def test_missing_file_chunk(self):
         archive, repository = self.open_archive("archive1")
         with repository:
             for item in archive.iter_items():
-                if item.path.endswith("testsuite/archiver/__init__.py"):
+                if item.path.endswith(src_file):
                     valid_chunks = item.chunks
                     killed_chunk = valid_chunks[-1]
                     repository.delete(killed_chunk.id)
                     break
             else:
                 self.fail("should not happen")
             repository.commit(compact=False)
@@ -112,33 +117,33 @@
         )
         self.assert_in("broken#", output)
         # check that the file in the old archives has now a different chunk list without the killed chunk
         for archive_name in ("archive1", "archive2"):
             archive, repository = self.open_archive(archive_name)
             with repository:
                 for item in archive.iter_items():
-                    if item.path.endswith("testsuite/archiver/__init__.py"):
+                    if item.path.endswith(src_file):
                         self.assert_not_equal(valid_chunks, item.chunks)
                         self.assert_not_in(killed_chunk, item.chunks)
                         break
                 else:
                     self.fail("should not happen")
         # do a fresh backup (that will include the killed chunk)
         with patch.object(ChunkBuffer, "BUFFER_SIZE", 10):
             self.create_src_archive("archive3")
         # check should be able to heal the file now:
         output = self.cmd(f"--repo={self.repository_location}", "check", "-v", "--repair", exit_code=0)
         self.assert_in("Healed previously missing file chunk", output)
-        self.assert_in("testsuite/archiver/__init__.py: Completely healed previously damaged file!", output)
+        self.assert_in(f"{src_file}: Completely healed previously damaged file!", output)
         # check that the file in the old archives has the correct chunks again
         for archive_name in ("archive1", "archive2"):
             archive, repository = self.open_archive(archive_name)
             with repository:
                 for item in archive.iter_items():
-                    if item.path.endswith("testsuite/archiver/__init__.py"):
+                    if item.path.endswith(src_file):
                         self.assert_equal(valid_chunks, item.chunks)
                         break
                 else:
                     self.fail("should not happen")
         # list is also all-healthy again
         output = self.cmd(
             f"--repo={self.repository_location}", "list", "archive1", "--format={health}#{path}{NL}", exit_code=0
@@ -247,28 +252,28 @@
     def _test_verify_data(self, *init_args):
         shutil.rmtree(self.repository_path)
         self.cmd(f"--repo={self.repository_location}", "rcreate", *init_args)
         self.create_src_archive("archive1")
         archive, repository = self.open_archive("archive1")
         with repository:
             for item in archive.iter_items():
-                if item.path.endswith("testsuite/archiver/__init__.py"):
+                if item.path.endswith(src_file):
                     chunk = item.chunks[-1]
                     data = repository.get(chunk.id)
                     data = data[0:100] + b"x" + data[101:]
                     repository.put(chunk.id, data)
                     break
             repository.commit(compact=False)
         self.cmd(f"--repo={self.repository_location}", "check", exit_code=0)
         output = self.cmd(f"--repo={self.repository_location}", "check", "--verify-data", exit_code=1)
         assert bin_to_hex(chunk.id) + ", integrity error" in output
         # repair (heal is tested in another test)
         output = self.cmd(f"--repo={self.repository_location}", "check", "--repair", "--verify-data", exit_code=0)
         assert bin_to_hex(chunk.id) + ", integrity error" in output
-        assert "testsuite/archiver/__init__.py: New missing file chunk detected" in output
+        assert f"{src_file}: New missing file chunk detected" in output
 
     def test_verify_data(self):
         self._test_verify_data(RK_ENCRYPTION)
 
     def test_verify_data_unencrypted(self):
         self._test_verify_data("--encryption", "none")
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/checks.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/checks.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/config_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/config_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/corruption.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/corruption.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/create_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/create_cmd.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 import errno
 import json
 import os
 from random import randbytes
 import shutil
 import socket
 import stat
+import subprocess
 import time
 import unittest
 
 import pytest
 
 from ... import platform
 from ...constants import *  # NOQA
@@ -20,14 +21,15 @@
 from .. import (
     are_symlinks_supported,
     are_hardlinks_supported,
     are_fifos_supported,
     is_utime_fully_supported,
     is_birthtime_fully_supported,
     same_ts_ns,
+    is_root,
 )
 from . import (
     ArchiverTestCaseBase,
     ArchiverTestCaseBinaryBase,
     RemoteArchiverTestCaseBase,
     RK_ENCRYPTION,
     BORG_EXES,
@@ -97,14 +99,40 @@
                     if line.startswith(prefix):
                         result.append(line)
             return "\n".join(result)
 
         # the interesting parts of info_output2 and info_output should be same
         self.assert_equal(filter(info_output), filter(info_output2))
 
+    @pytest.mark.skipif(is_win32, reason="still broken on windows")
+    def test_archived_paths(self):
+        # As borg comes from the POSIX (Linux, UNIX) world, a lot of stuff assumes path separators
+        # to be slashes "/", e.g.: in archived items, for pattern matching.
+        # To make our lives easier and to support cross-platform extraction we always use slashes.
+        # Similarly, archived paths are expected to be full, but relative (have no leading slash).
+        full_path = os.path.abspath(os.path.join(self.input_path, "test"))
+        # remove windows drive letter, if any:
+        posix_path = full_path[2:] if full_path[1] == ":" else full_path
+        # only needed on windows in case there are backslashes:
+        posix_path = posix_path.replace("\\", "/")
+        # no leading slash in borg archives:
+        archived_path = posix_path.lstrip("/")
+        self.create_regular_file("test")
+        self.cmd(f"--repo={self.repository_location}", "rcreate", "--encryption=none")
+        self.cmd(f"--repo={self.repository_location}", "create", "test", "input", full_path)
+        # "input" directory is recursed into, "input/test" is discovered and joined by borg's recursion.
+        # full_path was directly given as a cli argument and should end up as archive_path in the borg archive.
+        expected_paths = sorted(["input", "input/test", archived_path])
+        # check path in archived items:
+        archive_list = self.cmd(f"--repo={self.repository_location}", "list", "test", "--short")
+        assert expected_paths == sorted([path for path in archive_list.splitlines() if path])
+        # check path in archived items (json):
+        archive_list = self.cmd(f"--repo={self.repository_location}", "list", "test", "--json-lines")
+        assert expected_paths == sorted([json.loads(line)["path"] for line in archive_list.splitlines() if line])
+
     @requires_hardlinks
     def test_create_duplicate_root(self):
         # setup for #5603
         path_a = os.path.join(self.input_path, "a")
         path_b = os.path.join(self.input_path, "b")
         os.mkdir(path_a)
         os.mkdir(path_b)
@@ -204,23 +232,84 @@
             f"--chunker-params=fail,{chunk_size},rrrEEErrrr",
             "--paths-from-stdin",
             "--list",
             "test",
             input=flist.encode(),
             exit_code=0,
         )
+        assert "retry: 3 of " in out
         assert "E input/file2" not in out  # we managed to read it in the 3rd retry (after 3 failed reads)
         # repo looking good overall? checks for rc == 0.
         self.cmd(f"--repo={self.repository_location}", "check", "--debug")
         # check files in created archive
         out = self.cmd(f"--repo={self.repository_location}", "list", "test")
         assert "input/file1" in out
         assert "input/file2" in out
         assert "input/file3" in out
 
+    @pytest.mark.skipif(is_root(), reason="test must not be run as (fake)root")
+    def test_create_no_permission_file(self):
+        file_path = os.path.join(self.input_path, "file")
+        self.create_regular_file(file_path + "1", size=1000)
+        self.create_regular_file(file_path + "2", size=1000)
+        self.create_regular_file(file_path + "3", size=1000)
+        # revoke read permissions on file2 for everybody, including us:
+        if is_win32:
+            subprocess.run(["icacls.exe", file_path + "2", "/deny", "everyone:(R)"])
+        else:
+            # note: this will NOT take away read permissions for root
+            os.chmod(file_path + "2", 0o000)
+        self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
+        flist = "".join(f"input/file{n}\n" for n in range(1, 4))
+        out = self.cmd(
+            f"--repo={self.repository_location}",
+            "create",
+            "--paths-from-stdin",
+            "--list",
+            "test",
+            input=flist.encode(),
+            exit_code=1,  # WARNING status: could not back up file2.
+        )
+        assert "retry: 1 of " not in out  # retries were NOT attempted!
+        assert "E input/file2" in out  # no permissions!
+        # repo looking good overall? checks for rc == 0.
+        self.cmd(f"--repo={self.repository_location}", "check", "--debug")
+        # check files in created archive
+        out = self.cmd(f"--repo={self.repository_location}", "list", "test")
+        assert "input/file1" in out
+        assert "input/file2" not in out  # it skipped file2
+        assert "input/file3" in out
+
+    def test_sanitized_stdin_name(self):
+        self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
+        self.cmd(f"--repo={self.repository_location}", "create", "--stdin-name", "./a//path", "test", "-", input=b"")
+        item = json.loads(self.cmd(f"--repo={self.repository_location}", "list", "test", "--json-lines"))
+        assert item["path"] == "a/path"
+
+    def test_dotdot_stdin_name(self):
+        self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
+        output = self.cmd(
+            f"--repo={self.repository_location}",
+            "create",
+            "--stdin-name",
+            "foo/../bar",
+            "test",
+            "-",
+            input=b"",
+            exit_code=2,
+        )
+        assert output.endswith("'..' element in path 'foo/../bar'" + os.linesep)
+
+    def test_dot_stdin_name(self):
+        self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
+        output = self.cmd(
+            f"--repo={self.repository_location}", "create", "--stdin-name", "./", "test", "-", input=b"", exit_code=2
+        )
+        assert output.endswith("'./' is not a valid file name" + os.linesep)
+
     def test_create_content_from_command(self):
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
         input_data = "some test content"
         name = "a/b/c"
         self.cmd(
             f"--repo={self.repository_location}",
             "create",
@@ -520,24 +609,24 @@
             "--exclude-if-present",
             ".NOBACKUP2",
             "--exclude-caches",
             "--keep-exclude-tags",
         )
         self._assert_test_keep_tagged()
 
-    def test_path_normalization(self):
+    def test_path_sanitation(self):
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
         self.create_regular_file("dir1/dir2/file", size=1024 * 80)
         with changedir("input/dir1/dir2"):
             self.cmd(f"--repo={self.repository_location}", "create", "test", "../../../input/dir1/../dir1/dir2/..")
         output = self.cmd(f"--repo={self.repository_location}", "list", "test")
         self.assert_not_in("..", output)
         self.assert_in(" input/dir1/dir2/file", output)
 
-    def test_exclude_normalization(self):
+    def test_exclude_sanitation(self):
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
         self.create_regular_file("file1", size=1024 * 80)
         self.create_regular_file("file2", size=1024 * 80)
         with changedir("input"):
             self.cmd(f"--repo={self.repository_location}", "create", "test1", ".", "--exclude=file1")
         with changedir("output"):
             self.cmd(f"--repo={self.repository_location}", "extract", "test1")
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/debug_cmds.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/debug_cmds.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import json
 import os
 import pstats
 import unittest
-from hashlib import sha256
 
 from ...constants import *  # NOQA
 from .. import changedir
 from . import ArchiverTestCaseBase, RemoteArchiverTestCaseBase, ArchiverTestCaseBinaryBase, RK_ENCRYPTION, BORG_EXES
+from ..compress import Compressor
 
 
 class ArchiverTestCase(ArchiverTestCaseBase):
     def test_debug_profile(self):
         self.create_test_files()
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
         self.cmd(f"--repo={self.repository_location}", "create", "test", "input", "--debug-profile=create.prof")
@@ -43,30 +43,89 @@
         output_dir = sorted(os.listdir("output"))
         assert len(output_dir) > 0 and output_dir[0].startswith("00000000_")
         assert "Done." in output
 
     def test_debug_put_get_delete_obj(self):
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
         data = b"some data"
-        hexkey = sha256(data).hexdigest()
         self.create_regular_file("file", contents=data)
-        output = self.cmd(f"--repo={self.repository_location}", "debug", "put-obj", "input/file")
-        assert hexkey in output
-        output = self.cmd(f"--repo={self.repository_location}", "debug", "get-obj", hexkey, "output/file")
-        assert hexkey in output
+        output = self.cmd(f"--repo={self.repository_location}", "debug", "id-hash", "input/file")
+        id_hash = output.strip()
+        output = self.cmd(f"--repo={self.repository_location}", "debug", "put-obj", id_hash, "input/file")
+        assert id_hash in output
+        output = self.cmd(f"--repo={self.repository_location}", "debug", "get-obj", id_hash, "output/file")
+        assert id_hash in output
         with open("output/file", "rb") as f:
             data_read = f.read()
         assert data == data_read
-        output = self.cmd(f"--repo={self.repository_location}", "debug", "delete-obj", hexkey)
+        output = self.cmd(f"--repo={self.repository_location}", "debug", "delete-obj", id_hash)
         assert "deleted" in output
-        output = self.cmd(f"--repo={self.repository_location}", "debug", "delete-obj", hexkey)
+        output = self.cmd(f"--repo={self.repository_location}", "debug", "delete-obj", id_hash)
         assert "not found" in output
         output = self.cmd(f"--repo={self.repository_location}", "debug", "delete-obj", "invalid")
         assert "is invalid" in output
 
+    def test_debug_id_hash_format_put_get_parse_obj(self):
+        """Test format-obj and parse-obj commands"""
+
+        self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
+        data = b"some data" * 100
+        meta_dict = {"some": "property"}
+        meta = json.dumps(meta_dict).encode()
+
+        self.create_regular_file("plain.bin", contents=data)
+        self.create_regular_file("meta.json", contents=meta)
+
+        output = self.cmd(f"--repo={self.repository_location}", "debug", "id-hash", "input/plain.bin")
+        id_hash = output.strip()
+
+        output = self.cmd(
+            f"--repo={self.repository_location}",
+            "debug",
+            "format-obj",
+            id_hash,
+            "input/plain.bin",
+            "input/meta.json",
+            "output/data.bin",
+            "--compression=zstd,2",
+        )
+
+        output = self.cmd(f"--repo={self.repository_location}", "debug", "put-obj", id_hash, "output/data.bin")
+        assert id_hash in output
+
+        output = self.cmd(f"--repo={self.repository_location}", "debug", "get-obj", id_hash, "output/object.bin")
+        assert id_hash in output
+
+        output = self.cmd(
+            f"--repo={self.repository_location}",
+            "debug",
+            "parse-obj",
+            id_hash,
+            "output/object.bin",
+            "output/plain.bin",
+            "output/meta.json",
+        )
+
+        with open("output/plain.bin", "rb") as f:
+            data_read = f.read()
+        assert data == data_read
+
+        with open("output/meta.json") as f:
+            meta_read = json.load(f)
+        for key, value in meta_dict.items():
+            assert meta_read.get(key) == value
+
+        assert meta_read.get("size") == len(data_read)
+
+        c = Compressor(name="zstd", level=2)
+        _, data_compressed = c.compress(meta_dict, data=data)
+        assert meta_read.get("csize") == len(data_compressed)
+        assert meta_read.get("ctype") == c.compressor.ID
+        assert meta_read.get("clevel") == c.compressor.level
+
     def test_debug_dump_manifest(self):
         self.create_regular_file("file1", size=1024 * 80)
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
         self.cmd(f"--repo={self.repository_location}", "create", "test", "input")
         dump_file = self.output_path + "/dump"
         output = self.cmd(f"--repo={self.repository_location}", "debug", "dump-manifest", dump_file)
         assert output == ""
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/delete_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/delete_cmd.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 import unittest
 
 from ...archive import Archive
 from ...constants import *  # NOQA
 from ...manifest import Manifest
 from ...repository import Repository
 from . import ArchiverTestCaseBase, RemoteArchiverTestCaseBase, ArchiverTestCaseBinaryBase, RK_ENCRYPTION, BORG_EXES
+from . import src_file
 
 
 class ArchiverTestCase(ArchiverTestCaseBase):
     def test_delete(self):
         self.create_regular_file("file1", size=1024 * 80)
         self.create_regular_file("dir2/file2", size=1024 * 80)
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
@@ -44,15 +45,15 @@
     def test_delete_force(self):
         self.cmd(f"--repo={self.repository_location}", "rcreate", "--encryption=none")
         self.create_src_archive("test")
         with Repository(self.repository_path, exclusive=True) as repository:
             manifest = Manifest.load(repository, Manifest.NO_OPERATION_CHECK)
             archive = Archive(manifest, "test")
             for item in archive.iter_items():
-                if item.path.endswith("testsuite/archiver/__init__.py"):
+                if item.path.endswith(src_file):
                     repository.delete(item.chunks[-1].id)
                     break
             else:
                 assert False  # missed the file
             repository.commit(compact=False)
         output = self.cmd(f"--repo={self.repository_location}", "delete", "-a", "test", "--force")
         self.assert_in("deleted archive was corrupted", output)
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/diff_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/diff_cmd.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 import json
 import os
 import stat
+import time
 import unittest
 
 from ...constants import *  # NOQA
 from .. import are_symlinks_supported, are_hardlinks_supported
-from ..platform import is_win32
+from ..platform import is_win32, is_darwin
 from . import ArchiverTestCaseBase, RemoteArchiverTestCaseBase, ArchiverTestCaseBinaryBase, RK_ENCRYPTION, BORG_EXES
 
 
 class ArchiverTestCase(ArchiverTestCaseBase):
     def test_basic_functionality(self):
         # Setup files for the first snapshot
         self.create_regular_file("empty", size=0)
@@ -66,122 +67,124 @@
         with open("input/empty", "ab") as fd:
             fd.write(b"appended_data")
 
         # Create the second snapshot
         self.cmd(f"--repo={self.repository_location}", "create", "test1a", "input")
         self.cmd(f"--repo={self.repository_location}", "create", "test1b", "input", "--chunker-params", "16,18,17,4095")
 
-        def do_asserts(output, can_compare_ids):
-            # File contents changed (deleted and replaced with a new file)
-            change = "B" if can_compare_ids else "{:<19}".format("modified")
+        def do_asserts(output, can_compare_ids, content_only=False):
+            lines: list = output.splitlines()
             assert "file_replaced" in output  # added to debug #3494
-            assert f"{change} input/file_replaced" in output
-
+            change = "modified.*B" if can_compare_ids else r"modified:  \(can't get size\)"
+            self.assert_line_exists(lines, f"{change}.*input/file_replaced")
             # File unchanged
             assert "input/file_unchanged" not in output
 
             # Directory replaced with a regular file
-            if "BORG_TESTS_IGNORE_MODES" not in os.environ and not is_win32:
-                assert "[drwxr-xr-x -> -rwxr-xr-x] input/dir_replaced_with_file" in output
+            if "BORG_TESTS_IGNORE_MODES" not in os.environ and not is_win32 and not content_only:
+                self.assert_line_exists(lines, "[drwxr-xr-x -> -rwxr-xr-x].*input/dir_replaced_with_file")
 
             # Basic directory cases
-            assert "added directory     input/dir_added" in output
-            assert "removed directory   input/dir_removed" in output
+            assert "added directory             input/dir_added" in output
+            assert "removed directory           input/dir_removed" in output
 
             if are_symlinks_supported():
                 # Basic symlink cases
-                assert "changed link        input/link_changed" in output
-                assert "added link          input/link_added" in output
-                assert "removed link        input/link_removed" in output
+                self.assert_line_exists(lines, "changed link.*input/link_changed")
+                self.assert_line_exists(lines, "added link.*input/link_added")
+                self.assert_line_exists(lines, "removed link.*input/link_removed")
 
                 # Symlink replacing or being replaced
-                assert "] input/dir_replaced_with_link" in output
-                assert "] input/link_replaced_by_file" in output
+                if not content_only:
+                    assert "input/dir_replaced_with_link" in output
+                    assert "input/link_replaced_by_file" in output
 
                 # Symlink target removed. Should not affect the symlink at all.
                 assert "input/link_target_removed" not in output
 
             # The inode has two links and the file contents changed. Borg
             # should notice the changes in both links. However, the symlink
             # pointing to the file is not changed.
-            change = "0 B" if can_compare_ids else "{:<19}".format("modified")
-            assert f"{change} input/empty" in output
+            change = "modified.*0 B" if can_compare_ids else r"modified:  \(can't get size\)"
+            self.assert_line_exists(lines, f"{change}.*input/empty")
             if are_hardlinks_supported():
-                assert f"{change} input/hardlink_contents_changed" in output
+                self.assert_line_exists(lines, f"{change}.*input/hardlink_contents_changed")
             if are_symlinks_supported():
                 assert "input/link_target_contents_changed" not in output
 
             # Added a new file and a hard link to it. Both links to the same
             # inode should appear as separate files.
-            assert "added       2.05 kB input/file_added" in output
+            assert "added:              2.05 kB input/file_added" in output
             if are_hardlinks_supported():
-                assert "added       2.05 kB input/hardlink_added" in output
+                assert "added:              2.05 kB input/hardlink_added" in output
 
             # check if a diff between nonexistent and empty new file is found
-            assert "added           0 B input/file_empty_added" in output
+            assert "added:                  0 B input/file_empty_added" in output
 
             # The inode has two links and both of them are deleted. They should
             # appear as two deleted files.
-            assert "removed       256 B input/file_removed" in output
+            assert "removed:              256 B input/file_removed" in output
             if are_hardlinks_supported():
-                assert "removed       256 B input/hardlink_removed" in output
+                assert "removed:              256 B input/hardlink_removed" in output
 
-            # Another link (marked previously as the source in borg) to the
-            # same inode was removed. This should not change this link at all.
-            if are_hardlinks_supported():
+            if are_hardlinks_supported() and content_only:
+                # Another link (marked previously as the source in borg) to the
+                # same inode was removed. This should only change the ctime since removing
+                # the link would result in the decrementation of the inode's hard-link count.
                 assert "input/hardlink_target_removed" not in output
 
-            # Another link (marked previously as the source in borg) to the
-            # same inode was replaced with a new regular file. This should not
-            # change this link at all.
-            if are_hardlinks_supported():
+                # Another link (marked previously as the source in borg) to the
+                # same inode was replaced with a new regular file. This should only change
+                # its ctime. This should not be reflected in the output if content-only is set
                 assert "input/hardlink_target_replaced" not in output
 
-        def do_json_asserts(output, can_compare_ids):
+        def do_json_asserts(output, can_compare_ids, content_only=False):
             def get_changes(filename, data):
                 chgsets = [j["changes"] for j in data if j["path"] == filename]
                 assert len(chgsets) < 2
                 # return a flattened list of changes for given filename
-                return [chg for chgset in chgsets for chg in chgset]
+                return sum(chgsets, [])
 
             # convert output to list of dicts
             joutput = [json.loads(line) for line in output.split("\n") if line]
 
             # File contents changed (deleted and replaced with a new file)
             expected = {"type": "modified", "added": 4096, "removed": 1024} if can_compare_ids else {"type": "modified"}
             assert expected in get_changes("input/file_replaced", joutput)
 
             # File unchanged
             assert not any(get_changes("input/file_unchanged", joutput))
 
             # Directory replaced with a regular file
-            if "BORG_TESTS_IGNORE_MODES" not in os.environ and not is_win32:
-                assert {"type": "mode", "old_mode": "drwxr-xr-x", "new_mode": "-rwxr-xr-x"} in get_changes(
+            if "BORG_TESTS_IGNORE_MODES" not in os.environ and not is_win32 and not content_only:
+                assert {"type": "changed mode", "item1": "drwxr-xr-x", "item2": "-rwxr-xr-x"} in get_changes(
                     "input/dir_replaced_with_file", joutput
                 )
 
             # Basic directory cases
             assert {"type": "added directory"} in get_changes("input/dir_added", joutput)
             assert {"type": "removed directory"} in get_changes("input/dir_removed", joutput)
 
             if are_symlinks_supported():
                 # Basic symlink cases
                 assert {"type": "changed link"} in get_changes("input/link_changed", joutput)
                 assert {"type": "added link"} in get_changes("input/link_added", joutput)
                 assert {"type": "removed link"} in get_changes("input/link_removed", joutput)
 
                 # Symlink replacing or being replaced
-                assert any(
-                    chg["type"] == "mode" and chg["new_mode"].startswith("l")
-                    for chg in get_changes("input/dir_replaced_with_link", joutput)
-                )
-                assert any(
-                    chg["type"] == "mode" and chg["old_mode"].startswith("l")
-                    for chg in get_changes("input/link_replaced_by_file", joutput)
-                )
+
+                if not content_only:
+                    assert any(
+                        chg["type"] == "changed mode" and chg["item1"].startswith("d") and chg["item2"].startswith("l")
+                        for chg in get_changes("input/dir_replaced_with_link", joutput)
+                    ), get_changes("input/dir_replaced_with_link", joutput)
+                    assert any(
+                        chg["type"] == "changed mode" and chg["item1"].startswith("l") and chg["item2"].startswith("-")
+                        for chg in get_changes("input/link_replaced_by_file", joutput)
+                    ), get_changes("input/link_replaced_by_file", joutput)
 
                 # Symlink target removed. Should not affect the symlink at all.
                 assert not any(get_changes("input/link_target_removed", joutput))
 
             # The inode has two links and the file contents changed. Borg
             # should notice the changes in both links. However, the symlink
             # pointing to the file is not changed.
@@ -190,42 +193,95 @@
             if are_hardlinks_supported():
                 assert expected in get_changes("input/hardlink_contents_changed", joutput)
             if are_symlinks_supported():
                 assert not any(get_changes("input/link_target_contents_changed", joutput))
 
             # Added a new file and a hard link to it. Both links to the same
             # inode should appear as separate files.
-            assert {"type": "added", "size": 2048} in get_changes("input/file_added", joutput)
+            assert {"added": 2048, "removed": 0, "type": "added"} in get_changes("input/file_added", joutput)
             if are_hardlinks_supported():
-                assert {"type": "added", "size": 2048} in get_changes("input/hardlink_added", joutput)
+                assert {"added": 2048, "removed": 0, "type": "added"} in get_changes("input/hardlink_added", joutput)
 
             # check if a diff between nonexistent and empty new file is found
-            assert {"type": "added", "size": 0} in get_changes("input/file_empty_added", joutput)
+            assert {"added": 0, "removed": 0, "type": "added"} in get_changes("input/file_empty_added", joutput)
 
             # The inode has two links and both of them are deleted. They should
             # appear as two deleted files.
-            assert {"type": "removed", "size": 256} in get_changes("input/file_removed", joutput)
+            assert {"added": 0, "removed": 256, "type": "removed"} in get_changes("input/file_removed", joutput)
             if are_hardlinks_supported():
-                assert {"type": "removed", "size": 256} in get_changes("input/hardlink_removed", joutput)
+                assert {"added": 0, "removed": 256, "type": "removed"} in get_changes("input/hardlink_removed", joutput)
 
-            # Another link (marked previously as the source in borg) to the
-            # same inode was removed. This should not change this link at all.
-            if are_hardlinks_supported():
+            if are_hardlinks_supported() and content_only:
+                # Another link (marked previously as the source in borg) to the
+                # same inode was removed. This should only change the ctime since removing
+                # the link would result in the decrementation of the inode's hard-link count.
                 assert not any(get_changes("input/hardlink_target_removed", joutput))
 
-            # Another link (marked previously as the source in borg) to the
-            # same inode was replaced with a new regular file. This should not
-            # change this link at all.
-            if are_hardlinks_supported():
+                # Another link (marked previously as the source in borg) to the
+                # same inode was replaced with a new regular file. This should only change
+                # its ctime. This should not be reflected in the output if content-only is set
                 assert not any(get_changes("input/hardlink_target_replaced", joutput))
 
-        do_asserts(self.cmd(f"--repo={self.repository_location}", "diff", "test0", "test1a"), True)
+        output = self.cmd(f"--repo={self.repository_location}", "diff", "test0", "test1a")
+        do_asserts(output, True)
         # We expect exit_code=1 due to the chunker params warning
-        do_asserts(self.cmd(f"--repo={self.repository_location}", "diff", "test0", "test1b", exit_code=1), False)
-        do_json_asserts(self.cmd(f"--repo={self.repository_location}", "diff", "test0", "test1a", "--json-lines"), True)
+        output = self.cmd(
+            f"--repo={self.repository_location}", "diff", "test0", "test1b", "--content-only", exit_code=1
+        )
+        do_asserts(output, False, content_only=True)
+
+        output = self.cmd(f"--repo={self.repository_location}", "diff", "test0", "test1a", "--json-lines")
+        do_json_asserts(output, True)
+
+        output = self.cmd(
+            f"--repo={self.repository_location}", "diff", "test0", "test1a", "--json-lines", "--content-only"
+        )
+        do_json_asserts(output, True, content_only=True)
+
+    def test_time_diffs(self):
+        self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
+        self.create_regular_file("test_file", size=10)
+        self.cmd(f"--repo={self.repository_location}", "create", "archive1", "input")
+        time.sleep(0.1)
+        os.unlink("input/test_file")
+        if is_win32:
+            # Sleeping for 15s because Windows doesn't refresh ctime if file is deleted and recreated within 15 seconds.
+            time.sleep(15)
+        elif is_darwin:
+            time.sleep(1)  # HFS has a 1s timestamp granularity
+        self.create_regular_file("test_file", size=15)
+        self.cmd(f"--repo={self.repository_location}", "create", "archive2", "input")
+        output = self.cmd(
+            f"--repo={self.repository_location}",
+            "diff",
+            "archive1",
+            "archive2",
+            "--format",
+            "'{mtime}{ctime} {path}{NL}'",
+        )
+        self.assert_in("mtime", output)
+        self.assert_in("ctime", output)  # Should show up on windows as well since it is a new file.
+        if is_darwin:
+            time.sleep(1)  # HFS has a 1s timestamp granularity
+        os.chmod("input/test_file", 0o777)
+        self.cmd(f"--repo={self.repository_location}", "create", "archive3", "input")
+        output = self.cmd(
+            f"--repo={self.repository_location}",
+            "diff",
+            "archive2",
+            "archive3",
+            "--format",
+            "'{mtime}{ctime} {path}{NL}'",
+        )
+        self.assert_not_in("mtime", output)
+        # Checking platform because ctime should not be shown on windows since it wasn't recreated.
+        if not is_win32:
+            self.assert_in("ctime", output)
+        else:
+            self.assert_not_in("ctime", output)
 
     def test_sort_option(self):
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
 
         self.create_regular_file("a_file_removed", size=8)
         self.create_regular_file("f_file_removed", size=16)
         self.create_regular_file("c_file_changed", size=32)
@@ -238,25 +294,27 @@
         os.unlink("input/e_file_changed")
         self.create_regular_file("c_file_changed", size=512)
         self.create_regular_file("e_file_changed", size=1024)
         self.create_regular_file("b_file_added", size=128)
         self.create_regular_file("d_file_added", size=256)
         self.cmd(f"--repo={self.repository_location}", "create", "test1", "input")
 
-        output = self.cmd(f"--repo={self.repository_location}", "diff", "test0", "test1", "--sort")
+        output = self.cmd(f"--repo={self.repository_location}", "diff", "test0", "test1", "--sort", "--content-only")
         expected = [
             "a_file_removed",
             "b_file_added",
             "c_file_changed",
             "d_file_added",
             "e_file_changed",
             "f_file_removed",
         ]
-
-        assert all(x in line for x, line in zip(expected, output.splitlines()))
+        assert isinstance(output, str)
+        outputs = output.splitlines()
+        assert len(outputs) == len(expected)
+        assert all(x in line for x, line in zip(expected, outputs))
 
 
 class RemoteArchiverTestCase(RemoteArchiverTestCaseBase, ArchiverTestCase):
     """run the same tests, but with a remote repository"""
 
 
 @unittest.skipUnless("binary" in BORG_EXES, "no borg.exe available")
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/disk_full.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/disk_full.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/extract_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/extract_cmd.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 import errno
 import os
 import shutil
+import time
 import unittest
 from unittest.mock import patch
 
 import pytest
 
 from ... import xattr
 from ...chunker import has_seek_hole
 from ...constants import *  # NOQA
 from ...helpers import EXIT_WARNING
 from ...helpers import flags_noatime, flags_normal
 from .. import changedir, same_ts_ns
 from .. import are_symlinks_supported, are_hardlinks_supported, is_utime_fully_supported, is_birthtime_fully_supported
-from ..platform import is_darwin
+from ..platform import is_darwin, is_win32
 from . import (
     ArchiverTestCaseBase,
     ArchiverTestCaseBinaryBase,
     RemoteArchiverTestCaseBase,
     RK_ENCRYPTION,
     requires_hardlinks,
     BORG_EXES,
@@ -617,14 +618,62 @@
         xattr.setxattr(b"input/dir%p", b"user.attribute", b"value")
         self.cmd(f"--repo={self.repository_location}", "rcreate", "-e" "none")
         self.cmd(f"--repo={self.repository_location}", "create", "test", "input")
         with changedir("output"):
             with patch.object(xattr, "setxattr", patched_setxattr_EACCES):
                 self.cmd(f"--repo={self.repository_location}", "extract", "test", exit_code=EXIT_WARNING)
 
+    def test_extract_continue(self):
+        CONTENTS1, CONTENTS2, CONTENTS3 = b"contents1" * 100, b"contents2" * 200, b"contents3" * 300
+        self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
+        self.create_regular_file("file1", contents=CONTENTS1)
+        self.create_regular_file("file2", contents=CONTENTS2)
+        self.create_regular_file("file3", contents=CONTENTS3)
+        self.cmd(f"--repo={self.repository_location}", "create", "arch", "input")
+        with changedir("output"):
+            # we simulate an interrupted/partial extraction:
+            self.cmd(f"--repo={self.repository_location}", "extract", "arch")
+            # do not modify file1, it stands for a successfully extracted file
+            file1_st = os.stat("input/file1")
+            # simulate a partially extracted file2 (smaller size, archived mtime not yet set)
+            file2_st = os.stat("input/file2")
+            # make a hardlink, so it does not free the inode when unlinking input/file2
+            os.link("input/file2", "hardlink-to-keep-inode-f2")
+            os.truncate("input/file2", 123)  # -> incorrect size, incorrect mtime
+            # simulate file3 has not yet been extracted
+            file3_st = os.stat("input/file3")
+            # make a hardlink, so it does not free the inode when unlinking input/file3
+            os.link("input/file3", "hardlink-to-keep-inode-f3")
+            os.remove("input/file3")
+        time.sleep(1)  # needed due to timestamp granularity of apple hfs+
+        with changedir("output"):
+            # now try to continue extracting, using the same archive, same output dir:
+            self.cmd(f"--repo={self.repository_location}", "extract", "arch", "--continue")
+            now_file1_st = os.stat("input/file1")
+            assert file1_st.st_ino == now_file1_st.st_ino  # file1 was NOT extracted again
+            assert file1_st.st_mtime_ns == now_file1_st.st_mtime_ns  # has correct mtime
+            new_file2_st = os.stat("input/file2")
+            assert file2_st.st_ino != new_file2_st.st_ino  # file2 was extracted again
+            assert file2_st.st_mtime_ns == new_file2_st.st_mtime_ns  # has correct mtime
+            new_file3_st = os.stat("input/file3")
+            assert file3_st.st_ino != new_file3_st.st_ino  # file3 was extracted again
+            assert file3_st.st_mtime_ns == new_file3_st.st_mtime_ns  # has correct mtime
+            # windows has a strange ctime behaviour when deleting and recreating a file
+            if not is_win32:
+                assert file1_st.st_ctime_ns == now_file1_st.st_ctime_ns  # file not extracted again
+                assert file2_st.st_ctime_ns != new_file2_st.st_ctime_ns  # file extracted again
+                assert file3_st.st_ctime_ns != new_file3_st.st_ctime_ns  # file extracted again
+            # check if all contents (and thus also file sizes) are correct:
+            with open("input/file1", "rb") as f:
+                assert f.read() == CONTENTS1
+            with open("input/file2", "rb") as f:
+                assert f.read() == CONTENTS2
+            with open("input/file3", "rb") as f:
+                assert f.read() == CONTENTS3
+
 
 class RemoteArchiverTestCase(RemoteArchiverTestCaseBase, ArchiverTestCase):
     """run the same tests, but with a remote repository"""
 
 
 @unittest.skipUnless("binary" in BORG_EXES, "no borg.exe available")
 class ArchiverTestCaseBinary(ArchiverTestCaseBinaryBase, ArchiverTestCase):
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/help_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/help_cmd.py`

 * *Files 6% similar despite different names*

```diff
@@ -47,10 +47,11 @@
 
 @pytest.mark.parametrize("command, parser", list(get_all_parsers().items()))
 def test_help_formatting(command, parser):
     if isinstance(parser.epilog, RstToTextLazy):
         assert parser.epilog.rst
 
 
-@pytest.mark.parametrize("topic, helptext", list(Archiver.helptext.items()))
-def test_help_formatting_helptexts(topic, helptext):
+@pytest.mark.parametrize("topic", list(Archiver.helptext.keys()))
+def test_help_formatting_helptexts(topic):
+    helptext = Archiver.helptext[topic]
     assert str(rst_to_terminal(helptext))
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/info_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/info_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/key_cmds.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/key_cmds.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/list_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/list_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/lock_cmds.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/lock_cmds.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/mount_cmds.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/mount_cmds.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,22 +10,16 @@
 from ...constants import *  # NOQA
 from ...locking import Lock
 from ...helpers import flags_noatime, flags_normal
 from .. import has_lchflags, llfuse
 from .. import changedir, no_selinux, same_ts_ns
 from .. import are_symlinks_supported, are_hardlinks_supported, are_fifos_supported
 from ..platform import fakeroot_detected
-from . import (
-    ArchiverTestCaseBase,
-    ArchiverTestCaseBinaryBase,
-    RemoteArchiverTestCaseBase,
-    RK_ENCRYPTION,
-    requires_hardlinks,
-    BORG_EXES,
-)
+from . import ArchiverTestCaseBase, ArchiverTestCaseBinaryBase, RemoteArchiverTestCaseBase, RK_ENCRYPTION, BORG_EXES
+from . import src_file, requires_hardlinks
 
 
 class ArchiverTestCase(ArchiverTestCaseBase):
     @requires_hardlinks
     @unittest.skipUnless(llfuse, "llfuse not installed")
     def test_fuse_mount_hardlinks(self):
         self._extract_hardlinks_setup()
@@ -201,15 +195,15 @@
     def test_fuse_allow_damaged_files(self):
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
         self.create_src_archive("archive")
         # Get rid of a chunk and repair it
         archive, repository = self.open_archive("archive")
         with repository:
             for item in archive.iter_items():
-                if item.path.endswith("testsuite/archiver/__init__.py"):
+                if item.path.endswith(src_file):
                     repository.delete(item.chunks[-1].id)
                     path = item.path  # store full path for later
                     break
             else:
                 assert False  # missed the file
             repository.commit(compact=False)
         self.cmd(f"--repo={self.repository_location}", "check", "--repair", exit_code=0)
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/patterns.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/patterns.py`

 * *Files 26% similar despite different names*

```diff
@@ -18,10 +18,9 @@
         filter = build_filter(matcher, 0)
         assert filter(Item(path="anything"))
 
     def test_strip_components(self):
         matcher = PatternMatcher(fallback=True)
         filter = build_filter(matcher, strip_components=1)
         assert not filter(Item(path="shallow"))
-        assert not filter(Item(path="shallow/"))  # can this even happen? paths are normalized...
         assert filter(Item(path="deep enough/file"))
         assert filter(Item(path="something/dir/file"))
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/prune_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/prune_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/rcompress_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/rcompress_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/rcreate_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/rcreate_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/rdelete_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/rdelete_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/recreate_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/recreate_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/rename_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/rename_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/repo12.tar.gz` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/repo12.tar.gz`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/return_codes.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/return_codes.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/rinfo_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/rinfo_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/rlist_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/rlist_cmd.py`

 * *Files 3% similar despite different names*

```diff
@@ -36,14 +36,27 @@
         self.assertEqual(output_1, output_2)
         output_1 = self.cmd(f"--repo={self.repository_location}", "rlist", "--short")
         self.assertEqual(output_1, "test-1" + os.linesep + "test-2" + os.linesep)
         output_3 = self.cmd(f"--repo={self.repository_location}", "rlist", "--format", "{name} {comment}{NL}")
         self.assert_in("test-1 comment 1" + os.linesep, output_3)
         self.assert_in("test-2 comment 2" + os.linesep, output_3)
 
+    def test_size_nfiles(self):
+        self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
+        self.create_regular_file("file1", size=123000)
+        self.create_regular_file("file2", size=456)
+        self.cmd(f"--repo={self.repository_location}", "create", "test", "input/file1", "input/file2")
+        output = self.cmd(f"--repo={self.repository_location}", "list", "test")
+        print(output)
+        output = self.cmd(f"--repo={self.repository_location}", "rlist", "--format", "{name} {nfiles} {size}")
+        o_t = output.split()
+        assert o_t[0] == "test"
+        assert int(o_t[1]) == 2
+        assert 123456 <= int(o_t[2]) < 123999  # there is some metadata overhead
+
     def test_date_matching(self):
         self.cmd(f"--repo={self.repository_location}", "rcreate", RK_ENCRYPTION)
         earliest_ts = "2022-11-20T23:59:59"
         ts_in_between = "2022-12-18T23:59:59"
         self.create_src_archive("archive1", ts=earliest_ts)
         self.create_src_archive("archive2", ts=ts_in_between)
         self.create_src_archive("archive3")
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/tar_cmds.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/tar_cmds.py`

 * *Files 21% similar despite different names*

```diff
@@ -125,28 +125,102 @@
         self.cmd(f"--repo={self.repository_location}", "create", "src", "input")
         self.cmd(f"--repo={self.repository_location}", "export-tar", "src", "simple.tar", f"--tar-format={tar_format}")
         self.cmd(f"--repo={self.repository_location}", "import-tar", "dst", "simple.tar")
         with changedir(self.output_path):
             self.cmd(f"--repo={self.repository_location}", "extract", "dst")
         self.assert_dirs_equal("input", "output/input", ignore_ns=True, ignore_xattrs=True)
 
+    def test_import_unusual_tar(self):
+        # Contains these, unusual entries:
+        # /foobar
+        # ./bar
+        # ./foo2/
+        # ./foo//bar
+        # ./
+        tar_archive = os.path.join(os.path.dirname(__file__), "unusual_paths.tar")
+
+        self.cmd(f"--repo={self.repository_location}", "rcreate", "--encryption=none")
+        self.cmd(f"--repo={self.repository_location}", "import-tar", "dst", tar_archive)
+        files = self.cmd(f"--repo={self.repository_location}", "list", "dst", "--format", "{path}{NL}").splitlines()
+        self.assert_equal(set(files), {"foobar", "bar", "foo2", "foo/bar", "."})
+
+    def test_import_tar_with_dotdot(self):
+        # Contains this file:
+        # ../../../../etc/shadow
+        tar_archive = os.path.join(os.path.dirname(__file__), "dotdot_path.tar")
+
+        self.cmd(f"--repo={self.repository_location}", "rcreate", "--encryption=none")
+        with pytest.raises(ValueError, match="unexpected '..' element in path '../../../../etc/shadow'"):
+            self.cmd(f"--repo={self.repository_location}", "import-tar", "dst", tar_archive, exit_code=2)
+
     @requires_gzip
     def test_import_tar_gz(self, tar_format="GNU"):
         if not shutil.which("gzip"):
             pytest.skip("gzip is not installed")
         self.create_test_files(create_hardlinks=False)  # hardlinks become separate files
         os.unlink("input/flagfile")
         self.cmd(f"--repo={self.repository_location}", "rcreate", "--encryption=none")
         self.cmd(f"--repo={self.repository_location}", "create", "src", "input")
         self.cmd(f"--repo={self.repository_location}", "export-tar", "src", "simple.tgz", f"--tar-format={tar_format}")
         self.cmd(f"--repo={self.repository_location}", "import-tar", "dst", "simple.tgz")
         with changedir(self.output_path):
             self.cmd(f"--repo={self.repository_location}", "extract", "dst")
         self.assert_dirs_equal("input", "output/input", ignore_ns=True, ignore_xattrs=True)
 
+    @requires_gnutar
+    def test_import_concatenated_tar_with_ignore_zeros(self):
+        self.create_test_files(create_hardlinks=False)  # hardlinks become separate files
+        os.unlink("input/flagfile")
+        with changedir("input"):
+            subprocess.check_call(["tar", "cf", "file1.tar", "file1"])
+            subprocess.check_call(["tar", "cf", "the_rest.tar", "--exclude", "file1*", "."])
+            with open("concatenated.tar", "wb") as concatenated:
+                with open("file1.tar", "rb") as file1:
+                    concatenated.write(file1.read())
+                # Clean up for assert_dirs_equal.
+                os.unlink("file1.tar")
+
+                with open("the_rest.tar", "rb") as the_rest:
+                    concatenated.write(the_rest.read())
+                # Clean up for assert_dirs_equal.
+                os.unlink("the_rest.tar")
+
+        self.cmd(f"--repo={self.repository_location}", "rcreate", "--encryption=none")
+        self.cmd(f"--repo={self.repository_location}", "import-tar", "--ignore-zeros", "dst", "input/concatenated.tar")
+        # Clean up for assert_dirs_equal.
+        os.unlink("input/concatenated.tar")
+
+        with changedir(self.output_path):
+            self.cmd(f"--repo={self.repository_location}", "extract", "dst")
+        self.assert_dirs_equal("input", "output", ignore_ns=True, ignore_xattrs=True)
+
+    @requires_gnutar
+    def test_import_concatenated_tar_without_ignore_zeros(self):
+        self.create_test_files(create_hardlinks=False)  # hardlinks become separate files
+        os.unlink("input/flagfile")
+        with changedir("input"):
+            subprocess.check_call(["tar", "cf", "file1.tar", "file1"])
+            subprocess.check_call(["tar", "cf", "the_rest.tar", "--exclude", "file1*", "."])
+            with open("concatenated.tar", "wb") as concatenated:
+                with open("file1.tar", "rb") as file1:
+                    concatenated.write(file1.read())
+                with open("the_rest.tar", "rb") as the_rest:
+                    concatenated.write(the_rest.read())
+                os.unlink("the_rest.tar")
+
+        self.cmd(f"--repo={self.repository_location}", "rcreate", "--encryption=none")
+        self.cmd(f"--repo={self.repository_location}", "import-tar", "dst", "input/concatenated.tar")
+
+        with changedir(self.output_path):
+            self.cmd(f"--repo={self.repository_location}", "extract", "dst")
+
+        # Negative test -- assert that only file1 has been extracted, and the_rest has been ignored
+        # due to zero-filled block marker.
+        self.assert_equal(os.listdir("output"), ["file1"])
+
     def test_roundtrip_pax_borg(self):
         self.create_test_files()
         self.cmd(f"--repo={self.repository_location}", "rcreate", "--encryption=none")
         self.cmd(f"--repo={self.repository_location}", "create", "src", "input")
         self.cmd(f"--repo={self.repository_location}", "export-tar", "src", "simple.tar", "--tar-format=BORG")
         self.cmd(f"--repo={self.repository_location}", "import-tar", "dst", "simple.tar")
         with changedir(self.output_path):
@@ -157,7 +231,12 @@
 class RemoteArchiverTestCase(RemoteArchiverTestCaseBase, ArchiverTestCase):
     """run the same tests, but with a remote repository"""
 
 
 @unittest.skipUnless("binary" in BORG_EXES, "no borg.exe available")
 class ArchiverTestCaseBinary(ArchiverTestCaseBinaryBase, ArchiverTestCase):
     """runs the same tests, but via the borg binary"""
+
+    @unittest.skip("does not work with binaries")
+    def test_import_tar_with_dotdot(self):
+        # the test checks for a raised exception. that can't work if the code runs in a separate process.
+        pass
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/archiver/transfer_cmd.py` & `borgbackup-2.0.0b6/src/borg/testsuite/archiver/transfer_cmd.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/benchmark.py` & `borgbackup-2.0.0b6/src/borg/testsuite/benchmark.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/cache.py` & `borgbackup-2.0.0b6/src/borg/testsuite/cache.py`

 * *Files 2% similar despite different names*

```diff
@@ -70,14 +70,15 @@
             ),  # structure 3/3
             (1, "Unexpected object: integer"),
             (1.0, "Unexpected object: double"),
             (True, "Unexpected object: true"),
             (False, "Unexpected object: false"),
             (None, "Unexpected object: nil"),
         ),
+        ids=["map", "bytes", "int", "double", "true", "false", "none"],
     )
     @pytest.mark.parametrize(
         "structure",
         (lambda elem: {"chunks": elem}, lambda elem: {"chunks": [elem]}, lambda elem: {"chunks": [(elem, 1)]}),
     )
     def test_corrupted(self, sync, structure, elem, error):
         packed = packb(structure(elem))
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/checksums.py` & `borgbackup-2.0.0b6/src/borg/testsuite/checksums.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/chunker.py` & `borgbackup-2.0.0b6/src/borg/testsuite/chunker.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/chunker_pytest.py` & `borgbackup-2.0.0b6/src/borg/testsuite/chunker_pytest.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from io import BytesIO
 import os
 import tempfile
 
 import pytest
 
 from .chunker import cf
-from ..chunker import ChunkerFixed, sparsemap, has_seek_hole, ChunkerFailing
+from ..chunker import Chunker, ChunkerFixed, sparsemap, has_seek_hole, ChunkerFailing
 from ..constants import *  # NOQA
 
 BS = 4096  # fs block size
 
 # some sparse files. X = content blocks, _ = sparse blocks.
 # X__XXX____
 map_sparse1 = [(0 * BS, 1 * BS, True), (1 * BS, 2 * BS, False), (3 * BS, 3 * BS, True), (6 * BS, 4 * BS, False)]
@@ -147,7 +147,34 @@
         c1 = next(ch)  # block 3: success!
         c2 = next(ch)  # block 4: success!
         c3 = next(ch)  # block 5: success!
         assert c1.meta["allocation"] == c2.meta["allocation"] == c3.meta["allocation"] == CH_DATA
         assert c1.data == data[:SIZE]
         assert c2.data == data[SIZE : 2 * SIZE]
         assert c3.data == data[2 * SIZE :]
+
+
+def test_buzhash_chunksize_distribution():
+    data = os.urandom(1048576)
+    min_exp, max_exp, mask = 10, 16, 14  # chunk size target 16kiB, clip at 1kiB and 64kiB
+    chunker = Chunker(0, min_exp, max_exp, mask, 4095)
+    f = BytesIO(data)
+    chunks = cf(chunker.chunkify(f))
+    del chunks[-1]  # get rid of the last chunk, it can be smaller than 2**min_exp
+    chunk_sizes = [len(chunk) for chunk in chunks]
+    chunks_count = len(chunks)
+    min_chunksize_observed = min(chunk_sizes)
+    max_chunksize_observed = max(chunk_sizes)
+    min_count = sum((int(size == 2**min_exp) for size in chunk_sizes))
+    max_count = sum((int(size == 2**max_exp) for size in chunk_sizes))
+    print(
+        f"count: {chunks_count} min: {min_chunksize_observed} max: {max_chunksize_observed} "
+        f"min count: {min_count} max count: {max_count}"
+    )
+    # usually there will about 64 chunks
+    assert 32 < chunks_count < 128
+    # chunks always must be between min and max (clipping must work):
+    assert min_chunksize_observed >= 2**min_exp
+    assert max_chunksize_observed <= 2**max_exp
+    # most chunks should be cut due to buzhash triggering, not due to clipping at min/max size:
+    assert min_count < 10
+    assert max_count < 10
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/chunker_slow.py` & `borgbackup-2.0.0b6/src/borg/testsuite/chunker_slow.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/crypto.py` & `borgbackup-2.0.0b6/src/borg/testsuite/crypto.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/efficient_collection_queue.py` & `borgbackup-2.0.0b6/src/borg/testsuite/efficient_collection_queue.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/file_integrity.py` & `borgbackup-2.0.0b6/src/borg/testsuite/file_integrity.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/hashindex.py` & `borgbackup-2.0.0b6/src/borg/testsuite/hashindex.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/hashindex_pytest.py` & `borgbackup-2.0.0b6/src/borg/testsuite/hashindex_pytest.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/helpers.py` & `borgbackup-2.0.0b6/src/borg/testsuite/helpers.py`

 * *Files 4% similar despite different names*

```diff
@@ -21,37 +21,38 @@
     format_file_size,
     parse_file_size,
     format_timedelta,
     format_line,
     PlaceholderError,
     replace_placeholders,
 )
-from ..helpers import make_path_safe, clean_lines
+from ..helpers import remove_dotdot_prefixes, make_path_safe, clean_lines
 from ..helpers import interval
-from ..helpers import get_base_dir, get_cache_dir, get_keys_dir, get_security_dir, get_config_dir
+from ..helpers import get_base_dir, get_cache_dir, get_keys_dir, get_security_dir, get_config_dir, get_runtime_dir
 from ..helpers import is_slow_msgpack
 from ..helpers import msgpack
 from ..helpers import yes, TRUISH, FALSISH, DEFAULTISH
 from ..helpers import StableDict, bin_to_hex
 from ..helpers import parse_timestamp, ChunkIteratorFileWrapper, ChunkerParams
 from ..helpers import archivename_validator, text_validator
-from ..helpers import ProgressIndicatorPercent, ProgressIndicatorEndless
+from ..helpers import ProgressIndicatorPercent
 from ..helpers import swidth_slice
 from ..helpers import chunkit
 from ..helpers import safe_ns, safe_s, SUPPORT_32BIT_PLATFORMS
 from ..helpers import popen_with_error_handling
 from ..helpers import dash_open
 from ..helpers import iter_separated
 from ..helpers import eval_escapes
 from ..helpers import safe_unlink
 from ..helpers import text_to_json, binary_to_json
 from ..helpers.passphrase import Passphrase, PasswordRetriesExceeded
-from ..platform import is_cygwin, is_win32, is_darwin
+from ..platform import is_cygwin, is_win32, is_darwin, swidth
 
 from . import BaseTestCase, FakeInputs, are_hardlinks_supported
+from . import rejected_dotdot_paths
 
 
 def test_bin_to_hex():
     assert bin_to_hex(b"") == ""
     assert bin_to_hex(b"\x00\x01\xff") == "0001ff"
 
 
@@ -180,14 +181,22 @@
             == "Location(proto='ssh', user='user', host='2a02:0001:0002:0003:0004:0005:0006:0007', port=None, path='/some/path')"
         )
         assert (
             repr(Location("ssh://user@[2a02:0001:0002:0003:0004:0005:0006:0007]:1234/some/path"))
             == "Location(proto='ssh', user='user', host='2a02:0001:0002:0003:0004:0005:0006:0007', port=1234, path='/some/path')"
         )
 
+    def test_socket(self, monkeypatch, keys_dir):
+        monkeypatch.delenv("BORG_REPO", raising=False)
+        assert (
+            repr(Location("socket:///repo/path"))
+            == "Location(proto='socket', user=None, host=None, port=None, path='/repo/path')"
+        )
+        assert Location("socket:///some/path").to_key_filename() == keys_dir + "some_path"
+
     def test_file(self, monkeypatch, keys_dir):
         monkeypatch.delenv("BORG_REPO", raising=False)
         assert (
             repr(Location("file:///some/path"))
             == "Location(proto='file', user=None, host=None, port=None, path='/some/path')"
         )
         assert (
@@ -271,14 +280,15 @@
     def test_canonical_path(self, monkeypatch):
         monkeypatch.delenv("BORG_REPO", raising=False)
         locations = [
             "some/path",
             "file://some/path",
             "host:some/path",
             "host:~user/some/path",
+            "socket:///some/path",
             "ssh://host/some/path",
             "ssh://user@host:1234/some/path",
         ]
         for location in locations:
             assert (
                 Location(location).canonical_path() == Location(Location(location).canonical_path()).canonical_path()
             ), ("failed: %s" % location)
@@ -364,40 +374,61 @@
     assert ChunkerParams("default") == ("buzhash", 19, 23, 21, 4095)
     assert ChunkerParams("19,23,21,4095") == ("buzhash", 19, 23, 21, 4095)
     assert ChunkerParams("buzhash,19,23,21,4095") == ("buzhash", 19, 23, 21, 4095)
     assert ChunkerParams("10,23,16,4095") == ("buzhash", 10, 23, 16, 4095)
     assert ChunkerParams("fixed,4096") == ("fixed", 4096, 0)
     assert ChunkerParams("fixed,4096,200") == ("fixed", 4096, 200)
     # invalid values checking
-    with pytest.raises(ValueError):
+    with pytest.raises(ArgumentTypeError):
         ChunkerParams("crap,1,2,3,4")  # invalid algo
-    with pytest.raises(ValueError):
+    with pytest.raises(ArgumentTypeError):
         ChunkerParams("buzhash,5,7,6,4095")  # too small min. size
-    with pytest.raises(ValueError):
+    with pytest.raises(ArgumentTypeError):
         ChunkerParams("buzhash,19,24,21,4095")  # too big max. size
-    with pytest.raises(ValueError):
+    with pytest.raises(ArgumentTypeError):
         ChunkerParams("buzhash,23,19,21,4095")  # violates min <= mask <= max
-    with pytest.raises(ValueError):
+    with pytest.raises(ArgumentTypeError):
         ChunkerParams("fixed,63")  # too small block size
-    with pytest.raises(ValueError):
+    with pytest.raises(ArgumentTypeError):
         ChunkerParams("fixed,%d,%d" % (MAX_DATA_SIZE + 1, 4096))  # too big block size
-    with pytest.raises(ValueError):
+    with pytest.raises(ArgumentTypeError):
         ChunkerParams("fixed,%d,%d" % (4096, MAX_DATA_SIZE + 1))  # too big header size
 
 
+class RemoveDotdotPrefixesTestCase(BaseTestCase):
+    def test(self):
+        self.assert_equal(remove_dotdot_prefixes("."), ".")
+        self.assert_equal(remove_dotdot_prefixes(".."), ".")
+        self.assert_equal(remove_dotdot_prefixes("/"), ".")
+        self.assert_equal(remove_dotdot_prefixes("//"), ".")
+        self.assert_equal(remove_dotdot_prefixes("foo"), "foo")
+        self.assert_equal(remove_dotdot_prefixes("foo/bar"), "foo/bar")
+        self.assert_equal(remove_dotdot_prefixes("/foo/bar"), "foo/bar")
+        self.assert_equal(remove_dotdot_prefixes("../foo/bar"), "foo/bar")
+
+
 class MakePathSafeTestCase(BaseTestCase):
     def test(self):
+        self.assert_equal(make_path_safe("."), ".")
+        self.assert_equal(make_path_safe("./"), ".")
+        self.assert_equal(make_path_safe("./foo"), "foo")
+        self.assert_equal(make_path_safe(".//foo"), "foo")
+        self.assert_equal(make_path_safe(".//foo//bar//"), "foo/bar")
         self.assert_equal(make_path_safe("/foo/bar"), "foo/bar")
-        self.assert_equal(make_path_safe("/foo/bar"), "foo/bar")
-        self.assert_equal(make_path_safe("/f/bar"), "f/bar")
-        self.assert_equal(make_path_safe("fo/bar"), "fo/bar")
-        self.assert_equal(make_path_safe("../foo/bar"), "foo/bar")
-        self.assert_equal(make_path_safe("../../foo/bar"), "foo/bar")
-        self.assert_equal(make_path_safe("/"), ".")
-        self.assert_equal(make_path_safe("/"), ".")
+        self.assert_equal(make_path_safe("//foo/bar"), "foo/bar")
+        self.assert_equal(make_path_safe("//foo/./bar"), "foo/bar")
+        self.assert_equal(make_path_safe(".test"), ".test")
+        self.assert_equal(make_path_safe(".test."), ".test.")
+        self.assert_equal(make_path_safe("..test.."), "..test..")
+        self.assert_equal(make_path_safe("/te..st/foo/bar"), "te..st/foo/bar")
+        self.assert_equal(make_path_safe("/..test../abc//"), "..test../abc")
+
+        for path in rejected_dotdot_paths:
+            with pytest.raises(ValueError, match="unexpected '..' element in path"):
+                make_path_safe(path)
 
 
 class MockArchive:
     def __init__(self, ts, id):
         self.ts = ts
         self.id = id
 
@@ -631,27 +662,28 @@
         assert get_config_dir() == os.path.join("/var/tmp/.config", "borg")
         monkeypatch.setenv("BORG_CONFIG_DIR", "/var/tmp")
         assert get_config_dir() == "/var/tmp"
 
 
 def test_get_config_dir_compat(monkeypatch):
     """test that it works the same for legacy and for non-legacy implementation"""
+    monkeypatch.delenv("BORG_CONFIG_DIR", raising=False)
     monkeypatch.delenv("BORG_BASE_DIR", raising=False)
+    monkeypatch.delenv("XDG_CONFIG_HOME", raising=False)
     if not is_darwin and not is_win32:
-        monkeypatch.delenv("BORG_CONFIG_DIR", raising=False)
-        monkeypatch.delenv("XDG_CONFIG_HOME", raising=False)
         # fails on macOS: assert '/Users/tw/Library/Application Support/borg' == '/Users/tw/.config/borg'
         # fails on win32 MSYS2 (but we do not need legacy compat there).
         assert get_config_dir(legacy=False) == get_config_dir(legacy=True)
-    if not is_darwin and not is_win32:
-        monkeypatch.setenv("XDG_CONFIG_HOME", "/var/tmp/.config1")
-        # fails on macOS: assert '/Users/tw/Library/Application Support/borg' == '/var/tmp/.config1/borg'
+        monkeypatch.setenv("XDG_CONFIG_HOME", "/var/tmp/xdg.config.d")
+        # fails on macOS: assert '/Users/tw/Library/Application Support/borg' == '/var/tmp/xdg.config.d'
         # fails on win32 MSYS2 (but we do not need legacy compat there).
         assert get_config_dir(legacy=False) == get_config_dir(legacy=True)
-    monkeypatch.setenv("BORG_CONFIG_DIR", "/var/tmp/.config2")
+    monkeypatch.setenv("BORG_BASE_DIR", "/var/tmp/base")
+    assert get_config_dir(legacy=False) == get_config_dir(legacy=True)
+    monkeypatch.setenv("BORG_CONFIG_DIR", "/var/tmp/borg.config.d")
     assert get_config_dir(legacy=False) == get_config_dir(legacy=True)
 
 
 def test_get_cache_dir(monkeypatch):
     """test that get_cache_dir respects environment"""
     monkeypatch.delenv("BORG_BASE_DIR", raising=False)
     home_dir = os.path.expanduser("~")
@@ -671,14 +703,33 @@
         assert get_cache_dir() == os.path.join(home_dir, ".cache", "borg")
         monkeypatch.setenv("XDG_CACHE_HOME", "/var/tmp/.cache")
         assert get_cache_dir() == os.path.join("/var/tmp/.cache", "borg")
         monkeypatch.setenv("BORG_CACHE_DIR", "/var/tmp")
         assert get_cache_dir() == "/var/tmp"
 
 
+def test_get_cache_dir_compat(monkeypatch):
+    """test that it works the same for legacy and for non-legacy implementation"""
+    monkeypatch.delenv("BORG_CACHE_DIR", raising=False)
+    monkeypatch.delenv("BORG_BASE_DIR", raising=False)
+    monkeypatch.delenv("XDG_CACHE_HOME", raising=False)
+    if not is_darwin and not is_win32:
+        # fails on macOS: assert '/Users/tw/Library/Caches/borg' == '/Users/tw/.cache/borg'
+        # fails on win32 MSYS2 (but we do not need legacy compat there).
+        assert get_cache_dir(legacy=False) == get_cache_dir(legacy=True)
+        # fails on macOS: assert '/Users/tw/Library/Caches/borg' == '/var/tmp/xdg.cache.d'
+        # fails on win32 MSYS2 (but we do not need legacy compat there).
+        monkeypatch.setenv("XDG_CACHE_HOME", "/var/tmp/xdg.cache.d")
+        assert get_cache_dir(legacy=False) == get_cache_dir(legacy=True)
+    monkeypatch.setenv("BORG_BASE_DIR", "/var/tmp/base")
+    assert get_cache_dir(legacy=False) == get_cache_dir(legacy=True)
+    monkeypatch.setenv("BORG_CACHE_DIR", "/var/tmp/borg.cache.d")
+    assert get_cache_dir(legacy=False) == get_cache_dir(legacy=True)
+
+
 def test_get_keys_dir(monkeypatch):
     """test that get_keys_dir respects environment"""
     monkeypatch.delenv("BORG_BASE_DIR", raising=False)
     home_dir = os.path.expanduser("~")
     if is_win32:
         monkeypatch.delenv("BORG_KEYS_DIR", raising=False)
         assert get_keys_dir() == os.path.join(home_dir, "AppData", "Local", "borg", "borg", "keys")
@@ -716,24 +767,50 @@
         assert get_security_dir() == os.path.join(home_dir, "Library", "Application Support", "borg", "security")
         assert get_security_dir(repository_id="1234") == os.path.join(
             home_dir, "Library", "Application Support", "borg", "security", "1234"
         )
         monkeypatch.setenv("BORG_SECURITY_DIR", "/var/tmp")
         assert get_security_dir() == "/var/tmp"
     else:
-        monkeypatch.delenv("XDG_CONFIG_HOME", raising=False)
+        monkeypatch.delenv("XDG_DATA_HOME", raising=False)
         monkeypatch.delenv("BORG_SECURITY_DIR", raising=False)
-        assert get_security_dir() == os.path.join(home_dir, ".config", "borg", "security")
-        assert get_security_dir(repository_id="1234") == os.path.join(home_dir, ".config", "borg", "security", "1234")
-        monkeypatch.setenv("XDG_CONFIG_HOME", "/var/tmp/.config")
+        assert get_security_dir() == os.path.join(home_dir, ".local", "share", "borg", "security")
+        assert get_security_dir(repository_id="1234") == os.path.join(
+            home_dir, ".local", "share", "borg", "security", "1234"
+        )
+        monkeypatch.setenv("XDG_DATA_HOME", "/var/tmp/.config")
         assert get_security_dir() == os.path.join("/var/tmp/.config", "borg", "security")
         monkeypatch.setenv("BORG_SECURITY_DIR", "/var/tmp")
         assert get_security_dir() == "/var/tmp"
 
 
+def test_get_runtime_dir(monkeypatch):
+    """test that get_runtime_dir respects environment"""
+    monkeypatch.delenv("BORG_BASE_DIR", raising=False)
+    home_dir = os.path.expanduser("~")
+    if is_win32:
+        monkeypatch.delenv("BORG_RUNTIME_DIR", raising=False)
+        assert get_runtime_dir() == os.path.join(home_dir, "AppData", "Local", "Temp", "borg", "borg")
+        monkeypatch.setenv("BORG_RUNTIME_DIR", home_dir)
+        assert get_runtime_dir() == home_dir
+    elif is_darwin:
+        monkeypatch.delenv("BORG_RUNTIME_DIR", raising=False)
+        assert get_runtime_dir() == os.path.join(home_dir, "Library", "Caches", "TemporaryItems", "borg")
+        monkeypatch.setenv("BORG_RUNTIME_DIR", "/var/tmp")
+        assert get_runtime_dir() == "/var/tmp"
+    else:
+        monkeypatch.delenv("XDG_RUNTIME_DIR", raising=False)
+        monkeypatch.delenv("BORG_RUNTIME_DIR", raising=False)
+        assert get_runtime_dir() == os.path.join("/run/user", str(os.getuid()), "borg")
+        monkeypatch.setenv("XDG_RUNTIME_DIR", "/var/tmp/.cache")
+        assert get_runtime_dir() == os.path.join("/var/tmp/.cache", "borg")
+        monkeypatch.setenv("BORG_RUNTIME_DIR", "/var/tmp")
+        assert get_runtime_dir() == "/var/tmp"
+
+
 def test_file_size():
     """test the size formatting routines"""
     si_size_map = {
         0: "0 B",  # no rounding necessary for those
         1: "1 B",
         142: "142 B",
         999: "999 B",
@@ -972,50 +1049,44 @@
     assert yes(env_var_override=env_var)
     out, err = capfd.readouterr()
     assert out == ""
     assert env_var in err
     assert "yes" in err
 
 
-def test_progress_percentage_sameline(capfd, monkeypatch):
-    # run the test as if it was in a 4x1 terminal
-    monkeypatch.setenv("COLUMNS", "4")
-    monkeypatch.setenv("LINES", "1")
+def test_progress_percentage(capfd):
     pi = ProgressIndicatorPercent(1000, step=5, start=0, msg="%3.0f%%")
     pi.logger.setLevel("INFO")
     pi.show(0)
     out, err = capfd.readouterr()
-    assert err == "  0%\r"
+    assert err == "  0%\n"
     pi.show(420)
     pi.show(680)
     out, err = capfd.readouterr()
-    assert err == " 42%\r 68%\r"
+    assert err == " 42%\n 68%\n"
     pi.show(1000)
     out, err = capfd.readouterr()
-    assert err == "100%\r"
+    assert err == "100%\n"
     pi.finish()
     out, err = capfd.readouterr()
-    assert err == " " * 4 + "\r"
+    assert err == "\n"
 
 
-def test_progress_percentage_step(capfd, monkeypatch):
-    # run the test as if it was in a 4x1 terminal
-    monkeypatch.setenv("COLUMNS", "4")
-    monkeypatch.setenv("LINES", "1")
+def test_progress_percentage_step(capfd):
     pi = ProgressIndicatorPercent(100, step=2, start=0, msg="%3.0f%%")
     pi.logger.setLevel("INFO")
     pi.show()
     out, err = capfd.readouterr()
-    assert err == "  0%\r"
+    assert err == "  0%\n"
     pi.show()
     out, err = capfd.readouterr()
     assert err == ""  # no output at 1% as we have step == 2
     pi.show()
     out, err = capfd.readouterr()
-    assert err == "  2%\r"
+    assert err == "  2%\n"
 
 
 def test_progress_percentage_quiet(capfd):
     pi = ProgressIndicatorPercent(1000, step=5, start=0, msg="%3.0f%%")
     pi.logger.setLevel("WARN")
     pi.show(0)
     out, err = capfd.readouterr()
@@ -1024,43 +1095,14 @@
     out, err = capfd.readouterr()
     assert err == ""
     pi.finish()
     out, err = capfd.readouterr()
     assert err == ""
 
 
-def test_progress_endless(capfd):
-    pi = ProgressIndicatorEndless(step=1, file=sys.stderr)
-    pi.show()
-    out, err = capfd.readouterr()
-    assert err == "."
-    pi.show()
-    out, err = capfd.readouterr()
-    assert err == "."
-    pi.finish()
-    out, err = capfd.readouterr()
-    assert err == "\n"
-
-
-def test_progress_endless_step(capfd):
-    pi = ProgressIndicatorEndless(step=2, file=sys.stderr)
-    pi.show()
-    out, err = capfd.readouterr()
-    assert err == ""  # no output here as we have step == 2
-    pi.show()
-    out, err = capfd.readouterr()
-    assert err == "."
-    pi.show()
-    out, err = capfd.readouterr()
-    assert err == ""  # no output here as we have step == 2
-    pi.show()
-    out, err = capfd.readouterr()
-    assert err == "."
-
-
 def test_partial_format():
     assert partial_format("{space:10}", {"space": " "}) == " " * 10
     assert partial_format("{foobar}", {"bar": "wrong", "foobar": "correct"}) == "correct"
     assert partial_format("{unknown_key}", {}) == "{unknown_key}"
     assert partial_format("{key}{{escaped_key}}", {}) == "{key}{{escaped_key}}"
     assert partial_format("{{escaped_key}}", {"escaped_key": 1234}) == "{{escaped_key}}"
 
@@ -1273,27 +1315,27 @@
         safe_unlink(hard_link)
 
     assert victim.read_binary() == contents
 
 
 class TestPassphrase:
     def test_passphrase_new_verification(self, capsys, monkeypatch):
-        monkeypatch.setattr(getpass, "getpass", lambda prompt: "12a")
+        monkeypatch.setattr(getpass, "getpass", lambda prompt: "1234a")
         monkeypatch.setenv("BORG_DISPLAY_PASSPHRASE", "no")
         Passphrase.new()
         out, err = capsys.readouterr()
-        assert "12" not in out
-        assert "12" not in err
+        assert "1234" not in out
+        assert "1234" not in err
 
         monkeypatch.setenv("BORG_DISPLAY_PASSPHRASE", "yes")
         passphrase = Passphrase.new()
         out, err = capsys.readouterr()
-        assert "313261c3b6c3a4c3bc" not in out
-        assert "313261c3b6c3a4c3bc" in err
-        assert passphrase == "12a"
+        assert "3132333461c3b6c3a4c3bc" not in out
+        assert "3132333461c3b6c3a4c3bc" in err
+        assert passphrase == "1234a"
 
         monkeypatch.setattr(getpass, "getpass", lambda prompt: "1234/@=")
         Passphrase.new()
         out, err = capsys.readouterr()
         assert "1234/@=" not in out
         assert "1234/@=" in err
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/item.py` & `borgbackup-2.0.0b6/src/borg/testsuite/item.py`

 * *Files 26% similar despite different names*

```diff
@@ -31,87 +31,86 @@
     with pytest.raises(AttributeError):
         item.path
 
     with pytest.raises(AttributeError):
         del item.path
 
 
-def test_item_from_dict():
-    # does not matter whether we get str or bytes keys
-    item = Item({b"path": "/a/b/c", b"mode": 0o666})
-    assert item.path == "/a/b/c"
-    assert item.mode == 0o666
+@pytest.mark.parametrize(
+    "item_dict, path, mode",
+    [  # does not matter whether we get str or bytes keys
+        ({b"path": "a/b/c", b"mode": 0o666}, "a/b/c", 0o666),
+        ({"path": "a/b/c", "mode": 0o666}, "a/b/c", 0o666),
+    ],
+)
+def test_item_from_dict(item_dict, path, mode):
+    item = Item(item_dict)
+    assert item.path == path
+    assert item.mode == mode
     assert "path" in item
-
-    # does not matter whether we get str or bytes keys
-    item = Item({"path": "/a/b/c", "mode": 0o666})
-    assert item.path == "/a/b/c"
-    assert item.mode == 0o666
     assert "mode" in item
 
-    # invalid - no dict
-    with pytest.raises(TypeError):
-        Item(42)
-
-    # invalid - no bytes/str key
-    with pytest.raises(TypeError):
-        Item({42: 23})
 
-    # invalid - unknown key
-    with pytest.raises(ValueError):
-        Item({"foobar": "baz"})
+@pytest.mark.parametrize(
+    "invalid_item, error",
+    [
+        (42, TypeError),  # invalid - no dict
+        ({42: 23}, TypeError),  # invalid - no bytes/str key
+        ({"foobar": "baz"}, ValueError),  # invalid - unknown key
+    ],
+)
+def test_item_invalid(invalid_item, error):
+    with pytest.raises(error):
+        Item(invalid_item)
 
 
 def test_item_from_kw():
-    item = Item(path="/a/b/c", mode=0o666)
-    assert item.path == "/a/b/c"
+    item = Item(path="a/b/c", mode=0o666)
+    assert item.path == "a/b/c"
     assert item.mode == 0o666
 
 
 def test_item_int_property():
     item = Item()
     item.mode = 0o666
     assert item.mode == 0o666
     assert item.as_dict() == {"mode": 0o666}
     del item.mode
     assert item.as_dict() == {}
     with pytest.raises(TypeError):
         item.mode = "invalid"
 
 
-def test_item_mptimestamp_property():
+@pytest.mark.parametrize("atime", [42, 2**65])
+def test_item_mptimestamp_property(atime):
     item = Item()
-    small, big = 42, 2**65
-    item.atime = small
-    assert item.atime == small
-    assert item.as_dict() == {"atime": Timestamp.from_unix_nano(small)}
-    item.atime = big
-    assert item.atime == big
-    assert item.as_dict() == {"atime": Timestamp.from_unix_nano(big)}
+    item.atime = atime
+    assert item.atime == atime
+    assert item.as_dict() == {"atime": Timestamp.from_unix_nano(atime)}
 
 
 def test_item_se_str_property():
     # start simple
     item = Item()
-    item.path = "/a/b/c"
-    assert item.path == "/a/b/c"
-    assert item.as_dict() == {"path": "/a/b/c"}
+    item.path = "a/b/c"
+    assert item.path == "a/b/c"
+    assert item.as_dict() == {"path": "a/b/c"}
     del item.path
     assert item.as_dict() == {}
     with pytest.raises(TypeError):
         item.path = 42
 
     # non-utf-8 path, needing surrogate-escaping for latin-1 u-umlaut
-    item = Item(internal_dict={"path": b"/a/\xfc/c"})
-    assert item.path == "/a/\udcfc/c"  # getting a surrogate-escaped representation
-    assert item.as_dict() == {"path": "/a/\udcfc/c"}
+    item = Item(internal_dict={"path": b"a/\xfc/c"})
+    assert item.path == "a/\udcfc/c"  # getting a surrogate-escaped representation
+    assert item.as_dict() == {"path": "a/\udcfc/c"}
     del item.path
     assert "path" not in item
-    item.path = "/a/\udcfc/c"  # setting using a surrogate-escaped representation
-    assert item.as_dict() == {"path": "/a/\udcfc/c"}
+    item.path = "a/\udcfc/c"  # setting using a surrogate-escaped representation
+    assert item.as_dict() == {"path": "a/\udcfc/c"}
 
 
 def test_item_list_property():
     item = Item()
     item.chunks = []
     assert item.chunks == []
     item.chunks.append(0)
@@ -154,23 +153,23 @@
 
 
 def test_item_optr():
     item = Item()
     assert Item.from_optr(item.to_optr()) is item
 
 
-def test_chunk_content_equal():
-    def ccc(a, b):
-        chunks_a = [data for data in a]
-        chunks_b = [data for data in b]
-        compare1 = chunks_contents_equal(iter(chunks_a), iter(chunks_b))
-        compare2 = chunks_contents_equal(iter(chunks_b), iter(chunks_a))
-        assert compare1 == compare2
-        return compare1
-
-    assert ccc([b"1234", b"567A", b"bC"], [b"1", b"23", b"4567A", b"b", b"C"])
-    # one iterator exhausted before the other
-    assert not ccc([b"12345"], [b"1234", b"56"])
-    # content mismatch
-    assert not ccc([b"1234", b"65"], [b"1234", b"56"])
-    # first is the prefix of second
-    assert not ccc([b"1234", b"56"], [b"1234", b"565"])
+@pytest.mark.parametrize(
+    "chunk_a, chunk_b, chunks_equal",
+    [
+        (["1234", "567A", "bC"], ["1", "23", "4567A", "b", "C"], True),  # equal
+        (["12345"], ["1234", "56"], False),  # one iterator exhausted before the other
+        (["1234", "65"], ["1234", "56"], False),  # content mismatch
+        (["1234", "56"], ["1234", "565"], False),  # first is the prefix of second
+    ],
+)
+def test_chunk_content_equal(chunk_a: str, chunk_b: str, chunks_equal):
+    chunks_a = [data.encode() for data in chunk_a]
+    chunks_b = [data.encode() for data in chunk_b]
+    compare1 = chunks_contents_equal(iter(chunks_a), iter(chunks_b))
+    compare2 = chunks_contents_equal(iter(chunks_b), iter(chunks_a))
+    assert compare1 == compare2
+    assert compare1 == chunks_equal
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/key.py` & `borgbackup-2.0.0b6/src/borg/testsuite/key.py`

 * *Files 0% similar despite different names*

```diff
@@ -111,20 +111,15 @@
 
             def canonical_path(self):
                 return self.processed
 
         _location = _Location()
         id = bytes(32)
         id_str = bin_to_hex(id)
-
-        def get_free_nonce(self):
-            return None
-
-        def commit_nonce_reservation(self, next_unreserved, start_nonce):
-            pass
+        version = 2
 
         def save_key(self, data):
             self.key_data = data
 
         def load_key(self):
             return self.key_data
 
@@ -317,15 +312,19 @@
         ),
     )
     def test_invalid(self, key, tam, exc):
         blob = msgpack.packb({"tam": tam})
         with pytest.raises(exc):
             key.unpack_and_verify_manifest(blob)
 
-    @pytest.mark.parametrize("hmac, salt", (({}, bytes(64)), (bytes(64), {}), (None, bytes(64)), (bytes(64), None)))
+    @pytest.mark.parametrize(
+        "hmac, salt",
+        (({}, bytes(64)), (bytes(64), {}), (None, bytes(64)), (bytes(64), None)),
+        ids=["ed-b64", "b64-ed", "n-b64", "b64-n"],
+    )
     def test_wrong_types(self, key, hmac, salt):
         data = {"tam": {"type": "HKDF_HMAC_SHA512", "hmac": hmac, "salt": salt}}
         tam = data["tam"]
         if hmac is None:
             del tam["hmac"]
         if salt is None:
             del tam["salt"]
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/locking.py` & `borgbackup-2.0.0b6/src/borg/testsuite/locking.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/logger.py` & `borgbackup-2.0.0b6/src/borg/testsuite/logger.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/lrucache.py` & `borgbackup-2.0.0b6/src/borg/testsuite/lrucache.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 import pytest
 
 from ..helpers.lrucache import LRUCache
 
 
 class TestLRUCache:
     def test_lrucache(self):
-        c = LRUCache(2, dispose=lambda _: None)
+        c = LRUCache(2)
         assert len(c) == 0
         assert c.items() == set()
         for i, x in enumerate("abc"):
             c[x] = i
         assert len(c) == 2
         assert c.items() == {("b", 1), ("c", 2)}
         assert "a" not in c
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/nanorst.py` & `borgbackup-2.0.0b6/src/borg/testsuite/nanorst.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/patterns.py` & `borgbackup-2.0.0b6/src/borg/testsuite/patterns.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/platform.py` & `borgbackup-2.0.0b6/src/borg/testsuite/platform.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/remote.py` & `borgbackup-2.0.0b6/src/borg/testsuite/remote.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/repoobj.py` & `borgbackup-2.0.0b6/src/borg/testsuite/repoobj.py`

 * *Files 2% similar despite different names*

```diff
@@ -64,15 +64,17 @@
     # writes borg 2 repo objects (giving already compressed data to avoid compression).
     meta = {}  # borg1 does not support this kind of metadata
     data = b"foobar" * 10
     len_data = len(data)
     repo_objs1 = RepoObj1(key)
     id = repo_objs1.id_hash(data)
     borg1_cdata = repo_objs1.format(id, meta, data)
-    meta1, compr_data1 = repo_objs1.parse(id, borg1_cdata, decompress=False)  # borg transfer avoids (de)compression
+    meta1, compr_data1 = repo_objs1.parse(
+        id, borg1_cdata, decompress=True, want_compressed=True
+    )  # avoid re-compression
     # in borg 1, we can only get this metadata after decrypting the whole chunk (and we do not have "size" here):
     assert meta1["ctype"] == LZ4.ID  # default compression
     assert meta1["clevel"] == 0xFF  # lz4 does not know levels (yet?)
     assert meta1["csize"] < len_data  # lz4 should make it smaller
 
     repo_objs2 = RepoObj(key)
     # note: as we did not decompress, we do not have "size" and we need to get it from somewhere else.
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/repository.py` & `borgbackup-2.0.0b6/src/borg/testsuite/repository.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,23 +1,22 @@
-import io
 import logging
 import os
 import shutil
 import sys
 import tempfile
 from unittest.mock import patch
 
 import pytest
 
 from ..hashindex import NSIndex
 from ..helpers import Location
 from ..helpers import IntegrityError
 from ..helpers import msgpack
 from ..locking import Lock, LockFailed
-from ..remote import RemoteRepository, InvalidRPCMethod, PathNotAllowed, handle_remote_line
+from ..remote import RemoteRepository, InvalidRPCMethod, PathNotAllowed
 from ..repository import Repository, LoggedIO, MAGIC, MAX_DATA_SIZE, TAG_DELETE, TAG_PUT2, TAG_PUT, TAG_COMMIT
 from ..repoobj import RepoObj
 from . import BaseTestCase
 from .hashindex import H
 
 
 UNSPECIFIED = object()  # for default values where we can't use None
@@ -57,21 +56,21 @@
 
     def setUp(self):
         self.tmppath = tempfile.mkdtemp()
         self.repository = self.open(create=True)
         self.repository.__enter__()
 
     def tearDown(self):
-        self.repository.close()
+        self.repository.__exit__(None, None, None)
         shutil.rmtree(self.tmppath)
 
     def reopen(self, exclusive=UNSPECIFIED):
-        if self.repository:
-            self.repository.close()
+        self.repository.__exit__(None, None, None)
         self.repository = self.open(exclusive=exclusive)
+        self.repository.__enter__()
 
     def add_keys(self):
         self.repository.put(H(0), fchunk(b"foo"))
         self.repository.put(H(1), fchunk(b"bar"))
         self.repository.put(H(3), fchunk(b"bar"))
         self.repository.commit(compact=False)
         self.repository.put(H(1), fchunk(b"bar2"))
@@ -94,21 +93,20 @@
         for x in range(100):
             self.repository.put(H(x), fchunk(b"SOMEDATA"))
         key50 = H(50)
         self.assert_equal(pdchunk(self.repository.get(key50)), b"SOMEDATA")
         self.repository.delete(key50)
         self.assert_raises(Repository.ObjectNotFound, lambda: self.repository.get(key50))
         self.repository.commit(compact=False)
-        self.repository.close()
-        with self.open() as repository2:
-            self.assert_raises(Repository.ObjectNotFound, lambda: repository2.get(key50))
-            for x in range(100):
-                if x == 50:
-                    continue
-                self.assert_equal(pdchunk(repository2.get(H(x))), b"SOMEDATA")
+        self.reopen()
+        self.assert_raises(Repository.ObjectNotFound, lambda: self.repository.get(key50))
+        for x in range(100):
+            if x == 50:
+                continue
+            self.assert_equal(pdchunk(self.repository.get(H(x))), b"SOMEDATA")
 
     def test2(self):
         """Test multiple sequential transactions"""
         self.repository.put(H(0), fchunk(b"foo"))
         self.repository.put(H(1), fchunk(b"foo"))
         self.repository.commit(compact=False)
         self.repository.delete(H(0))
@@ -155,25 +153,22 @@
         self.repository.commit(compact=False)
         self.assert_equal(pdchunk(self.repository.get(H(0))), b"foo2")
 
     def test_single_kind_transactions(self):
         # put
         self.repository.put(H(0), fchunk(b"foo"))
         self.repository.commit(compact=False)
-        self.repository.close()
+        self.reopen()
         # replace
-        self.repository = self.open()
-        with self.repository:
-            self.repository.put(H(0), fchunk(b"bar"))
-            self.repository.commit(compact=False)
+        self.repository.put(H(0), fchunk(b"bar"))
+        self.repository.commit(compact=False)
+        self.reopen()
         # delete
-        self.repository = self.open()
-        with self.repository:
-            self.repository.delete(H(0))
-            self.repository.commit(compact=False)
+        self.repository.delete(H(0))
+        self.repository.commit(compact=False)
 
     def test_list(self):
         for x in range(100):
             self.repository.put(H(x), fchunk(b"SOMEDATA"))
         self.repository.commit(compact=False)
         all = self.repository.list()
         self.assert_equal(len(all), 100)
@@ -272,22 +267,19 @@
 
     def test_flags_persistence(self):
         self.repository.put(H(0), fchunk(b"default"))
         self.repository.put(H(1), fchunk(b"one one zero"))
         # we do not set flags for H(0), so we can later check their default state.
         self.repository.flags(H(1), mask=0x00000007, value=0x00000006)
         self.repository.commit(compact=False)
-        self.repository.close()
-
-        self.repository = self.open()
-        with self.repository:
-            # we query all flags to check if the initial flags were all zero and
-            # only the ones we explicitly set to one are as expected.
-            self.assert_equal(self.repository.flags(H(0), mask=0xFFFFFFFF), 0x00000000)
-            self.assert_equal(self.repository.flags(H(1), mask=0xFFFFFFFF), 0x00000006)
+        self.reopen()
+        # we query all flags to check if the initial flags were all zero and
+        # only the ones we explicitly set to one are as expected.
+        self.assert_equal(self.repository.flags(H(0), mask=0xFFFFFFFF), 0x00000000)
+        self.assert_equal(self.repository.flags(H(1), mask=0xFFFFFFFF), 0x00000006)
 
 
 class LocalRepositoryTestCase(RepositoryTestCaseBase):
     # test case that doesn't work with remote repositories
 
     def _assert_sparse(self):
         # The superseded 123456... PUT
@@ -333,103 +325,94 @@
         # we just have to be careful with invalidation of cached FDs in LoggedIO.
         self.repository.put(H(0), fchunk(b"foo"))
         self.repository.commit(compact=False)
         # write some crap to a uncommitted segment file
         last_segment = self.repository.io.get_latest_segment()
         with open(self.repository.io.segment_filename(last_segment + 1), "wb") as f:
             f.write(MAGIC + b"crapcrapcrap")
-        self.repository.close()
+        self.reopen()
         # usually, opening the repo and starting a transaction should trigger a cleanup.
-        self.repository = self.open()
-        with self.repository:
-            self.repository.put(H(0), fchunk(b"bar"))  # this may trigger compact_segments()
-            self.repository.commit(compact=True)
+        self.repository.put(H(0), fchunk(b"bar"))  # this may trigger compact_segments()
+        self.repository.commit(compact=True)
         # the point here is that nothing blows up with an exception.
 
 
 class RepositoryCommitTestCase(RepositoryTestCaseBase):
     def test_replay_of_missing_index(self):
         self.add_keys()
         for name in os.listdir(self.repository.path):
             if name.startswith("index."):
                 os.unlink(os.path.join(self.repository.path, name))
         self.reopen()
-        with self.repository:
-            self.assert_equal(len(self.repository), 3)
-            self.assert_equal(self.repository.check(), True)
+        self.assert_equal(len(self.repository), 3)
+        self.assert_equal(self.repository.check(), True)
 
     def test_crash_before_compact_segments(self):
         self.add_keys()
         self.repository.compact_segments = None
         try:
             self.repository.commit(compact=True)
         except TypeError:
             pass
         self.reopen()
-        with self.repository:
-            self.assert_equal(len(self.repository), 3)
-            self.assert_equal(self.repository.check(), True)
+        self.assert_equal(len(self.repository), 3)
+        self.assert_equal(self.repository.check(), True)
 
     def test_crash_before_write_index(self):
         self.add_keys()
         self.repository.write_index = None
         try:
             self.repository.commit(compact=False)
         except TypeError:
             pass
         self.reopen()
-        with self.repository:
-            self.assert_equal(len(self.repository), 3)
-            self.assert_equal(self.repository.check(), True)
+        self.assert_equal(len(self.repository), 3)
+        self.assert_equal(self.repository.check(), True)
 
     def test_replay_lock_upgrade_old(self):
         self.add_keys()
         for name in os.listdir(self.repository.path):
             if name.startswith("index."):
                 os.unlink(os.path.join(self.repository.path, name))
         with patch.object(Lock, "upgrade", side_effect=LockFailed) as upgrade:
             self.reopen(exclusive=None)  # simulate old client that always does lock upgrades
-            with self.repository:
-                # the repo is only locked by a shared read lock, but to replay segments,
-                # we need an exclusive write lock - check if the lock gets upgraded.
-                self.assert_raises(LockFailed, lambda: len(self.repository))
-                upgrade.assert_called_once_with()
+            # the repo is only locked by a shared read lock, but to replay segments,
+            # we need an exclusive write lock - check if the lock gets upgraded.
+            self.assert_raises(LockFailed, lambda: len(self.repository))
+            upgrade.assert_called_once_with()
 
     def test_replay_lock_upgrade(self):
         self.add_keys()
         for name in os.listdir(self.repository.path):
             if name.startswith("index."):
                 os.unlink(os.path.join(self.repository.path, name))
         with patch.object(Lock, "upgrade", side_effect=LockFailed) as upgrade:
             self.reopen(exclusive=False)  # current client usually does not do lock upgrade, except for replay
-            with self.repository:
-                # the repo is only locked by a shared read lock, but to replay segments,
-                # we need an exclusive write lock - check if the lock gets upgraded.
-                self.assert_raises(LockFailed, lambda: len(self.repository))
-                upgrade.assert_called_once_with()
+            # the repo is only locked by a shared read lock, but to replay segments,
+            # we need an exclusive write lock - check if the lock gets upgraded.
+            self.assert_raises(LockFailed, lambda: len(self.repository))
+            upgrade.assert_called_once_with()
 
     def test_crash_before_deleting_compacted_segments(self):
         self.add_keys()
         self.repository.io.delete_segment = None
         try:
             self.repository.commit(compact=False)
         except TypeError:
             pass
         self.reopen()
-        with self.repository:
-            self.assert_equal(len(self.repository), 3)
-            self.assert_equal(self.repository.check(), True)
-            self.assert_equal(len(self.repository), 3)
+        self.assert_equal(len(self.repository), 3)
+        self.assert_equal(self.repository.check(), True)
+        self.assert_equal(len(self.repository), 3)
 
     def test_ignores_commit_tag_in_data(self):
         self.repository.put(H(0), LoggedIO.COMMIT)
         self.reopen()
-        with self.repository:
-            io = self.repository.io
-            assert not io.is_committed_segment(io.get_latest_segment())
+        io = self.repository.io
+        assert not io.is_committed_segment(io.get_latest_segment())
 
     def test_moved_deletes_are_tracked(self):
         self.repository.put(H(1), fchunk(b"1"))
         self.repository.put(H(2), fchunk(b"2"))
         self.repository.commit(compact=False)
         self.repo_dump("p1 p2 c")
         self.repository.delete(H(1))
@@ -544,19 +527,17 @@
 
 class RepositoryFreeSpaceTestCase(RepositoryTestCaseBase):
     def test_additional_free_space(self):
         self.add_keys()
         self.repository.config.set("repository", "additional_free_space", "1000T")
         self.repository.save_key(b"shortcut to save_config")
         self.reopen()
-
-        with self.repository:
-            self.repository.put(H(0), fchunk(b"foobar"))
-            with pytest.raises(Repository.InsufficientFreeSpaceError):
-                self.repository.commit(compact=False)
+        self.repository.put(H(0), fchunk(b"foobar"))
+        with pytest.raises(Repository.InsufficientFreeSpaceError):
+            self.repository.commit(compact=False)
         assert os.path.exists(self.repository.path)
 
     def test_create_free_space(self):
         self.repository.additional_free_space = 1e20
         with pytest.raises(Repository.InsufficientFreeSpaceError):
             self.add_keys()
         assert not os.path.exists(self.repository.path)
@@ -572,24 +553,23 @@
         self.repository.put(H(2), ch2)
         assert self.repository.storage_quota_use == len(ch1) + len(ch2) + 2 * (41 + 8)
         self.repository.delete(H(1))
         assert self.repository.storage_quota_use == len(ch1) + len(ch2) + 2 * (41 + 8)  # we have not compacted yet
         self.repository.commit(compact=False)
         assert self.repository.storage_quota_use == len(ch1) + len(ch2) + 2 * (41 + 8)  # we have not compacted yet
         self.reopen()
-        with self.repository:
-            # Open new transaction; hints and thus quota data is not loaded unless needed.
-            ch3 = fchunk(b"")
-            self.repository.put(H(3), ch3)
-            self.repository.delete(H(3))
-            assert self.repository.storage_quota_use == len(ch1) + len(ch2) + len(ch3) + 3 * (
-                41 + 8
-            )  # we have not compacted yet
-            self.repository.commit(compact=True)
-            assert self.repository.storage_quota_use == len(ch2) + 41 + 8
+        # Open new transaction; hints and thus quota data is not loaded unless needed.
+        ch3 = fchunk(b"")
+        self.repository.put(H(3), ch3)
+        self.repository.delete(H(3))
+        assert self.repository.storage_quota_use == len(ch1) + len(ch2) + len(ch3) + 3 * (
+            41 + 8
+        )  # we have not compacted yet
+        self.repository.commit(compact=True)
+        assert self.repository.storage_quota_use == len(ch2) + 41 + 8
 
     def test_exceed_quota(self):
         assert self.repository.storage_quota_use == 0
         self.repository.storage_quota = 80
         ch1 = fchunk(b"x" * 7)
         self.repository.put(H(1), ch1)
         assert self.repository.storage_quota_use == len(ch1) + 41 + 8
@@ -598,65 +578,22 @@
             ch2 = fchunk(b"y" * 13)
             self.repository.put(H(2), ch2)
         assert self.repository.storage_quota_use == len(ch1) + len(ch2) + (41 + 8) * 2  # check ch2!?
         with pytest.raises(Repository.StorageQuotaExceeded):
             self.repository.commit(compact=False)
         assert self.repository.storage_quota_use == len(ch1) + len(ch2) + (41 + 8) * 2  # check ch2!?
         self.reopen()
-        with self.repository:
-            self.repository.storage_quota = 150
-            # Open new transaction; hints and thus quota data is not loaded unless needed.
-            self.repository.put(H(1), ch1)
-            assert (
-                self.repository.storage_quota_use == len(ch1) * 2 + (41 + 8) * 2
-            )  # we have 2 puts for H(1) here and not yet compacted.
-            self.repository.commit(compact=True)
-            assert self.repository.storage_quota_use == len(ch1) + 41 + 8  # now we have compacted.
-
-
-class NonceReservation(RepositoryTestCaseBase):
-    def test_get_free_nonce_asserts(self):
-        self.reopen(exclusive=False)
-        with pytest.raises(AssertionError):
-            with self.repository:
-                self.repository.get_free_nonce()
-
-    def test_get_free_nonce(self):
-        with self.repository:
-            assert self.repository.get_free_nonce() is None
-
-            with open(os.path.join(self.repository.path, "nonce"), "w") as fd:
-                fd.write("0000000000000000")
-            assert self.repository.get_free_nonce() == 0
-
-            with open(os.path.join(self.repository.path, "nonce"), "w") as fd:
-                fd.write("5000000000000000")
-            assert self.repository.get_free_nonce() == 0x5000000000000000
-
-    def test_commit_nonce_reservation_asserts(self):
-        self.reopen(exclusive=False)
-        with pytest.raises(AssertionError):
-            with self.repository:
-                self.repository.commit_nonce_reservation(0x200, 0x100)
-
-    def test_commit_nonce_reservation(self):
-        with self.repository:
-            with pytest.raises(Exception):
-                self.repository.commit_nonce_reservation(0x200, 15)
-
-            self.repository.commit_nonce_reservation(0x200, None)
-            with open(os.path.join(self.repository.path, "nonce")) as fd:
-                assert fd.read() == "0000000000000200"
-
-            with pytest.raises(Exception):
-                self.repository.commit_nonce_reservation(0x200, 15)
-
-            self.repository.commit_nonce_reservation(0x400, 0x200)
-            with open(os.path.join(self.repository.path, "nonce")) as fd:
-                assert fd.read() == "0000000000000400"
+        self.repository.storage_quota = 150
+        # Open new transaction; hints and thus quota data is not loaded unless needed.
+        self.repository.put(H(1), ch1)
+        assert (
+            self.repository.storage_quota_use == len(ch1) * 2 + (41 + 8) * 2
+        )  # we have 2 puts for H(1) here and not yet compacted.
+        self.repository.commit(compact=True)
+        assert self.repository.storage_quota_use == len(ch1) + 41 + 8  # now we have compacted.
 
 
 class RepositoryAuxiliaryCorruptionTestCase(RepositoryTestCaseBase):
     def setUp(self):
         super().setUp()
         self.repository.put(H(0), fchunk(b"foo"))
         self.repository.commit(compact=False)
@@ -934,38 +871,36 @@
         self.repository.put(H(0), fchunk(b"data"))
         self.repository.put(H(0), fchunk(b"data2"))
         # Simulate a crash before compact
         with patch.object(Repository, "compact_segments") as compact:
             self.repository.commit(compact=True)
             compact.assert_called_once_with(0.1)
         self.reopen()
-        with self.repository:
-            self.check(repair=True)
-            self.assert_equal(pdchunk(self.repository.get(H(0))), b"data2")
+        self.check(repair=True)
+        self.assert_equal(pdchunk(self.repository.get(H(0))), b"data2")
 
 
 class RepositoryHintsTestCase(RepositoryTestCaseBase):
     def test_hints_persistence(self):
         self.repository.put(H(0), fchunk(b"data"))
         self.repository.delete(H(0))
         self.repository.commit(compact=False)
         shadow_index_expected = self.repository.shadow_index
         compact_expected = self.repository.compact
         segments_expected = self.repository.segments
         # close and re-open the repository (create fresh Repository instance) to
         # check whether hints were persisted to / reloaded from disk
         self.reopen()
-        with self.repository:
-            # see also do_compact()
-            self.repository.put(H(42), fchunk(b"foobar"))  # this will call prepare_txn() and load the hints data
-            # check if hints persistence worked:
-            self.assert_equal(shadow_index_expected, self.repository.shadow_index)
-            self.assert_equal(compact_expected, self.repository.compact)
-            del self.repository.segments[2]  # ignore the segment created by put(H(42), ...)
-            self.assert_equal(segments_expected, self.repository.segments)
+        # see also do_compact()
+        self.repository.put(H(42), fchunk(b"foobar"))  # this will call prepare_txn() and load the hints data
+        # check if hints persistence worked:
+        self.assert_equal(shadow_index_expected, self.repository.shadow_index)
+        self.assert_equal(compact_expected, self.repository.compact)
+        del self.repository.segments[2]  # ignore the segment created by put(H(42), ...)
+        self.assert_equal(segments_expected, self.repository.segments)
 
     def test_hints_behaviour(self):
         self.repository.put(H(0), fchunk(b"data"))
         self.assert_equal(self.repository.shadow_index, {})
         assert len(self.repository.compact) == 0
         self.repository.delete(H(0))
         self.repository.commit(compact=False)
@@ -981,15 +916,15 @@
         self.assert_not_in(0, self.repository.compact)
         self.assert_not_in(0, self.repository.segments)
 
 
 class RemoteRepositoryTestCase(RepositoryTestCase):
     repository = None  # type: RemoteRepository
 
-    def open(self, create=False):
+    def open(self, create=False, exclusive=UNSPECIFIED):
         return RemoteRepository(
             Location("ssh://__testsuite__" + os.path.join(self.tmppath, "repository")), exclusive=True, create=create
         )
 
     def _get_mock_args(self):
         class MockArgs:
             remote_path = "borg"
@@ -1096,42 +1031,14 @@
         args.storage_quota = 314159265
         assert self.repository.borg_cmd(args, testing=False) == ["borg", "serve", "--info", "--storage-quota=314159265"]
         args.rsh = "ssh -i foo"
         self.repository._args = args
         assert self.repository.ssh_cmd(Location("ssh://example.com/foo")) == ["ssh", "-i", "foo", "example.com"]
 
 
-class RemoteLegacyFree(RepositoryTestCaseBase):
-    # Keep testing this so we can someday safely remove the legacy tuple format.
-
-    def open(self, create=False):
-        with patch.object(RemoteRepository, "dictFormat", True):
-            return RemoteRepository(
-                Location("ssh://__testsuite__" + os.path.join(self.tmppath, "repository")),
-                exclusive=True,
-                create=create,
-            )
-
-    def test_legacy_free(self):
-        # put
-        self.repository.put(H(0), fchunk(b"foo"))
-        self.repository.commit(compact=False)
-        self.repository.close()
-        # replace
-        self.repository = self.open()
-        with self.repository:
-            self.repository.put(H(0), fchunk(b"bar"))
-            self.repository.commit(compact=False)
-        # delete
-        self.repository = self.open()
-        with self.repository:
-            self.repository.delete(H(0))
-            self.repository.commit(compact=False)
-
-
 class RemoteRepositoryCheckTestCase(RepositoryCheckTestCase):
     def open(self, create=False):
         return RemoteRepository(
             Location("ssh://__testsuite__" + os.path.join(self.tmppath, "repository")), exclusive=True, create=create
         )
 
     def test_crash_before_compact(self):
@@ -1141,82 +1048,7 @@
     def test_repair_missing_commit_segment(self):
         # skip this test, files in RemoteRepository cannot be deleted
         pass
 
     def test_repair_missing_segment(self):
         # skip this test, files in RemoteRepository cannot be deleted
         pass
-
-
-class RemoteLoggerTestCase(BaseTestCase):
-    def setUp(self):
-        self.stream = io.StringIO()
-        self.handler = logging.StreamHandler(self.stream)
-        logging.getLogger().handlers[:] = [self.handler]
-        logging.getLogger("borg.repository").handlers[:] = []
-        logging.getLogger("borg.repository.foo").handlers[:] = []
-        # capture stderr
-        sys.stderr.flush()
-        self.old_stderr = sys.stderr
-        self.stderr = sys.stderr = io.StringIO()
-
-    def tearDown(self):
-        sys.stderr = self.old_stderr
-
-    def test_stderr_messages(self):
-        handle_remote_line("unstructured stderr message\n")
-        self.assert_equal(self.stream.getvalue(), "")
-        # stderr messages don't get an implicit newline
-        self.assert_equal(self.stderr.getvalue(), "Remote: unstructured stderr message\n")
-
-    def test_stderr_progress_messages(self):
-        handle_remote_line("unstructured stderr progress message\r")
-        self.assert_equal(self.stream.getvalue(), "")
-        # stderr messages don't get an implicit newline
-        self.assert_equal(self.stderr.getvalue(), "Remote: unstructured stderr progress message\r")
-
-    def test_pre11_format_messages(self):
-        self.handler.setLevel(logging.DEBUG)
-        logging.getLogger().setLevel(logging.DEBUG)
-
-        handle_remote_line("$LOG INFO Remote: borg < 1.1 format message\n")
-        self.assert_equal(self.stream.getvalue(), "Remote: borg < 1.1 format message\n")
-        self.assert_equal(self.stderr.getvalue(), "")
-
-    def test_post11_format_messages(self):
-        self.handler.setLevel(logging.DEBUG)
-        logging.getLogger().setLevel(logging.DEBUG)
-
-        handle_remote_line("$LOG INFO borg.repository Remote: borg >= 1.1 format message\n")
-        self.assert_equal(self.stream.getvalue(), "Remote: borg >= 1.1 format message\n")
-        self.assert_equal(self.stderr.getvalue(), "")
-
-    def test_remote_messages_screened(self):
-        # default borg config for root logger
-        self.handler.setLevel(logging.WARNING)
-        logging.getLogger().setLevel(logging.WARNING)
-
-        handle_remote_line("$LOG INFO borg.repository Remote: new format info message\n")
-        self.assert_equal(self.stream.getvalue(), "")
-        self.assert_equal(self.stderr.getvalue(), "")
-
-    def test_info_to_correct_local_child(self):
-        logging.getLogger("borg.repository").setLevel(logging.INFO)
-        logging.getLogger("borg.repository.foo").setLevel(logging.INFO)
-        # default borg config for root logger
-        self.handler.setLevel(logging.WARNING)
-        logging.getLogger().setLevel(logging.WARNING)
-
-        child_stream = io.StringIO()
-        child_handler = logging.StreamHandler(child_stream)
-        child_handler.setLevel(logging.INFO)
-        logging.getLogger("borg.repository").handlers[:] = [child_handler]
-        foo_stream = io.StringIO()
-        foo_handler = logging.StreamHandler(foo_stream)
-        foo_handler.setLevel(logging.INFO)
-        logging.getLogger("borg.repository.foo").handlers[:] = [foo_handler]
-
-        handle_remote_line("$LOG INFO borg.repository Remote: new format child message\n")
-        self.assert_equal(foo_stream.getvalue(), "")
-        self.assert_equal(child_stream.getvalue(), "Remote: new format child message\n")
-        self.assert_equal(self.stream.getvalue(), "")
-        self.assert_equal(self.stderr.getvalue(), "")
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/shellpattern.py` & `borgbackup-2.0.0b6/src/borg/testsuite/shellpattern.py`

 * *Files 10% similar despite different names*

```diff
@@ -62,14 +62,24 @@
         ("foo2/bar", ["foo[12]/*"]),
         ("f??f", ["f??f", "f[?][?]f"]),
         ("foo]", ["foo[]]"]),
         # Inverted set
         ("foo3", ["foo[!12]"]),
         ("foo^", ["foo[^!]"]),
         ("foo!", ["foo[^!]"]),
+        # Group
+        ("foo1", ["{foo1,foo2}"]),
+        ("foo2", ["foo{1,2}"]),
+        ("foo", ["foo{,1,2}"]),
+        ("foo1", ["{foo{1,2},bar}"]),
+        ("bar", ["{foo{1,2},bar}"]),
+        ("{foo", ["{foo{,bar}"]),
+        ("{foobar", ["{foo{,bar}"]),
+        ("{foo},bar}", ["{foo},bar}"]),
+        ("bar/foobar", ["**/foo{ba[!z]*,[0-9]}"]),
     ],
 )
 def test_match(path, patterns):
     for p in patterns:
         assert check(path, p)
 
 
@@ -95,14 +105,19 @@
         # Double asterisk not matching filename
         ("foo/bar", ["**/"]),
         # Set
         ("foo3", ["foo[12]"]),
         # Inverted set
         ("foo1", ["foo[!12]"]),
         ("foo2", ["foo[!12]"]),
+        # Group
+        ("foo", ["{foo1,foo2}"]),
+        ("foo", ["foo{1,2}"]),
+        ("foo{1,2}", ["foo{1,2}"]),
+        ("bar/foobaz", ["**/foo{ba[!z]*,[0-9]}"]),
     ],
 )
 def test_mismatch(path, patterns):
     for p in patterns:
         assert not check(path, p)
```

### Comparing `borgbackup-2.0.0b5/src/borg/testsuite/xattr.py` & `borgbackup-2.0.0b6/src/borg/testsuite/xattr.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/upgrade.py` & `borgbackup-2.0.0b6/src/borg/upgrade.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/version.py` & `borgbackup-2.0.0b6/src/borg/version.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borg/xattr.py` & `borgbackup-2.0.0b6/src/borg/xattr.py`

 * *Files identical despite different names*

### Comparing `borgbackup-2.0.0b5/src/borgbackup.egg-info/PKG-INFO` & `borgbackup-2.0.0b6/src/borgbackup.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: borgbackup
-Version: 2.0.0b5
+Version: 2.0.0b6
 Summary: Deduplicated, encrypted, authenticated and compressed backups
 Home-page: https://borgbackup.org
 Author: The Borg Collective (see AUTHORS file)
 License: BSD
 Project-URL: Bug Tracker, https://github.com/borgbackup/borg/issues
 Project-URL: Documentation, https://borgbackup.readthedocs.io
 Project-URL: Source Code, https://github.com/borgbackup/borg
```

### Comparing `borgbackup-2.0.0b5/src/borgbackup.egg-info/SOURCES.txt` & `borgbackup-2.0.0b6/src/borgbackup.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 .coveragerc
 .git-blame-ignore-revs
+.pre-commit-config.yaml
 .readthedocs.yaml
 AUTHORS
 CHANGES.rst
 LICENSE
 MANIFEST.in
 README.rst
-README_WINDOWS.rst
 SECURITY.md
 conftest.py
 pyproject.toml
 setup.cfg
 setup.py
 setup_docs.py
 tox.ini
@@ -202,15 +202,14 @@
 requirements.d/development.lock.txt
 requirements.d/development.txt
 requirements.d/docs.txt
 scripts/borg.exe.spec
 scripts/errorlist.py
 scripts/glibc_check.py
 scripts/hash_sizes.py
-scripts/msys2-build
 scripts/msys2-install-deps
 scripts/sdist-sign
 scripts/sign-binaries
 scripts/upload-pypi
 scripts/fuzz-cache-sync/HOWTO
 scripts/fuzz-cache-sync/main.c
 scripts/fuzz-cache-sync/testcase_dir/test_simple
@@ -293,15 +292,14 @@
 src/borg/cache_sync/unpack_template.h
 src/borg/crypto/__init__.py
 src/borg/crypto/file_integrity.py
 src/borg/crypto/key.py
 src/borg/crypto/keymanager.py
 src/borg/crypto/low_level.c
 src/borg/crypto/low_level.pyx
-src/borg/crypto/nonces.py
 src/borg/helpers/__init__.py
 src/borg/helpers/checks.py
 src/borg/helpers/datastruct.py
 src/borg/helpers/errors.py
 src/borg/helpers/fs.py
 src/borg/helpers/lrucache.py
 src/borg/helpers/misc.py
@@ -346,15 +344,14 @@
 src/borg/testsuite/helpers.py
 src/borg/testsuite/item.py
 src/borg/testsuite/key.py
 src/borg/testsuite/locking.py
 src/borg/testsuite/logger.py
 src/borg/testsuite/lrucache.py
 src/borg/testsuite/nanorst.py
-src/borg/testsuite/nonces.py
 src/borg/testsuite/patterns.py
 src/borg/testsuite/platform.py
 src/borg/testsuite/remote.py
 src/borg/testsuite/repoobj.py
 src/borg/testsuite/repository.py
 src/borg/testsuite/shellpattern.py
 src/borg/testsuite/version.py
@@ -368,14 +365,15 @@
 src/borg/testsuite/archiver/config_cmd.py
 src/borg/testsuite/archiver/corruption.py
 src/borg/testsuite/archiver/create_cmd.py
 src/borg/testsuite/archiver/debug_cmds.py
 src/borg/testsuite/archiver/delete_cmd.py
 src/borg/testsuite/archiver/diff_cmd.py
 src/borg/testsuite/archiver/disk_full.py
+src/borg/testsuite/archiver/dotdot_path.tar
 src/borg/testsuite/archiver/extract_cmd.py
 src/borg/testsuite/archiver/help_cmd.py
 src/borg/testsuite/archiver/info_cmd.py
 src/borg/testsuite/archiver/key_cmds.py
 src/borg/testsuite/archiver/list_cmd.py
 src/borg/testsuite/archiver/lock_cmds.py
 src/borg/testsuite/archiver/mount_cmds.py
@@ -386,16 +384,18 @@
 src/borg/testsuite/archiver/rdelete_cmd.py
 src/borg/testsuite/archiver/recreate_cmd.py
 src/borg/testsuite/archiver/rename_cmd.py
 src/borg/testsuite/archiver/repo12.tar.gz
 src/borg/testsuite/archiver/return_codes.py
 src/borg/testsuite/archiver/rinfo_cmd.py
 src/borg/testsuite/archiver/rlist_cmd.py
+src/borg/testsuite/archiver/serve_cmd.py
 src/borg/testsuite/archiver/tar_cmds.py
 src/borg/testsuite/archiver/transfer_cmd.py
+src/borg/testsuite/archiver/unusual_paths.tar
 src/borgbackup.egg-info/PKG-INFO
 src/borgbackup.egg-info/SOURCES.txt
 src/borgbackup.egg-info/dependency_links.txt
 src/borgbackup.egg-info/entry_points.txt
 src/borgbackup.egg-info/not-zip-safe
 src/borgbackup.egg-info/requires.txt
 src/borgbackup.egg-info/top_level.txt
```

### Comparing `borgbackup-2.0.0b5/tox.ini` & `borgbackup-2.0.0b6/tox.ini`

 * *Files 20% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 minversion = 3.2
 requires =
 	pkgconfig
 	cython
 	wheel
 	setuptools_scm
 [testenv]
+package = editable-legacy  # without this it does not find setup_docs when running under fakeroot
 setenv =
    fuse2: BORG_FUSE_IMPL=llfuse
    fuse3: BORG_FUSE_IMPL=pyfuse3
 deps =
     fuse2: llfuse
     fuse3: pyfuse3
     -rrequirements.d/development.txt
```

